// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcmPcaClientTypes.ASN1Subject: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonName = "CommonName"
        case country = "Country"
        case distinguishedNameQualifier = "DistinguishedNameQualifier"
        case generationQualifier = "GenerationQualifier"
        case givenName = "GivenName"
        case initials = "Initials"
        case locality = "Locality"
        case organization = "Organization"
        case organizationalUnit = "OrganizationalUnit"
        case pseudonym = "Pseudonym"
        case serialNumber = "SerialNumber"
        case state = "State"
        case surname = "Surname"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonName = commonName {
            try encodeContainer.encode(commonName, forKey: .commonName)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let distinguishedNameQualifier = distinguishedNameQualifier {
            try encodeContainer.encode(distinguishedNameQualifier, forKey: .distinguishedNameQualifier)
        }
        if let generationQualifier = generationQualifier {
            try encodeContainer.encode(generationQualifier, forKey: .generationQualifier)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let initials = initials {
            try encodeContainer.encode(initials, forKey: .initials)
        }
        if let locality = locality {
            try encodeContainer.encode(locality, forKey: .locality)
        }
        if let organization = organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
        if let organizationalUnit = organizationalUnit {
            try encodeContainer.encode(organizationalUnit, forKey: .organizationalUnit)
        }
        if let pseudonym = pseudonym {
            try encodeContainer.encode(pseudonym, forKey: .pseudonym)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let organizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organization)
        organization = organizationDecoded
        let organizationalUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnit)
        organizationalUnit = organizationalUnitDecoded
        let distinguishedNameQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distinguishedNameQualifier)
        distinguishedNameQualifier = distinguishedNameQualifierDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let commonNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commonName)
        commonName = commonNameDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let localityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locality)
        locality = localityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let initialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initials)
        initials = initialsDecoded
        let pseudonymDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pseudonym)
        pseudonym = pseudonymDecoded
        let generationQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationQualifier)
        generationQualifier = generationQualifierDecoded
    }
}

extension AcmPcaClientTypes.ASN1Subject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ASN1Subject(commonName: \(Swift.String(describing: commonName)), country: \(Swift.String(describing: country)), distinguishedNameQualifier: \(Swift.String(describing: distinguishedNameQualifier)), generationQualifier: \(Swift.String(describing: generationQualifier)), givenName: \(Swift.String(describing: givenName)), initials: \(Swift.String(describing: initials)), locality: \(Swift.String(describing: locality)), organization: \(Swift.String(describing: organization)), organizationalUnit: \(Swift.String(describing: organizationalUnit)), pseudonym: \(Swift.String(describing: pseudonym)), serialNumber: \(Swift.String(describing: serialNumber)), state: \(Swift.String(describing: state)), surname: \(Swift.String(describing: surname)), title: \(Swift.String(describing: title)))"}
}

extension AcmPcaClientTypes {
    /// Contains information about the certificate subject. The Subject field in
    /// 			the certificate identifies the entity that owns or controls the public key in the
    /// 			certificate. The entity can be a user, computer, device, or service. The Subject
    /// 			must contain an X.500 distinguished name (DN). A DN is a sequence of relative
    /// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.
    public struct ASN1Subject: Swift.Equatable {
        /// For CA and end-entity certificates in a private PKI, the common name (CN) can be any
        /// 			string within the length limit.
        /// 		       Note: In publicly trusted certificates, the common name must be a fully qualified
        /// 			domain name (FQDN) associated with the certificate subject.
        public var commonName: Swift.String?
        /// Two-digit code that specifies the country in which the certificate subject
        /// 			located.
        public var country: Swift.String?
        /// Disambiguating information for the certificate subject.
        public var distinguishedNameQualifier: Swift.String?
        /// Typically a qualifier appended to the name of an individual. Examples include Jr. for
        /// 			junior, Sr. for senior, and III for third.
        public var generationQualifier: Swift.String?
        /// First name.
        public var givenName: Swift.String?
        /// Concatenation that typically contains the first letter of the GivenName, the first letter of the middle name if one exists, and the
        /// 			first letter of the Surname.
        public var initials: Swift.String?
        /// The locality (such as a city or town) in which the certificate subject is
        /// 			located.
        public var locality: Swift.String?
        /// Legal name of the organization with which the certificate subject is affiliated.
        /// 		
        public var organization: Swift.String?
        /// A subdivision or unit of the organization (such as sales or finance) with which the
        /// 			certificate subject is affiliated.
        public var organizationalUnit: Swift.String?
        /// Typically a shortened version of a longer GivenName.
        /// 			For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth,
        /// 			Liz, or Eliza.
        public var pseudonym: Swift.String?
        /// The certificate serial number.
        public var serialNumber: Swift.String?
        /// State in which the subject of the certificate is located.
        public var state: Swift.String?
        /// Family name. In the US and the UK, for example, the surname of an individual is
        /// 			ordered last. In Asian cultures the surname is typically ordered first.
        public var surname: Swift.String?
        /// A title such as Mr. or Ms., which is pre-pended to the name to refer formally to the
        /// 			certificate subject.
        public var title: Swift.String?

        public init (
            commonName: Swift.String? = nil,
            country: Swift.String? = nil,
            distinguishedNameQualifier: Swift.String? = nil,
            generationQualifier: Swift.String? = nil,
            givenName: Swift.String? = nil,
            initials: Swift.String? = nil,
            locality: Swift.String? = nil,
            organization: Swift.String? = nil,
            organizationalUnit: Swift.String? = nil,
            pseudonym: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            state: Swift.String? = nil,
            surname: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.commonName = commonName
            self.country = country
            self.distinguishedNameQualifier = distinguishedNameQualifier
            self.generationQualifier = generationQualifier
            self.givenName = givenName
            self.initials = initials
            self.locality = locality
            self.organization = organization
            self.organizationalUnit = organizationalUnit
            self.pseudonym = pseudonym
            self.serialNumber = serialNumber
            self.state = state
            self.surname = surname
            self.title = title
        }
    }

}

extension AcmPcaClientTypes.AccessDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLocation = "AccessLocation"
        case accessMethod = "AccessMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLocation = accessLocation {
            try encodeContainer.encode(accessLocation, forKey: .accessLocation)
        }
        if let accessMethod = accessMethod {
            try encodeContainer.encode(accessMethod, forKey: .accessMethod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessMethodDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.AccessMethod.self, forKey: .accessMethod)
        accessMethod = accessMethodDecoded
        let accessLocationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.GeneralName.self, forKey: .accessLocation)
        accessLocation = accessLocationDecoded
    }
}

extension AcmPcaClientTypes.AccessDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDescription(accessLocation: \(Swift.String(describing: accessLocation)), accessMethod: \(Swift.String(describing: accessMethod)))"}
}

extension AcmPcaClientTypes {
    /// Provides access information used by the authorityInfoAccess and
    /// 				subjectInfoAccess extensions described in <a href="https://tools.ietf.org/html/rfc5280">RFC 5280.
    public struct AccessDescription: Swift.Equatable {
        /// The location of AccessDescription information.
        /// This member is required.
        public var accessLocation: AcmPcaClientTypes.GeneralName?
        /// The type and format of AccessDescription information.
        /// This member is required.
        public var accessMethod: AcmPcaClientTypes.AccessMethod?

        public init (
            accessLocation: AcmPcaClientTypes.GeneralName? = nil,
            accessMethod: AcmPcaClientTypes.AccessMethod? = nil
        )
        {
            self.accessLocation = accessLocation
            self.accessMethod = accessMethod
        }
    }

}

extension AcmPcaClientTypes.AccessMethod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessMethodType = "AccessMethodType"
        case customObjectIdentifier = "CustomObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessMethodType = accessMethodType {
            try encodeContainer.encode(accessMethodType.rawValue, forKey: .accessMethodType)
        }
        if let customObjectIdentifier = customObjectIdentifier {
            try encodeContainer.encode(customObjectIdentifier, forKey: .customObjectIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customObjectIdentifier)
        customObjectIdentifier = customObjectIdentifierDecoded
        let accessMethodTypeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.AccessMethodType.self, forKey: .accessMethodType)
        accessMethodType = accessMethodTypeDecoded
    }
}

extension AcmPcaClientTypes.AccessMethod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessMethod(accessMethodType: \(Swift.String(describing: accessMethodType)), customObjectIdentifier: \(Swift.String(describing: customObjectIdentifier)))"}
}

extension AcmPcaClientTypes {
    /// Describes the type and format of extension access. Only one of
    /// 				CustomObjectIdentifier or AccessMethodType may be
    /// 			provided. Providing both results in InvalidArgsException.
    public struct AccessMethod: Swift.Equatable {
        /// Specifies the AccessMethod.
        public var accessMethodType: AcmPcaClientTypes.AccessMethodType?
        /// An object identifier (OID) specifying the AccessMethod. The OID must
        /// 			satisfy the regular expression shown below. For more information, see NIST's definition
        /// 			of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
        /// 				(OID).
        public var customObjectIdentifier: Swift.String?

        public init (
            accessMethodType: AcmPcaClientTypes.AccessMethodType? = nil,
            customObjectIdentifier: Swift.String? = nil
        )
        {
            self.accessMethodType = accessMethodType
            self.customObjectIdentifier = customObjectIdentifier
        }
    }

}

extension AcmPcaClientTypes {
    public enum AccessMethodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case caRepository
        case resourcePkiManifest
        case resourcePkiNotify
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessMethodType] {
            return [
                .caRepository,
                .resourcePkiManifest,
                .resourcePkiNotify,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .caRepository: return "CA_REPOSITORY"
            case .resourcePkiManifest: return "RESOURCE_PKI_MANIFEST"
            case .resourcePkiNotify: return "RESOURCE_PKI_NOTIFY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessMethodType(rawValue: rawValue) ?? AccessMethodType.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getcertificate
        case issuecertificate
        case listpermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .getcertificate,
                .issuecertificate,
                .listpermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getcertificate: return "GetCertificate"
            case .issuecertificate: return "IssueCertificate"
            case .listpermissions: return "ListPermissions"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.ApiPassthrough: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extensions = "Extensions"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extensions = extensions {
            try encodeContainer.encode(extensions, forKey: .extensions)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extensionsDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.Extensions.self, forKey: .extensions)
        extensions = extensionsDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ASN1Subject.self, forKey: .subject)
        subject = subjectDecoded
    }
}

extension AcmPcaClientTypes.ApiPassthrough: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiPassthrough(extensions: \(Swift.String(describing: extensions)), subject: \(Swift.String(describing: subject)))"}
}

extension AcmPcaClientTypes {
    /// Contains X.509 certificate information to be placed in an issued certificate. An
    /// 				APIPassthrough or APICSRPassthrough template variant must
    /// 			be selected, or else this parameter is ignored.
    /// 		       If conflicting or duplicate certificate information is supplied from other sources,
    /// 			ACM Private CA applies <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html#template-order-of-operations">order of
    /// 				operation rules to determine what information is used.
    public struct ApiPassthrough: Swift.Equatable {
        /// Specifies X.509 extension information for a certificate.
        public var extensions: AcmPcaClientTypes.Extensions?
        /// Contains information about the certificate subject. The Subject field in
        /// 			the certificate identifies the entity that owns or controls the public key in the
        /// 			certificate. The entity can be a user, computer, device, or service. The Subject
        /// 			must contain an X.500 distinguished name (DN). A DN is a sequence of relative
        /// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.
        public var subject: AcmPcaClientTypes.ASN1Subject?

        public init (
            extensions: AcmPcaClientTypes.Extensions? = nil,
            subject: AcmPcaClientTypes.ASN1Subject? = nil
        )
        {
            self.extensions = extensions
            self.subject = subject
        }
    }

}

extension AcmPcaClientTypes {
    public enum AuditReportResponseFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditReportResponseFormat] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditReportResponseFormat(rawValue: rawValue) ?? AuditReportResponseFormat.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes {
    public enum AuditReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case failed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditReportStatus] {
            return [
                .creating,
                .failed,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditReportStatus(rawValue: rawValue) ?? AuditReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.CertificateAuthority: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case createdAt = "CreatedAt"
        case failureReason = "FailureReason"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case lastStateChangeAt = "LastStateChangeAt"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case ownerAccount = "OwnerAccount"
        case restorableUntil = "RestorableUntil"
        case revocationConfiguration = "RevocationConfiguration"
        case serial = "Serial"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateAuthorityConfiguration = certificateAuthorityConfiguration {
            try encodeContainer.encode(certificateAuthorityConfiguration, forKey: .certificateAuthorityConfiguration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let keyStorageSecurityStandard = keyStorageSecurityStandard {
            try encodeContainer.encode(keyStorageSecurityStandard.rawValue, forKey: .keyStorageSecurityStandard)
        }
        if let lastStateChangeAt = lastStateChangeAt {
            try encodeContainer.encode(lastStateChangeAt.timeIntervalSince1970, forKey: .lastStateChangeAt)
        }
        if let notAfter = notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let ownerAccount = ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let restorableUntil = restorableUntil {
            try encodeContainer.encode(restorableUntil.timeIntervalSince1970, forKey: .restorableUntil)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let serial = serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastStateChangeAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStateChangeAt)
        lastStateChangeAt = lastStateChangeAtDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityType.self, forKey: .type)
        type = typeDecoded
        let serialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serial)
        serial = serialDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityStatus.self, forKey: .status)
        status = statusDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let certificateAuthorityConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityConfiguration.self, forKey: .certificateAuthorityConfiguration)
        certificateAuthorityConfiguration = certificateAuthorityConfigurationDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let restorableUntilDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .restorableUntil)
        restorableUntil = restorableUntilDecoded
        let keyStorageSecurityStandardDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.KeyStorageSecurityStandard.self, forKey: .keyStorageSecurityStandard)
        keyStorageSecurityStandard = keyStorageSecurityStandardDecoded
    }
}

extension AcmPcaClientTypes.CertificateAuthority: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateAuthority(arn: \(Swift.String(describing: arn)), certificateAuthorityConfiguration: \(Swift.String(describing: certificateAuthorityConfiguration)), createdAt: \(Swift.String(describing: createdAt)), failureReason: \(Swift.String(describing: failureReason)), keyStorageSecurityStandard: \(Swift.String(describing: keyStorageSecurityStandard)), lastStateChangeAt: \(Swift.String(describing: lastStateChangeAt)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), ownerAccount: \(Swift.String(describing: ownerAccount)), restorableUntil: \(Swift.String(describing: restorableUntil)), revocationConfiguration: \(Swift.String(describing: revocationConfiguration)), serial: \(Swift.String(describing: serial)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)))"}
}

extension AcmPcaClientTypes {
    /// Contains information about your private certificate authority (CA). Your private CA
    /// 			can issue and revoke X.509 digital certificates. Digital certificates verify that the
    /// 			entity named in the certificate Subject field owns or
    /// 			controls the public key contained in the Subject Public Key
    /// 				Info field. Call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action to create your private CA. You must then
    /// 			call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_GetCertificateAuthorityCertificate.html">GetCertificateAuthorityCertificate action to retrieve a private CA
    /// 			certificate signing request (CSR). Sign the CSR with your ACM Private CA-hosted or on-premises
    /// 			root or subordinate CA certificate. Call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ImportCertificateAuthorityCertificate.html">ImportCertificateAuthorityCertificate action to import the signed
    /// 			certificate into AWS Certificate Manager (ACM).
    public struct CertificateAuthority: Swift.Equatable {
        /// Amazon Resource Name (ARN) for your private certificate authority (CA). The format is
        /// 					
        ///                12345678-1234-1234-1234-123456789012
        ///             .
        public var arn: Swift.String?
        /// Your private CA configuration.
        public var certificateAuthorityConfiguration: AcmPcaClientTypes.CertificateAuthorityConfiguration?
        /// Date and time at which your private CA was created.
        public var createdAt: ClientRuntime.Date?
        /// Reason the request to create your private CA failed.
        public var failureReason: AcmPcaClientTypes.FailureReason?
        /// Defines a cryptographic key management compliance standard used for handling CA keys.
        /// 		       Default: FIPS_140_2_LEVEL_3_OR_HIGHER
        /// 		       Note: AWS Region ap-northeast-3 supports only FIPS_140_2_LEVEL_2_OR_HIGHER. You must
        /// 			explicitly specify this parameter and value when creating a CA in that Region.
        /// 			Specifying a different value (or no value) results in an
        /// 				InvalidArgsException with the message "A certificate authority cannot
        /// 			be created in this region with the specified security standard."
        public var keyStorageSecurityStandard: AcmPcaClientTypes.KeyStorageSecurityStandard?
        /// Date and time at which your private CA was last updated.
        public var lastStateChangeAt: ClientRuntime.Date?
        /// Date and time after which your private CA certificate is not valid.
        public var notAfter: ClientRuntime.Date?
        /// Date and time before which your private CA certificate is not valid.
        public var notBefore: ClientRuntime.Date?
        /// The AWS account ID that owns the certificate authority.
        public var ownerAccount: Swift.String?
        /// The period during which a deleted CA can be restored. For more information, see the
        /// 				PermanentDeletionTimeInDays parameter of the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_DeleteCertificateAuthorityRequest.html">DeleteCertificateAuthorityRequest action.
        public var restorableUntil: ClientRuntime.Date?
        /// Information about the Online Certificate Status Protocol (OCSP) configuration or
        /// 			certificate revocation list (CRL) created and maintained by your private CA.
        public var revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration?
        /// Serial number of your private CA.
        public var serial: Swift.String?
        /// Status of your private CA.
        public var status: AcmPcaClientTypes.CertificateAuthorityStatus?
        /// Type of your private CA.
        public var type: AcmPcaClientTypes.CertificateAuthorityType?

        public init (
            arn: Swift.String? = nil,
            certificateAuthorityConfiguration: AcmPcaClientTypes.CertificateAuthorityConfiguration? = nil,
            createdAt: ClientRuntime.Date? = nil,
            failureReason: AcmPcaClientTypes.FailureReason? = nil,
            keyStorageSecurityStandard: AcmPcaClientTypes.KeyStorageSecurityStandard? = nil,
            lastStateChangeAt: ClientRuntime.Date? = nil,
            notAfter: ClientRuntime.Date? = nil,
            notBefore: ClientRuntime.Date? = nil,
            ownerAccount: Swift.String? = nil,
            restorableUntil: ClientRuntime.Date? = nil,
            revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration? = nil,
            serial: Swift.String? = nil,
            status: AcmPcaClientTypes.CertificateAuthorityStatus? = nil,
            type: AcmPcaClientTypes.CertificateAuthorityType? = nil
        )
        {
            self.arn = arn
            self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
            self.createdAt = createdAt
            self.failureReason = failureReason
            self.keyStorageSecurityStandard = keyStorageSecurityStandard
            self.lastStateChangeAt = lastStateChangeAt
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.ownerAccount = ownerAccount
            self.restorableUntil = restorableUntil
            self.revocationConfiguration = revocationConfiguration
            self.serial = serial
            self.status = status
            self.type = type
        }
    }

}

extension AcmPcaClientTypes.CertificateAuthorityConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csrExtensions = "CsrExtensions"
        case keyAlgorithm = "KeyAlgorithm"
        case signingAlgorithm = "SigningAlgorithm"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csrExtensions = csrExtensions {
            try encodeContainer.encode(csrExtensions, forKey: .csrExtensions)
        }
        if let keyAlgorithm = keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm.rawValue, forKey: .keyAlgorithm)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.KeyAlgorithm.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.SigningAlgorithm.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ASN1Subject.self, forKey: .subject)
        subject = subjectDecoded
        let csrExtensionsDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CsrExtensions.self, forKey: .csrExtensions)
        csrExtensions = csrExtensionsDecoded
    }
}

extension AcmPcaClientTypes.CertificateAuthorityConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateAuthorityConfiguration(csrExtensions: \(Swift.String(describing: csrExtensions)), keyAlgorithm: \(Swift.String(describing: keyAlgorithm)), signingAlgorithm: \(Swift.String(describing: signingAlgorithm)), subject: \(Swift.String(describing: subject)))"}
}

extension AcmPcaClientTypes {
    /// Contains configuration information for your private certificate authority (CA). This
    /// 			includes information about the class of public key algorithm and the key pair that your
    /// 			private CA creates when it issues a certificate. It also includes the signature
    /// 			algorithm that it uses when issuing certificates, and its X.500 distinguished name. You
    /// 			must specify this information when you call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action.
    public struct CertificateAuthorityConfiguration: Swift.Equatable {
        /// Specifies information to be added to the extension section of the certificate signing
        /// 			request (CSR).
        public var csrExtensions: AcmPcaClientTypes.CsrExtensions?
        /// Type of the public key algorithm and size, in bits, of the key pair that your CA
        /// 			creates when it issues a certificate. When you create a subordinate CA, you must use a
        /// 			key algorithm supported by the parent CA.
        /// This member is required.
        public var keyAlgorithm: AcmPcaClientTypes.KeyAlgorithm?
        /// Name of the algorithm your private CA uses to sign certificate requests.
        /// 		       This parameter should not be confused with the SigningAlgorithm parameter
        /// 			used to sign certificates when they are issued.
        /// This member is required.
        public var signingAlgorithm: AcmPcaClientTypes.SigningAlgorithm?
        /// Structure that contains X.500 distinguished name information for your private
        /// 			CA.
        /// This member is required.
        public var subject: AcmPcaClientTypes.ASN1Subject?

        public init (
            csrExtensions: AcmPcaClientTypes.CsrExtensions? = nil,
            keyAlgorithm: AcmPcaClientTypes.KeyAlgorithm? = nil,
            signingAlgorithm: AcmPcaClientTypes.SigningAlgorithm? = nil,
            subject: AcmPcaClientTypes.ASN1Subject? = nil
        )
        {
            self.csrExtensions = csrExtensions
            self.keyAlgorithm = keyAlgorithm
            self.signingAlgorithm = signingAlgorithm
            self.subject = subject
        }
    }

}

extension AcmPcaClientTypes {
    public enum CertificateAuthorityStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case disabled
        case expired
        case failed
        case pendingCertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateAuthorityStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .disabled,
                .expired,
                .failed,
                .pendingCertificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .pendingCertificate: return "PENDING_CERTIFICATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateAuthorityStatus(rawValue: rawValue) ?? CertificateAuthorityStatus.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes {
    public enum CertificateAuthorityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case root
        case subordinate
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateAuthorityType] {
            return [
                .root,
                .subordinate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .root: return "ROOT"
            case .subordinate: return "SUBORDINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateAuthorityType(rawValue: rawValue) ?? CertificateAuthorityType.sdkUnknown(rawValue)
        }
    }
}

extension CertificateMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateMismatchException(message: \(Swift.String(describing: message)))"}
}

extension CertificateMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CertificateMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The certificate authority certificate you are importing does not comply with
/// 			conditions specified in the certificate that signed it.
public struct CertificateMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CertificateMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A previous update to your private CA is still ongoing.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCertificateAuthorityAuditReportInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityAuditReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

extension CreateCertificateAuthorityAuditReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCertificateAuthorityAuditReportInput(auditReportResponseFormat: \(Swift.String(describing: auditReportResponseFormat)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), s3BucketName: \(Swift.String(describing: s3BucketName)))"}
}

extension CreateCertificateAuthorityAuditReportInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportResponseFormat = "AuditReportResponseFormat"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case s3BucketName = "S3BucketName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditReportResponseFormat = auditReportResponseFormat {
            try encodeContainer.encode(auditReportResponseFormat.rawValue, forKey: .auditReportResponseFormat)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
    }
}

public struct CreateCertificateAuthorityAuditReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityAuditReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityAuditReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityAuditReportInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCertificateAuthorityAuditReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCertificateAuthorityAuditReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityAuditReportInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCertificateAuthorityAuditReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCertificateAuthorityAuditReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityAuditReportOutputError>
}

public struct CreateCertificateAuthorityAuditReportInput: Swift.Equatable {
    /// The format in which to create the report. This can be either JSON or CSV.
    /// This member is required.
    public var auditReportResponseFormat: AcmPcaClientTypes.AuditReportResponseFormat?
    /// The Amazon Resource Name (ARN) of the CA to be audited. This is of the form:
    /// 		
    ///             arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// The name of the S3 bucket that will contain the audit report.
    /// This member is required.
    public var s3BucketName: Swift.String?

    public init (
        auditReportResponseFormat: AcmPcaClientTypes.AuditReportResponseFormat? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil
    )
    {
        self.auditReportResponseFormat = auditReportResponseFormat
        self.certificateAuthorityArn = certificateAuthorityArn
        self.s3BucketName = s3BucketName
    }
}

struct CreateCertificateAuthorityAuditReportInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let s3BucketName: Swift.String?
    public let auditReportResponseFormat: AcmPcaClientTypes.AuditReportResponseFormat?
}

extension CreateCertificateAuthorityAuditReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportResponseFormat = "AuditReportResponseFormat"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case s3BucketName = "S3BucketName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let auditReportResponseFormatDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.AuditReportResponseFormat.self, forKey: .auditReportResponseFormat)
        auditReportResponseFormat = auditReportResponseFormatDecoded
    }
}

extension CreateCertificateAuthorityAuditReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCertificateAuthorityAuditReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCertificateAuthorityAuditReportOutputError: Swift.Error, Swift.Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCertificateAuthorityAuditReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCertificateAuthorityAuditReportOutputResponse(auditReportId: \(Swift.String(describing: auditReportId)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension CreateCertificateAuthorityAuditReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCertificateAuthorityAuditReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.auditReportId = output.auditReportId
            self.s3Key = output.s3Key
        } else {
            self.auditReportId = nil
            self.s3Key = nil
        }
    }
}

public struct CreateCertificateAuthorityAuditReportOutputResponse: Swift.Equatable {
    /// An alphanumeric string that contains a report identifier.
    public var auditReportId: Swift.String?
    /// The key that uniquely identifies the report file in
    /// 			your S3 bucket.
    public var s3Key: Swift.String?

    public init (
        auditReportId: Swift.String? = nil,
        s3Key: Swift.String? = nil
    )
    {
        self.auditReportId = auditReportId
        self.s3Key = s3Key
    }
}

struct CreateCertificateAuthorityAuditReportOutputResponseBody: Swift.Equatable {
    public let auditReportId: Swift.String?
    public let s3Key: Swift.String?
}

extension CreateCertificateAuthorityAuditReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportId = "AuditReportId"
        case s3Key = "S3Key"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditReportId)
        auditReportId = auditReportIdDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

public struct CreateCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityOutputError>
}

extension CreateCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCertificateAuthorityInput(certificateAuthorityConfiguration: \(Swift.String(describing: certificateAuthorityConfiguration)), certificateAuthorityType: \(Swift.String(describing: certificateAuthorityType)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), keyStorageSecurityStandard: \(Swift.String(describing: keyStorageSecurityStandard)), revocationConfiguration: \(Swift.String(describing: revocationConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case certificateAuthorityType = "CertificateAuthorityType"
        case idempotencyToken = "IdempotencyToken"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case revocationConfiguration = "RevocationConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityConfiguration = certificateAuthorityConfiguration {
            try encodeContainer.encode(certificateAuthorityConfiguration, forKey: .certificateAuthorityConfiguration)
        }
        if let certificateAuthorityType = certificateAuthorityType {
            try encodeContainer.encode(certificateAuthorityType.rawValue, forKey: .certificateAuthorityType)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let keyStorageSecurityStandard = keyStorageSecurityStandard {
            try encodeContainer.encode(keyStorageSecurityStandard.rawValue, forKey: .keyStorageSecurityStandard)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCertificateAuthorityOutputError>
}

public struct CreateCertificateAuthorityInput: Swift.Equatable {
    /// Name and bit size of the private key algorithm, the name of the signing algorithm, and
    /// 			X.500 certificate subject information.
    /// This member is required.
    public var certificateAuthorityConfiguration: AcmPcaClientTypes.CertificateAuthorityConfiguration?
    /// The type of the certificate authority.
    /// This member is required.
    public var certificateAuthorityType: AcmPcaClientTypes.CertificateAuthorityType?
    /// Custom string that can be used to distinguish between calls to the CreateCertificateAuthority action. Idempotency tokens for
    /// 				CreateCertificateAuthority time out after five
    /// 			minutes. Therefore, if you call CreateCertificateAuthority multiple times with the same idempotency
    /// 			token within five minutes, ACM Private CA recognizes that you are requesting only certificate
    /// 			authority and will issue only one. If you change the idempotency token for each call,
    /// 			PCA recognizes that you are requesting multiple certificate authorities.
    public var idempotencyToken: Swift.String?
    /// Specifies a
    /// 			cryptographic key management compliance standard used for handling CA keys.
    /// 		       Default: FIPS_140_2_LEVEL_3_OR_HIGHER
    /// 		       Note: FIPS_140_2_LEVEL_3_OR_HIGHER is not supported in Region
    /// 			ap-northeast-3. When creating a CA in the ap-northeast-3, you must provide
    /// 				FIPS_140_2_LEVEL_2_OR_HIGHER as the argument for
    /// 				KeyStorageSecurityStandard. Failure to do this results in an
    /// 				InvalidArgsException with the message, "A certificate authority cannot
    /// 			be created in this region with the specified security standard."
    public var keyStorageSecurityStandard: AcmPcaClientTypes.KeyStorageSecurityStandard?
    /// Contains information to enable Online Certificate Status Protocol (OCSP) support,
    /// 			to enable a certificate revocation list (CRL), to enable both, or to enable neither. The
    /// 			default is for both certificate validation mechanisms to be disabled. For more
    /// 			information, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_OcspConfiguration.html">OcspConfiguration and <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CrlConfiguration.html">CrlConfiguration types.
    public var revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration?
    /// Key-value pairs that will be attached to the new private CA. You can associate up to
    /// 			50 tags with a private CA. For information using tags with IAM to manage permissions,
    /// 			see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM Tags.
    public var tags: [AcmPcaClientTypes.Tag]?

    public init (
        certificateAuthorityConfiguration: AcmPcaClientTypes.CertificateAuthorityConfiguration? = nil,
        certificateAuthorityType: AcmPcaClientTypes.CertificateAuthorityType? = nil,
        idempotencyToken: Swift.String? = nil,
        keyStorageSecurityStandard: AcmPcaClientTypes.KeyStorageSecurityStandard? = nil,
        revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration? = nil,
        tags: [AcmPcaClientTypes.Tag]? = nil
    )
    {
        self.certificateAuthorityConfiguration = certificateAuthorityConfiguration
        self.certificateAuthorityType = certificateAuthorityType
        self.idempotencyToken = idempotencyToken
        self.keyStorageSecurityStandard = keyStorageSecurityStandard
        self.revocationConfiguration = revocationConfiguration
        self.tags = tags
    }
}

struct CreateCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityConfiguration: AcmPcaClientTypes.CertificateAuthorityConfiguration?
    public let revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration?
    public let certificateAuthorityType: AcmPcaClientTypes.CertificateAuthorityType?
    public let idempotencyToken: Swift.String?
    public let keyStorageSecurityStandard: AcmPcaClientTypes.KeyStorageSecurityStandard?
    public let tags: [AcmPcaClientTypes.Tag]?
}

extension CreateCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityConfiguration = "CertificateAuthorityConfiguration"
        case certificateAuthorityType = "CertificateAuthorityType"
        case idempotencyToken = "IdempotencyToken"
        case keyStorageSecurityStandard = "KeyStorageSecurityStandard"
        case revocationConfiguration = "RevocationConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityConfiguration.self, forKey: .certificateAuthorityConfiguration)
        certificateAuthorityConfiguration = certificateAuthorityConfigurationDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let certificateAuthorityTypeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityType.self, forKey: .certificateAuthorityType)
        certificateAuthorityType = certificateAuthorityTypeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let keyStorageSecurityStandardDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.KeyStorageSecurityStandard.self, forKey: .keyStorageSecurityStandard)
        keyStorageSecurityStandard = keyStorageSecurityStandardDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AcmPcaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AcmPcaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidTagException(InvalidTagException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCertificateAuthorityOutputResponse(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension CreateCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorityArn = output.certificateAuthorityArn
        } else {
            self.certificateAuthorityArn = nil
        }
    }
}

public struct CreateCertificateAuthorityOutputResponse: Swift.Equatable {
    /// If successful, the Amazon Resource Name (ARN) of the certificate authority (CA). This
    /// 			is of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct CreateCertificateAuthorityOutputResponseBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
}

extension CreateCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

public struct CreatePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePermissionOutputError>
}

extension CreatePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePermissionInput(actions: \(Swift.String(describing: actions)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), principal: \(Swift.String(describing: principal)), sourceAccount: \(Swift.String(describing: sourceAccount)))"}
}

extension CreatePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0.rawValue)
            }
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }
}

public struct CreatePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePermissionOutputError>
}

public struct CreatePermissionInput: Swift.Equatable {
    /// The actions that the specified AWS service principal can use. These include
    /// 				IssueCertificate, GetCertificate, and
    /// 				ListPermissions.
    /// This member is required.
    public var actions: [AcmPcaClientTypes.ActionType]?
    /// The Amazon Resource Name (ARN) of the CA that grants the permissions. You can find the
    /// 			ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action. This must have the following form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// The AWS service or identity that receives the permission. At this time, the only
    /// 			valid principal is acm.amazonaws.com.
    /// This member is required.
    public var principal: Swift.String?
    /// The ID of the calling account.
    public var sourceAccount: Swift.String?

    public init (
        actions: [AcmPcaClientTypes.ActionType]? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        principal: Swift.String? = nil,
        sourceAccount: Swift.String? = nil
    )
    {
        self.actions = actions
        self.certificateAuthorityArn = certificateAuthorityArn
        self.principal = principal
        self.sourceAccount = sourceAccount
    }
}

struct CreatePermissionInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let principal: Swift.String?
    public let sourceAccount: Swift.String?
    public let actions: [AcmPcaClientTypes.ActionType]?
}

extension CreatePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let actionsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.ActionType?].self, forKey: .actions)
        var actionsDecoded0:[AcmPcaClientTypes.ActionType]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [AcmPcaClientTypes.ActionType]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension CreatePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PermissionAlreadyExistsException" : self = .permissionAlreadyExistsException(try PermissionAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case permissionAlreadyExistsException(PermissionAlreadyExistsException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePermissionOutputResponse()"}
}

extension CreatePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreatePermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreatePermissionOutputResponseBody: Swift.Equatable {
}

extension CreatePermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcmPcaClientTypes.CrlConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customCname = "CustomCname"
        case enabled = "Enabled"
        case expirationInDays = "ExpirationInDays"
        case s3BucketName = "S3BucketName"
        case s3ObjectAcl = "S3ObjectAcl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customCname = customCname {
            try encodeContainer.encode(customCname, forKey: .customCname)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let expirationInDays = expirationInDays {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3ObjectAcl = s3ObjectAcl {
            try encodeContainer.encode(s3ObjectAcl.rawValue, forKey: .s3ObjectAcl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays)
        expirationInDays = expirationInDaysDecoded
        let customCnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customCname)
        customCname = customCnameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3ObjectAclDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.S3ObjectAcl.self, forKey: .s3ObjectAcl)
        s3ObjectAcl = s3ObjectAclDecoded
    }
}

extension AcmPcaClientTypes.CrlConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CrlConfiguration(customCname: \(Swift.String(describing: customCname)), enabled: \(Swift.String(describing: enabled)), expirationInDays: \(Swift.String(describing: expirationInDays)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3ObjectAcl: \(Swift.String(describing: s3ObjectAcl)))"}
}

extension AcmPcaClientTypes {
    /// Contains configuration information for a certificate revocation list (CRL). Your
    /// 			private certificate authority (CA) creates base CRLs. Delta CRLs are not supported. You
    /// 			can enable CRLs for your new or an existing private CA by setting the Enabled parameter to true. Your private CA
    /// 			writes CRLs to an S3 bucket that you specify in the S3BucketName parameter. You can hide the name of your bucket by
    /// 			specifying a value for the CustomCname parameter. Your
    /// 			private CA copies the CNAME or the S3 bucket name to the CRL
    /// 				Distribution Points extension of each certificate it issues. Your S3
    /// 			bucket policy must give write permission to ACM Private CA.
    /// 		       ACM Private CA assets that are stored in Amazon S3 can be protected with encryption.
    ///   For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#crl-encryption">Encrypting Your
    /// 			CRLs.
    /// 		       Your private CA uses the value in the ExpirationInDays
    /// 			parameter to calculate the nextUpdate field in the CRL.
    /// 			The CRL is refreshed at 1/2 the age of next update or when a certificate is revoked.
    /// 			When a certificate is revoked, it is recorded in the next CRL that is generated and in
    /// 			the next audit report. Only time valid certificates are listed in the CRL. Expired
    /// 			certificates are not included.
    /// 		
    /// 		       A CRL is typically updated approximately 30 minutes after a certificate
    /// 	is revoked. If for any reason a CRL update fails, ACM Private CA makes further attempts
    /// 	every 15 minutes.
    /// 		
    /// 		       CRLs contain the following fields:
    /// 		
    ///
    /// 				
    ///                   Version: The current version number defined
    /// 					in RFC 5280 is V2. The integer value is 0x1.
    /// 			
    ///
    /// 				
    ///                   Signature Algorithm: The name of the
    /// 					algorithm used to sign the CRL.
    /// 			
    ///
    /// 				
    ///                   Issuer: The X.500 distinguished name of your
    /// 					private CA that issued the CRL.
    /// 			
    ///
    /// 				
    ///                   Last Update: The issue date and time of this
    /// 					CRL.
    /// 			
    ///
    /// 				
    ///                   Next Update: The day and time by which the
    /// 					next CRL will be issued.
    /// 			
    ///
    /// 				
    ///                   Revoked Certificates: List of revoked
    /// 					certificates. Each list item contains the following information.
    /// 				
    ///
    /// 						
    ///                         Serial Number: The serial number, in
    /// 							hexadecimal format, of the revoked certificate.
    /// 					
    ///
    /// 						
    ///                         Revocation Date: Date and time the
    /// 							certificate was revoked.
    /// 					
    ///
    /// 						
    ///                         CRL Entry Extensions: Optional
    /// 							extensions for the CRL entry.
    /// 						
    ///
    /// 								
    ///                               X509v3 CRL Reason Code:
    /// 									Reason the certificate was revoked.
    /// 							
    ///
    /// 					
    ///
    /// 			
    ///
    /// 				
    ///                   CRL Extensions: Optional extensions for the
    /// 					CRL.
    /// 				
    ///
    /// 						
    ///                         X509v3 Authority Key Identifier:
    /// 							Identifies the public key associated with the private key used to sign
    /// 							the certificate.
    /// 					
    ///
    /// 						
    ///                         X509v3 CRL Number:: Decimal sequence
    /// 							number for the CRL.
    /// 					
    ///
    /// 			
    ///
    /// 				
    ///                   Signature Algorithm: Algorithm used by your
    /// 					private CA to sign the CRL.
    /// 			
    ///
    /// 				
    ///                   Signature Value: Signature computed over the
    /// 					CRL.
    /// 			
    ///
    /// 		       Certificate revocation lists created by ACM Private CA are DER-encoded. You can use the
    /// 			following OpenSSL command to list a CRL.
    /// 		
    ///             openssl crl -inform DER -text -in crl_path
    /// 			-noout
    ///
    /// 		       For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/crl-planning.html">Planning a certificate revocation list (CRL)
    /// 			in the AWS Certificate Manager Private Certificate Authority (PCA) User Guide
    ///
    public struct CrlConfiguration: Swift.Equatable {
        /// Name inserted into the certificate CRL Distribution
        /// 				Points extension that enables the use of an alias for the CRL
        /// 			distribution point. Use this value if you don't want the name of your S3 bucket to be
        /// 			public.
        public var customCname: Swift.String?
        /// Boolean value that specifies whether certificate revocation lists (CRLs) are enabled.
        /// 			You can use this value to enable certificate revocation for a new CA when you call the
        /// 				<a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action or for an existing CA when you call the
        /// 				<a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority action.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Validity period of the CRL in days.
        public var expirationInDays: Swift.Int?
        /// Name of the S3 bucket that contains the CRL. If you do not provide a value for the
        /// 				CustomCname argument, the name of your S3 bucket
        /// 			is placed into the CRL Distribution Points extension of
        /// 			the issued certificate. You can change the name of your bucket by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority operation. You must specify a <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#s3-policies">bucket
        /// 				policy that allows ACM Private CA to write the CRL to your bucket.
        public var s3BucketName: Swift.String?
        /// Determines whether the CRL will be publicly readable or privately held in the CRL
        /// 			Amazon S3 bucket. If you choose PUBLIC_READ, the CRL will be accessible over the public
        /// 			internet. If you choose BUCKET_OWNER_FULL_CONTROL, only the owner of the CRL S3 bucket
        /// 			can access the CRL, and your PKI clients may need an alternative method of access.
        /// 		       If no value is specified, the default is PUBLIC_READ.
        /// 		
        ///             Note: This default can cause CA creation to fail in some
        /// 			circumstances. If you have have enabled the Block Public Access (BPA) feature in your S3
        /// 			account, then you must specify the value of this parameter as
        /// 				BUCKET_OWNER_FULL_CONTROL, and not doing so results in an error. If you
        /// 			have disabled BPA in S3, then you can specify either
        /// 				BUCKET_OWNER_FULL_CONTROL or PUBLIC_READ as the
        /// 			value.
        /// 		       For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaCreateCa.html#s3-bpa">Blocking public access to the S3
        /// 				bucket.
        public var s3ObjectAcl: AcmPcaClientTypes.S3ObjectAcl?

        public init (
            customCname: Swift.String? = nil,
            enabled: Swift.Bool = false,
            expirationInDays: Swift.Int? = nil,
            s3BucketName: Swift.String? = nil,
            s3ObjectAcl: AcmPcaClientTypes.S3ObjectAcl? = nil
        )
        {
            self.customCname = customCname
            self.enabled = enabled
            self.expirationInDays = expirationInDays
            self.s3BucketName = s3BucketName
            self.s3ObjectAcl = s3ObjectAcl
        }
    }

}

extension AcmPcaClientTypes.CsrExtensions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyUsage = "KeyUsage"
        case subjectInformationAccess = "SubjectInformationAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage, forKey: .keyUsage)
        }
        if let subjectInformationAccess = subjectInformationAccess {
            var subjectInformationAccessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectInformationAccess)
            for accessdescriptionlist0 in subjectInformationAccess {
                try subjectInformationAccessContainer.encode(accessdescriptionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyUsageDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.KeyUsage.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let subjectInformationAccessContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.AccessDescription?].self, forKey: .subjectInformationAccess)
        var subjectInformationAccessDecoded0:[AcmPcaClientTypes.AccessDescription]? = nil
        if let subjectInformationAccessContainer = subjectInformationAccessContainer {
            subjectInformationAccessDecoded0 = [AcmPcaClientTypes.AccessDescription]()
            for structure0 in subjectInformationAccessContainer {
                if let structure0 = structure0 {
                    subjectInformationAccessDecoded0?.append(structure0)
                }
            }
        }
        subjectInformationAccess = subjectInformationAccessDecoded0
    }
}

extension AcmPcaClientTypes.CsrExtensions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CsrExtensions(keyUsage: \(Swift.String(describing: keyUsage)), subjectInformationAccess: \(Swift.String(describing: subjectInformationAccess)))"}
}

extension AcmPcaClientTypes {
    /// Describes the certificate extensions to be added to the certificate signing request
    /// 			(CSR).
    public struct CsrExtensions: Swift.Equatable {
        /// Indicates the purpose of the certificate and of the key contained in the
        /// 			certificate.
        public var keyUsage: AcmPcaClientTypes.KeyUsage?
        /// For CA certificates, provides a path to additional information pertaining to the CA,
        /// 			such as revocation and policy. For more information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.2">Subject Information
        /// 				Access in RFC 5280.
        public var subjectInformationAccess: [AcmPcaClientTypes.AccessDescription]?

        public init (
            keyUsage: AcmPcaClientTypes.KeyUsage? = nil,
            subjectInformationAccess: [AcmPcaClientTypes.AccessDescription]? = nil
        )
        {
            self.keyUsage = keyUsage
            self.subjectInformationAccess = subjectInformationAccess
        }
    }

}

public struct DeleteCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateAuthorityOutputError>
}

extension DeleteCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), permanentDeletionTimeInDays: \(Swift.String(describing: permanentDeletionTimeInDays)))"}
}

extension DeleteCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case permanentDeletionTimeInDays = "PermanentDeletionTimeInDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let permanentDeletionTimeInDays = permanentDeletionTimeInDays {
            try encodeContainer.encode(permanentDeletionTimeInDays, forKey: .permanentDeletionTimeInDays)
        }
    }
}

public struct DeleteCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCertificateAuthorityOutputError>
}

public struct DeleteCertificateAuthorityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must have the following form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// The number of days to make a CA restorable after it has been deleted. This can be
    /// 			anywhere from 7 to 30 days, with 30 being the default.
    public var permanentDeletionTimeInDays: Swift.Int?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        permanentDeletionTimeInDays: Swift.Int? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.permanentDeletionTimeInDays = permanentDeletionTimeInDays
    }
}

struct DeleteCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let permanentDeletionTimeInDays: Swift.Int?
}

extension DeleteCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case permanentDeletionTimeInDays = "PermanentDeletionTimeInDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let permanentDeletionTimeInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permanentDeletionTimeInDays)
        permanentDeletionTimeInDays = permanentDeletionTimeInDaysDecoded
    }
}

extension DeleteCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCertificateAuthorityOutputResponse()"}
}

extension DeleteCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension DeleteCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePermissionOutputError>
}

extension DeletePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePermissionInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), principal: \(Swift.String(describing: principal)), sourceAccount: \(Swift.String(describing: sourceAccount)))"}
}

extension DeletePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }
}

public struct DeletePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePermissionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePermissionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePermissionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePermissionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePermissionOutputError>
}

public struct DeletePermissionInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the private CA that issued the permissions. You
    /// 			can find the CA's ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action. This must have the following form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// The AWS service or identity that will have its CA permissions revoked. At this time,
    /// 			the only valid service principal is acm.amazonaws.com
    ///
    /// This member is required.
    public var principal: Swift.String?
    /// The AWS account that calls this action.
    public var sourceAccount: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        principal: Swift.String? = nil,
        sourceAccount: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.principal = principal
        self.sourceAccount = sourceAccount
    }
}

struct DeletePermissionInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let principal: Swift.String?
    public let sourceAccount: Swift.String?
}

extension DeletePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
    }
}

extension DeletePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePermissionOutputResponse()"}
}

extension DeletePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePermissionOutputResponseBody: Swift.Equatable {
}

extension DeletePermissionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePolicyOutputError>
}

extension DeletePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePolicyInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension DeletePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeletePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePolicyOutputError>
}

public struct DeletePolicyInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the private CA that will have its policy deleted.
    /// 			You can find the CA's ARN by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action. The ARN value must have the form
    /// 				arn:aws:acm-pca:region:account:certificate-authority/01234567-89ab-cdef-0123-0123456789ab.
    /// 		
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeletePolicyInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension DeletePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeletePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockoutPreventedException" : self = .lockoutPreventedException(try LockoutPreventedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePolicyOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case lockoutPreventedException(LockoutPreventedException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePolicyOutputResponse()"}
}

extension DeletePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePolicyOutputResponseBody: Swift.Equatable {
}

extension DeletePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeCertificateAuthorityAuditReportInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityAuditReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

extension DescribeCertificateAuthorityAuditReportInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificateAuthorityAuditReportInput(auditReportId: \(Swift.String(describing: auditReportId)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension DescribeCertificateAuthorityAuditReportInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportId = "AuditReportId"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditReportId = auditReportId {
            try encodeContainer.encode(auditReportId, forKey: .auditReportId)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct DescribeCertificateAuthorityAuditReportInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityAuditReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityAuditReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityAuditReportInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityAuditReportInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCertificateAuthorityAuditReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCertificateAuthorityAuditReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityAuditReportInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCertificateAuthorityAuditReportInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCertificateAuthorityAuditReportInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityAuditReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityAuditReportOutputError>
}

public struct DescribeCertificateAuthorityAuditReportInput: Swift.Equatable {
    /// The report ID returned by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthorityAuditReport.html">CreateCertificateAuthorityAuditReport action.
    /// This member is required.
    public var auditReportId: Swift.String?
    /// The Amazon Resource Name (ARN) of the private CA. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        auditReportId: Swift.String? = nil,
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.auditReportId = auditReportId
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct DescribeCertificateAuthorityAuditReportInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let auditReportId: Swift.String?
}

extension DescribeCertificateAuthorityAuditReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportId = "AuditReportId"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let auditReportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditReportId)
        auditReportId = auditReportIdDecoded
    }
}

extension DescribeCertificateAuthorityAuditReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateAuthorityAuditReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateAuthorityAuditReportOutputError: Swift.Error, Swift.Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateAuthorityAuditReportOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificateAuthorityAuditReportOutputResponse(auditReportStatus: \(Swift.String(describing: auditReportStatus)), createdAt: \(Swift.String(describing: createdAt)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3Key: \(Swift.String(describing: s3Key)))"}
}

extension DescribeCertificateAuthorityAuditReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCertificateAuthorityAuditReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.auditReportStatus = output.auditReportStatus
            self.createdAt = output.createdAt
            self.s3BucketName = output.s3BucketName
            self.s3Key = output.s3Key
        } else {
            self.auditReportStatus = nil
            self.createdAt = nil
            self.s3BucketName = nil
            self.s3Key = nil
        }
    }
}

public struct DescribeCertificateAuthorityAuditReportOutputResponse: Swift.Equatable {
    /// Specifies whether report creation is in progress, has succeeded, or has failed.
    public var auditReportStatus: AcmPcaClientTypes.AuditReportStatus?
    /// The date and time at which the report was created.
    public var createdAt: ClientRuntime.Date?
    /// Name of the S3 bucket that contains the report.
    public var s3BucketName: Swift.String?
    /// S3 key that uniquely identifies the report file in
    /// 			your S3 bucket.
    public var s3Key: Swift.String?

    public init (
        auditReportStatus: AcmPcaClientTypes.AuditReportStatus? = nil,
        createdAt: ClientRuntime.Date? = nil,
        s3BucketName: Swift.String? = nil,
        s3Key: Swift.String? = nil
    )
    {
        self.auditReportStatus = auditReportStatus
        self.createdAt = createdAt
        self.s3BucketName = s3BucketName
        self.s3Key = s3Key
    }
}

struct DescribeCertificateAuthorityAuditReportOutputResponseBody: Swift.Equatable {
    public let auditReportStatus: AcmPcaClientTypes.AuditReportStatus?
    public let s3BucketName: Swift.String?
    public let s3Key: Swift.String?
    public let createdAt: ClientRuntime.Date?
}

extension DescribeCertificateAuthorityAuditReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditReportStatus = "AuditReportStatus"
        case createdAt = "CreatedAt"
        case s3BucketName = "S3BucketName"
        case s3Key = "S3Key"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditReportStatusDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.AuditReportStatus.self, forKey: .auditReportStatus)
        auditReportStatus = auditReportStatusDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

public struct DescribeCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityOutputError>
}

extension DescribeCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension DescribeCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct DescribeCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificateAuthorityOutputError>
}

public struct DescribeCertificateAuthorityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct DescribeCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
}

extension DescribeCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension DescribeCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificateAuthorityOutputResponse(certificateAuthority: \(Swift.String(describing: certificateAuthority)))"}
}

extension DescribeCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthority = output.certificateAuthority
        } else {
            self.certificateAuthority = nil
        }
    }
}

public struct DescribeCertificateAuthorityOutputResponse: Swift.Equatable {
    /// A <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CertificateAuthority.html">CertificateAuthority structure that contains information about your private
    /// 			CA.
    public var certificateAuthority: AcmPcaClientTypes.CertificateAuthority?

    public init (
        certificateAuthority: AcmPcaClientTypes.CertificateAuthority? = nil
    )
    {
        self.certificateAuthority = certificateAuthority
    }
}

struct DescribeCertificateAuthorityOutputResponseBody: Swift.Equatable {
    public let certificateAuthority: AcmPcaClientTypes.CertificateAuthority?
}

extension DescribeCertificateAuthorityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthority = "CertificateAuthority"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthority.self, forKey: .certificateAuthority)
        certificateAuthority = certificateAuthorityDecoded
    }
}

extension AcmPcaClientTypes.EdiPartyName: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nameAssigner = "NameAssigner"
        case partyName = "PartyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nameAssigner = nameAssigner {
            try encodeContainer.encode(nameAssigner, forKey: .nameAssigner)
        }
        if let partyName = partyName {
            try encodeContainer.encode(partyName, forKey: .partyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partyName)
        partyName = partyNameDecoded
        let nameAssignerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameAssigner)
        nameAssigner = nameAssignerDecoded
    }
}

extension AcmPcaClientTypes.EdiPartyName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EdiPartyName(nameAssigner: \(Swift.String(describing: nameAssigner)), partyName: \(Swift.String(describing: partyName)))"}
}

extension AcmPcaClientTypes {
    /// Describes an Electronic Data Interchange (EDI) entity as described in as defined in
    /// 				<a href="https://tools.ietf.org/html/rfc5280">Subject Alternative Name in
    /// 			RFC 5280.
    public struct EdiPartyName: Swift.Equatable {
        /// Specifies the name assigner.
        public var nameAssigner: Swift.String?
        /// Specifies the party name.
        /// This member is required.
        public var partyName: Swift.String?

        public init (
            nameAssigner: Swift.String? = nil,
            partyName: Swift.String? = nil
        )
        {
            self.nameAssigner = nameAssigner
            self.partyName = partyName
        }
    }

}

extension AcmPcaClientTypes.ExtendedKeyUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extendedKeyUsageObjectIdentifier = "ExtendedKeyUsageObjectIdentifier"
        case extendedKeyUsageType = "ExtendedKeyUsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifier {
            try encodeContainer.encode(extendedKeyUsageObjectIdentifier, forKey: .extendedKeyUsageObjectIdentifier)
        }
        if let extendedKeyUsageType = extendedKeyUsageType {
            try encodeContainer.encode(extendedKeyUsageType.rawValue, forKey: .extendedKeyUsageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let extendedKeyUsageTypeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ExtendedKeyUsageType.self, forKey: .extendedKeyUsageType)
        extendedKeyUsageType = extendedKeyUsageTypeDecoded
        let extendedKeyUsageObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extendedKeyUsageObjectIdentifier)
        extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifierDecoded
    }
}

extension AcmPcaClientTypes.ExtendedKeyUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExtendedKeyUsage(extendedKeyUsageObjectIdentifier: \(Swift.String(describing: extendedKeyUsageObjectIdentifier)), extendedKeyUsageType: \(Swift.String(describing: extendedKeyUsageType)))"}
}

extension AcmPcaClientTypes {
    /// Specifies additional purposes for which the certified public key may be used other
    /// 			than basic purposes indicated in the KeyUsage extension.
    public struct ExtendedKeyUsage: Swift.Equatable {
        /// Specifies a custom ExtendedKeyUsage with an object identifier
        /// 			(OID).
        public var extendedKeyUsageObjectIdentifier: Swift.String?
        /// Specifies a standard ExtendedKeyUsage as defined as in <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.12">RFC 5280.
        public var extendedKeyUsageType: AcmPcaClientTypes.ExtendedKeyUsageType?

        public init (
            extendedKeyUsageObjectIdentifier: Swift.String? = nil,
            extendedKeyUsageType: AcmPcaClientTypes.ExtendedKeyUsageType? = nil
        )
        {
            self.extendedKeyUsageObjectIdentifier = extendedKeyUsageObjectIdentifier
            self.extendedKeyUsageType = extendedKeyUsageType
        }
    }

}

extension AcmPcaClientTypes {
    public enum ExtendedKeyUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case certificateTransparency
        case clientAuth
        case codeSigning
        case documentSigning
        case emailProtection
        case ocspSigning
        case serverAuth
        case smartCardLogin
        case timeStamping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExtendedKeyUsageType] {
            return [
                .certificateTransparency,
                .clientAuth,
                .codeSigning,
                .documentSigning,
                .emailProtection,
                .ocspSigning,
                .serverAuth,
                .smartCardLogin,
                .timeStamping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .certificateTransparency: return "CERTIFICATE_TRANSPARENCY"
            case .clientAuth: return "CLIENT_AUTH"
            case .codeSigning: return "CODE_SIGNING"
            case .documentSigning: return "DOCUMENT_SIGNING"
            case .emailProtection: return "EMAIL_PROTECTION"
            case .ocspSigning: return "OCSP_SIGNING"
            case .serverAuth: return "SERVER_AUTH"
            case .smartCardLogin: return "SMART_CARD_LOGIN"
            case .timeStamping: return "TIME_STAMPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExtendedKeyUsageType(rawValue: rawValue) ?? ExtendedKeyUsageType.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.Extensions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatePolicies = "CertificatePolicies"
        case extendedKeyUsage = "ExtendedKeyUsage"
        case keyUsage = "KeyUsage"
        case subjectAlternativeNames = "SubjectAlternativeNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatePolicies = certificatePolicies {
            var certificatePoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatePolicies)
            for certificatepolicylist0 in certificatePolicies {
                try certificatePoliciesContainer.encode(certificatepolicylist0)
            }
        }
        if let extendedKeyUsage = extendedKeyUsage {
            var extendedKeyUsageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsage)
            for extendedkeyusagelist0 in extendedKeyUsage {
                try extendedKeyUsageContainer.encode(extendedkeyusagelist0)
            }
        }
        if let keyUsage = keyUsage {
            try encodeContainer.encode(keyUsage, forKey: .keyUsage)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for generalnamelist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(generalnamelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatePoliciesContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.PolicyInformation?].self, forKey: .certificatePolicies)
        var certificatePoliciesDecoded0:[AcmPcaClientTypes.PolicyInformation]? = nil
        if let certificatePoliciesContainer = certificatePoliciesContainer {
            certificatePoliciesDecoded0 = [AcmPcaClientTypes.PolicyInformation]()
            for structure0 in certificatePoliciesContainer {
                if let structure0 = structure0 {
                    certificatePoliciesDecoded0?.append(structure0)
                }
            }
        }
        certificatePolicies = certificatePoliciesDecoded0
        let extendedKeyUsageContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.ExtendedKeyUsage?].self, forKey: .extendedKeyUsage)
        var extendedKeyUsageDecoded0:[AcmPcaClientTypes.ExtendedKeyUsage]? = nil
        if let extendedKeyUsageContainer = extendedKeyUsageContainer {
            extendedKeyUsageDecoded0 = [AcmPcaClientTypes.ExtendedKeyUsage]()
            for structure0 in extendedKeyUsageContainer {
                if let structure0 = structure0 {
                    extendedKeyUsageDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsage = extendedKeyUsageDecoded0
        let keyUsageDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.KeyUsage.self, forKey: .keyUsage)
        keyUsage = keyUsageDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.GeneralName?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[AcmPcaClientTypes.GeneralName]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [AcmPcaClientTypes.GeneralName]()
            for structure0 in subjectAlternativeNamesContainer {
                if let structure0 = structure0 {
                    subjectAlternativeNamesDecoded0?.append(structure0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
    }
}

extension AcmPcaClientTypes.Extensions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Extensions(certificatePolicies: \(Swift.String(describing: certificatePolicies)), extendedKeyUsage: \(Swift.String(describing: extendedKeyUsage)), keyUsage: \(Swift.String(describing: keyUsage)), subjectAlternativeNames: \(Swift.String(describing: subjectAlternativeNames)))"}
}

extension AcmPcaClientTypes {
    /// Contains X.509 extension information for a certificate.
    public struct Extensions: Swift.Equatable {
        /// Contains a sequence of one or more policy information terms, each of which consists of
        /// 			an object identifier (OID) and optional qualifiers. For more information, see NIST's
        /// 			definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object
        /// 				Identifier (OID).
        /// 		       In an end-entity certificate, these terms indicate the policy under which the
        /// 			certificate was issued and the purposes for which it may be used. In a CA certificate,
        /// 			these terms limit the set of policies for certification paths that include this
        /// 			certificate.
        public var certificatePolicies: [AcmPcaClientTypes.PolicyInformation]?
        /// Specifies additional purposes for which the certified public key may be used other
        /// 			than basic purposes indicated in the KeyUsage extension.
        public var extendedKeyUsage: [AcmPcaClientTypes.ExtendedKeyUsage]?
        /// Defines one or more purposes for which the key contained in the certificate can be
        /// 			used. Default value for each option is false.
        public var keyUsage: AcmPcaClientTypes.KeyUsage?
        /// The subject alternative name extension allows identities to be bound to the subject of
        /// 			the certificate. These identities may be included in addition to or in place of the
        /// 			identity in the subject field of the certificate.
        public var subjectAlternativeNames: [AcmPcaClientTypes.GeneralName]?

        public init (
            certificatePolicies: [AcmPcaClientTypes.PolicyInformation]? = nil,
            extendedKeyUsage: [AcmPcaClientTypes.ExtendedKeyUsage]? = nil,
            keyUsage: AcmPcaClientTypes.KeyUsage? = nil,
            subjectAlternativeNames: [AcmPcaClientTypes.GeneralName]? = nil
        )
        {
            self.certificatePolicies = certificatePolicies
            self.extendedKeyUsage = extendedKeyUsage
            self.keyUsage = keyUsage
            self.subjectAlternativeNames = subjectAlternativeNames
        }
    }

}

extension AcmPcaClientTypes {
    public enum FailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case other
        case requestTimedOut
        case unsupportedAlgorithm
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReason] {
            return [
                .other,
                .requestTimedOut,
                .unsupportedAlgorithm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .other: return "OTHER"
            case .requestTimedOut: return "REQUEST_TIMED_OUT"
            case .unsupportedAlgorithm: return "UNSUPPORTED_ALGORITHM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.GeneralName: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case dnsName = "DnsName"
        case ediPartyName = "EdiPartyName"
        case ipAddress = "IpAddress"
        case otherName = "OtherName"
        case registeredId = "RegisteredId"
        case rfc822Name = "Rfc822Name"
        case uniformResourceIdentifier = "UniformResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsName = dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ediPartyName = ediPartyName {
            try encodeContainer.encode(ediPartyName, forKey: .ediPartyName)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let otherName = otherName {
            try encodeContainer.encode(otherName, forKey: .otherName)
        }
        if let registeredId = registeredId {
            try encodeContainer.encode(registeredId, forKey: .registeredId)
        }
        if let rfc822Name = rfc822Name {
            try encodeContainer.encode(rfc822Name, forKey: .rfc822Name)
        }
        if let uniformResourceIdentifier = uniformResourceIdentifier {
            try encodeContainer.encode(uniformResourceIdentifier, forKey: .uniformResourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otherNameDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.OtherName.self, forKey: .otherName)
        otherName = otherNameDecoded
        let rfc822NameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rfc822Name)
        rfc822Name = rfc822NameDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ASN1Subject.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let ediPartyNameDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.EdiPartyName.self, forKey: .ediPartyName)
        ediPartyName = ediPartyNameDecoded
        let uniformResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniformResourceIdentifier)
        uniformResourceIdentifier = uniformResourceIdentifierDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let registeredIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredId)
        registeredId = registeredIdDecoded
    }
}

extension AcmPcaClientTypes.GeneralName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeneralName(directoryName: \(Swift.String(describing: directoryName)), dnsName: \(Swift.String(describing: dnsName)), ediPartyName: \(Swift.String(describing: ediPartyName)), ipAddress: \(Swift.String(describing: ipAddress)), otherName: \(Swift.String(describing: otherName)), registeredId: \(Swift.String(describing: registeredId)), rfc822Name: \(Swift.String(describing: rfc822Name)), uniformResourceIdentifier: \(Swift.String(describing: uniformResourceIdentifier)))"}
}

extension AcmPcaClientTypes {
    /// Describes an ASN.1 X.400 GeneralName as defined in <a href="https://tools.ietf.org/html/rfc5280">RFC 5280. Only one of the
    /// 			following naming options should be provided. Providing more than one option results in
    /// 			an InvalidArgsException error.
    public struct GeneralName: Swift.Equatable {
        /// Contains information about the certificate subject. The Subject field in
        /// 			the certificate identifies the entity that owns or controls the public key in the
        /// 			certificate. The entity can be a user, computer, device, or service. The Subject
        /// 			must contain an X.500 distinguished name (DN). A DN is a sequence of relative
        /// 			distinguished names (RDNs). The RDNs are separated by commas in the certificate.
        public var directoryName: AcmPcaClientTypes.ASN1Subject?
        /// Represents GeneralName as a DNS name.
        public var dnsName: Swift.String?
        /// Represents GeneralName as an EdiPartyName object.
        public var ediPartyName: AcmPcaClientTypes.EdiPartyName?
        /// Represents GeneralName as an IPv4 or IPv6 address.
        public var ipAddress: Swift.String?
        /// Represents GeneralName using an OtherName object.
        public var otherName: AcmPcaClientTypes.OtherName?
        ///  Represents GeneralName as an object identifier (OID).
        public var registeredId: Swift.String?
        /// Represents GeneralName as an <a href="https://tools.ietf.org/html/rfc822">RFC 822 email address.
        public var rfc822Name: Swift.String?
        /// Represents GeneralName as a URI.
        public var uniformResourceIdentifier: Swift.String?

        public init (
            directoryName: AcmPcaClientTypes.ASN1Subject? = nil,
            dnsName: Swift.String? = nil,
            ediPartyName: AcmPcaClientTypes.EdiPartyName? = nil,
            ipAddress: Swift.String? = nil,
            otherName: AcmPcaClientTypes.OtherName? = nil,
            registeredId: Swift.String? = nil,
            rfc822Name: Swift.String? = nil,
            uniformResourceIdentifier: Swift.String? = nil
        )
        {
            self.directoryName = directoryName
            self.dnsName = dnsName
            self.ediPartyName = ediPartyName
            self.ipAddress = ipAddress
            self.otherName = otherName
            self.registeredId = registeredId
            self.rfc822Name = rfc822Name
            self.uniformResourceIdentifier = uniformResourceIdentifier
        }
    }

}

public struct GetCertificateAuthorityCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCertificateOutputError>
}

extension GetCertificateAuthorityCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateAuthorityCertificateInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateAuthorityCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateAuthorityCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCertificateAuthorityCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateAuthorityCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCertificateAuthorityCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateAuthorityCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCertificateOutputError>
}

public struct GetCertificateAuthorityCertificateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of your private CA. This is of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateAuthorityCertificateInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
}

extension GetCertificateAuthorityCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension GetCertificateAuthorityCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateAuthorityCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateAuthorityCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateAuthorityCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateAuthorityCertificateOutputResponse(certificate: \(Swift.String(describing: certificate)), certificateChain: \(Swift.String(describing: certificateChain)))"}
}

extension GetCertificateAuthorityCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCertificateAuthorityCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.certificateChain = output.certificateChain
        } else {
            self.certificate = nil
            self.certificateChain = nil
        }
    }
}

public struct GetCertificateAuthorityCertificateOutputResponse: Swift.Equatable {
    /// Base64-encoded certificate authority (CA) certificate.
    public var certificate: Swift.String?
    /// Base64-encoded certificate chain that includes any intermediate certificates and
    /// 			chains up to root certificate that you used to sign your private CA certificate. The
    /// 			chain does not include your private CA certificate. If this is a root CA, the value will
    /// 			be null.
    public var certificateChain: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        certificateChain: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.certificateChain = certificateChain
    }
}

struct GetCertificateAuthorityCertificateOutputResponseBody: Swift.Equatable {
    public let certificate: Swift.String?
    public let certificateChain: Swift.String?
}

extension GetCertificateAuthorityCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

public struct GetCertificateAuthorityCsrInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCsrInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCsrOutputError>
}

extension GetCertificateAuthorityCsrInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateAuthorityCsrInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateAuthorityCsrInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateAuthorityCsrInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCsrInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCsrInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateAuthorityCsrInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCsrInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCertificateAuthorityCsrInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateAuthorityCsrInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateAuthorityCsrInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCertificateAuthorityCsrInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateAuthorityCsrInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateAuthorityCsrOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateAuthorityCsrOutputError>
}

public struct GetCertificateAuthorityCsrInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateAuthorityCsrInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
}

extension GetCertificateAuthorityCsrInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension GetCertificateAuthorityCsrOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateAuthorityCsrOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateAuthorityCsrOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateAuthorityCsrOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateAuthorityCsrOutputResponse(csr: \(Swift.String(describing: csr)))"}
}

extension GetCertificateAuthorityCsrOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCertificateAuthorityCsrOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.csr = output.csr
        } else {
            self.csr = nil
        }
    }
}

public struct GetCertificateAuthorityCsrOutputResponse: Swift.Equatable {
    /// The base64 PEM-encoded certificate signing request (CSR) for your private CA
    /// 			certificate.
    public var csr: Swift.String?

    public init (
        csr: Swift.String? = nil
    )
    {
        self.csr = csr
    }
}

struct GetCertificateAuthorityCsrOutputResponseBody: Swift.Equatable {
    public let csr: Swift.String?
}

extension GetCertificateAuthorityCsrOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csr = "Csr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csr)
        csr = csrDecoded
    }
}

public struct GetCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateOutputError>
}

extension GetCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateInput(certificateArn: \(Swift.String(describing: certificateArn)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension GetCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct GetCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateOutputError>
}

public struct GetCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateOutputError>
}

public struct GetCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateOutputError>
}

public struct GetCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCertificateOutputError>
}

public struct GetCertificateInput: Swift.Equatable {
    /// The ARN of the issued certificate. The ARN contains the certificate serial number and
    /// 			must be in the following form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012/certificate/286535153982981100925020015808220737245
    ///
    /// 		
    /// This member is required.
    public var certificateArn: Swift.String?
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///             .
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct GetCertificateInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let certificateArn: Swift.String?
}

extension GetCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension GetCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCertificateOutputResponse(certificate: \(Swift.String(describing: certificate)), certificateChain: \(Swift.String(describing: certificateChain)))"}
}

extension GetCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.certificateChain = output.certificateChain
        } else {
            self.certificate = nil
            self.certificateChain = nil
        }
    }
}

public struct GetCertificateOutputResponse: Swift.Equatable {
    /// The base64 PEM-encoded certificate specified by the CertificateArn
    /// 			parameter.
    public var certificate: Swift.String?
    /// The base64 PEM-encoded certificate chain that chains up to the root CA certificate
    /// 			that you used to sign your private CA certificate.
    public var certificateChain: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        certificateChain: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.certificateChain = certificateChain
    }
}

struct GetCertificateOutputResponseBody: Swift.Equatable {
    public let certificate: Swift.String?
    public let certificateChain: Swift.String?
}

extension GetCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

public struct GetPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

extension GetPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension GetPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the private CA that will have its policy
    /// 			retrieved. You can find the CA's ARN by calling the ListCertificateAuthorities action.
    /// 			
    /// 		
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetPolicyInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension GetPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetPolicyOutputResponse: Swift.Equatable {
    /// The policy attached to the private CA as a JSON document.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct ImportCertificateAuthorityCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateAuthorityCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateAuthorityCertificateOutputError>
}

extension ImportCertificateAuthorityCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateAuthorityCertificateInput(certificate: \(Swift.String(describing: certificate)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), certificateChain: \(Swift.String(describing: certificateChain)))"}
}

extension ImportCertificateAuthorityCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateChain = "CertificateChain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate.base64EncodedString(), forKey: .certificate)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain.base64EncodedString(), forKey: .certificateChain)
        }
    }
}

public struct ImportCertificateAuthorityCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateAuthorityCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateAuthorityCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportCertificateAuthorityCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateAuthorityCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ImportCertificateAuthorityCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportCertificateAuthorityCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportCertificateAuthorityCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ImportCertificateAuthorityCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportCertificateAuthorityCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportCertificateAuthorityCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportCertificateAuthorityCertificateOutputError>
}

public struct ImportCertificateAuthorityCertificateInput: Swift.Equatable {
    /// The PEM-encoded certificate for a private CA. This may be a self-signed certificate in
    /// 			the case of a root CA, or it may be signed by another CA that you control.
    /// This member is required.
    public var certificate: ClientRuntime.Data?
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    ///             arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    ///
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// A PEM-encoded file that contains all of your certificates, other than the certificate
    /// 			you're importing, chaining up to your root CA. Your ACM Private CA-hosted or on-premises root
    /// 			certificate is the last in the chain, and each certificate in the chain signs the one
    /// 			preceding.
    /// 		       This parameter must be supplied when you import a subordinate CA. When you import a
    /// 			root CA, there is no chain.
    public var certificateChain: ClientRuntime.Data?

    public init (
        certificate: ClientRuntime.Data? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        certificateChain: ClientRuntime.Data? = nil
    )
    {
        self.certificate = certificate
        self.certificateAuthorityArn = certificateAuthorityArn
        self.certificateChain = certificateChain
    }
}

struct ImportCertificateAuthorityCertificateInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let certificate: ClientRuntime.Data?
    public let certificateChain: ClientRuntime.Data?
}

extension ImportCertificateAuthorityCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateChain = "CertificateChain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension ImportCertificateAuthorityCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateAuthorityCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateMismatchException" : self = .certificateMismatchException(try CertificateMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCertificateException" : self = .malformedCertificateException(try MalformedCertificateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportCertificateAuthorityCertificateOutputError: Swift.Error, Swift.Equatable {
    case certificateMismatchException(CertificateMismatchException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case malformedCertificateException(MalformedCertificateException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateAuthorityCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateAuthorityCertificateOutputResponse()"}
}

extension ImportCertificateAuthorityCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ImportCertificateAuthorityCertificateOutputResponse: Swift.Equatable {

    public init() {}
}

struct ImportCertificateAuthorityCertificateOutputResponseBody: Swift.Equatable {
}

extension ImportCertificateAuthorityCertificateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InvalidArgsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgsException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified arguments was not valid.
public struct InvalidArgsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArnException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested Amazon Resource Name (ARN) does not refer to an existing
/// 			resource.
public struct InvalidArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token specified in the NextToken argument is not valid. Use the token
/// 			returned from your previous call to <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPolicyException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPolicyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource policy is invalid or is missing a required statement. For general
/// 			information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies.
public struct InvalidPolicyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request action cannot be performed or is prohibited.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the private CA does not allow this action to occur.
public struct InvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The tag associated with the CA is not valid. The invalid argument is contained in the
/// 			message field.
public struct InvalidTagException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct IssueCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IssueCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IssueCertificateOutputError>
}

extension IssueCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IssueCertificateInput(apiPassthrough: \(Swift.String(describing: apiPassthrough)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), csr: \(Swift.String(describing: csr)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), signingAlgorithm: \(Swift.String(describing: signingAlgorithm)), templateArn: \(Swift.String(describing: templateArn)), validity: \(Swift.String(describing: validity)), validityNotBefore: \(Swift.String(describing: validityNotBefore)))"}
}

extension IssueCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiPassthrough = "ApiPassthrough"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case csr = "Csr"
        case idempotencyToken = "IdempotencyToken"
        case signingAlgorithm = "SigningAlgorithm"
        case templateArn = "TemplateArn"
        case validity = "Validity"
        case validityNotBefore = "ValidityNotBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiPassthrough = apiPassthrough {
            try encodeContainer.encode(apiPassthrough, forKey: .apiPassthrough)
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let csr = csr {
            try encodeContainer.encode(csr.base64EncodedString(), forKey: .csr)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let signingAlgorithm = signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm.rawValue, forKey: .signingAlgorithm)
        }
        if let templateArn = templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
        if let validityNotBefore = validityNotBefore {
            try encodeContainer.encode(validityNotBefore, forKey: .validityNotBefore)
        }
    }
}

public struct IssueCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IssueCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IssueCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<IssueCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<IssueCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IssueCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: IssueCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IssueCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "IssueCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: IssueCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<IssueCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = IssueCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<IssueCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<IssueCertificateOutputError>
}

public struct IssueCertificateInput: Swift.Equatable {
    /// Specifies X.509 certificate information to be included in the issued certificate. An
    /// 				APIPassthrough or APICSRPassthrough template variant must
    /// 			be selected, or else this parameter is ignored. For more information about using these
    /// 			templates, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html">Understanding Certificate Templates.
    /// 		       If conflicting or duplicate certificate information is supplied during certificate
    /// 			issuance, ACM Private CA applies <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html#template-order-of-operations">order of
    /// 				operation rules to determine what information is used.
    public var apiPassthrough: AcmPcaClientTypes.ApiPassthrough?
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// The certificate signing request (CSR) for the certificate you want to issue. As an
    /// 			example, you can use the following OpenSSL command to create the CSR and a 2048 bit RSA
    /// 			private key.
    /// 		
    /// 			         openssl req -new -newkey rsa:2048 -days 365 -keyout private/test_cert_priv_key.pem
    /// 				-out csr/test_cert_.csr
    /// 		
    /// 		       If you have a configuration file, you can then use the following OpenSSL command. The
    /// 				usr_cert block in the configuration file contains your X509 version 3
    /// 			extensions.
    /// 		
    ///             openssl req -new -config openssl_rsa.cnf -extensions usr_cert -newkey rsa:2048
    /// 				-days -365 -keyout private/test_cert_priv_key.pem -out
    /// 			csr/test_cert_.csr
    ///
    /// 		       Note: A CSR must provide either a subject name or a
    /// 				subject alternative name or the request will be rejected.
    /// 		
    /// This member is required.
    public var csr: ClientRuntime.Data?
    /// Alphanumeric string that can be used to distinguish between calls to the IssueCertificate action. Idempotency tokens for IssueCertificate time out after one minute. Therefore, if you
    /// 			call IssueCertificate multiple times with the same
    /// 			idempotency token within one minute, ACM Private CA recognizes that you are requesting only one
    /// 			certificate and will issue only one. If you change the idempotency token for each call,
    /// 			PCA recognizes that you are requesting multiple certificates.
    public var idempotencyToken: Swift.String?
    /// The name of the algorithm that will be used to sign the certificate to be issued.
    /// 		       This parameter should not be confused with the SigningAlgorithm parameter
    /// 			used to sign a CSR in the CreateCertificateAuthority action.
    /// This member is required.
    public var signingAlgorithm: AcmPcaClientTypes.SigningAlgorithm?
    /// Specifies a custom configuration template to use when issuing a certificate. If this
    /// 			parameter is not provided, ACM Private CA defaults to the EndEntityCertificate/V1
    /// 			template. For CA certificates, you should choose the shortest path length that meets
    /// 			your needs. The path length is indicated by the PathLenN portion of
    /// 			the ARN, where N is the <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/PcaTerms.html#terms-cadepth">CA depth.
    /// 		       Note: The CA depth configured on a subordinate CA certificate must not exceed the
    /// 			limit set by its parents in the CA hierarchy.
    /// 		       For a list of TemplateArn values supported by ACM Private CA, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/UsingTemplates.html">Understanding Certificate
    /// 				Templates.
    public var templateArn: Swift.String?
    /// Information describing the end of the validity period of the certificate. This
    /// 			parameter sets the Not After date for the certificate.
    /// 		       Certificate validity is the period of time during which a certificate is valid.
    /// 			Validity can be expressed as an explicit date and time when the certificate expires, or
    /// 			as a span of time after issuance, stated in days, months, or years. For more
    /// 			information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity in RFC 5280.
    /// 		       This value is unaffected when ValidityNotBefore is also specified. For
    /// 			example, if Validity is set to 20 days in the future, the certificate will
    /// 			expire 20 days from issuance time regardless of the ValidityNotBefore
    /// 			value.
    /// 		       The end of the validity period configured on a certificate must not exceed the limit
    /// 			set on its parents in the CA hierarchy.
    /// This member is required.
    public var validity: AcmPcaClientTypes.Validity?
    /// Information describing the start of the validity period of the certificate. This
    /// 			parameter sets the Not Before" date for the certificate.
    /// 		       By default, when issuing a certificate, ACM Private CA sets the "Not Before" date to the
    /// 			issuance time minus 60 minutes. This compensates for clock inconsistencies across
    /// 			computer systems. The ValidityNotBefore parameter can be used to customize
    /// 			the Not Before value.
    /// 		       Unlike the Validity parameter, the ValidityNotBefore
    /// 			parameter is optional.
    /// 		       The ValidityNotBefore value is expressed as an explicit date and time,
    /// 			using the Validity type value ABSOLUTE. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_Validity.html">Validity in this API reference and <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity in RFC
    /// 			5280.
    public var validityNotBefore: AcmPcaClientTypes.Validity?

    public init (
        apiPassthrough: AcmPcaClientTypes.ApiPassthrough? = nil,
        certificateAuthorityArn: Swift.String? = nil,
        csr: ClientRuntime.Data? = nil,
        idempotencyToken: Swift.String? = nil,
        signingAlgorithm: AcmPcaClientTypes.SigningAlgorithm? = nil,
        templateArn: Swift.String? = nil,
        validity: AcmPcaClientTypes.Validity? = nil,
        validityNotBefore: AcmPcaClientTypes.Validity? = nil
    )
    {
        self.apiPassthrough = apiPassthrough
        self.certificateAuthorityArn = certificateAuthorityArn
        self.csr = csr
        self.idempotencyToken = idempotencyToken
        self.signingAlgorithm = signingAlgorithm
        self.templateArn = templateArn
        self.validity = validity
        self.validityNotBefore = validityNotBefore
    }
}

struct IssueCertificateInputBody: Swift.Equatable {
    public let apiPassthrough: AcmPcaClientTypes.ApiPassthrough?
    public let certificateAuthorityArn: Swift.String?
    public let csr: ClientRuntime.Data?
    public let signingAlgorithm: AcmPcaClientTypes.SigningAlgorithm?
    public let templateArn: Swift.String?
    public let validity: AcmPcaClientTypes.Validity?
    public let validityNotBefore: AcmPcaClientTypes.Validity?
    public let idempotencyToken: Swift.String?
}

extension IssueCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiPassthrough = "ApiPassthrough"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case csr = "Csr"
        case idempotencyToken = "IdempotencyToken"
        case signingAlgorithm = "SigningAlgorithm"
        case templateArn = "TemplateArn"
        case validity = "Validity"
        case validityNotBefore = "ValidityNotBefore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiPassthroughDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ApiPassthrough.self, forKey: .apiPassthrough)
        apiPassthrough = apiPassthroughDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let csrDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .csr)
        csr = csrDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.SigningAlgorithm.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let validityDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.Validity.self, forKey: .validity)
        validity = validityDecoded
        let validityNotBeforeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.Validity.self, forKey: .validityNotBefore)
        validityNotBefore = validityNotBeforeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension IssueCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IssueCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedCSRException" : self = .malformedCSRException(try MalformedCSRException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IssueCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case malformedCSRException(MalformedCSRException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension IssueCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IssueCertificateOutputResponse(certificateArn: \(Swift.String(describing: certificateArn)))"}
}

extension IssueCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IssueCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
        } else {
            self.certificateArn = nil
        }
    }
}

public struct IssueCertificateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the issued certificate and the certificate serial
    /// 			number. This is of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012/certificate/286535153982981100925020015808220737245
    ///
    /// 		
    public var certificateArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct IssueCertificateOutputResponseBody: Swift.Equatable {
    public let certificateArn: Swift.String?
}

extension IssueCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension AcmPcaClientTypes {
    public enum KeyAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecPrime256v1
        case ecSecp384r1
        case rsa2048
        case rsa4096
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyAlgorithm] {
            return [
                .ecPrime256v1,
                .ecSecp384r1,
                .rsa2048,
                .rsa4096,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecPrime256v1: return "EC_prime256v1"
            case .ecSecp384r1: return "EC_secp384r1"
            case .rsa2048: return "RSA_2048"
            case .rsa4096: return "RSA_4096"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyAlgorithm(rawValue: rawValue) ?? KeyAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes {
    public enum KeyStorageSecurityStandard: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fips1402Level2OrHigher
        case fips1402Level3OrHigher
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyStorageSecurityStandard] {
            return [
                .fips1402Level2OrHigher,
                .fips1402Level3OrHigher,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fips1402Level2OrHigher: return "FIPS_140_2_LEVEL_2_OR_HIGHER"
            case .fips1402Level3OrHigher: return "FIPS_140_2_LEVEL_3_OR_HIGHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyStorageSecurityStandard(rawValue: rawValue) ?? KeyStorageSecurityStandard.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.KeyUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cRLSign = "CRLSign"
        case dataEncipherment = "DataEncipherment"
        case decipherOnly = "DecipherOnly"
        case digitalSignature = "DigitalSignature"
        case encipherOnly = "EncipherOnly"
        case keyAgreement = "KeyAgreement"
        case keyCertSign = "KeyCertSign"
        case keyEncipherment = "KeyEncipherment"
        case nonRepudiation = "NonRepudiation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cRLSign != false {
            try encodeContainer.encode(cRLSign, forKey: .cRLSign)
        }
        if dataEncipherment != false {
            try encodeContainer.encode(dataEncipherment, forKey: .dataEncipherment)
        }
        if decipherOnly != false {
            try encodeContainer.encode(decipherOnly, forKey: .decipherOnly)
        }
        if digitalSignature != false {
            try encodeContainer.encode(digitalSignature, forKey: .digitalSignature)
        }
        if encipherOnly != false {
            try encodeContainer.encode(encipherOnly, forKey: .encipherOnly)
        }
        if keyAgreement != false {
            try encodeContainer.encode(keyAgreement, forKey: .keyAgreement)
        }
        if keyCertSign != false {
            try encodeContainer.encode(keyCertSign, forKey: .keyCertSign)
        }
        if keyEncipherment != false {
            try encodeContainer.encode(keyEncipherment, forKey: .keyEncipherment)
        }
        if nonRepudiation != false {
            try encodeContainer.encode(nonRepudiation, forKey: .nonRepudiation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let digitalSignatureDecoded = try containerValues.decode(Swift.Bool.self, forKey: .digitalSignature)
        digitalSignature = digitalSignatureDecoded
        let nonRepudiationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .nonRepudiation)
        nonRepudiation = nonRepudiationDecoded
        let keyEnciphermentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .keyEncipherment)
        keyEncipherment = keyEnciphermentDecoded
        let dataEnciphermentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dataEncipherment)
        dataEncipherment = dataEnciphermentDecoded
        let keyAgreementDecoded = try containerValues.decode(Swift.Bool.self, forKey: .keyAgreement)
        keyAgreement = keyAgreementDecoded
        let keyCertSignDecoded = try containerValues.decode(Swift.Bool.self, forKey: .keyCertSign)
        keyCertSign = keyCertSignDecoded
        let cRLSignDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cRLSign)
        cRLSign = cRLSignDecoded
        let encipherOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encipherOnly)
        encipherOnly = encipherOnlyDecoded
        let decipherOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .decipherOnly)
        decipherOnly = decipherOnlyDecoded
    }
}

extension AcmPcaClientTypes.KeyUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyUsage(cRLSign: \(Swift.String(describing: cRLSign)), dataEncipherment: \(Swift.String(describing: dataEncipherment)), decipherOnly: \(Swift.String(describing: decipherOnly)), digitalSignature: \(Swift.String(describing: digitalSignature)), encipherOnly: \(Swift.String(describing: encipherOnly)), keyAgreement: \(Swift.String(describing: keyAgreement)), keyCertSign: \(Swift.String(describing: keyCertSign)), keyEncipherment: \(Swift.String(describing: keyEncipherment)), nonRepudiation: \(Swift.String(describing: nonRepudiation)))"}
}

extension AcmPcaClientTypes {
    /// Defines one or more purposes for which the key contained in the certificate can be
    /// 			used. Default value for each option is false.
    public struct KeyUsage: Swift.Equatable {
        /// Key can be used to sign CRLs.
        public var cRLSign: Swift.Bool
        /// Key can be used to decipher data.
        public var dataEncipherment: Swift.Bool
        /// Key can be used only to decipher data.
        public var decipherOnly: Swift.Bool
        ///  Key can be used for digital signing.
        public var digitalSignature: Swift.Bool
        /// Key can be used only to encipher data.
        public var encipherOnly: Swift.Bool
        /// Key can be used in a key-agreement protocol.
        public var keyAgreement: Swift.Bool
        /// Key can be used to sign certificates.
        public var keyCertSign: Swift.Bool
        /// Key can be used to encipher data.
        public var keyEncipherment: Swift.Bool
        /// Key can be used for non-repudiation.
        public var nonRepudiation: Swift.Bool

        public init (
            cRLSign: Swift.Bool = false,
            dataEncipherment: Swift.Bool = false,
            decipherOnly: Swift.Bool = false,
            digitalSignature: Swift.Bool = false,
            encipherOnly: Swift.Bool = false,
            keyAgreement: Swift.Bool = false,
            keyCertSign: Swift.Bool = false,
            keyEncipherment: Swift.Bool = false,
            nonRepudiation: Swift.Bool = false
        )
        {
            self.cRLSign = cRLSign
            self.dataEncipherment = dataEncipherment
            self.decipherOnly = decipherOnly
            self.digitalSignature = digitalSignature
            self.encipherOnly = encipherOnly
            self.keyAgreement = keyAgreement
            self.keyCertSign = keyCertSign
            self.keyEncipherment = keyEncipherment
            self.nonRepudiation = nonRepudiation
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An ACM Private CA quota has been exceeded. See the exception message returned to determine the
/// 			quota that was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListCertificateAuthoritiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCertificateAuthoritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCertificateAuthoritiesOutputError>
}

extension ListCertificateAuthoritiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCertificateAuthoritiesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceOwner: \(Swift.String(describing: resourceOwner)))"}
}

extension ListCertificateAuthoritiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceOwner = "ResourceOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
    }
}

public struct ListCertificateAuthoritiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCertificateAuthoritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCertificateAuthoritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCertificateAuthoritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCertificateAuthoritiesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCertificateAuthoritiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCertificateAuthoritiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCertificateAuthoritiesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCertificateAuthoritiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCertificateAuthoritiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCertificateAuthoritiesOutputError>
}

public struct ListCertificateAuthoritiesInput: Swift.Equatable {
    /// Use this parameter when paginating results to specify the maximum number of items to
    /// 			return in the response on each page. If additional items exist beyond the number you
    /// 			specify, the NextToken element is sent in the response. Use this
    /// 				NextToken value in a subsequent request to retrieve additional
    /// 			items.
    public var maxResults: Swift.Int?
    /// Use this parameter when paginating results in a subsequent request after you receive a
    /// 			response with truncated results. Set it to the value of the NextToken
    /// 			parameter from the response you just received.
    public var nextToken: Swift.String?
    /// Use this parameter to filter the returned set of certificate authorities based on
    /// 			their owner. The default is SELF.
    public var resourceOwner: AcmPcaClientTypes.ResourceOwner?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceOwner: AcmPcaClientTypes.ResourceOwner? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
    }
}

struct ListCertificateAuthoritiesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let resourceOwner: AcmPcaClientTypes.ResourceOwner?
}

extension ListCertificateAuthoritiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceOwner = "ResourceOwner"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
    }
}

extension ListCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCertificateAuthoritiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCertificateAuthoritiesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCertificateAuthoritiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCertificateAuthoritiesOutputResponse(certificateAuthorities: \(Swift.String(describing: certificateAuthorities)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCertificateAuthoritiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorities = output.certificateAuthorities
            self.nextToken = output.nextToken
        } else {
            self.certificateAuthorities = nil
            self.nextToken = nil
        }
    }
}

public struct ListCertificateAuthoritiesOutputResponse: Swift.Equatable {
    /// Summary information about each certificate authority you have created.
    public var certificateAuthorities: [AcmPcaClientTypes.CertificateAuthority]?
    /// When the list is truncated, this value is present and should be used for the
    /// 				NextToken parameter in a subsequent pagination request.
    public var nextToken: Swift.String?

    public init (
        certificateAuthorities: [AcmPcaClientTypes.CertificateAuthority]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificateAuthorities = certificateAuthorities
        self.nextToken = nextToken
    }
}

struct ListCertificateAuthoritiesOutputResponseBody: Swift.Equatable {
    public let certificateAuthorities: [AcmPcaClientTypes.CertificateAuthority]?
    public let nextToken: Swift.String?
}

extension ListCertificateAuthoritiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorities = "CertificateAuthorities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthoritiesContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.CertificateAuthority?].self, forKey: .certificateAuthorities)
        var certificateAuthoritiesDecoded0:[AcmPcaClientTypes.CertificateAuthority]? = nil
        if let certificateAuthoritiesContainer = certificateAuthoritiesContainer {
            certificateAuthoritiesDecoded0 = [AcmPcaClientTypes.CertificateAuthority]()
            for structure0 in certificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    certificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        certificateAuthorities = certificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the private CA to inspect. You can find the ARN by
    /// 			calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action. This must be of the form:
    /// 				arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    /// 			You can get a private CA's ARN by running the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action.
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// When paginating results, use this parameter to specify the maximum number of items to
    /// 			return in the response. If additional items exist beyond the number you specify, the
    /// 				NextToken element is sent in the response. Use this
    /// 				NextToken value in a subsequent request to retrieve
    /// 			additional items.
    public var maxResults: Swift.Int?
    /// When paginating results, use this parameter in a subsequent request after you receive
    /// 			a response with truncated results. Set it to the value of NextToken from the response you just received.
    public var nextToken: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidStateException(InvalidStateException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// When the list is truncated, this value is present and should be used for the NextToken parameter in a subsequent pagination request.
    /// 		
    public var nextToken: Swift.String?
    /// Summary information about each permission assigned by the specified private CA,
    /// 			including the action enabled, the policy provided, and the time of creation.
    public var permissions: [AcmPcaClientTypes.Permission]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [AcmPcaClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [AcmPcaClientTypes.Permission]?
    public let nextToken: Swift.String?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[AcmPcaClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [AcmPcaClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// Use this parameter when paginating results to specify the maximum number of items to
    /// 			return in the response. If additional items exist beyond the number you specify, the
    /// 				NextToken element is sent in the response. Use this
    /// 				NextToken value in a subsequent request to retrieve
    /// 			additional items.
    public var maxResults: Swift.Int?
    /// Use this parameter when paginating results in a subsequent request after you receive a
    /// 			response with truncated results. Set it to the value of NextToken from the response you just received.
    public var nextToken: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// When the list is truncated, this value is present and should be used for the NextToken parameter in a subsequent pagination request.
    /// 		
    public var nextToken: Swift.String?
    /// The tags associated with your private CA.
    public var tags: [AcmPcaClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [AcmPcaClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [AcmPcaClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AcmPcaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AcmPcaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LockoutPreventedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LockoutPreventedException(message: \(Swift.String(describing: message)))"}
}

extension LockoutPreventedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LockoutPreventedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The current action was prevented because it would lock the caller out from performing
/// 			subsequent actions. Verify that the specified parameters would not result in the caller
/// 			being denied access to the resource.
public struct LockoutPreventedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LockoutPreventedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LockoutPreventedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedCSRException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedCSRException(message: \(Swift.String(describing: message)))"}
}

extension MalformedCSRException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedCSRExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The certificate signing request is invalid.
public struct MalformedCSRException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCSRExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedCSRExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedCertificateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedCertificateException(message: \(Swift.String(describing: message)))"}
}

extension MalformedCertificateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedCertificateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more fields in the certificate are invalid.
public struct MalformedCertificateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedCertificateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedCertificateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcmPcaClientTypes.OcspConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case ocspCustomCname = "OcspCustomCname"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ocspCustomCname = ocspCustomCname {
            try encodeContainer.encode(ocspCustomCname, forKey: .ocspCustomCname)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let ocspCustomCnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ocspCustomCname)
        ocspCustomCname = ocspCustomCnameDecoded
    }
}

extension AcmPcaClientTypes.OcspConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OcspConfiguration(enabled: \(Swift.String(describing: enabled)), ocspCustomCname: \(Swift.String(describing: ocspCustomCname)))"}
}

extension AcmPcaClientTypes {
    /// Contains information to enable and configure Online Certificate Status Protocol (OCSP) for
    /// 			validating certificate revocation status.
    /// 		       When you revoke a certificate, OCSP responses may take up to 60 minutes
    /// 	to reflect the new status.
    public struct OcspConfiguration: Swift.Equatable {
        /// Flag enabling use of the Online Certificate Status Protocol (OCSP) for validating
        /// 			certificate revocation status.
        /// This member is required.
        public var enabled: Swift.Bool
        /// By default, ACM Private CA injects an AWS domain into certificates being validated by the
        /// 			Online Certificate Status Protocol (OCSP). A customer can alternatively use this object
        /// 			to define a CNAME specifying a customized OCSP domain.
        /// 		       Note: The value of the CNAME must not include a protocol prefix such as "http://" or
        /// 			"https://".
        /// 		       For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/ocsp-customize.html">Customizing Online Certificate
        /// 			Status Protocol (OCSP)  in the AWS Certificate Manager Private Certificate Authority (PCA) User
        /// 				Guide.
        public var ocspCustomCname: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            ocspCustomCname: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.ocspCustomCname = ocspCustomCname
        }
    }

}

extension AcmPcaClientTypes.OtherName: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typeId = "TypeId"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeId = typeId {
            try encodeContainer.encode(typeId, forKey: .typeId)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeId)
        typeId = typeIdDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AcmPcaClientTypes.OtherName: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OtherName(typeId: \(Swift.String(describing: typeId)), value: \(Swift.String(describing: value)))"}
}

extension AcmPcaClientTypes {
    /// Defines a custom ASN.1 X.400 GeneralName using an object identifier (OID)
    /// 			and value. The OID must satisfy the regular expression shown below. For more
    /// 			information, see NIST's definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
    /// 				(OID).
    public struct OtherName: Swift.Equatable {
        /// Specifies an OID.
        /// This member is required.
        public var typeId: Swift.String?
        /// Specifies an OID value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            typeId: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.typeId = typeId
            self.value = value
        }
    }

}

extension AcmPcaClientTypes.Permission: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case policy = "Policy"
        case principal = "Principal"
        case sourceAccount = "SourceAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0.rawValue)
            }
        }
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let actionsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.ActionType?].self, forKey: .actions)
        var actionsDecoded0:[AcmPcaClientTypes.ActionType]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [AcmPcaClientTypes.ActionType]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension AcmPcaClientTypes.Permission: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Permission(actions: \(Swift.String(describing: actions)), certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), createdAt: \(Swift.String(describing: createdAt)), policy: \(Swift.String(describing: policy)), principal: \(Swift.String(describing: principal)), sourceAccount: \(Swift.String(describing: sourceAccount)))"}
}

extension AcmPcaClientTypes {
    /// Permissions designate which private CA actions can be performed by an AWS service or
    /// 			entity. In order for ACM to automatically renew private certificates, you must give
    /// 			the ACM service principal all available permissions (IssueCertificate,
    /// 				GetCertificate, and ListPermissions). Permissions can be
    /// 			assigned with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreatePermission.html">CreatePermission action,
    /// 			removed with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_DeletePermission.html">DeletePermission action, and
    /// 			listed with the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListPermissions.html">ListPermissions action.
    public struct Permission: Swift.Equatable {
        /// The private CA actions that can be performed by the designated AWS service.
        public var actions: [AcmPcaClientTypes.ActionType]?
        /// The Amazon Resource Number (ARN) of the private CA from which the permission was
        /// 			issued.
        public var certificateAuthorityArn: Swift.String?
        /// The time at which the permission was created.
        public var createdAt: ClientRuntime.Date?
        /// The name of the policy that is associated with the permission.
        public var policy: Swift.String?
        /// The AWS service or entity that holds the permission. At this time, the only valid
        /// 			principal is acm.amazonaws.com.
        public var principal: Swift.String?
        /// The ID of the account that assigned the permission.
        public var sourceAccount: Swift.String?

        public init (
            actions: [AcmPcaClientTypes.ActionType]? = nil,
            certificateAuthorityArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            policy: Swift.String? = nil,
            principal: Swift.String? = nil,
            sourceAccount: Swift.String? = nil
        )
        {
            self.actions = actions
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.policy = policy
            self.principal = principal
            self.sourceAccount = sourceAccount
        }
    }

}

extension PermissionAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension PermissionAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PermissionAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The designated permission has already been given to the user.
public struct PermissionAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PermissionAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PermissionAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcmPcaClientTypes.PolicyInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certPolicyId = "CertPolicyId"
        case policyQualifiers = "PolicyQualifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certPolicyId = certPolicyId {
            try encodeContainer.encode(certPolicyId, forKey: .certPolicyId)
        }
        if let policyQualifiers = policyQualifiers {
            var policyQualifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyQualifiers)
            for policyqualifierinfolist0 in policyQualifiers {
                try policyQualifiersContainer.encode(policyqualifierinfolist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certPolicyId)
        certPolicyId = certPolicyIdDecoded
        let policyQualifiersContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.PolicyQualifierInfo?].self, forKey: .policyQualifiers)
        var policyQualifiersDecoded0:[AcmPcaClientTypes.PolicyQualifierInfo]? = nil
        if let policyQualifiersContainer = policyQualifiersContainer {
            policyQualifiersDecoded0 = [AcmPcaClientTypes.PolicyQualifierInfo]()
            for structure0 in policyQualifiersContainer {
                if let structure0 = structure0 {
                    policyQualifiersDecoded0?.append(structure0)
                }
            }
        }
        policyQualifiers = policyQualifiersDecoded0
    }
}

extension AcmPcaClientTypes.PolicyInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyInformation(certPolicyId: \(Swift.String(describing: certPolicyId)), policyQualifiers: \(Swift.String(describing: policyQualifiers)))"}
}

extension AcmPcaClientTypes {
    /// Defines the X.509 CertificatePolicies extension.
    public struct PolicyInformation: Swift.Equatable {
        /// Specifies the object identifier (OID) of the certificate policy under which the
        /// 			certificate was issued. For more information, see NIST's definition of <a href="https://csrc.nist.gov/glossary/term/Object_Identifier">Object Identifier
        /// 				(OID).
        /// This member is required.
        public var certPolicyId: Swift.String?
        /// Modifies the given CertPolicyId with a qualifier. ACM Private CA supports the
        /// 			certification practice statement (CPS) qualifier.
        public var policyQualifiers: [AcmPcaClientTypes.PolicyQualifierInfo]?

        public init (
            certPolicyId: Swift.String? = nil,
            policyQualifiers: [AcmPcaClientTypes.PolicyQualifierInfo]? = nil
        )
        {
            self.certPolicyId = certPolicyId
            self.policyQualifiers = policyQualifiers
        }
    }

}

extension AcmPcaClientTypes {
    public enum PolicyQualifierId: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cps
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyQualifierId] {
            return [
                .cps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cps: return "CPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyQualifierId(rawValue: rawValue) ?? PolicyQualifierId.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.PolicyQualifierInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyQualifierId = "PolicyQualifierId"
        case qualifier = "Qualifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyQualifierId = policyQualifierId {
            try encodeContainer.encode(policyQualifierId.rawValue, forKey: .policyQualifierId)
        }
        if let qualifier = qualifier {
            try encodeContainer.encode(qualifier, forKey: .qualifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyQualifierIdDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.PolicyQualifierId.self, forKey: .policyQualifierId)
        policyQualifierId = policyQualifierIdDecoded
        let qualifierDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.Qualifier.self, forKey: .qualifier)
        qualifier = qualifierDecoded
    }
}

extension AcmPcaClientTypes.PolicyQualifierInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyQualifierInfo(policyQualifierId: \(Swift.String(describing: policyQualifierId)), qualifier: \(Swift.String(describing: qualifier)))"}
}

extension AcmPcaClientTypes {
    /// Modifies the CertPolicyId of a PolicyInformation object with
    /// 			a qualifier. ACM Private CA supports the certification practice statement (CPS) qualifier.
    public struct PolicyQualifierInfo: Swift.Equatable {
        /// Identifies the qualifier modifying a CertPolicyId.
        /// This member is required.
        public var policyQualifierId: AcmPcaClientTypes.PolicyQualifierId?
        /// Defines the qualifier type. ACM Private CA supports the use of a URI for a CPS qualifier in
        /// 			this field.
        /// This member is required.
        public var qualifier: AcmPcaClientTypes.Qualifier?

        public init (
            policyQualifierId: AcmPcaClientTypes.PolicyQualifierId? = nil,
            qualifier: AcmPcaClientTypes.Qualifier? = nil
        )
        {
            self.policyQualifierId = policyQualifierId
            self.qualifier = qualifier
        }
    }

}

public struct PutPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPolicyOutputError>
}

extension PutPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPolicyInput(policy: \(Swift.String(describing: policy)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension PutPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPolicyOutputError>
}

public struct PutPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPolicyOutputError>
}

public struct PutPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPolicyOutputError>
}

public struct PutPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPolicyOutputError>
}

public struct PutPolicyInput: Swift.Equatable {
    /// The path and file name of a JSON-formatted IAM policy to attach to the specified
    /// 			private CA resource. If this policy does not contain all required statements or if it
    /// 			includes any statement that is not allowed, the PutPolicy action returns an
    /// 				InvalidPolicyException. For information about IAM policy and
    /// 			statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Number (ARN) of the private CA to associate with the policy. The
    /// 			ARN of the CA can be found by calling the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities action.
    /// 		
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutPolicyInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let policy: Swift.String?
}

extension PutPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockoutPreventedException" : self = .lockoutPreventedException(try LockoutPreventedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPolicyOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidStateException(InvalidStateException)
    case lockoutPreventedException(LockoutPreventedException)
    case requestFailedException(RequestFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPolicyOutputResponse()"}
}

extension PutPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutPolicyOutputResponseBody: Swift.Equatable {
}

extension PutPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcmPcaClientTypes.Qualifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpsUri = "CpsUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpsUri = cpsUri {
            try encodeContainer.encode(cpsUri, forKey: .cpsUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpsUri)
        cpsUri = cpsUriDecoded
    }
}

extension AcmPcaClientTypes.Qualifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Qualifier(cpsUri: \(Swift.String(describing: cpsUri)))"}
}

extension AcmPcaClientTypes {
    /// Defines a PolicyInformation qualifier. ACM Private CA supports the <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.4">certification practice
    /// 				statement (CPS) qualifier defined in RFC 5280.
    public struct Qualifier: Swift.Equatable {
        /// Contains a pointer to a certification practice statement (CPS) published by the
        /// 			CA.
        /// This member is required.
        public var cpsUri: Swift.String?

        public init (
            cpsUri: Swift.String? = nil
        )
        {
            self.cpsUri = cpsUri
        }
    }

}

extension RequestAlreadyProcessedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestAlreadyProcessedException(message: \(Swift.String(describing: message)))"}
}

extension RequestAlreadyProcessedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestAlreadyProcessedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has already been completed.
public struct RequestAlreadyProcessedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestAlreadyProcessedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestAlreadyProcessedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RequestFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestFailedException(message: \(Swift.String(describing: message)))"}
}

extension RequestFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed for an unspecified reason.
public struct RequestFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RequestInProgressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestInProgressException(message: \(Swift.String(describing: message)))"}
}

extension RequestInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request is already in progress.
public struct RequestInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestInProgressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource such as a private CA, S3 bucket, certificate, audit report, or policy
/// 			cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AcmPcaClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case otherAccounts
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .otherAccounts,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .otherAccounts: return "OTHER_ACCOUNTS"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

public struct RestoreCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCertificateAuthorityOutputError>
}

extension RestoreCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)))"}
}

extension RestoreCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
    }
}

public struct RestoreCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RestoreCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RestoreCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreCertificateAuthorityOutputError>
}

public struct RestoreCertificateAuthorityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority action. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?

    public init (
        certificateAuthorityArn: Swift.String? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
    }
}

struct RestoreCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
}

extension RestoreCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension RestoreCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreCertificateAuthorityOutputResponse()"}
}

extension RestoreCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RestoreCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct RestoreCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension RestoreCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcmPcaClientTypes.RevocationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crlConfiguration = "CrlConfiguration"
        case ocspConfiguration = "OcspConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crlConfiguration = crlConfiguration {
            try encodeContainer.encode(crlConfiguration, forKey: .crlConfiguration)
        }
        if let ocspConfiguration = ocspConfiguration {
            try encodeContainer.encode(ocspConfiguration, forKey: .ocspConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crlConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CrlConfiguration.self, forKey: .crlConfiguration)
        crlConfiguration = crlConfigurationDecoded
        let ocspConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.OcspConfiguration.self, forKey: .ocspConfiguration)
        ocspConfiguration = ocspConfigurationDecoded
    }
}

extension AcmPcaClientTypes.RevocationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevocationConfiguration(crlConfiguration: \(Swift.String(describing: crlConfiguration)), ocspConfiguration: \(Swift.String(describing: ocspConfiguration)))"}
}

extension AcmPcaClientTypes {
    /// Certificate revocation information used by the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority and <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UpdateCertificateAuthority.html">UpdateCertificateAuthority actions. Your private certificate authority (CA)
    /// 			can configure Online Certificate Status Protocol (OCSP) support and/or maintain a
    /// 			certificate revocation list (CRL). OCSP returns validation information about
    /// 			certificates as requested by clients, and a CRL contains an updated list of certificates
    /// 			revoked by your CA. For more information, see <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_RevokeCertificate.html">RevokeCertificate and <a href="https://docs.aws.amazon.com/acm-pca/latest/userguide/revocation-setup.html">Setting up a
    /// 				certificate revocation method in the AWS Certificate Manager Private Certificate Authority (PCA) User
    /// 				Guide.
    public struct RevocationConfiguration: Swift.Equatable {
        /// Configuration of the certificate revocation list (CRL), if any, maintained by your private
        /// 			CA. A CRL is typically updated approximately 30 minutes after a certificate
        /// 	is revoked. If for any reason a CRL update fails, ACM Private CA makes further attempts
        /// 	every 15 minutes.
        public var crlConfiguration: AcmPcaClientTypes.CrlConfiguration?
        /// Configuration of Online Certificate Status Protocol (OCSP) support, if any, maintained by
        /// 			your private CA. When you revoke a certificate, OCSP responses may take up to 60 minutes
        /// 	to reflect the new status.
        public var ocspConfiguration: AcmPcaClientTypes.OcspConfiguration?

        public init (
            crlConfiguration: AcmPcaClientTypes.CrlConfiguration? = nil,
            ocspConfiguration: AcmPcaClientTypes.OcspConfiguration? = nil
        )
        {
            self.crlConfiguration = crlConfiguration
            self.ocspConfiguration = ocspConfiguration
        }
    }

}

extension AcmPcaClientTypes {
    public enum RevocationReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case affiliationChanged
        case aACompromise
        case certificateAuthorityCompromise
        case cessationOfOperation
        case keyCompromise
        case privilegeWithdrawn
        case superseded
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [RevocationReason] {
            return [
                .affiliationChanged,
                .aACompromise,
                .certificateAuthorityCompromise,
                .cessationOfOperation,
                .keyCompromise,
                .privilegeWithdrawn,
                .superseded,
                .unspecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .affiliationChanged: return "AFFILIATION_CHANGED"
            case .aACompromise: return "A_A_COMPROMISE"
            case .certificateAuthorityCompromise: return "CERTIFICATE_AUTHORITY_COMPROMISE"
            case .cessationOfOperation: return "CESSATION_OF_OPERATION"
            case .keyCompromise: return "KEY_COMPROMISE"
            case .privilegeWithdrawn: return "PRIVILEGE_WITHDRAWN"
            case .superseded: return "SUPERSEDED"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RevocationReason(rawValue: rawValue) ?? RevocationReason.sdkUnknown(rawValue)
        }
    }
}

public struct RevokeCertificateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeCertificateOutputError>
}

extension RevokeCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeCertificateInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), certificateSerial: \(Swift.String(describing: certificateSerial)), revocationReason: \(Swift.String(describing: revocationReason)))"}
}

extension RevokeCertificateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateSerial = "CertificateSerial"
        case revocationReason = "RevocationReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let certificateSerial = certificateSerial {
            try encodeContainer.encode(certificateSerial, forKey: .certificateSerial)
        }
        if let revocationReason = revocationReason {
            try encodeContainer.encode(revocationReason.rawValue, forKey: .revocationReason)
        }
    }
}

public struct RevokeCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RevokeCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RevokeCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RevokeCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RevokeCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeCertificateOutputError>
}

public struct RevokeCertificateInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the private CA that issued the certificate to be
    /// 			revoked. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// Serial number of the certificate to be revoked. This must be in hexadecimal format.
    /// 			You can retrieve the serial number by calling <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_GetCertificate.html">GetCertificate with the Amazon
    /// 			Resource Name (ARN) of the certificate you want and the ARN of your private CA. The
    /// 				GetCertificate action retrieves the certificate in
    /// 			the PEM format. You can use the following OpenSSL command to list the certificate in
    /// 			text format and copy the hexadecimal serial number.
    /// 		
    ///             openssl x509 -in file_path -text -noout
    ///
    /// 		       You can also copy the serial number from the console or use the <a href="https://docs.aws.amazon.com/acm/latest/APIReference/API_DescribeCertificate.html">DescribeCertificate action in the AWS Certificate Manager API
    /// 				Reference.
    /// This member is required.
    public var certificateSerial: Swift.String?
    /// Specifies why you revoked the certificate.
    /// This member is required.
    public var revocationReason: AcmPcaClientTypes.RevocationReason?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        certificateSerial: Swift.String? = nil,
        revocationReason: AcmPcaClientTypes.RevocationReason? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.certificateSerial = certificateSerial
        self.revocationReason = revocationReason
    }
}

struct RevokeCertificateInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let certificateSerial: Swift.String?
    public let revocationReason: AcmPcaClientTypes.RevocationReason?
}

extension RevokeCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case certificateSerial = "CertificateSerial"
        case revocationReason = "RevocationReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let certificateSerialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateSerial)
        certificateSerial = certificateSerialDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.RevocationReason.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
    }
}

extension RevokeCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestAlreadyProcessedException" : self = .requestAlreadyProcessedException(try RequestAlreadyProcessedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestInProgressException" : self = .requestInProgressException(try RequestInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeCertificateOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case requestAlreadyProcessedException(RequestAlreadyProcessedException)
    case requestFailedException(RequestFailedException)
    case requestInProgressException(RequestInProgressException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeCertificateOutputResponse()"}
}

extension RevokeCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeCertificateOutputResponse: Swift.Equatable {

    public init() {}
}

struct RevokeCertificateOutputResponseBody: Swift.Equatable {
}

extension RevokeCertificateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcmPcaClientTypes {
    public enum S3ObjectAcl: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketOwnerFullControl
        case publicRead
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectAcl] {
            return [
                .bucketOwnerFullControl,
                .publicRead,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketOwnerFullControl: return "BUCKET_OWNER_FULL_CONTROL"
            case .publicRead: return "PUBLIC_READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectAcl(rawValue: rawValue) ?? S3ObjectAcl.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes {
    public enum SigningAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sha256withecdsa
        case sha256withrsa
        case sha384withecdsa
        case sha384withrsa
        case sha512withecdsa
        case sha512withrsa
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningAlgorithm] {
            return [
                .sha256withecdsa,
                .sha256withrsa,
                .sha384withecdsa,
                .sha384withrsa,
                .sha512withecdsa,
                .sha512withrsa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sha256withecdsa: return "SHA256WITHECDSA"
            case .sha256withrsa: return "SHA256WITHRSA"
            case .sha384withecdsa: return "SHA384WITHECDSA"
            case .sha384withrsa: return "SHA384WITHRSA"
            case .sha512withecdsa: return "SHA512WITHECDSA"
            case .sha512withrsa: return "SHA512WITHRSA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SigningAlgorithm(rawValue: rawValue) ?? SigningAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension AcmPcaClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AcmPcaClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension AcmPcaClientTypes {
    /// Tags are labels that you can use to identify and organize your private CAs. Each tag
    /// 			consists of a key and an optional value. You can associate up to 50 tags with a private
    /// 			CA. To add one or more tags to a private CA, call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_TagCertificateAuthority.html">TagCertificateAuthority
    /// 			action. To remove a tag, call the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_UntagCertificateAuthority.html">UntagCertificateAuthority action.
    public struct Tag: Swift.Equatable {
        /// Key (name) of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagCertificateAuthorityOutputError>
}

extension TagCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagCertificateAuthorityOutputError>
}

public struct TagCertificateAuthorityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// List of tags to be associated with the CA.
    /// This member is required.
    public var tags: [AcmPcaClientTypes.Tag]?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        tags: [AcmPcaClientTypes.Tag]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.tags = tags
    }
}

struct TagCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let tags: [AcmPcaClientTypes.Tag]?
}

extension TagCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AcmPcaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AcmPcaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case invalidTagException(InvalidTagException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagCertificateAuthorityOutputResponse()"}
}

extension TagCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension TagCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can associate up to 50 tags with a private CA. Exception information is contained
/// 			in the exception message field.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagCertificateAuthorityOutputError>
}

extension UntagCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), tags: \(Swift.String(describing: tags)))"}
}

extension UntagCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct UntagCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagCertificateAuthorityOutputError>
}

public struct UntagCertificateAuthorityInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that was returned when you called <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CreateCertificateAuthority.html">CreateCertificateAuthority. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// List of tags to be removed from the CA.
    /// This member is required.
    public var tags: [AcmPcaClientTypes.Tag]?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        tags: [AcmPcaClientTypes.Tag]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.tags = tags
    }
}

struct UntagCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let tags: [AcmPcaClientTypes.Tag]?
}

extension UntagCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AcmPcaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AcmPcaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AcmPcaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidStateException(InvalidStateException)
    case invalidTagException(InvalidTagException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagCertificateAuthorityOutputResponse()"}
}

extension UntagCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension UntagCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCertificateAuthorityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCertificateAuthorityOutputError>
}

extension UpdateCertificateAuthorityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCertificateAuthorityInput(certificateAuthorityArn: \(Swift.String(describing: certificateAuthorityArn)), revocationConfiguration: \(Swift.String(describing: revocationConfiguration)), status: \(Swift.String(describing: status)))"}
}

extension UpdateCertificateAuthorityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case revocationConfiguration = "RevocationConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let revocationConfiguration = revocationConfiguration {
            try encodeContainer.encode(revocationConfiguration, forKey: .revocationConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateCertificateAuthorityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCertificateAuthorityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCertificateAuthorityInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCertificateAuthorityInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateCertificateAuthorityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCertificateAuthorityInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCertificateAuthorityOutputError>
}

public struct UpdateCertificateAuthorityInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the private CA that issued the certificate to be
    /// 			revoked. This must be of the form:
    /// 		
    /// 			         arn:aws:acm-pca:region:account:certificate-authority/12345678-1234-1234-1234-123456789012
    ///
    /// 		
    /// This member is required.
    public var certificateAuthorityArn: Swift.String?
    /// Contains information to enable Online Certificate Status Protocol (OCSP) support,
    /// 			to enable a certificate revocation list (CRL), to enable both, or to enable neither. If
    /// 			this parameter is not supplied, existing capibilites remain unchanged. For more
    /// 			information, see the <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_OcspConfiguration.html">OcspConfiguration and <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_CrlConfiguration.html">CrlConfiguration types.
    public var revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration?
    /// Status of your private CA.
    public var status: AcmPcaClientTypes.CertificateAuthorityStatus?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration? = nil,
        status: AcmPcaClientTypes.CertificateAuthorityStatus? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.revocationConfiguration = revocationConfiguration
        self.status = status
    }
}

struct UpdateCertificateAuthorityInputBody: Swift.Equatable {
    public let certificateAuthorityArn: Swift.String?
    public let revocationConfiguration: AcmPcaClientTypes.RevocationConfiguration?
    public let status: AcmPcaClientTypes.CertificateAuthorityStatus?
}

extension UpdateCertificateAuthorityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case revocationConfiguration = "RevocationConfiguration"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let revocationConfigurationDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.RevocationConfiguration.self, forKey: .revocationConfiguration)
        revocationConfiguration = revocationConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.CertificateAuthorityStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateCertificateAuthorityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCertificateAuthorityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCertificateAuthorityOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgsException(InvalidArgsException)
    case invalidArnException(InvalidArnException)
    case invalidPolicyException(InvalidPolicyException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCertificateAuthorityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCertificateAuthorityOutputResponse()"}
}

extension UpdateCertificateAuthorityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCertificateAuthorityOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateCertificateAuthorityOutputResponseBody: Swift.Equatable {
}

extension UpdateCertificateAuthorityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcmPcaClientTypes.Validity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AcmPcaClientTypes.ValidityPeriodType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AcmPcaClientTypes.Validity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Validity(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension AcmPcaClientTypes {
    /// Validity specifies the period of time during which a certificate is valid. Validity
    /// 			can be expressed as an explicit date and time when the validity of a certificate starts
    /// 			or expires, or as a span of time after issuance, stated in days, months, or years. For
    /// 			more information, see <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.5">Validity in RFC 5280.
    /// 		       ACM Private CA API consumes the Validity data type differently in two distinct
    /// 			parameters of the IssueCertificate action. The required parameter
    /// 				IssueCertificate:Validity specifies the end of a
    /// 			certificate's validity period. The optional parameter
    /// 				IssueCertificate:ValidityNotBefore specifies a customized
    /// 			starting time for the validity period.
    public struct Validity: Swift.Equatable {
        /// Determines how ACM Private CA interprets the Value
        /// 			parameter, an integer. Supported validity types include those listed below. Type
        /// 			definitions with values include a sample input value and the resulting output.
        /// 		
        ///             END_DATE: The specific date and time when the certificate will expire,
        /// 			expressed using UTCTime (YYMMDDHHMMSS) or GeneralizedTime (YYYYMMDDHHMMSS) format. When
        /// 			UTCTime is used, if the year field (YY) is greater than or equal to 50, the year is
        /// 			interpreted as 19YY. If the year field is less than 50, the year is interpreted as
        /// 			20YY.
        /// 		
        ///
        /// 				           Sample input value: 491231235959 (UTCTime format)
        /// 			
        ///
        /// 				           Output expiration date/time: 12/31/2049 23:59:59
        /// 			
        ///
        /// 		
        ///             ABSOLUTE: The specific date and time when the validity of a certificate
        /// 			will start or expire, expressed in seconds since the Unix Epoch.
        /// 		
        ///
        /// 				           Sample input value: 2524608000
        /// 			
        ///
        /// 				           Output expiration date/time: 01/01/2050 00:00:00
        /// 			
        ///
        /// 		
        ///             DAYS, MONTHS, YEARS: The relative time from the
        /// 			moment of issuance until the certificate will expire, expressed in days, months, or
        /// 			years.
        /// 		       Example if DAYS, issued on 10/12/2020 at 12:34:54 UTC:
        /// 		
        ///
        /// 				           Sample input value: 90
        /// 			
        ///
        /// 				           Output expiration date: 01/10/2020 12:34:54 UTC
        /// 			
        ///
        /// 		       The minimum validity duration for a certificate using relative time
        /// 			(DAYS) is one day. The minimum validity for a certificate using absolute
        /// 			time (ABSOLUTE or END_DATE) is one second.
        /// This member is required.
        public var type: AcmPcaClientTypes.ValidityPeriodType?
        /// A long integer interpreted according to the value of Type, below.
        /// This member is required.
        public var value: Swift.Int?

        public init (
            type: AcmPcaClientTypes.ValidityPeriodType? = nil,
            value: Swift.Int? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension AcmPcaClientTypes {
    public enum ValidityPeriodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absolute
        case days
        case endDate
        case months
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidityPeriodType] {
            return [
                .absolute,
                .days,
                .endDate,
                .months,
                .years,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absolute: return "ABSOLUTE"
            case .days: return "DAYS"
            case .endDate: return "END_DATE"
            case .months: return "MONTHS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidityPeriodType(rawValue: rawValue) ?? ValidityPeriodType.sdkUnknown(rawValue)
        }
    }
}
