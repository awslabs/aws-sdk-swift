// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ContainerNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ContainerNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified container was not found for the specified account.
public struct ContainerNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ContainerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ContainerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path)"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: //
    /// This member is required.
    public var path: Swift.String?

    public init (
        path: Swift.String? = nil
    )
    {
        self.path = path
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
}

extension DeleteObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteObjectOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteObjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path)"
    }
}

public struct DescribeObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: //
    /// This member is required.
    public var path: Swift.String?

    public init (
        path: Swift.String? = nil
    )
    {
        self.path = path
    }
}

struct DescribeObjectInputBody: Swift.Equatable {
}

extension DescribeObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeObjectOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = TimestampFormatter(format: .httpDate).date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
    }
}

public struct DescribeObjectOutputResponse: Swift.Equatable {
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The length of the object in bytes.
    public var contentLength: Swift.Int?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The ETag that represents a unique instance of the object.
    public var eTag: Swift.String?
    /// The date and time that the object was last modified.
    public var lastModified: ClientRuntime.Date?

    public init (
        cacheControl: Swift.String? = nil,
        contentLength: Swift.Int? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil
    )
    {
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
    }
}

extension GetObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path)"
    }
}

public struct GetObjectInput: Swift.Equatable {
    /// The path (including the file name) where the object is stored in the container. Format: // For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder. There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the [AWS Elemental MediaStore User Guide](http://docs.aws.amazon.com/mediastore/latest/ug/). The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension.
    /// This member is required.
    public var path: Swift.String?
    /// The range bytes of an object to retrieve. For more information about the Range header, see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35). AWS Elemental MediaStore ignores this header for partially uploaded objects that have streaming upload availability.
    public var range: Swift.String?

    public init (
        path: Swift.String? = nil,
        range: Swift.String? = nil
    )
    {
        self.path = path
        self.range = range
    }
}

struct GetObjectInputBody: Swift.Equatable {
}

extension GetObjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ObjectNotFoundException" : self = .objectNotFoundException(try ObjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestedRangeNotSatisfiableException" : self = .requestedRangeNotSatisfiableException(try RequestedRangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetObjectOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case objectNotFoundException(ObjectNotFoundException)
    case requestedRangeNotSatisfiableException(RequestedRangeNotSatisfiableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            self.cacheControl = cacheControlHeaderValue
        } else {
            self.cacheControl = nil
        }
        if let contentLengthHeaderValue = httpResponse.headers.value(for: "Content-Length") {
            self.contentLength = Swift.Int(contentLengthHeaderValue) ?? 0
        } else {
            self.contentLength = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let lastModifiedHeaderValue = httpResponse.headers.value(for: "Last-Modified") {
            self.lastModified = TimestampFormatter(format: .httpDate).date(from: lastModifiedHeaderValue)
        } else {
            self.lastModified = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.body = ByteStream.from(data: data)
        } else {
            self.body = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct GetObjectOutputResponse: Swift.Equatable {
    /// The bytes of the object.
    public var body: ClientRuntime.ByteStream?
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP spec at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The length of the object in bytes.
    public var contentLength: Swift.Int?
    /// The range of bytes to retrieve.
    public var contentRange: Swift.String?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The ETag that represents a unique instance of the object.
    public var eTag: Swift.String?
    /// The date and time that the object was last modified.
    public var lastModified: ClientRuntime.Date?
    /// The HTML status code of the request. Status codes ranging from 200 to 299 indicate success. All other status codes indicate the type of error that occurred.
    /// This member is required.
    public var statusCode: Swift.Int

    public init (
        body: ClientRuntime.ByteStream? = nil,
        cacheControl: Swift.String? = nil,
        contentLength: Swift.Int? = nil,
        contentRange: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        statusCode: Swift.Int = 0
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentLength = contentLength
        self.contentRange = contentRange
        self.contentType = contentType
        self.eTag = eTag
        self.lastModified = lastModified
        self.statusCode = statusCode
    }
}

struct GetObjectOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
    let statusCode: Swift.Int
}

extension GetObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
        case statusCode = "StatusCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreDataClientTypes.Item: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentLength = "ContentLength"
        case contentType = "ContentType"
        case eTag = "ETag"
        case lastModified = "LastModified"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentLength = self.contentLength {
            try encodeContainer.encode(contentLength, forKey: .contentLength)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MediaStoreDataClientTypes.ItemType.self, forKey: .type)
        type = typeDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
    }
}

extension MediaStoreDataClientTypes {
    /// A metadata entry for a folder or object.
    public struct Item: Swift.Equatable {
        /// The length of the item in bytes.
        public var contentLength: Swift.Int?
        /// The content type of the item.
        public var contentType: Swift.String?
        /// The ETag that represents a unique instance of the item.
        public var eTag: Swift.String?
        /// The date and time that the item was last modified.
        public var lastModified: ClientRuntime.Date?
        /// The name of the item.
        public var name: Swift.String?
        /// The item type (folder or object).
        public var type: MediaStoreDataClientTypes.ItemType?

        public init (
            contentLength: Swift.Int? = nil,
            contentType: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: MediaStoreDataClientTypes.ItemType? = nil
        )
        {
            self.contentLength = contentLength
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.name = name
            self.type = type
        }
    }

}

extension MediaStoreDataClientTypes {
    public enum ItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case folder
        case object
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemType] {
            return [
                .folder,
                .object,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .folder: return "FOLDER"
            case .object: return "OBJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
        }
    }
}

extension ListItemsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let path = path {
                let pathQueryItem = ClientRuntime.URLQueryItem(name: "Path".urlPercentEncoding(), value: Swift.String(path).urlPercentEncoding())
                items.append(pathQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListItemsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListItems request with MaxResults set at 500. Although 2,000 items match your request, the service returns no more than the first 500 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 1,000 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListItems request with MaxResults set at 500. The service returns the first batch of results (up to 500) and a NextToken value. To see the next batch of results, you can submit the ListItems request a second time and specify the NextToken value. Tokens expire after 15 minutes.
    public var nextToken: Swift.String?
    /// The path in the container from which to retrieve items. Format: //
    public var path: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        path: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.path = path
    }
}

struct ListItemsInputBody: Swift.Equatable {
}

extension ListItemsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListItemsOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListItemsOutputResponse: Swift.Equatable {
    /// The metadata entries for the folders and objects at the requested path.
    public var items: [MediaStoreDataClientTypes.Item]?
    /// The token that can be used in a request to view the next set of results. For example, you submit a ListItems request that matches 2,000 items with MaxResults set at 500. The service returns the first batch of results (up to 500) and a NextToken value that can be used to fetch the next batch of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaStoreDataClientTypes.Item]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListItemsOutputResponseBody: Swift.Equatable {
    let items: [MediaStoreDataClientTypes.Item]?
    let nextToken: Swift.String?
}

extension ListItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaStoreDataClientTypes.Item?].self, forKey: .items)
        var itemsDecoded0:[MediaStoreDataClientTypes.Item]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaStoreDataClientTypes.Item]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ObjectNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ObjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Could not perform an operation on an object that does not exist.
public struct ObjectNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ObjectNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ObjectNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutObjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutObjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutObjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutObjectOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.stream(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutObjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutObjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body.toBytes().getData(), forKey: .body)
        }
    }
}

extension PutObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let cacheControl = cacheControl {
            items.add(Header(name: "Cache-Control", value: Swift.String(cacheControl)))
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let storageClass = storageClass {
            items.add(Header(name: "x-amz-storage-class", value: Swift.String(storageClass.rawValue)))
        }
        if let uploadAvailability = uploadAvailability {
            items.add(Header(name: "x-amz-upload-availability", value: Swift.String(uploadAvailability.rawValue)))
        }
        return items
    }
}

extension PutObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let path = path else {
            return nil
        }
        return "/\(path)"
    }
}

public struct PutObjectInput: Swift.Equatable {
    /// The bytes to be stored.
    /// This member is required.
    public var body: ClientRuntime.ByteStream?
    /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at [https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9). Headers with a custom user-defined value are also accepted.
    public var cacheControl: Swift.String?
    /// The content type of the object.
    public var contentType: Swift.String?
    /// The path (including the file name) where the object is stored in the container. Format: // For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder. There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the [AWS Elemental MediaStore User Guide](http://docs.aws.amazon.com/mediastore/latest/ug/). The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension.
    /// This member is required.
    public var path: Swift.String?
    /// Indicates the storage class of a Put request. Defaults to high-performance temporal storage class, and objects are persisted into durable storage shortly after being received.
    public var storageClass: MediaStoreDataClientTypes.StorageClass?
    /// Indicates the availability of an object while it is still uploading. If the value is set to streaming, the object is available for downloading after some initial buffering but before the object is uploaded completely. If the value is set to standard, the object is available for downloading only when it is uploaded completely. The default value for this header is standard. To use this header, you must also set the HTTP Transfer-Encoding header to chunked.
    public var uploadAvailability: MediaStoreDataClientTypes.UploadAvailability?

    public init (
        body: ClientRuntime.ByteStream? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        path: Swift.String? = nil,
        storageClass: MediaStoreDataClientTypes.StorageClass? = nil,
        uploadAvailability: MediaStoreDataClientTypes.UploadAvailability? = nil
    )
    {
        self.body = body
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.path = path
        self.storageClass = storageClass
        self.uploadAvailability = uploadAvailability
    }
}

struct PutObjectInputBody: Swift.Equatable {
    let body: ClientRuntime.ByteStream?
}

extension PutObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutObjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutObjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ContainerNotFoundException" : self = .containerNotFoundException(try ContainerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutObjectOutputError: Swift.Error, Swift.Equatable {
    case containerNotFoundException(ContainerNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutObjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutObjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSHA256 = output.contentSHA256
            self.eTag = output.eTag
            self.storageClass = output.storageClass
        } else {
            self.contentSHA256 = nil
            self.eTag = nil
            self.storageClass = nil
        }
    }
}

public struct PutObjectOutputResponse: Swift.Equatable {
    /// The SHA256 digest of the object that is persisted.
    public var contentSHA256: Swift.String?
    /// Unique identifier of the object in the container.
    public var eTag: Swift.String?
    /// The storage class where the object was persisted. The class should be “Temporal”.
    public var storageClass: MediaStoreDataClientTypes.StorageClass?

    public init (
        contentSHA256: Swift.String? = nil,
        eTag: Swift.String? = nil,
        storageClass: MediaStoreDataClientTypes.StorageClass? = nil
    )
    {
        self.contentSHA256 = contentSHA256
        self.eTag = eTag
        self.storageClass = storageClass
    }
}

struct PutObjectOutputResponseBody: Swift.Equatable {
    let contentSHA256: Swift.String?
    let eTag: Swift.String?
    let storageClass: MediaStoreDataClientTypes.StorageClass?
}

extension PutObjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSHA256 = "ContentSHA256"
        case eTag = "ETag"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSHA256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSHA256)
        contentSHA256 = contentSHA256Decoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(MediaStoreDataClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension RequestedRangeNotSatisfiableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestedRangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested content range is not valid.
public struct RequestedRangeNotSatisfiableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestedRangeNotSatisfiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestedRangeNotSatisfiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaStoreDataClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case temporal
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .temporal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .temporal: return "TEMPORAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension MediaStoreDataClientTypes {
    public enum UploadAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standard
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadAvailability] {
            return [
                .standard,
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standard: return "STANDARD"
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploadAvailability(rawValue: rawValue) ?? UploadAvailability.sdkUnknown(rawValue)
        }
    }
}
