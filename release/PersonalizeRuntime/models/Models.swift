// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct GetPersonalizedRankingInputBodyMiddleware: Middleware {
    public let id: String = "GetPersonalizedRankingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPersonalizedRankingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPersonalizedRankingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPersonalizedRankingInput>
    public typealias MOutput = OperationOutput<GetPersonalizedRankingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPersonalizedRankingOutputError>
}

extension GetPersonalizedRankingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPersonalizedRankingInput(campaignArn: \(String(describing: campaignArn)), context: \(String(describing: context)), filterArn: \(String(describing: filterArn)), filterValues: \(String(describing: filterValues)), inputList: \(String(describing: inputList)), userId: \(String(describing: userId)))"}
}

extension GetPersonalizedRankingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filterValues)
            for (dictKey0, filtervalues0) in filterValues {
                try filterValuesContainer.encode(filtervalues0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let inputList = inputList {
            var inputListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputList)
            for inputlist0 in inputList {
                try inputListContainer.encode(inputlist0)
            }
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetPersonalizedRankingInputHeadersMiddleware: Middleware {
    public let id: String = "GetPersonalizedRankingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPersonalizedRankingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPersonalizedRankingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPersonalizedRankingInput>
    public typealias MOutput = OperationOutput<GetPersonalizedRankingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPersonalizedRankingOutputError>
}

public struct GetPersonalizedRankingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPersonalizedRankingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPersonalizedRankingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPersonalizedRankingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPersonalizedRankingInput>
    public typealias MOutput = OperationOutput<GetPersonalizedRankingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPersonalizedRankingOutputError>
}

public struct GetPersonalizedRankingInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign to use for generating the personalized
    ///       ranking.</p>
    public let campaignArn: String?
    /// <p>The contextual metadata to use when getting recommendations. Contextual metadata includes
    ///       any interaction information that might be relevant when getting a user's recommendations, such
    ///       as the user's current location or device type.</p>
    public let context: [String:String]?
    /// <p>The Amazon Resource Name (ARN) of a filter you created to include items or exclude items from recommendations for a given user.
    ///       For more information, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter.html">Filtering Recommendations</a>.</p>
    public let filterArn: String?
    /// <p>The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case)
    ///       as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma.
    ///     </p>
    ///          <p>For filter expressions that use an <code>INCLUDE</code> element to include items,
    ///       you must provide values for all parameters that are defined in the expression. For
    ///       filters with expressions that use an <code>EXCLUDE</code> element to exclude items, you
    ///       can omit the <code>filter-values</code>.In this case, Amazon Personalize doesn't use that portion of
    ///       the expression to filter recommendations.</p>
    ///          <p>For more information, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter.html">Filtering Recommendations</a>.</p>
    public let filterValues: [String:String]?
    /// <p>A list of items (by <code>itemId</code>) to rank. If an item was not included in the training dataset,
    ///       the item is appended to the end of the reranked list. The maximum is 500.</p>
    public let inputList: [String]?
    /// <p>The user for which you want the campaign to provide a personalized ranking.</p>
    public let userId: String?

    public init (
        campaignArn: String? = nil,
        context: [String:String]? = nil,
        filterArn: String? = nil,
        filterValues: [String:String]? = nil,
        inputList: [String]? = nil,
        userId: String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.inputList = inputList
        self.userId = userId
    }
}

struct GetPersonalizedRankingInputBody: Equatable {
    public let campaignArn: String?
    public let inputList: [String]?
    public let userId: String?
    public let context: [String:String]?
    public let filterArn: String?
    public let filterValues: [String:String]?
}

extension GetPersonalizedRankingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let inputListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .inputList)
        var inputListDecoded0:[String]? = nil
        if let inputListContainer = inputListContainer {
            inputListDecoded0 = [String]()
            for string0 in inputListContainer {
                if let string0 = string0 {
                    inputListDecoded0?.append(string0)
                }
            }
        }
        inputList = inputListDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [String:String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [String:String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension GetPersonalizedRankingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPersonalizedRankingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPersonalizedRankingOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPersonalizedRankingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPersonalizedRankingOutputResponse(personalizedRanking: \(String(describing: personalizedRanking)), recommendationId: \(String(describing: recommendationId)))"}
}

extension GetPersonalizedRankingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPersonalizedRankingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.personalizedRanking = output.personalizedRanking
            self.recommendationId = output.recommendationId
        } else {
            self.personalizedRanking = nil
            self.recommendationId = nil
        }
    }
}

public struct GetPersonalizedRankingOutputResponse: Equatable {
    /// <p>A list of items in order of most likely interest to the user. The maximum is 500.</p>
    public let personalizedRanking: [PredictedItem]?
    /// <p>The ID of the recommendation.</p>
    public let recommendationId: String?

    public init (
        personalizedRanking: [PredictedItem]? = nil,
        recommendationId: String? = nil
    )
    {
        self.personalizedRanking = personalizedRanking
        self.recommendationId = recommendationId
    }
}

struct GetPersonalizedRankingOutputResponseBody: Equatable {
    public let personalizedRanking: [PredictedItem]?
    public let recommendationId: String?
}

extension GetPersonalizedRankingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case personalizedRanking
        case recommendationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personalizedRankingContainer = try containerValues.decodeIfPresent([PredictedItem?].self, forKey: .personalizedRanking)
        var personalizedRankingDecoded0:[PredictedItem]? = nil
        if let personalizedRankingContainer = personalizedRankingContainer {
            personalizedRankingDecoded0 = [PredictedItem]()
            for structure0 in personalizedRankingContainer {
                if let structure0 = structure0 {
                    personalizedRankingDecoded0?.append(structure0)
                }
            }
        }
        personalizedRanking = personalizedRankingDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

public struct GetRecommendationsInputBodyMiddleware: Middleware {
    public let id: String = "GetRecommendationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationsOutputError>
}

extension GetRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationsInput(campaignArn: \(String(describing: campaignArn)), context: \(String(describing: context)), filterArn: \(String(describing: filterArn)), filterValues: \(String(describing: filterValues)), itemId: \(String(describing: itemId)), numResults: \(String(describing: numResults)), userId: \(String(describing: userId)))"}
}

extension GetRecommendationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case userId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filterValues)
            for (dictKey0, filtervalues0) in filterValues {
                try filterValuesContainer.encode(filtervalues0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let itemId = itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if numResults != 0 {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the campaign to use for getting recommendations.</p>
    public let campaignArn: String?
    /// <p>The contextual metadata to use when getting recommendations. Contextual metadata includes
    ///       any interaction information that might be relevant when getting a user's recommendations, such
    ///       as the user's current location or device type.</p>
    public let context: [String:String]?
    /// <p>The ARN of the filter to apply to the returned recommendations. For more information, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter.html">Filtering Recommendations</a>.</p>
    ///          <p>When using this parameter, be sure the filter resource is <code>ACTIVE</code>.</p>
    public let filterArn: String?
    /// <p>The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case)
    ///       as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma.
    ///     </p>
    ///          <p>For filter expressions that use an <code>INCLUDE</code> element to include items,
    ///     you must provide values for all parameters that are defined in the expression. For
    ///     filters with expressions that use an <code>EXCLUDE</code> element to exclude items, you
    ///       can omit the <code>filter-values</code>.In this case, Amazon Personalize doesn't use that portion of
    ///     the expression to filter recommendations.</p>
    ///          <p>For more information, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter.html">Filtering Recommendations</a>.</p>
    public let filterValues: [String:String]?
    /// <p>The item ID to provide recommendations for.</p>
    ///          <p>Required for <code>RELATED_ITEMS</code> recipe type.</p>
    public let itemId: String?
    /// <p>The number of results to return. The default is 25. The maximum is 500.</p>
    public let numResults: Int
    /// <p>The user ID to provide recommendations for.</p>
    ///          <p>Required for <code>USER_PERSONALIZATION</code> recipe type.</p>
    public let userId: String?

    public init (
        campaignArn: String? = nil,
        context: [String:String]? = nil,
        filterArn: String? = nil,
        filterValues: [String:String]? = nil,
        itemId: String? = nil,
        numResults: Int = 0,
        userId: String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.itemId = itemId
        self.numResults = numResults
        self.userId = userId
    }
}

struct GetRecommendationsInputBody: Equatable {
    public let campaignArn: String?
    public let itemId: String?
    public let userId: String?
    public let numResults: Int
    public let context: [String:String]?
    public let filterArn: String?
    public let filterValues: [String:String]?
}

extension GetRecommendationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case userId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let itemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let numResultsDecoded = try containerValues.decode(Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [String:String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [String:String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension GetRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationsOutputResponse(itemList: \(String(describing: itemList)), recommendationId: \(String(describing: recommendationId)))"}
}

extension GetRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.itemList = output.itemList
            self.recommendationId = output.recommendationId
        } else {
            self.itemList = nil
            self.recommendationId = nil
        }
    }
}

public struct GetRecommendationsOutputResponse: Equatable {
    /// <p>A list of recommendations sorted in ascending order by prediction score. There can be a
    ///       maximum of 500 items in the list.</p>
    public let itemList: [PredictedItem]?
    /// <p>The ID of the recommendation.</p>
    public let recommendationId: String?

    public init (
        itemList: [PredictedItem]? = nil,
        recommendationId: String? = nil
    )
    {
        self.itemList = itemList
        self.recommendationId = recommendationId
    }
}

struct GetRecommendationsOutputResponseBody: Equatable {
    public let itemList: [PredictedItem]?
    public let recommendationId: String?
}

extension GetRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case itemList
        case recommendationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemListContainer = try containerValues.decodeIfPresent([PredictedItem?].self, forKey: .itemList)
        var itemListDecoded0:[PredictedItem]? = nil
        if let itemListContainer = itemListContainer {
            itemListDecoded0 = [PredictedItem]()
            for structure0 in itemListContainer {
                if let structure0 = structure0 {
                    itemListDecoded0?.append(structure0)
                }
            }
        }
        itemList = itemListDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provide a valid value for the field or parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PredictedItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemId
        case score
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemId = itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension PredictedItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictedItem(itemId: \(String(describing: itemId)), score: \(String(describing: score)))"}
}

/// <p>An object that identifies an item.</p>
///          <p>The  and  APIs return a list of
///       <code>PredictedItem</code>s.</p>
public struct PredictedItem: Equatable {
    /// <p>The recommended item ID.</p>
    public let itemId: String?
    /// <p>A numeric representation of the model's certainty that the item will be the next user
    ///       selection. For more information on scoring logic, see <a>how-scores-work</a>.</p>
    public let score: Double?

    public init (
        itemId: String? = nil,
        score: Double? = nil
    )
    {
        self.itemId = itemId
        self.score = score
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
