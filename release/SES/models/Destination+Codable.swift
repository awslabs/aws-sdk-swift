// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bccAddresses = "BccAddresses"
        case ccAddresses = "CcAddresses"
        case toAddresses = "ToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bccAddresses = bccAddresses {
            var bccAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("BccAddresses"))
            for (index0, address0) in bccAddresses.enumerated() {
                try bccAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let ccAddresses = ccAddresses {
            var ccAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CcAddresses"))
            for (index0, address0) in ccAddresses.enumerated() {
                try ccAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let toAddresses = toAddresses {
            var toAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ToAddresses"))
            for (index0, address0) in toAddresses.enumerated() {
                try toAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.toAddresses) {
            struct KeyVal0{struct member{}}
            let toAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .toAddresses)
            if let toAddressesWrappedContainer = toAddressesWrappedContainer {
                let toAddressesContainer = try toAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var toAddressesBuffer:[String]? = nil
                if let toAddressesContainer = toAddressesContainer {
                    toAddressesBuffer = [String]()
                    for stringContainer0 in toAddressesContainer {
                        toAddressesBuffer?.append(stringContainer0)
                    }
                }
                toAddresses = toAddressesBuffer
            } else {
                toAddresses = []
            }
        } else {
            toAddresses = nil
        }
        if containerValues.contains(.ccAddresses) {
            struct KeyVal0{struct member{}}
            let ccAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ccAddresses)
            if let ccAddressesWrappedContainer = ccAddressesWrappedContainer {
                let ccAddressesContainer = try ccAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var ccAddressesBuffer:[String]? = nil
                if let ccAddressesContainer = ccAddressesContainer {
                    ccAddressesBuffer = [String]()
                    for stringContainer0 in ccAddressesContainer {
                        ccAddressesBuffer?.append(stringContainer0)
                    }
                }
                ccAddresses = ccAddressesBuffer
            } else {
                ccAddresses = []
            }
        } else {
            ccAddresses = nil
        }
        if containerValues.contains(.bccAddresses) {
            struct KeyVal0{struct member{}}
            let bccAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .bccAddresses)
            if let bccAddressesWrappedContainer = bccAddressesWrappedContainer {
                let bccAddressesContainer = try bccAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var bccAddressesBuffer:[String]? = nil
                if let bccAddressesContainer = bccAddressesContainer {
                    bccAddressesBuffer = [String]()
                    for stringContainer0 in bccAddressesContainer {
                        bccAddressesBuffer?.append(stringContainer0)
                    }
                }
                bccAddresses = bccAddressesBuffer
            } else {
                bccAddresses = []
            }
        } else {
            bccAddresses = nil
        }
    }
}
