// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountSendingPausedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSendingPausedException(message: \(String(describing: message)))"}
}

extension AccountSendingPausedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AccountSendingPausedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that email sending is disabled for your entire Amazon SES account.</p>
///         <p>You can enable or disable email sending for your Amazon SES account using <a>UpdateAccountSendingEnabled</a>.</p>
public struct AccountSendingPausedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccountSendingPausedExceptionBody: Equatable {
    public let message: String?
}

extension AccountSendingPausedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddHeaderAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let headerName = headerName {
            try container.encode(headerName, forKey: Key("HeaderName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: Key("HeaderValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension AddHeaderAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddHeaderAction(headerName: \(String(describing: headerName)), headerValue: \(String(describing: headerValue)))"}
}

/// <p>When included in a receipt rule, this action adds a header to the received
///             email.</p>
///         <p>For information about adding a header using a receipt rule, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-add-header.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct AddHeaderAction: Equatable {
    /// <p>The name of the header to add. Must be between 1 and 50 characters, inclusive, and
    ///             consist of alphanumeric (a-z, A-Z, 0-9) characters and dashes only.</p>
    public let headerName: String?
    /// <p>Must be less than 2048 characters, and must not contain newline characters ("\r" or
    ///             "\n").</p>
    public let headerValue: String?

    public init (
        headerName: String? = nil,
        headerValue: String? = nil
    )
    {
        self.headerName = headerName
        self.headerValue = headerValue
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(name: \(String(describing: name)), message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.name = output.error.name
        } else {
            self.name = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a resource could not be created because of a naming conflict.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates that a resource could not be created because the resource name already
    ///             exists.</p>
    public var name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let name: String?
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum BehaviorOnMXFailure {
    case rejectmessage
    case usedefaultvalue
    case sdkUnknown(String)
}

extension BehaviorOnMXFailure : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BehaviorOnMXFailure] {
        return [
            .rejectmessage,
            .usedefaultvalue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rejectmessage: return "RejectMessage"
        case .usedefaultvalue: return "UseDefaultValue"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BehaviorOnMXFailure(rawValue: rawValue) ?? BehaviorOnMXFailure.sdkUnknown(rawValue)
    }
}

extension Body: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case html = "Html"
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let html = html {
            try container.encode(html, forKey: Key("Html"))
        }
        if let text = text {
            try container.encode(text, forKey: Key("Text"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .text)
        text = textDecoded
        let htmlDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .html)
        html = htmlDecoded
    }
}

extension Body: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Body(html: \(String(describing: html)), text: \(String(describing: text)))"}
}

/// <p>Represents the body of the message. You can specify text, HTML, or both. If you use
///             both, then the message should display correctly in the widest variety of email
///             clients.</p>
public struct Body: Equatable {
    /// <p>The content of the message, in HTML format. Use this for email clients that can
    ///             process HTML. You can include clickable links, formatted text, and much more in an HTML
    ///             message.</p>
    public let html: Content?
    /// <p>The content of the message, in text format. Use this for text-based email clients, or
    ///             clients on high-latency networks (such as mobile devices).</p>
    public let text: Content?

    public init (
        html: Content? = nil,
        text: Content? = nil
    )
    {
        self.html = html
        self.text = text
    }
}

extension BounceAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case sender = "Sender"
        case smtpReplyCode = "SmtpReplyCode"
        case statusCode = "StatusCode"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let sender = sender {
            try container.encode(sender, forKey: Key("Sender"))
        }
        if let smtpReplyCode = smtpReplyCode {
            try container.encode(smtpReplyCode, forKey: Key("SmtpReplyCode"))
        }
        if let statusCode = statusCode {
            try container.encode(statusCode, forKey: Key("StatusCode"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let smtpReplyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smtpReplyCode)
        smtpReplyCode = smtpReplyCodeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let senderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sender)
        sender = senderDecoded
    }
}

extension BounceAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BounceAction(message: \(String(describing: message)), sender: \(String(describing: sender)), smtpReplyCode: \(String(describing: smtpReplyCode)), statusCode: \(String(describing: statusCode)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action rejects the received email by returning a
///             bounce response to the sender and, optionally, publishes a notification to Amazon Simple Notification Service
///             (Amazon SNS).</p>
///         <p>For information about sending a bounce message in response to a received email, see
///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-bounce.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct BounceAction: Equatable {
    /// <p>Human-readable text to include in the bounce message.</p>
    public let message: String?
    /// <p>The email address of the sender of the bounced email. This is the address from which
    ///             the bounce message will be sent.</p>
    public let sender: String?
    /// <p>The SMTP reply code, as defined by <a href="https://tools.ietf.org/html/rfc5321">RFC 5321</a>.</p>
    public let smtpReplyCode: String?
    /// <p>The SMTP enhanced status code, as defined by <a href="https://tools.ietf.org/html/rfc3463">RFC 3463</a>.</p>
    public let statusCode: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to notify when the bounce action is
    ///             taken. An example of an Amazon SNS topic ARN is
    ///                 <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more information about
    ///             Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        message: String? = nil,
        sender: String? = nil,
        smtpReplyCode: String? = nil,
        statusCode: String? = nil,
        topicArn: String? = nil
    )
    {
        self.message = message
        self.sender = sender
        self.smtpReplyCode = smtpReplyCode
        self.statusCode = statusCode
        self.topicArn = topicArn
    }
}

public enum BounceType {
    case contentrejected
    case doesnotexist
    case exceededquota
    case messagetoolarge
    case temporaryfailure
    case undefined
    case sdkUnknown(String)
}

extension BounceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BounceType] {
        return [
            .contentrejected,
            .doesnotexist,
            .exceededquota,
            .messagetoolarge,
            .temporaryfailure,
            .undefined,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contentrejected: return "ContentRejected"
        case .doesnotexist: return "DoesNotExist"
        case .exceededquota: return "ExceededQuota"
        case .messagetoolarge: return "MessageTooLarge"
        case .temporaryfailure: return "TemporaryFailure"
        case .undefined: return "Undefined"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BounceType(rawValue: rawValue) ?? BounceType.sdkUnknown(rawValue)
    }
}

extension BouncedRecipientInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bounceType = "BounceType"
        case recipient = "Recipient"
        case recipientArn = "RecipientArn"
        case recipientDsnFields = "RecipientDsnFields"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bounceType = bounceType {
            try container.encode(bounceType, forKey: Key("BounceType"))
        }
        if let recipient = recipient {
            try container.encode(recipient, forKey: Key("Recipient"))
        }
        if let recipientArn = recipientArn {
            try container.encode(recipientArn, forKey: Key("RecipientArn"))
        }
        if let recipientDsnFields = recipientDsnFields {
            try container.encode(recipientDsnFields, forKey: Key("RecipientDsnFields"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipientDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipient)
        recipient = recipientDecoded
        let recipientArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recipientArn)
        recipientArn = recipientArnDecoded
        let bounceTypeDecoded = try containerValues.decodeIfPresent(BounceType.self, forKey: .bounceType)
        bounceType = bounceTypeDecoded
        let recipientDsnFieldsDecoded = try containerValues.decodeIfPresent(RecipientDsnFields.self, forKey: .recipientDsnFields)
        recipientDsnFields = recipientDsnFieldsDecoded
    }
}

extension BouncedRecipientInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BouncedRecipientInfo(bounceType: \(String(describing: bounceType)), recipient: \(String(describing: recipient)), recipientArn: \(String(describing: recipientArn)), recipientDsnFields: \(String(describing: recipientDsnFields)))"}
}

/// <p>Recipient-related information to include in the Delivery Status Notification (DSN)
///             when an email that Amazon SES receives on your behalf bounces.</p>
///         <p>For information about receiving email through Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct BouncedRecipientInfo: Equatable {
    /// <p>The reason for the bounce. You must provide either this parameter or
    ///                 <code>RecipientDsnFields</code>.</p>
    public let bounceType: BounceType?
    /// <p>The email address of the recipient of the bounced email.</p>
    public let recipient: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to receive
    ///             email for the recipient of the bounced email. For more information about sending
    ///             authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let recipientArn: String?
    /// <p>Recipient-related DSN fields, most of which would normally be filled in automatically
    ///             when provided with a <code>BounceType</code>. You must provide either this parameter or
    ///                 <code>BounceType</code>.</p>
    public let recipientDsnFields: RecipientDsnFields?

    public init (
        bounceType: BounceType? = nil,
        recipient: String? = nil,
        recipientArn: String? = nil,
        recipientDsnFields: RecipientDsnFields? = nil
    )
    {
        self.bounceType = bounceType
        self.recipient = recipient
        self.recipientArn = recipientArn
        self.recipientDsnFields = recipientDsnFields
    }
}

extension BulkEmailDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case replacementTags = "ReplacementTags"
        case replacementTemplateData = "ReplacementTemplateData"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let destination = destination {
            try container.encode(destination, forKey: Key("Destination"))
        }
        if let replacementTags = replacementTags {
            var replacementTagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplacementTags"))
            for (index0, messagetag0) in replacementTags.enumerated() {
                try replacementTagsContainer.encode(messagetag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let replacementTemplateData = replacementTemplateData {
            try container.encode(replacementTemplateData, forKey: Key("ReplacementTemplateData"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Destination.self, forKey: .destination)
        destination = destinationDecoded
        if containerValues.contains(.replacementTags) {
            struct KeyVal0{struct member{}}
            let replacementTagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .replacementTags)
            if let replacementTagsWrappedContainer = replacementTagsWrappedContainer {
                let replacementTagsContainer = try replacementTagsWrappedContainer.decodeIfPresent([MessageTag].self, forKey: .member)
                var replacementTagsBuffer:[MessageTag]? = nil
                if let replacementTagsContainer = replacementTagsContainer {
                    replacementTagsBuffer = [MessageTag]()
                    for structureContainer0 in replacementTagsContainer {
                        replacementTagsBuffer?.append(structureContainer0)
                    }
                }
                replacementTags = replacementTagsBuffer
            } else {
                replacementTags = []
            }
        } else {
            replacementTags = nil
        }
        let replacementTemplateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replacementTemplateData)
        replacementTemplateData = replacementTemplateDataDecoded
    }
}

extension BulkEmailDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkEmailDestination(destination: \(String(describing: destination)), replacementTags: \(String(describing: replacementTags)), replacementTemplateData: \(String(describing: replacementTemplateData)))"}
}

/// <p>An array that contains one or more Destinations, as well as the tags and replacement
///             data associated with each of those Destinations.</p>
public struct BulkEmailDestination: Equatable {
    /// <p>Represents the destination of the message, consisting of To:, CC:, and BCC:
    ///             fields.</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                     <i>local part</i> of a destination email address (the part of the
    ///                 email address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the <i>domain part</i> of an address (the
    ///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
    ///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>.</p>
    ///         </note>
    public let destination: Destination?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using <code>SendBulkTemplatedEmail</code>. Tags correspond to characteristics of the
    ///             email that you define, so that you can publish email sending events.</p>
    public let replacementTags: [MessageTag]?
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    ///             object, typically consisting of key-value pairs in which the keys correspond to
    ///             replacement tags in the email template.</p>
    public let replacementTemplateData: String?

    public init (
        destination: Destination? = nil,
        replacementTags: [MessageTag]? = nil,
        replacementTemplateData: String? = nil
    )
    {
        self.destination = destination
        self.replacementTags = replacementTags
        self.replacementTemplateData = replacementTemplateData
    }
}

extension BulkEmailDestinationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case messageId = "MessageId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let error = error {
            try container.encode(error, forKey: Key("Error"))
        }
        if let messageId = messageId {
            try container.encode(messageId, forKey: Key("MessageId"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BulkEmailStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension BulkEmailDestinationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BulkEmailDestinationStatus(error: \(String(describing: error)), messageId: \(String(describing: messageId)), status: \(String(describing: status)))"}
}

/// <p>An object that contains the response from the <code>SendBulkTemplatedEmail</code>
///             operation.</p>
public struct BulkEmailDestinationStatus: Equatable {
    /// <p>A description of an error that prevented a message being sent using the
    ///                 <code>SendBulkTemplatedEmail</code> operation.</p>
    public let error: String?
    /// <p>The unique message identifier returned from the <code>SendBulkTemplatedEmail</code>
    ///             operation.</p>
    public let messageId: String?
    /// <p>The status of a message sent using the <code>SendBulkTemplatedEmail</code>
    ///             operation.</p>
    ///         <p>Possible values for this parameter include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Success</code>: Amazon SES accepted the message, and will attempt to deliver
    ///                     it to the recipients.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MessageRejected</code>: The message was rejected because it contained a
    ///                     virus.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MailFromDomainNotVerified</code>: The sender's email address or domain
    ///                     was not verified.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ConfigurationSetDoesNotExist</code>: The configuration set you specified
    ///                     does not exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TemplateDoesNotExist</code>: The template you specified does not
    ///                     exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AccountSuspended</code>: Your account has been shut down because of
    ///                     issues related to your email sending practices.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AccountThrottled</code>: The number of emails you can send has been
    ///                     reduced because your account has exceeded its allocated sending limit.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AccountDailyQuotaExceeded</code>: You have reached or exceeded the
    ///                     maximum number of emails you can send from your account in a 24-hour
    ///                     period.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InvalidSendingPoolName</code>: The configuration set you specified
    ///                     refers to an IP pool that does not exist.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AccountSendingPaused</code>: Email sending for the Amazon SES account was
    ///                     disabled using the <a>UpdateAccountSendingEnabled</a>
    ///                     operation.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ConfigurationSetSendingPaused</code>: Email sending for this
    ///                     configuration set was disabled using the <a>UpdateConfigurationSetSendingEnabled</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InvalidParameterValue</code>: One or more of the parameters you
    ///                     specified when calling this operation was invalid. See the error message for
    ///                     additional information.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>TransientFailure</code>: Amazon SES was unable to process your request
    ///                     because of a temporary issue.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Failed</code>: Amazon SES was unable to process your request. See the error
    ///                     message for additional information.</p>
    ///             </li>
    ///          </ul>
    public let status: BulkEmailStatus?

    public init (
        error: String? = nil,
        messageId: String? = nil,
        status: BulkEmailStatus? = nil
    )
    {
        self.error = error
        self.messageId = messageId
        self.status = status
    }
}

public enum BulkEmailStatus {
    case accountdailyquotaexceeded
    case accountsendingpaused
    case accountsuspended
    case accountthrottled
    case configurationsetdoesnotexist
    case configurationsetsendingpaused
    case failed
    case invalidparametervalue
    case invalidsendingpoolname
    case mailfromdomainnotverified
    case messagerejected
    case success
    case templatedoesnotexist
    case transientfailure
    case sdkUnknown(String)
}

extension BulkEmailStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BulkEmailStatus] {
        return [
            .accountdailyquotaexceeded,
            .accountsendingpaused,
            .accountsuspended,
            .accountthrottled,
            .configurationsetdoesnotexist,
            .configurationsetsendingpaused,
            .failed,
            .invalidparametervalue,
            .invalidsendingpoolname,
            .mailfromdomainnotverified,
            .messagerejected,
            .success,
            .templatedoesnotexist,
            .transientfailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountdailyquotaexceeded: return "AccountDailyQuotaExceeded"
        case .accountsendingpaused: return "AccountSendingPaused"
        case .accountsuspended: return "AccountSuspended"
        case .accountthrottled: return "AccountThrottled"
        case .configurationsetdoesnotexist: return "ConfigurationSetDoesNotExist"
        case .configurationsetsendingpaused: return "ConfigurationSetSendingPaused"
        case .failed: return "Failed"
        case .invalidparametervalue: return "InvalidParameterValue"
        case .invalidsendingpoolname: return "InvalidSendingPoolName"
        case .mailfromdomainnotverified: return "MailFromDomainNotVerified"
        case .messagerejected: return "MessageRejected"
        case .success: return "Success"
        case .templatedoesnotexist: return "TemplateDoesNotExist"
        case .transientfailure: return "TransientFailure"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BulkEmailStatus(rawValue: rawValue) ?? BulkEmailStatus.sdkUnknown(rawValue)
    }
}

extension CannotDeleteException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotDeleteException(name: \(String(describing: name)), message: \(String(describing: message)))"}
}

extension CannotDeleteException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CannotDeleteExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.name = output.error.name
        } else {
            self.name = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the delete operation could not be completed.</p>
public struct CannotDeleteException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates that a resource could not be deleted because no resource with the specified
    ///             name exists.</p>
    public var name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

struct CannotDeleteExceptionBody: Equatable {
    public let name: String?
    public let message: String?
}

extension CannotDeleteExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CloneReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "CloneReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CloneReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneReceiptRuleSetOutputError>
}

extension CloneReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneReceiptRuleSetInput(originalRuleSetName: \(String(describing: originalRuleSetName)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension CloneReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let originalRuleSetName = originalRuleSetName {
            try container.encode(originalRuleSetName, forKey: Key("OriginalRuleSetName"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("CloneReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CloneReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "CloneReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CloneReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneReceiptRuleSetOutputError>
}

public struct CloneReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CloneReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CloneReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CloneReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CloneReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CloneReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CloneReceiptRuleSetOutputError>
}

/// <p>Represents a request to create a receipt rule set by cloning an existing one. You use
///             receipt rule sets to receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct CloneReceiptRuleSetInput: Equatable {
    /// <p>The name of the rule set to clone.</p>
    public let originalRuleSetName: String?
    /// <p>The name of the rule set to create. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Start and end with a letter or number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let ruleSetName: String?

    public init (
        originalRuleSetName: String? = nil,
        ruleSetName: String? = nil
    )
    {
        self.originalRuleSetName = originalRuleSetName
        self.ruleSetName = ruleSetName
    }
}

extension CloneReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CloneReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloneReceiptRuleSetOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloneReceiptRuleSetOutputResponse()"}
}

extension CloneReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CloneReceiptRuleSetOutputResponse: Equatable {

    public init() {}
}

struct CloneReceiptRuleSetOutputResponseBody: Equatable {
}

extension CloneReceiptRuleSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CloudWatchDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionConfigurations = "DimensionConfigurations"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dimensionConfigurations = dimensionConfigurations {
            var dimensionConfigurationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DimensionConfigurations"))
            for (index0, cloudwatchdimensionconfiguration0) in dimensionConfigurations.enumerated() {
                try dimensionConfigurationsContainer.encode(cloudwatchdimensionconfiguration0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.dimensionConfigurations) {
            struct KeyVal0{struct member{}}
            let dimensionConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dimensionConfigurations)
            if let dimensionConfigurationsWrappedContainer = dimensionConfigurationsWrappedContainer {
                let dimensionConfigurationsContainer = try dimensionConfigurationsWrappedContainer.decodeIfPresent([CloudWatchDimensionConfiguration].self, forKey: .member)
                var dimensionConfigurationsBuffer:[CloudWatchDimensionConfiguration]? = nil
                if let dimensionConfigurationsContainer = dimensionConfigurationsContainer {
                    dimensionConfigurationsBuffer = [CloudWatchDimensionConfiguration]()
                    for structureContainer0 in dimensionConfigurationsContainer {
                        dimensionConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                dimensionConfigurations = dimensionConfigurationsBuffer
            } else {
                dimensionConfigurations = []
            }
        } else {
            dimensionConfigurations = nil
        }
    }
}

extension CloudWatchDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDestination(dimensionConfigurations: \(String(describing: dimensionConfigurations)))"}
}

/// <p>Contains information associated with an Amazon CloudWatch event destination to which email
///             sending events are published.</p>
///         <p>Event destinations, such as Amazon CloudWatch, are associated with configuration sets, which
///             enable you to publish email sending events. For information about using configuration
///             sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CloudWatchDestination: Equatable {
    /// <p>A list of dimensions upon which to categorize your emails when you publish email
    ///             sending events to Amazon CloudWatch.</p>
    public let dimensionConfigurations: [CloudWatchDimensionConfiguration]?

    public init (
        dimensionConfigurations: [CloudWatchDimensionConfiguration]? = nil
    )
    {
        self.dimensionConfigurations = dimensionConfigurations
    }
}

extension CloudWatchDimensionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultDimensionValue = "DefaultDimensionValue"
        case dimensionName = "DimensionName"
        case dimensionValueSource = "DimensionValueSource"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let defaultDimensionValue = defaultDimensionValue {
            try container.encode(defaultDimensionValue, forKey: Key("DefaultDimensionValue"))
        }
        if let dimensionName = dimensionName {
            try container.encode(dimensionName, forKey: Key("DimensionName"))
        }
        if let dimensionValueSource = dimensionValueSource {
            try container.encode(dimensionValueSource, forKey: Key("DimensionValueSource"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueSourceDecoded = try containerValues.decodeIfPresent(DimensionValueSource.self, forKey: .dimensionValueSource)
        dimensionValueSource = dimensionValueSourceDecoded
        let defaultDimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultDimensionValue)
        defaultDimensionValue = defaultDimensionValueDecoded
    }
}

extension CloudWatchDimensionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchDimensionConfiguration(defaultDimensionValue: \(String(describing: defaultDimensionValue)), dimensionName: \(String(describing: dimensionName)), dimensionValueSource: \(String(describing: dimensionValueSource)))"}
}

/// <p>Contains the dimension configuration to use when you publish email sending events to
///             Amazon CloudWatch.</p>
///         <p>For information about publishing email sending events to Amazon CloudWatch, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer Guide</a>.</p>
public struct CloudWatchDimensionConfiguration: Equatable {
    /// <p>The default value of the dimension that is published to Amazon CloudWatch if you do not provide
    ///             the value of the dimension when you send an email. The default value must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let defaultDimensionValue: String?
    /// <p>The name of an Amazon CloudWatch dimension associated with an email sending metric. The name
    ///             must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let dimensionName: String?
    /// <p>The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. If you
    ///             want Amazon SES to use the message tags that you specify using an
    ///                 <code>X-SES-MESSAGE-TAGS</code> header or a parameter to the
    ///                 <code>SendEmail</code>/<code>SendRawEmail</code> API, choose
    ///             <code>messageTag</code>. If you want Amazon SES to use your own email headers, choose
    ///                 <code>emailHeader</code>.</p>
    public let dimensionValueSource: DimensionValueSource?

    public init (
        defaultDimensionValue: String? = nil,
        dimensionName: String? = nil,
        dimensionValueSource: DimensionValueSource? = nil
    )
    {
        self.defaultDimensionValue = defaultDimensionValue
        self.dimensionName = dimensionName
        self.dimensionValueSource = dimensionValueSource
    }
}

extension ConfigurationSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConfigurationSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationSet(name: \(String(describing: name)))"}
}

/// <p>The name of the configuration set.</p>
///         <p>Configuration sets let you create groups of rules that you can apply to the emails you
///             send using Amazon SES. For more information about using configuration sets, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/using-configuration-sets.html">Using Amazon SES Configuration Sets</a> in the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/">Amazon SES Developer Guide</a>.</p>
public struct ConfigurationSet: Equatable {
    /// <p>The name of the configuration set. The name must meet the following
    ///             requirements:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Contain only letters (a-z, A-Z), numbers (0-9), underscores (_), or dashes
    ///                     (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain 64 characters or fewer.</p>
    ///             </li>
    ///          </ul>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension ConfigurationSetAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationSetAlreadyExistsException(configurationSetName: \(String(describing: configurationSetName)), message: \(String(describing: message)))"}
}

extension ConfigurationSetAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ConfigurationSetAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the configuration set could not be created because of a naming
///             conflict.</p>
public struct ConfigurationSetAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.message = message
    }
}

struct ConfigurationSetAlreadyExistsExceptionBody: Equatable {
    public let configurationSetName: String?
    public let message: String?
}

extension ConfigurationSetAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConfigurationSetAttribute {
    case deliveryOptions
    case eventDestinations
    case reputationOptions
    case trackingOptions
    case sdkUnknown(String)
}

extension ConfigurationSetAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationSetAttribute] {
        return [
            .deliveryOptions,
            .eventDestinations,
            .reputationOptions,
            .trackingOptions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deliveryOptions: return "deliveryOptions"
        case .eventDestinations: return "eventDestinations"
        case .reputationOptions: return "reputationOptions"
        case .trackingOptions: return "trackingOptions"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationSetAttribute(rawValue: rawValue) ?? ConfigurationSetAttribute.sdkUnknown(rawValue)
    }
}

extension ConfigurationSetDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationSetDoesNotExistException(configurationSetName: \(String(describing: configurationSetName)), message: \(String(describing: message)))"}
}

extension ConfigurationSetDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ConfigurationSetDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the configuration set does not exist.</p>
public struct ConfigurationSetDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.message = message
    }
}

struct ConfigurationSetDoesNotExistExceptionBody: Equatable {
    public let configurationSetName: String?
    public let message: String?
}

extension ConfigurationSetDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigurationSetSendingPausedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationSetSendingPausedException(configurationSetName: \(String(describing: configurationSetName)), message: \(String(describing: message)))"}
}

extension ConfigurationSetSendingPausedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ConfigurationSetSendingPausedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that email sending is disabled for the configuration set.</p>
///         <p>You can enable or disable email sending for a configuration set using <a>UpdateConfigurationSetSendingEnabled</a>.</p>
public struct ConfigurationSetSendingPausedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The name of the configuration set for which email sending is disabled.</p>
    public var configurationSetName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.message = message
    }
}

struct ConfigurationSetSendingPausedExceptionBody: Equatable {
    public let configurationSetName: String?
    public let message: String?
}

extension ConfigurationSetSendingPausedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Content: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let charset = charset {
            try container.encode(charset, forKey: Key("Charset"))
        }
        if let data = data {
            try container.encode(data, forKey: Key("Data"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension Content: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Content(charset: \(String(describing: charset)), data: \(String(describing: data)))"}
}

/// <p>Represents textual data, plus an optional character set specification.</p>
///         <p>By default, the text must be 7-bit ASCII, due to the constraints of the SMTP protocol.
///             If the text must contain any other characters, then you must also specify a character
///             set. Examples include UTF-8, ISO-8859-1, and Shift_JIS.</p>
public struct Content: Equatable {
    /// <p>The character set of the content.</p>
    public let charset: String?
    /// <p>The textual data of the content.</p>
    public let data: String?

    public init (
        charset: String? = nil,
        data: String? = nil
    )
    {
        self.charset = charset
        self.data = data
    }
}

public struct CreateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

extension CreateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)))"}
}

extension CreateConfigurationSetEventDestinationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let eventDestination = eventDestination {
            try container.encode(eventDestination, forKey: Key("EventDestination"))
        }
        try container.encode("CreateConfigurationSetEventDestination", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

public struct CreateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

/// <p>Represents a request to create a configuration set event destination. A configuration
///             set event destination, which can be either Amazon CloudWatch or Amazon Kinesis Firehose, describes an AWS service
///             in which Amazon SES publishes the email sending events associated with a configuration set.
///             For information about using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CreateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that the event destination should be associated
    ///             with.</p>
    public let configurationSetName: String?
    /// <p>An object that describes the AWS service that email sending event information will
    ///             be published to.</p>
    public let eventDestination: EventDestination?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestination? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

extension CreateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDestinationAlreadyExistsException" : self = .eventDestinationAlreadyExistsException(try EventDestinationAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchDestinationException" : self = .invalidCloudWatchDestinationException(try InvalidCloudWatchDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFirehoseDestinationException" : self = .invalidFirehoseDestinationException(try InvalidFirehoseDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSNSDestinationException" : self = .invalidSNSDestinationException(try InvalidSNSDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case eventDestinationAlreadyExistsException(EventDestinationAlreadyExistsException)
    case invalidCloudWatchDestinationException(InvalidCloudWatchDestinationException)
    case invalidFirehoseDestinationException(InvalidFirehoseDestinationException)
    case invalidSNSDestinationException(InvalidSNSDestinationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationOutputResponse()"}
}

extension CreateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension CreateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

extension CreateConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetInput(configurationSet: \(String(describing: configurationSet)))"}
}

extension CreateConfigurationSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSet = configurationSet {
            try container.encode(configurationSet, forKey: Key("ConfigurationSet"))
        }
        try container.encode("CreateConfigurationSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

public struct CreateConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

/// <p>Represents a request to create a configuration set. Configuration sets enable you to
///             publish email sending events. For information about using configuration sets, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CreateConfigurationSetInput: Equatable {
    /// <p>A data structure that contains the name of the configuration set.</p>
    public let configurationSet: ConfigurationSet?

    public init (
        configurationSet: ConfigurationSet? = nil
    )
    {
        self.configurationSet = configurationSet
    }
}

extension CreateConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetAlreadyExistsException" : self = .configurationSetAlreadyExistsException(try ConfigurationSetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationSetException" : self = .invalidConfigurationSetException(try InvalidConfigurationSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Equatable {
    case configurationSetAlreadyExistsException(ConfigurationSetAlreadyExistsException)
    case invalidConfigurationSetException(InvalidConfigurationSetException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetOutputResponse()"}
}

extension CreateConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetOutputResponseBody: Equatable {
}

extension CreateConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConfigurationSetTrackingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetTrackingOptionsOutputError>
}

extension CreateConfigurationSetTrackingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetTrackingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension CreateConfigurationSetTrackingOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let trackingOptions = trackingOptions {
            try container.encode(trackingOptions, forKey: Key("TrackingOptions"))
        }
        try container.encode("CreateConfigurationSetTrackingOptions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateConfigurationSetTrackingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetTrackingOptionsOutputError>
}

public struct CreateConfigurationSetTrackingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetTrackingOptionsOutputError>
}

/// <p>Represents a request to create an open and click tracking option object in a
///             configuration set. </p>
public struct CreateConfigurationSetTrackingOptionsInput: Equatable {
    /// <p>The name of the configuration set that the tracking options should be associated
    ///             with.</p>
    public let configurationSetName: String?
    /// <p>A domain that is used to redirect email recipients to an Amazon SES-operated domain. This
    ///             domain captures open and click events generated by Amazon SES emails.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Configuring
    ///                 Custom Domains to Handle Open and Click Tracking</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.trackingOptions = trackingOptions
    }
}

extension CreateConfigurationSetTrackingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateConfigurationSetTrackingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrackingOptionsException" : self = .invalidTrackingOptionsException(try InvalidTrackingOptionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrackingOptionsAlreadyExistsException" : self = .trackingOptionsAlreadyExistsException(try TrackingOptionsAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetTrackingOptionsOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case invalidTrackingOptionsException(InvalidTrackingOptionsException)
    case trackingOptionsAlreadyExistsException(TrackingOptionsAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetTrackingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetTrackingOptionsOutputResponse()"}
}

extension CreateConfigurationSetTrackingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateConfigurationSetTrackingOptionsOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetTrackingOptionsOutputResponseBody: Equatable {
}

extension CreateConfigurationSetTrackingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

extension CreateCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomVerificationEmailTemplateInput(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension CreateCustomVerificationEmailTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try container.encode(failureRedirectionURL, forKey: Key("FailureRedirectionURL"))
        }
        if let fromEmailAddress = fromEmailAddress {
            try container.encode(fromEmailAddress, forKey: Key("FromEmailAddress"))
        }
        if let successRedirectionURL = successRedirectionURL {
            try container.encode(successRedirectionURL, forKey: Key("SuccessRedirectionURL"))
        }
        if let templateContent = templateContent {
            try container.encode(templateContent, forKey: Key("TemplateContent"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let templateSubject = templateSubject {
            try container.encode(templateSubject, forKey: Key("TemplateSubject"))
        }
        try container.encode("CreateCustomVerificationEmailTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

public struct CreateCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to create a custom verification email template.</p>
public struct CreateCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email. The total size of the email must be less
    ///             than 10 MB. The message body may contain HTML, with some limitations. For more
    ///             information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

extension CreateCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomVerificationEmailInvalidContentException" : self = .customVerificationEmailInvalidContentException(try CustomVerificationEmailInvalidContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomVerificationEmailTemplateAlreadyExistsException" : self = .customVerificationEmailTemplateAlreadyExistsException(try CustomVerificationEmailTemplateAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FromEmailAddressNotVerifiedException" : self = .fromEmailAddressNotVerifiedException(try FromEmailAddressNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomVerificationEmailTemplateOutputError: Equatable {
    case customVerificationEmailInvalidContentException(CustomVerificationEmailInvalidContentException)
    case customVerificationEmailTemplateAlreadyExistsException(CustomVerificationEmailTemplateAlreadyExistsException)
    case fromEmailAddressNotVerifiedException(FromEmailAddressNotVerifiedException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomVerificationEmailTemplateOutputResponse()"}
}

extension CreateCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct CreateCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension CreateCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateReceiptFilterInputBodyMiddleware: Middleware {
    public let id: String = "CreateReceiptFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptFilterInput>
    public typealias MOutput = OperationOutput<CreateReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptFilterOutputError>
}

extension CreateReceiptFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptFilterInput(filter: \(String(describing: filter)))"}
}

extension CreateReceiptFilterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filter = filter {
            try container.encode(filter, forKey: Key("Filter"))
        }
        try container.encode("CreateReceiptFilter", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateReceiptFilterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReceiptFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptFilterInput>
    public typealias MOutput = OperationOutput<CreateReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptFilterOutputError>
}

public struct CreateReceiptFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReceiptFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptFilterInput>
    public typealias MOutput = OperationOutput<CreateReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptFilterOutputError>
}

/// <p>Represents a request to create a new IP address filter. You use IP address filters
///             when you receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct CreateReceiptFilterInput: Equatable {
    /// <p>A data structure that describes the IP address filter to create, which consists of a
    ///             name, an IP address range, and whether to allow or block mail from it.</p>
    public let filter: ReceiptFilter?

    public init (
        filter: ReceiptFilter? = nil
    )
    {
        self.filter = filter
    }
}

extension CreateReceiptFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateReceiptFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReceiptFilterOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReceiptFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptFilterOutputResponse()"}
}

extension CreateReceiptFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateReceiptFilterOutputResponse: Equatable {

    public init() {}
}

struct CreateReceiptFilterOutputResponseBody: Equatable {
}

extension CreateReceiptFilterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateReceiptRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleOutputError>
}

extension CreateReceiptRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptRuleInput(after: \(String(describing: after)), rule: \(String(describing: rule)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension CreateReceiptRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let after = after {
            try container.encode(after, forKey: Key("After"))
        }
        if let rule = rule {
            try container.encode(rule, forKey: Key("Rule"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("CreateReceiptRule", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateReceiptRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleOutputError>
}

public struct CreateReceiptRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleOutputError>
}

/// <p>Represents a request to create a receipt rule. You use receipt rules to receive email
///             with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CreateReceiptRuleInput: Equatable {
    /// <p>The name of an existing rule after which the new rule will be placed. If this
    ///             parameter is null, the new rule will be inserted at the beginning of the rule
    ///             list.</p>
    public let after: String?
    /// <p>A data structure that contains the specified rule's name, actions, recipients,
    ///             domains, enabled status, scan status, and TLS policy.</p>
    public let rule: ReceiptRule?
    /// <p>The name of the rule set that the receipt rule will be added to.</p>
    public let ruleSetName: String?

    public init (
        after: String? = nil,
        rule: ReceiptRule? = nil,
        ruleSetName: String? = nil
    )
    {
        self.after = after
        self.rule = rule
        self.ruleSetName = ruleSetName
    }
}

extension CreateReceiptRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateReceiptRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionException" : self = .invalidLambdaFunctionException(try InvalidLambdaFunctionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ConfigurationException" : self = .invalidS3ConfigurationException(try InvalidS3ConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicException" : self = .invalidSnsTopicException(try InvalidSnsTopicException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleDoesNotExistException" : self = .ruleDoesNotExistException(try RuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReceiptRuleOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidLambdaFunctionException(InvalidLambdaFunctionException)
    case invalidS3ConfigurationException(InvalidS3ConfigurationException)
    case invalidSnsTopicException(InvalidSnsTopicException)
    case limitExceededException(LimitExceededException)
    case ruleDoesNotExistException(RuleDoesNotExistException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReceiptRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptRuleOutputResponse()"}
}

extension CreateReceiptRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateReceiptRuleOutputResponse: Equatable {

    public init() {}
}

struct CreateReceiptRuleOutputResponseBody: Equatable {
}

extension CreateReceiptRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleSetOutputError>
}

extension CreateReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptRuleSetInput(ruleSetName: \(String(describing: ruleSetName)))"}
}

extension CreateReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("CreateReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleSetOutputError>
}

public struct CreateReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<CreateReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReceiptRuleSetOutputError>
}

/// <p>Represents a request to create an empty receipt rule set. You use receipt rule sets to
///             receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CreateReceiptRuleSetInput: Equatable {
    /// <p>The name of the rule set to create. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Start and end with a letter or number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let ruleSetName: String?

    public init (
        ruleSetName: String? = nil
    )
    {
        self.ruleSetName = ruleSetName
    }
}

extension CreateReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReceiptRuleSetOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReceiptRuleSetOutputResponse()"}
}

extension CreateReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct CreateReceiptRuleSetOutputResponse: Equatable {

    public init() {}
}

struct CreateReceiptRuleSetOutputResponseBody: Equatable {
}

extension CreateReceiptRuleSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

extension CreateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateInput(template: \(String(describing: template)))"}
}

extension CreateTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let template = template {
            try container.encode(template, forKey: Key("Template"))
        }
        try container.encode("CreateTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct CreateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

public struct CreateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTemplateInput>
    public typealias MOutput = OperationOutput<CreateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTemplateOutputError>
}

/// <p>Represents a request to create an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct CreateTemplateInput: Equatable {
    /// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
    ///             part.</p>
    public let template: Template?

    public init (
        template: Template? = nil
    )
    {
        self.template = template
    }
}

extension CreateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTemplateException" : self = .invalidTemplateException(try InvalidTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTemplateOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidTemplateException(InvalidTemplateException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateOutputResponse()"}
}

extension CreateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTemplateOutputResponse: Equatable {

    public init() {}
}

struct CreateTemplateOutputResponseBody: Equatable {
}

extension CreateTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum CustomMailFromStatus {
    case failed
    case pending
    case success
    case temporaryfailure
    case sdkUnknown(String)
}

extension CustomMailFromStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomMailFromStatus] {
        return [
            .failed,
            .pending,
            .success,
            .temporaryfailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .pending: return "Pending"
        case .success: return "Success"
        case .temporaryfailure: return "TemporaryFailure"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomMailFromStatus(rawValue: rawValue) ?? CustomMailFromStatus.sdkUnknown(rawValue)
    }
}

extension CustomVerificationEmailInvalidContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomVerificationEmailInvalidContentException(message: \(String(describing: message)))"}
}

extension CustomVerificationEmailInvalidContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomVerificationEmailInvalidContentExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that custom verification email template provided content is invalid.</p>
public struct CustomVerificationEmailInvalidContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomVerificationEmailInvalidContentExceptionBody: Equatable {
    public let message: String?
}

extension CustomVerificationEmailInvalidContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomVerificationEmailTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try container.encode(failureRedirectionURL, forKey: Key("FailureRedirectionURL"))
        }
        if let fromEmailAddress = fromEmailAddress {
            try container.encode(fromEmailAddress, forKey: Key("FromEmailAddress"))
        }
        if let successRedirectionURL = successRedirectionURL {
            try container.encode(successRedirectionURL, forKey: Key("SuccessRedirectionURL"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let templateSubject = templateSubject {
            try container.encode(templateSubject, forKey: Key("TemplateSubject"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

extension CustomVerificationEmailTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomVerificationEmailTemplate(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

/// <p>Contains information about a custom verification email template.</p>
public struct CustomVerificationEmailTemplate: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

extension CustomVerificationEmailTemplateAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomVerificationEmailTemplateAlreadyExistsException(customVerificationEmailTemplateName: \(String(describing: customVerificationEmailTemplateName)), message: \(String(describing: message)))"}
}

extension CustomVerificationEmailTemplateAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomVerificationEmailTemplateAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.customVerificationEmailTemplateName = output.error.customVerificationEmailTemplateName
            self.message = output.error.message
        } else {
            self.customVerificationEmailTemplateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a custom verification email template with the name you specified
///             already exists.</p>
public struct CustomVerificationEmailTemplateAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the provided custom verification email template with the specified
    ///             template name already exists.</p>
    public var customVerificationEmailTemplateName: String?
    public var message: String?

    public init (
        customVerificationEmailTemplateName: String? = nil,
        message: String? = nil
    )
    {
        self.customVerificationEmailTemplateName = customVerificationEmailTemplateName
        self.message = message
    }
}

struct CustomVerificationEmailTemplateAlreadyExistsExceptionBody: Equatable {
    public let customVerificationEmailTemplateName: String?
    public let message: String?
}

extension CustomVerificationEmailTemplateAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customVerificationEmailTemplateName = "CustomVerificationEmailTemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVerificationEmailTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customVerificationEmailTemplateName)
        customVerificationEmailTemplateName = customVerificationEmailTemplateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomVerificationEmailTemplateDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomVerificationEmailTemplateDoesNotExistException(customVerificationEmailTemplateName: \(String(describing: customVerificationEmailTemplateName)), message: \(String(describing: message)))"}
}

extension CustomVerificationEmailTemplateDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CustomVerificationEmailTemplateDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.customVerificationEmailTemplateName = output.error.customVerificationEmailTemplateName
            self.message = output.error.message
        } else {
            self.customVerificationEmailTemplateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a custom verification email template with the name you specified does
///             not exist.</p>
public struct CustomVerificationEmailTemplateDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the provided custom verification email template does not exist.</p>
    public var customVerificationEmailTemplateName: String?
    public var message: String?

    public init (
        customVerificationEmailTemplateName: String? = nil,
        message: String? = nil
    )
    {
        self.customVerificationEmailTemplateName = customVerificationEmailTemplateName
        self.message = message
    }
}

struct CustomVerificationEmailTemplateDoesNotExistExceptionBody: Equatable {
    public let customVerificationEmailTemplateName: String?
    public let message: String?
}

extension CustomVerificationEmailTemplateDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customVerificationEmailTemplateName = "CustomVerificationEmailTemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customVerificationEmailTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customVerificationEmailTemplateName)
        customVerificationEmailTemplateName = customVerificationEmailTemplateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

extension DeleteConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension DeleteConfigurationSetEventDestinationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let eventDestinationName = eventDestinationName {
            try container.encode(eventDestinationName, forKey: Key("EventDestinationName"))
        }
        try container.encode("DeleteConfigurationSetEventDestination", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

/// <p>Represents a request to delete a configuration set event destination. Configuration
///             set event destinations are associated with configuration sets, which enable you to
///             publish email sending events. For information about using configuration sets, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set from which to delete the event destination.</p>
    public let configurationSetName: String?
    /// <p>The name of the event destination to delete.</p>
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDestinationDoesNotExistException" : self = .eventDestinationDoesNotExistException(try EventDestinationDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case eventDestinationDoesNotExistException(EventDestinationDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationOutputResponse()"}
}

extension DeleteConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

extension DeleteConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        try container.encode("DeleteConfigurationSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

/// <p>Represents a request to delete a configuration set. Configuration sets enable you to
///             publish email sending events. For information about using configuration sets, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteConfigurationSetInput: Equatable {
    /// <p>The name of the configuration set to delete.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

extension DeleteConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetOutputResponse()"}
}

extension DeleteConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConfigurationSetTrackingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetTrackingOptionsOutputError>
}

extension DeleteConfigurationSetTrackingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetTrackingOptionsInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetTrackingOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        try container.encode("DeleteConfigurationSetTrackingOptions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteConfigurationSetTrackingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetTrackingOptionsOutputError>
}

public struct DeleteConfigurationSetTrackingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetTrackingOptionsOutputError>
}

/// <p>Represents a request to delete open and click tracking options in a configuration set.
///         </p>
public struct DeleteConfigurationSetTrackingOptionsInput: Equatable {
    /// <p>The name of the configuration set from which you want to delete the tracking
    ///             options.</p>
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

extension DeleteConfigurationSetTrackingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteConfigurationSetTrackingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrackingOptionsDoesNotExistException" : self = .trackingOptionsDoesNotExistException(try TrackingOptionsDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetTrackingOptionsOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case trackingOptionsDoesNotExistException(TrackingOptionsDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetTrackingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetTrackingOptionsOutputResponse()"}
}

extension DeleteConfigurationSetTrackingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteConfigurationSetTrackingOptionsOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetTrackingOptionsOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetTrackingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomVerificationEmailTemplateOutputError>
}

extension DeleteCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomVerificationEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DeleteCustomVerificationEmailTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("DeleteCustomVerificationEmailTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomVerificationEmailTemplateOutputError>
}

public struct DeleteCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to delete an existing custom verification email template.</p>
public struct DeleteCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The name of the custom verification email template that you want to delete.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

extension DeleteCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomVerificationEmailTemplateOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomVerificationEmailTemplateOutputResponse()"}
}

extension DeleteCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension DeleteCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteIdentityInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityInput>
    public typealias MOutput = OperationOutput<DeleteIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityOutputError>
}

extension DeleteIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityInput(identity: \(String(describing: identity)))"}
}

extension DeleteIdentityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        try container.encode("DeleteIdentity", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityInput>
    public typealias MOutput = OperationOutput<DeleteIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityOutputError>
}

public struct DeleteIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityInput>
    public typealias MOutput = OperationOutput<DeleteIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityOutputError>
}

/// <p>Represents a request to delete one of your Amazon SES identities (an email address or
///             domain).</p>
public struct DeleteIdentityInput: Equatable {
    /// <p>The identity to be removed from the list of identities for the AWS Account.</p>
    public let identity: String?

    public init (
        identity: String? = nil
    )
    {
        self.identity = identity
    }
}

extension DeleteIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityOutputResponse()"}
}

extension DeleteIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteIdentityOutputResponse: Equatable {

    public init() {}
}

struct DeleteIdentityOutputResponseBody: Equatable {
}

extension DeleteIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteIdentityPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIdentityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPolicyInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPolicyOutputError>
}

extension DeleteIdentityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityPolicyInput(identity: \(String(describing: identity)), policyName: \(String(describing: policyName)))"}
}

extension DeleteIdentityPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("DeleteIdentityPolicy", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteIdentityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIdentityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPolicyInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPolicyOutputError>
}

public struct DeleteIdentityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIdentityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPolicyInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPolicyOutputError>
}

/// <p>Represents a request to delete a sending authorization policy for an identity. Sending
///             authorization is an Amazon SES feature that enables you to authorize other senders to use
///             your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteIdentityPolicyInput: Equatable {
    /// <p>The identity that is associated with the policy that you want to delete. You can
    ///             specify the identity by using its name or by using its Amazon Resource Name (ARN).
    ///             Examples: <code>user@example.com</code>, <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    ///         <p>To successfully call this API, you must own the identity.</p>
    public let identity: String?
    /// <p>The name of the policy to be deleted.</p>
    public let policyName: String?

    public init (
        identity: String? = nil,
        policyName: String? = nil
    )
    {
        self.identity = identity
        self.policyName = policyName
    }
}

extension DeleteIdentityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteIdentityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityPolicyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityPolicyOutputResponse()"}
}

extension DeleteIdentityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteIdentityPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteIdentityPolicyOutputResponseBody: Equatable {
}

extension DeleteIdentityPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReceiptFilterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReceiptFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptFilterInput>
    public typealias MOutput = OperationOutput<DeleteReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptFilterOutputError>
}

extension DeleteReceiptFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptFilterInput(filterName: \(String(describing: filterName)))"}
}

extension DeleteReceiptFilterInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let filterName = filterName {
            try container.encode(filterName, forKey: Key("FilterName"))
        }
        try container.encode("DeleteReceiptFilter", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteReceiptFilterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReceiptFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptFilterInput>
    public typealias MOutput = OperationOutput<DeleteReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptFilterOutputError>
}

public struct DeleteReceiptFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReceiptFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptFilterInput>
    public typealias MOutput = OperationOutput<DeleteReceiptFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptFilterOutputError>
}

/// <p>Represents a request to delete an IP address filter. You use IP address filters when
///             you receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteReceiptFilterInput: Equatable {
    /// <p>The name of the IP address filter to delete.</p>
    public let filterName: String?

    public init (
        filterName: String? = nil
    )
    {
        self.filterName = filterName
    }
}

extension DeleteReceiptFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteReceiptFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReceiptFilterOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReceiptFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptFilterOutputResponse()"}
}

extension DeleteReceiptFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteReceiptFilterOutputResponse: Equatable {

    public init() {}
}

struct DeleteReceiptFilterOutputResponseBody: Equatable {
}

extension DeleteReceiptFilterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReceiptRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleOutputError>
}

extension DeleteReceiptRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptRuleInput(ruleName: \(String(describing: ruleName)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension DeleteReceiptRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleName = ruleName {
            try container.encode(ruleName, forKey: Key("RuleName"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("DeleteReceiptRule", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteReceiptRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleOutputError>
}

public struct DeleteReceiptRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleOutputError>
}

/// <p>Represents a request to delete a receipt rule. You use receipt rules to receive email
///             with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteReceiptRuleInput: Equatable {
    /// <p>The name of the receipt rule to delete.</p>
    public let ruleName: String?
    /// <p>The name of the receipt rule set that contains the receipt rule to delete.</p>
    public let ruleSetName: String?

    public init (
        ruleName: String? = nil,
        ruleSetName: String? = nil
    )
    {
        self.ruleName = ruleName
        self.ruleSetName = ruleSetName
    }
}

extension DeleteReceiptRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteReceiptRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReceiptRuleOutputError: Equatable {
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReceiptRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptRuleOutputResponse()"}
}

extension DeleteReceiptRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteReceiptRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteReceiptRuleOutputResponseBody: Equatable {
}

extension DeleteReceiptRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleSetOutputError>
}

extension DeleteReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptRuleSetInput(ruleSetName: \(String(describing: ruleSetName)))"}
}

extension DeleteReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("DeleteReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleSetOutputError>
}

public struct DeleteReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DeleteReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReceiptRuleSetOutputError>
}

/// <p>Represents a request to delete a receipt rule set and all of the receipt rules it
///             contains. You use receipt rule sets to receive email with Amazon SES. For more information,
///             see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteReceiptRuleSetInput: Equatable {
    /// <p>The name of the receipt rule set to delete.</p>
    public let ruleSetName: String?

    public init (
        ruleSetName: String? = nil
    )
    {
        self.ruleSetName = ruleSetName
    }
}

extension DeleteReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CannotDeleteException" : self = .cannotDeleteException(try CannotDeleteException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReceiptRuleSetOutputError: Equatable {
    case cannotDeleteException(CannotDeleteException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReceiptRuleSetOutputResponse()"}
}

extension DeleteReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct DeleteReceiptRuleSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteReceiptRuleSetOutputResponseBody: Equatable {
}

extension DeleteReceiptRuleSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateInput>
    public typealias MOutput = OperationOutput<DeleteTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateOutputError>
}

extension DeleteTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension DeleteTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("DeleteTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateInput>
    public typealias MOutput = OperationOutput<DeleteTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateOutputError>
}

public struct DeleteTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTemplateInput>
    public typealias MOutput = OperationOutput<DeleteTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTemplateOutputError>
}

/// <p>Represents a request to delete an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DeleteTemplateInput: Equatable {
    /// <p>The name of the template to be deleted.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

extension DeleteTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTemplateOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTemplateOutputResponse()"}
}

extension DeleteTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteTemplateOutputResponseBody: Equatable {
}

extension DeleteTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteVerifiedEmailAddressInputBodyMiddleware: Middleware {
    public let id: String = "DeleteVerifiedEmailAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVerifiedEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVerifiedEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVerifiedEmailAddressInput>
    public typealias MOutput = OperationOutput<DeleteVerifiedEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVerifiedEmailAddressOutputError>
}

extension DeleteVerifiedEmailAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVerifiedEmailAddressInput(emailAddress: \(String(describing: emailAddress)))"}
}

extension DeleteVerifiedEmailAddressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: Key("EmailAddress"))
        }
        try container.encode("DeleteVerifiedEmailAddress", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DeleteVerifiedEmailAddressInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVerifiedEmailAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVerifiedEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVerifiedEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVerifiedEmailAddressInput>
    public typealias MOutput = OperationOutput<DeleteVerifiedEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVerifiedEmailAddressOutputError>
}

public struct DeleteVerifiedEmailAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVerifiedEmailAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVerifiedEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVerifiedEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVerifiedEmailAddressInput>
    public typealias MOutput = OperationOutput<DeleteVerifiedEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVerifiedEmailAddressOutputError>
}

/// <p>Represents a request to delete an email address from the list of email addresses you
///             have attempted to verify under your AWS account.</p>
public struct DeleteVerifiedEmailAddressInput: Equatable {
    /// <p>An email address to be removed from the list of verified addresses.</p>
    public let emailAddress: String?

    public init (
        emailAddress: String? = nil
    )
    {
        self.emailAddress = emailAddress
    }
}

extension DeleteVerifiedEmailAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteVerifiedEmailAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVerifiedEmailAddressOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVerifiedEmailAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVerifiedEmailAddressOutputResponse()"}
}

extension DeleteVerifiedEmailAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVerifiedEmailAddressOutputResponse: Equatable {

    public init() {}
}

struct DeleteVerifiedEmailAddressOutputResponseBody: Equatable {
}

extension DeleteVerifiedEmailAddressOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeliveryOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let tlsPolicy = tlsPolicy {
            try container.encode(tlsPolicy, forKey: Key("TlsPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
    }
}

extension DeliveryOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeliveryOptions(tlsPolicy: \(String(describing: tlsPolicy)))"}
}

/// <p>Specifies whether messages that use the configuration set are required to use
///             Transport Layer Security (TLS).</p>
public struct DeliveryOptions: Equatable {
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    ///             delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    ///             messages can be delivered in plain text if a TLS connection can't be established.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.tlsPolicy = tlsPolicy
    }
}

public struct DescribeActiveReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeActiveReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActiveReceiptRuleSetOutputError>
}

extension DescribeActiveReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActiveReceiptRuleSetInput()"}
}

extension DescribeActiveReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("DescribeActiveReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeActiveReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeActiveReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActiveReceiptRuleSetOutputError>
}

public struct DescribeActiveReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeActiveReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActiveReceiptRuleSetOutputError>
}

/// <p>Represents a request to return the metadata and receipt rules for the receipt rule set
///             that is currently active. You use receipt rule sets to receive email with Amazon SES. For
///             more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DescribeActiveReceiptRuleSetInput: Equatable {

    public init() {}
}

extension DescribeActiveReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeActiveReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActiveReceiptRuleSetOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActiveReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActiveReceiptRuleSetOutputResponse(metadata: \(String(describing: metadata)), rules: \(String(describing: rules)))"}
}

extension DescribeActiveReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeActiveReceiptRuleSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.rules = output.rules
        } else {
            self.metadata = nil
            self.rules = nil
        }
    }
}

/// <p>Represents the metadata and receipt rules for the receipt rule set that is currently
///             active.</p>
public struct DescribeActiveReceiptRuleSetOutputResponse: Equatable {
    /// <p>The metadata for the currently active receipt rule set. The metadata consists of the
    ///             rule set name and a timestamp of when the rule set was created.</p>
    public let metadata: ReceiptRuleSetMetadata?
    /// <p>The receipt rules that belong to the active rule set.</p>
    public let rules: [ReceiptRule]?

    public init (
        metadata: ReceiptRuleSetMetadata? = nil,
        rules: [ReceiptRule]? = nil
    )
    {
        self.metadata = metadata
        self.rules = rules
    }
}

struct DescribeActiveReceiptRuleSetOutputResponseBody: Equatable {
    public let metadata: ReceiptRuleSetMetadata?
    public let rules: [ReceiptRule]?
}

extension DescribeActiveReceiptRuleSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeActiveReceiptRuleSetResult"))
        let metadataDecoded = try containerValues.decodeIfPresent(ReceiptRuleSetMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ReceiptRule].self, forKey: .member)
                var rulesBuffer:[ReceiptRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ReceiptRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct DescribeConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSetInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSetOutputError>
}

extension DescribeConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationSetInput(configurationSetAttributeNames: \(String(describing: configurationSetAttributeNames)), configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DescribeConfigurationSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetAttributeNames = configurationSetAttributeNames {
            var configurationSetAttributeNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ConfigurationSetAttributeNames"))
            for (index0, configurationsetattribute0) in configurationSetAttributeNames.enumerated() {
                try configurationSetAttributeNamesContainer.encode(configurationsetattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        try container.encode("DescribeConfigurationSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSetInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSetOutputError>
}

public struct DescribeConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationSetInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationSetOutputError>
}

/// <p>Represents a request to return the details of a configuration set. Configuration sets
///             enable you to publish email sending events. For information about using configuration
///             sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DescribeConfigurationSetInput: Equatable {
    /// <p>A list of configuration set attributes to return.</p>
    public let configurationSetAttributeNames: [ConfigurationSetAttribute]?
    /// <p>The name of the configuration set to describe.</p>
    public let configurationSetName: String?

    public init (
        configurationSetAttributeNames: [ConfigurationSetAttribute]? = nil,
        configurationSetName: String? = nil
    )
    {
        self.configurationSetAttributeNames = configurationSetAttributeNames
        self.configurationSetName = configurationSetName
    }
}

extension DescribeConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationSetOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationSetOutputResponse(configurationSet: \(String(describing: configurationSet)), deliveryOptions: \(String(describing: deliveryOptions)), eventDestinations: \(String(describing: eventDestinations)), reputationOptions: \(String(describing: reputationOptions)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension DescribeConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSet = output.configurationSet
            self.deliveryOptions = output.deliveryOptions
            self.eventDestinations = output.eventDestinations
            self.reputationOptions = output.reputationOptions
            self.trackingOptions = output.trackingOptions
        } else {
            self.configurationSet = nil
            self.deliveryOptions = nil
            self.eventDestinations = nil
            self.reputationOptions = nil
            self.trackingOptions = nil
        }
    }
}

/// <p>Represents the details of a configuration set. Configuration sets enable you to
///             publish email sending events. For information about using configuration sets, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DescribeConfigurationSetOutputResponse: Equatable {
    /// <p>The configuration set object associated with the specified configuration set.</p>
    public let configurationSet: ConfigurationSet?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS).</p>
    public let deliveryOptions: DeliveryOptions?
    /// <p>A list of event destinations associated with the configuration set. </p>
    public let eventDestinations: [EventDestination]?
    /// <p>An object that represents the reputation settings for the configuration set. </p>
    public let reputationOptions: ReputationOptions?
    /// <p>The name of the custom open and click tracking domain associated with the
    ///             configuration set.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSet: ConfigurationSet? = nil,
        deliveryOptions: DeliveryOptions? = nil,
        eventDestinations: [EventDestination]? = nil,
        reputationOptions: ReputationOptions? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSet = configurationSet
        self.deliveryOptions = deliveryOptions
        self.eventDestinations = eventDestinations
        self.reputationOptions = reputationOptions
        self.trackingOptions = trackingOptions
    }
}

struct DescribeConfigurationSetOutputResponseBody: Equatable {
    public let configurationSet: ConfigurationSet?
    public let eventDestinations: [EventDestination]?
    public let trackingOptions: TrackingOptions?
    public let deliveryOptions: DeliveryOptions?
    public let reputationOptions: ReputationOptions?
}

extension DescribeConfigurationSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSet = "ConfigurationSet"
        case deliveryOptions = "DeliveryOptions"
        case eventDestinations = "EventDestinations"
        case reputationOptions = "ReputationOptions"
        case trackingOptions = "TrackingOptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeConfigurationSetResult"))
        let configurationSetDecoded = try containerValues.decodeIfPresent(ConfigurationSet.self, forKey: .configurationSet)
        configurationSet = configurationSetDecoded
        if containerValues.contains(.eventDestinations) {
            struct KeyVal0{struct member{}}
            let eventDestinationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .eventDestinations)
            if let eventDestinationsWrappedContainer = eventDestinationsWrappedContainer {
                let eventDestinationsContainer = try eventDestinationsWrappedContainer.decodeIfPresent([EventDestination].self, forKey: .member)
                var eventDestinationsBuffer:[EventDestination]? = nil
                if let eventDestinationsContainer = eventDestinationsContainer {
                    eventDestinationsBuffer = [EventDestination]()
                    for structureContainer0 in eventDestinationsContainer {
                        eventDestinationsBuffer?.append(structureContainer0)
                    }
                }
                eventDestinations = eventDestinationsBuffer
            } else {
                eventDestinations = []
            }
        } else {
            eventDestinations = nil
        }
        let trackingOptionsDecoded = try containerValues.decodeIfPresent(TrackingOptions.self, forKey: .trackingOptions)
        trackingOptions = trackingOptionsDecoded
        let deliveryOptionsDecoded = try containerValues.decodeIfPresent(DeliveryOptions.self, forKey: .deliveryOptions)
        deliveryOptions = deliveryOptionsDecoded
        let reputationOptionsDecoded = try containerValues.decodeIfPresent(ReputationOptions.self, forKey: .reputationOptions)
        reputationOptions = reputationOptionsDecoded
    }
}

public struct DescribeReceiptRuleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleOutputError>
}

extension DescribeReceiptRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReceiptRuleInput(ruleName: \(String(describing: ruleName)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension DescribeReceiptRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleName = ruleName {
            try container.encode(ruleName, forKey: Key("RuleName"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("DescribeReceiptRule", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeReceiptRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleOutputError>
}

public struct DescribeReceiptRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleOutputError>
}

/// <p>Represents a request to return the details of a receipt rule. You use receipt rules to
///             receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct DescribeReceiptRuleInput: Equatable {
    /// <p>The name of the receipt rule.</p>
    public let ruleName: String?
    /// <p>The name of the receipt rule set that the receipt rule belongs to.</p>
    public let ruleSetName: String?

    public init (
        ruleName: String? = nil,
        ruleSetName: String? = nil
    )
    {
        self.ruleName = ruleName
        self.ruleSetName = ruleSetName
    }
}

extension DescribeReceiptRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReceiptRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleDoesNotExistException" : self = .ruleDoesNotExistException(try RuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReceiptRuleOutputError: Equatable {
    case ruleDoesNotExistException(RuleDoesNotExistException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReceiptRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReceiptRuleOutputResponse(rule: \(String(describing: rule)))"}
}

extension DescribeReceiptRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReceiptRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

/// <p>Represents the details of a receipt rule.</p>
public struct DescribeReceiptRuleOutputResponse: Equatable {
    /// <p>A data structure that contains the specified receipt rule's name, actions, recipients,
    ///             domains, enabled status, scan status, and Transport Layer Security (TLS) policy.</p>
    public let rule: ReceiptRule?

    public init (
        rule: ReceiptRule? = nil
    )
    {
        self.rule = rule
    }
}

struct DescribeReceiptRuleOutputResponseBody: Equatable {
    public let rule: ReceiptRule?
}

extension DescribeReceiptRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReceiptRuleResult"))
        let ruleDecoded = try containerValues.decodeIfPresent(ReceiptRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct DescribeReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleSetOutputError>
}

extension DescribeReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReceiptRuleSetInput(ruleSetName: \(String(describing: ruleSetName)))"}
}

extension DescribeReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("DescribeReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct DescribeReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleSetOutputError>
}

public struct DescribeReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<DescribeReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReceiptRuleSetOutputError>
}

/// <p>Represents a request to return the details of a receipt rule set. You use receipt rule
///             sets to receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct DescribeReceiptRuleSetInput: Equatable {
    /// <p>The name of the receipt rule set to describe.</p>
    public let ruleSetName: String?

    public init (
        ruleSetName: String? = nil
    )
    {
        self.ruleSetName = ruleSetName
    }
}

extension DescribeReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReceiptRuleSetOutputError: Equatable {
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReceiptRuleSetOutputResponse(metadata: \(String(describing: metadata)), rules: \(String(describing: rules)))"}
}

extension DescribeReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReceiptRuleSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.rules = output.rules
        } else {
            self.metadata = nil
            self.rules = nil
        }
    }
}

/// <p>Represents the details of the specified receipt rule set.</p>
public struct DescribeReceiptRuleSetOutputResponse: Equatable {
    /// <p>The metadata for the receipt rule set, which consists of the rule set name and the
    ///             timestamp of when the rule set was created.</p>
    public let metadata: ReceiptRuleSetMetadata?
    /// <p>A list of the receipt rules that belong to the specified receipt rule set.</p>
    public let rules: [ReceiptRule]?

    public init (
        metadata: ReceiptRuleSetMetadata? = nil,
        rules: [ReceiptRule]? = nil
    )
    {
        self.metadata = metadata
        self.rules = rules
    }
}

struct DescribeReceiptRuleSetOutputResponseBody: Equatable {
    public let metadata: ReceiptRuleSetMetadata?
    public let rules: [ReceiptRule]?
}

extension DescribeReceiptRuleSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeReceiptRuleSetResult"))
        let metadataDecoded = try containerValues.decodeIfPresent(ReceiptRuleSetMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ReceiptRule].self, forKey: .member)
                var rulesBuffer:[ReceiptRule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ReceiptRule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bccAddresses = "BccAddresses"
        case ccAddresses = "CcAddresses"
        case toAddresses = "ToAddresses"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bccAddresses = bccAddresses {
            var bccAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("BccAddresses"))
            for (index0, address0) in bccAddresses.enumerated() {
                try bccAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let ccAddresses = ccAddresses {
            var ccAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("CcAddresses"))
            for (index0, address0) in ccAddresses.enumerated() {
                try ccAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let toAddresses = toAddresses {
            var toAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ToAddresses"))
            for (index0, address0) in toAddresses.enumerated() {
                try toAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.toAddresses) {
            struct KeyVal0{struct member{}}
            let toAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .toAddresses)
            if let toAddressesWrappedContainer = toAddressesWrappedContainer {
                let toAddressesContainer = try toAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var toAddressesBuffer:[String]? = nil
                if let toAddressesContainer = toAddressesContainer {
                    toAddressesBuffer = [String]()
                    for stringContainer0 in toAddressesContainer {
                        toAddressesBuffer?.append(stringContainer0)
                    }
                }
                toAddresses = toAddressesBuffer
            } else {
                toAddresses = []
            }
        } else {
            toAddresses = nil
        }
        if containerValues.contains(.ccAddresses) {
            struct KeyVal0{struct member{}}
            let ccAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ccAddresses)
            if let ccAddressesWrappedContainer = ccAddressesWrappedContainer {
                let ccAddressesContainer = try ccAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var ccAddressesBuffer:[String]? = nil
                if let ccAddressesContainer = ccAddressesContainer {
                    ccAddressesBuffer = [String]()
                    for stringContainer0 in ccAddressesContainer {
                        ccAddressesBuffer?.append(stringContainer0)
                    }
                }
                ccAddresses = ccAddressesBuffer
            } else {
                ccAddresses = []
            }
        } else {
            ccAddresses = nil
        }
        if containerValues.contains(.bccAddresses) {
            struct KeyVal0{struct member{}}
            let bccAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .bccAddresses)
            if let bccAddressesWrappedContainer = bccAddressesWrappedContainer {
                let bccAddressesContainer = try bccAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var bccAddressesBuffer:[String]? = nil
                if let bccAddressesContainer = bccAddressesContainer {
                    bccAddressesBuffer = [String]()
                    for stringContainer0 in bccAddressesContainer {
                        bccAddressesBuffer?.append(stringContainer0)
                    }
                }
                bccAddresses = bccAddressesBuffer
            } else {
                bccAddresses = []
            }
        } else {
            bccAddresses = nil
        }
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(bccAddresses: \(String(describing: bccAddresses)), ccAddresses: \(String(describing: ccAddresses)), toAddresses: \(String(describing: toAddresses)))"}
}

/// <p>Represents the destination of the message, consisting of To:, CC:, and BCC:
///             fields.</p>
///         <note>
///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
///                     <i>local part</i> of a destination email address (the part of the
///                 email address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
///                     characters</a>. If the <i>domain part</i> of an address (the
///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>.</p>
///         </note>
public struct Destination: Equatable {
    /// <p>The recipients to place on the BCC: line of the message.</p>
    public let bccAddresses: [String]?
    /// <p>The recipients to place on the CC: line of the message.</p>
    public let ccAddresses: [String]?
    /// <p>The recipients to place on the To: line of the message.</p>
    public let toAddresses: [String]?

    public init (
        bccAddresses: [String]? = nil,
        ccAddresses: [String]? = nil,
        toAddresses: [String]? = nil
    )
    {
        self.bccAddresses = bccAddresses
        self.ccAddresses = ccAddresses
        self.toAddresses = toAddresses
    }
}

public enum DimensionValueSource {
    case emailHeader
    case linkTag
    case messageTag
    case sdkUnknown(String)
}

extension DimensionValueSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionValueSource] {
        return [
            .emailHeader,
            .linkTag,
            .messageTag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .emailHeader: return "emailHeader"
        case .linkTag: return "linkTag"
        case .messageTag: return "messageTag"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionValueSource(rawValue: rawValue) ?? DimensionValueSource.sdkUnknown(rawValue)
    }
}

public enum DsnAction {
    case delayed
    case delivered
    case expanded
    case failed
    case relayed
    case sdkUnknown(String)
}

extension DsnAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DsnAction] {
        return [
            .delayed,
            .delivered,
            .expanded,
            .failed,
            .relayed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delayed: return "delayed"
        case .delivered: return "delivered"
        case .expanded: return "expanded"
        case .failed: return "failed"
        case .relayed: return "relayed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DsnAction(rawValue: rawValue) ?? DsnAction.sdkUnknown(rawValue)
    }
}

extension EventDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchDestination = "CloudWatchDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case sNSDestination = "SNSDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cloudWatchDestination = cloudWatchDestination {
            try container.encode(cloudWatchDestination, forKey: Key("CloudWatchDestination"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try container.encode(kinesisFirehoseDestination, forKey: Key("KinesisFirehoseDestination"))
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("MatchingEventTypes"))
            for (index0, eventtype0) in matchingEventTypes.enumerated() {
                try matchingEventTypesContainer.encode(eventtype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let sNSDestination = sNSDestination {
            try container.encode(sNSDestination, forKey: Key("SNSDestination"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        if containerValues.contains(.matchingEventTypes) {
            struct KeyVal0{struct member{}}
            let matchingEventTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .matchingEventTypes)
            if let matchingEventTypesWrappedContainer = matchingEventTypesWrappedContainer {
                let matchingEventTypesContainer = try matchingEventTypesWrappedContainer.decodeIfPresent([EventType].self, forKey: .member)
                var matchingEventTypesBuffer:[EventType]? = nil
                if let matchingEventTypesContainer = matchingEventTypesContainer {
                    matchingEventTypesBuffer = [EventType]()
                    for stringContainer0 in matchingEventTypesContainer {
                        matchingEventTypesBuffer?.append(stringContainer0)
                    }
                }
                matchingEventTypes = matchingEventTypesBuffer
            } else {
                matchingEventTypes = []
            }
        } else {
            matchingEventTypes = nil
        }
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let cloudWatchDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchDestination.self, forKey: .cloudWatchDestination)
        cloudWatchDestination = cloudWatchDestinationDecoded
        let sNSDestinationDecoded = try containerValues.decodeIfPresent(SNSDestination.self, forKey: .sNSDestination)
        sNSDestination = sNSDestinationDecoded
    }
}

extension EventDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestination(cloudWatchDestination: \(String(describing: cloudWatchDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), name: \(String(describing: name)), sNSDestination: \(String(describing: sNSDestination)))"}
}

/// <p>Contains information about the event destination that the specified email sending
///             events will be published to.</p>
///         <note>
///             <p>When you create or update an event destination, you must provide one, and only
///                 one, destination. The destination can be Amazon CloudWatch, Amazon Kinesis Firehose or Amazon Simple Notification Service (Amazon SNS).</p>
///         </note>
///         <p>Event destinations are associated with configuration sets, which enable you to publish
///             email sending events to Amazon CloudWatch, Amazon Kinesis Firehose, or Amazon Simple Notification Service (Amazon SNS). For information about
///             using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct EventDestination: Equatable {
    /// <p>An object that contains the names, default values, and sources of the dimensions
    ///             associated with an Amazon CloudWatch event destination.</p>
    public let cloudWatchDestination: CloudWatchDestination?
    /// <p>Sets whether Amazon SES publishes events to this destination when you send an email with
    ///             the associated configuration set. Set to <code>true</code> to enable publishing to this
    ///             destination; set to <code>false</code> to prevent publishing to this destination. The
    ///             default value is <code>false</code>.</p>
    public let enabled: Bool
    /// <p>An object that contains the delivery stream ARN and the IAM role ARN associated with
    ///             an Amazon Kinesis Firehose event destination.</p>
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// <p>The type of email sending events to publish to the event destination.</p>
    public let matchingEventTypes: [EventType]?
    /// <p>The name of the event destination. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>An object that contains the topic ARN associated with an Amazon Simple Notification Service (Amazon SNS) event
    ///             destination.</p>
    public let sNSDestination: SNSDestination?

    public init (
        cloudWatchDestination: CloudWatchDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        name: String? = nil,
        sNSDestination: SNSDestination? = nil
    )
    {
        self.cloudWatchDestination = cloudWatchDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.name = name
        self.sNSDestination = sNSDestination
    }
}

extension EventDestinationAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestinationAlreadyExistsException(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)), message: \(String(describing: message)))"}
}

extension EventDestinationAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EventDestinationAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.eventDestinationName = output.error.eventDestinationName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.eventDestinationName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the event destination could not be created because of a naming
///             conflict.</p>
public struct EventDestinationAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    /// <p>Indicates that the event destination does not exist.</p>
    public var eventDestinationName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.message = message
    }
}

struct EventDestinationAlreadyExistsExceptionBody: Equatable {
    public let configurationSetName: String?
    public let eventDestinationName: String?
    public let message: String?
}

extension EventDestinationAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDestinationDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestinationDoesNotExistException(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)), message: \(String(describing: message)))"}
}

extension EventDestinationDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<EventDestinationDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.eventDestinationName = output.error.eventDestinationName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.eventDestinationName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the event destination does not exist.</p>
public struct EventDestinationDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    /// <p>Indicates that the event destination does not exist.</p>
    public var eventDestinationName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.message = message
    }
}

struct EventDestinationDoesNotExistExceptionBody: Equatable {
    public let configurationSetName: String?
    public let eventDestinationName: String?
    public let message: String?
}

extension EventDestinationDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EventType {
    case bounce
    case click
    case complaint
    case delivery
    case `open`
    case reject
    case renderingFailure
    case send
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .bounce,
            .click,
            .complaint,
            .delivery,
            .open,
            .reject,
            .renderingFailure,
            .send,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bounce: return "bounce"
        case .click: return "click"
        case .complaint: return "complaint"
        case .delivery: return "delivery"
        case .open: return "open"
        case .reject: return "reject"
        case .renderingFailure: return "renderingFailure"
        case .send: return "send"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension ExtensionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExtensionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExtensionField(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Additional X-headers to include in the Delivery Status Notification (DSN) when an
///             email that Amazon SES receives on your behalf bounces.</p>
///         <p>For information about receiving email through Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct ExtensionField: Equatable {
    /// <p>The name of the header to add. Must be between 1 and 50 characters, inclusive, and
    ///             consist of alphanumeric (a-z, A-Z, 0-9) characters and dashes only.</p>
    public let name: String?
    /// <p>The value of the header to add. Must be less than 2048 characters, and must not
    ///             contain newline characters ("\r" or "\n").</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension FromEmailAddressNotVerifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FromEmailAddressNotVerifiedException(fromEmailAddress: \(String(describing: fromEmailAddress)), message: \(String(describing: message)))"}
}

extension FromEmailAddressNotVerifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FromEmailAddressNotVerifiedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.fromEmailAddress = output.error.fromEmailAddress
            self.message = output.error.message
        } else {
            self.fromEmailAddress = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the sender address specified for a custom verification email is not
///             verified, and is therefore not eligible to send the custom verification email. </p>
public struct FromEmailAddressNotVerifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the from email address associated with the custom verification email
    ///             template is not verified.</p>
    public var fromEmailAddress: String?
    public var message: String?

    public init (
        fromEmailAddress: String? = nil,
        message: String? = nil
    )
    {
        self.fromEmailAddress = fromEmailAddress
        self.message = message
    }
}

struct FromEmailAddressNotVerifiedExceptionBody: Equatable {
    public let fromEmailAddress: String?
    public let message: String?
}

extension FromEmailAddressNotVerifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fromEmailAddress = "FromEmailAddress"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAccountSendingEnabledInputBodyMiddleware: Middleware {
    public let id: String = "GetAccountSendingEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<GetAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSendingEnabledOutputError>
}

extension GetAccountSendingEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSendingEnabledInput()"}
}

extension GetAccountSendingEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetAccountSendingEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetAccountSendingEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountSendingEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<GetAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSendingEnabledOutputError>
}

public struct GetAccountSendingEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountSendingEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<GetAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSendingEnabledOutputError>
}

public struct GetAccountSendingEnabledInput: Equatable {

    public init() {}
}

extension GetAccountSendingEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccountSendingEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSendingEnabledOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSendingEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSendingEnabledOutputResponse(enabled: \(String(describing: enabled)))"}
}

extension GetAccountSendingEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountSendingEnabledOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.enabled = output.enabled
        } else {
            self.enabled = false
        }
    }
}

/// <p>Represents a request to return the email sending status for your Amazon SES account in the
///             current AWS Region.</p>
public struct GetAccountSendingEnabledOutputResponse: Equatable {
    /// <p>Describes whether email sending is enabled or disabled for your Amazon SES account in the
    ///             current AWS Region.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

struct GetAccountSendingEnabledOutputResponseBody: Equatable {
    public let enabled: Bool
}

extension GetAccountSendingEnabledOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccountSendingEnabledResult"))
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

public struct GetCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomVerificationEmailTemplateOutputError>
}

extension GetCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomVerificationEmailTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension GetCustomVerificationEmailTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("GetCustomVerificationEmailTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomVerificationEmailTemplateOutputError>
}

public struct GetCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to retrieve an existing custom verification email
///             template.</p>
public struct GetCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The name of the custom verification email template that you want to retrieve.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

extension GetCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomVerificationEmailTemplateDoesNotExistException" : self = .customVerificationEmailTemplateDoesNotExistException(try CustomVerificationEmailTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomVerificationEmailTemplateOutputError: Equatable {
    case customVerificationEmailTemplateDoesNotExistException(CustomVerificationEmailTemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomVerificationEmailTemplateOutputResponse(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension GetCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCustomVerificationEmailTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failureRedirectionURL = output.failureRedirectionURL
            self.fromEmailAddress = output.fromEmailAddress
            self.successRedirectionURL = output.successRedirectionURL
            self.templateContent = output.templateContent
            self.templateName = output.templateName
            self.templateSubject = output.templateSubject
        } else {
            self.failureRedirectionURL = nil
            self.fromEmailAddress = nil
            self.successRedirectionURL = nil
            self.templateContent = nil
            self.templateName = nil
            self.templateSubject = nil
        }
    }
}

/// <p>The content of the custom verification email template.</p>
public struct GetCustomVerificationEmailTemplateOutputResponse: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

struct GetCustomVerificationEmailTemplateOutputResponseBody: Equatable {
    public let templateName: String?
    public let fromEmailAddress: String?
    public let templateSubject: String?
    public let templateContent: String?
    public let successRedirectionURL: String?
    public let failureRedirectionURL: String?
}

extension GetCustomVerificationEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failureRedirectionURL = "FailureRedirectionURL"
        case fromEmailAddress = "FromEmailAddress"
        case successRedirectionURL = "SuccessRedirectionURL"
        case templateContent = "TemplateContent"
        case templateName = "TemplateName"
        case templateSubject = "TemplateSubject"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetCustomVerificationEmailTemplateResult"))
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let fromEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromEmailAddress)
        fromEmailAddress = fromEmailAddressDecoded
        let templateSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateSubject)
        templateSubject = templateSubjectDecoded
        let templateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateContent)
        templateContent = templateContentDecoded
        let successRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .successRedirectionURL)
        successRedirectionURL = successRedirectionURLDecoded
        let failureRedirectionURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureRedirectionURL)
        failureRedirectionURL = failureRedirectionURLDecoded
    }
}

public struct GetIdentityDkimAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityDkimAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityDkimAttributesOutputError>
}

extension GetIdentityDkimAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityDkimAttributesInput(identities: \(String(describing: identities)))"}
}

extension GetIdentityDkimAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identities = identities {
            var identitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Identities"))
            for (index0, identity0) in identities.enumerated() {
                try identitiesContainer.encode(identity0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetIdentityDkimAttributes", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetIdentityDkimAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityDkimAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityDkimAttributesOutputError>
}

public struct GetIdentityDkimAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityDkimAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityDkimAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityDkimAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityDkimAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityDkimAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityDkimAttributesOutputError>
}

/// <p>Represents a request for the status of Amazon SES Easy DKIM signing for an identity. For
///             domain identities, this request also returns the DKIM tokens that are required for Easy
///             DKIM signing, and whether Amazon SES successfully verified that these tokens were published.
///             For more information about Easy DKIM, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer Guide</a>.</p>
public struct GetIdentityDkimAttributesInput: Equatable {
    /// <p>A list of one or more verified identities - email addresses, domains, or both.</p>
    public let identities: [String]?

    public init (
        identities: [String]? = nil
    )
    {
        self.identities = identities
    }
}

extension GetIdentityDkimAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetIdentityDkimAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityDkimAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityDkimAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityDkimAttributesOutputResponse(dkimAttributes: \(String(describing: dkimAttributes)))"}
}

extension GetIdentityDkimAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityDkimAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimAttributes = output.dkimAttributes
        } else {
            self.dkimAttributes = nil
        }
    }
}

/// <p>Represents the status of Amazon SES Easy DKIM signing for an identity. For domain
///             identities, this response also contains the DKIM tokens that are required for Easy DKIM
///             signing, and whether Amazon SES successfully verified that these tokens were
///             published.</p>
public struct GetIdentityDkimAttributesOutputResponse: Equatable {
    /// <p>The DKIM attributes for an email address or a domain.</p>
    public let dkimAttributes: [String:IdentityDkimAttributes]?

    public init (
        dkimAttributes: [String:IdentityDkimAttributes]? = nil
    )
    {
        self.dkimAttributes = dkimAttributes
    }
}

struct GetIdentityDkimAttributesOutputResponseBody: Equatable {
    public let dkimAttributes: [String:IdentityDkimAttributes]?
}

extension GetIdentityDkimAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimAttributes = "DkimAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetIdentityDkimAttributesResult"))
        if containerValues.contains(.dkimAttributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let dkimAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, IdentityDkimAttributes, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .dkimAttributes)
            if let dkimAttributesWrappedContainer = dkimAttributesWrappedContainer {
                let dkimAttributesContainer = try dkimAttributesWrappedContainer.decodeIfPresent([MapKeyValue<String, IdentityDkimAttributes, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var dkimAttributesBuffer: [String:IdentityDkimAttributes]? = nil
                if let dkimAttributesContainer = dkimAttributesContainer {
                    dkimAttributesBuffer = [String:IdentityDkimAttributes]()
                    for structureContainer0 in dkimAttributesContainer {
                        dkimAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                dkimAttributes = dkimAttributesBuffer
            } else {
                dkimAttributes = [:]
            }
        } else {
            dkimAttributes = nil
        }
    }
}

public struct GetIdentityMailFromDomainAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityMailFromDomainAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityMailFromDomainAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityMailFromDomainAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityMailFromDomainAttributesOutputError>
}

extension GetIdentityMailFromDomainAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityMailFromDomainAttributesInput(identities: \(String(describing: identities)))"}
}

extension GetIdentityMailFromDomainAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identities = identities {
            var identitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Identities"))
            for (index0, identity0) in identities.enumerated() {
                try identitiesContainer.encode(identity0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetIdentityMailFromDomainAttributes", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetIdentityMailFromDomainAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityMailFromDomainAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityMailFromDomainAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityMailFromDomainAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityMailFromDomainAttributesOutputError>
}

public struct GetIdentityMailFromDomainAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityMailFromDomainAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityMailFromDomainAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityMailFromDomainAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityMailFromDomainAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityMailFromDomainAttributesOutputError>
}

/// <p>Represents a request to return the Amazon SES custom MAIL FROM attributes for a list of
///             identities. For information about using a custom MAIL FROM domain, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct GetIdentityMailFromDomainAttributesInput: Equatable {
    /// <p>A list of one or more identities.</p>
    public let identities: [String]?

    public init (
        identities: [String]? = nil
    )
    {
        self.identities = identities
    }
}

extension GetIdentityMailFromDomainAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetIdentityMailFromDomainAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityMailFromDomainAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityMailFromDomainAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityMailFromDomainAttributesOutputResponse(mailFromDomainAttributes: \(String(describing: mailFromDomainAttributes)))"}
}

extension GetIdentityMailFromDomainAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityMailFromDomainAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mailFromDomainAttributes = output.mailFromDomainAttributes
        } else {
            self.mailFromDomainAttributes = nil
        }
    }
}

/// <p>Represents the custom MAIL FROM attributes for a list of identities.</p>
public struct GetIdentityMailFromDomainAttributesOutputResponse: Equatable {
    /// <p>A map of identities to custom MAIL FROM attributes.</p>
    public let mailFromDomainAttributes: [String:IdentityMailFromDomainAttributes]?

    public init (
        mailFromDomainAttributes: [String:IdentityMailFromDomainAttributes]? = nil
    )
    {
        self.mailFromDomainAttributes = mailFromDomainAttributes
    }
}

struct GetIdentityMailFromDomainAttributesOutputResponseBody: Equatable {
    public let mailFromDomainAttributes: [String:IdentityMailFromDomainAttributes]?
}

extension GetIdentityMailFromDomainAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mailFromDomainAttributes = "MailFromDomainAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetIdentityMailFromDomainAttributesResult"))
        if containerValues.contains(.mailFromDomainAttributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let mailFromDomainAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, IdentityMailFromDomainAttributes, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .mailFromDomainAttributes)
            if let mailFromDomainAttributesWrappedContainer = mailFromDomainAttributesWrappedContainer {
                let mailFromDomainAttributesContainer = try mailFromDomainAttributesWrappedContainer.decodeIfPresent([MapKeyValue<String, IdentityMailFromDomainAttributes, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var mailFromDomainAttributesBuffer: [String:IdentityMailFromDomainAttributes]? = nil
                if let mailFromDomainAttributesContainer = mailFromDomainAttributesContainer {
                    mailFromDomainAttributesBuffer = [String:IdentityMailFromDomainAttributes]()
                    for structureContainer0 in mailFromDomainAttributesContainer {
                        mailFromDomainAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                mailFromDomainAttributes = mailFromDomainAttributesBuffer
            } else {
                mailFromDomainAttributes = [:]
            }
        } else {
            mailFromDomainAttributes = nil
        }
    }
}

public struct GetIdentityNotificationAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityNotificationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityNotificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityNotificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityNotificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityNotificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityNotificationAttributesOutputError>
}

extension GetIdentityNotificationAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityNotificationAttributesInput(identities: \(String(describing: identities)))"}
}

extension GetIdentityNotificationAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identities = identities {
            var identitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Identities"))
            for (index0, identity0) in identities.enumerated() {
                try identitiesContainer.encode(identity0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetIdentityNotificationAttributes", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetIdentityNotificationAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityNotificationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityNotificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityNotificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityNotificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityNotificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityNotificationAttributesOutputError>
}

public struct GetIdentityNotificationAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityNotificationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityNotificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityNotificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityNotificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityNotificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityNotificationAttributesOutputError>
}

/// <p>Represents a request to return the notification attributes for a list of identities
///             you verified with Amazon SES. For information about Amazon SES notifications, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct GetIdentityNotificationAttributesInput: Equatable {
    /// <p>A list of one or more identities. You can specify an identity by using its name or by
    ///             using its Amazon Resource Name (ARN). Examples: <code>user@example.com</code>,
    ///                 <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    public let identities: [String]?

    public init (
        identities: [String]? = nil
    )
    {
        self.identities = identities
    }
}

extension GetIdentityNotificationAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetIdentityNotificationAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityNotificationAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityNotificationAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityNotificationAttributesOutputResponse(notificationAttributes: \(String(describing: notificationAttributes)))"}
}

extension GetIdentityNotificationAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityNotificationAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.notificationAttributes = output.notificationAttributes
        } else {
            self.notificationAttributes = nil
        }
    }
}

/// <p>Represents the notification attributes for a list of identities.</p>
public struct GetIdentityNotificationAttributesOutputResponse: Equatable {
    /// <p>A map of Identity to IdentityNotificationAttributes.</p>
    public let notificationAttributes: [String:IdentityNotificationAttributes]?

    public init (
        notificationAttributes: [String:IdentityNotificationAttributes]? = nil
    )
    {
        self.notificationAttributes = notificationAttributes
    }
}

struct GetIdentityNotificationAttributesOutputResponseBody: Equatable {
    public let notificationAttributes: [String:IdentityNotificationAttributes]?
}

extension GetIdentityNotificationAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationAttributes = "NotificationAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetIdentityNotificationAttributesResult"))
        if containerValues.contains(.notificationAttributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let notificationAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, IdentityNotificationAttributes, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .notificationAttributes)
            if let notificationAttributesWrappedContainer = notificationAttributesWrappedContainer {
                let notificationAttributesContainer = try notificationAttributesWrappedContainer.decodeIfPresent([MapKeyValue<String, IdentityNotificationAttributes, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var notificationAttributesBuffer: [String:IdentityNotificationAttributes]? = nil
                if let notificationAttributesContainer = notificationAttributesContainer {
                    notificationAttributesBuffer = [String:IdentityNotificationAttributes]()
                    for structureContainer0 in notificationAttributesContainer {
                        notificationAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                notificationAttributes = notificationAttributesBuffer
            } else {
                notificationAttributes = [:]
            }
        } else {
            notificationAttributes = nil
        }
    }
}

public struct GetIdentityPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoliciesOutputError>
}

extension GetIdentityPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoliciesInput(identity: \(String(describing: identity)), policyNames: \(String(describing: policyNames)))"}
}

extension GetIdentityPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let policyNames = policyNames {
            var policyNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyNames"))
            for (index0, policyname0) in policyNames.enumerated() {
                try policyNamesContainer.encode(policyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetIdentityPolicies", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetIdentityPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoliciesOutputError>
}

public struct GetIdentityPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoliciesOutputError>
}

/// <p>Represents a request to return the requested sending authorization policies for an
///             identity. Sending authorization is an Amazon SES feature that enables you to authorize other
///             senders to use your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct GetIdentityPoliciesInput: Equatable {
    /// <p>The identity for which the policies will be retrieved. You can specify an identity by
    ///             using its name or by using its Amazon Resource Name (ARN). Examples:
    ///                 <code>user@example.com</code>, <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    ///         <p>To successfully call this API, you must own the identity.</p>
    public let identity: String?
    /// <p>A list of the names of policies to be retrieved. You can retrieve a maximum of 20
    ///             policies at a time. If you do not know the names of the policies that are attached to
    ///             the identity, you can use <code>ListIdentityPolicies</code>.</p>
    public let policyNames: [String]?

    public init (
        identity: String? = nil,
        policyNames: [String]? = nil
    )
    {
        self.identity = identity
        self.policyNames = policyNames
    }
}

extension GetIdentityPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetIdentityPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoliciesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoliciesOutputResponse(policies: \(String(describing: policies)))"}
}

extension GetIdentityPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policies = output.policies
        } else {
            self.policies = nil
        }
    }
}

/// <p>Represents the requested sending authorization policies.</p>
public struct GetIdentityPoliciesOutputResponse: Equatable {
    /// <p>A map of policy names to policies.</p>
    public let policies: [String:String]?

    public init (
        policies: [String:String]? = nil
    )
    {
        self.policies = policies
    }
}

struct GetIdentityPoliciesOutputResponseBody: Equatable {
    public let policies: [String:String]?
}

extension GetIdentityPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policies = "Policies"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetIdentityPoliciesResult"))
        if containerValues.contains(.policies) {
            struct KeyVal0{struct key{}; struct value{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var policiesBuffer: [String:String]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [String:String]()
                    for stringContainer0 in policiesContainer {
                        policiesBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                policies = policiesBuffer
            } else {
                policies = [:]
            }
        } else {
            policies = nil
        }
    }
}

public struct GetIdentityVerificationAttributesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityVerificationAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityVerificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityVerificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityVerificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityVerificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityVerificationAttributesOutputError>
}

extension GetIdentityVerificationAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityVerificationAttributesInput(identities: \(String(describing: identities)))"}
}

extension GetIdentityVerificationAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identities = identities {
            var identitiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Identities"))
            for (index0, identity0) in identities.enumerated() {
                try identitiesContainer.encode(identity0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetIdentityVerificationAttributes", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetIdentityVerificationAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityVerificationAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityVerificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityVerificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityVerificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityVerificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityVerificationAttributesOutputError>
}

public struct GetIdentityVerificationAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityVerificationAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityVerificationAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityVerificationAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityVerificationAttributesInput>
    public typealias MOutput = OperationOutput<GetIdentityVerificationAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityVerificationAttributesOutputError>
}

/// <p>Represents a request to return the Amazon SES verification status of a list of identities.
///             For domain identities, this request also returns the verification token. For information
///             about verifying identities with Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct GetIdentityVerificationAttributesInput: Equatable {
    /// <p>A list of identities.</p>
    public let identities: [String]?

    public init (
        identities: [String]? = nil
    )
    {
        self.identities = identities
    }
}

extension GetIdentityVerificationAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetIdentityVerificationAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityVerificationAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityVerificationAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityVerificationAttributesOutputResponse(verificationAttributes: \(String(describing: verificationAttributes)))"}
}

extension GetIdentityVerificationAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityVerificationAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.verificationAttributes = output.verificationAttributes
        } else {
            self.verificationAttributes = nil
        }
    }
}

/// <p>The Amazon SES verification status of a list of identities. For domain identities, this
///             response also contains the verification token.</p>
public struct GetIdentityVerificationAttributesOutputResponse: Equatable {
    /// <p>A map of Identities to IdentityVerificationAttributes objects.</p>
    public let verificationAttributes: [String:IdentityVerificationAttributes]?

    public init (
        verificationAttributes: [String:IdentityVerificationAttributes]? = nil
    )
    {
        self.verificationAttributes = verificationAttributes
    }
}

struct GetIdentityVerificationAttributesOutputResponseBody: Equatable {
    public let verificationAttributes: [String:IdentityVerificationAttributes]?
}

extension GetIdentityVerificationAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case verificationAttributes = "VerificationAttributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetIdentityVerificationAttributesResult"))
        if containerValues.contains(.verificationAttributes) {
            struct KeyVal0{struct key{}; struct value{}}
            let verificationAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, IdentityVerificationAttributes, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .verificationAttributes)
            if let verificationAttributesWrappedContainer = verificationAttributesWrappedContainer {
                let verificationAttributesContainer = try verificationAttributesWrappedContainer.decodeIfPresent([MapKeyValue<String, IdentityVerificationAttributes, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var verificationAttributesBuffer: [String:IdentityVerificationAttributes]? = nil
                if let verificationAttributesContainer = verificationAttributesContainer {
                    verificationAttributesBuffer = [String:IdentityVerificationAttributes]()
                    for structureContainer0 in verificationAttributesContainer {
                        verificationAttributesBuffer?[structureContainer0.key] = structureContainer0.value
                    }
                }
                verificationAttributes = verificationAttributesBuffer
            } else {
                verificationAttributes = [:]
            }
        } else {
            verificationAttributes = nil
        }
    }
}

public struct GetSendQuotaInputBodyMiddleware: Middleware {
    public let id: String = "GetSendQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendQuotaInput>
    public typealias MOutput = OperationOutput<GetSendQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendQuotaOutputError>
}

extension GetSendQuotaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSendQuotaInput()"}
}

extension GetSendQuotaInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetSendQuota", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetSendQuotaInputHeadersMiddleware: Middleware {
    public let id: String = "GetSendQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendQuotaInput>
    public typealias MOutput = OperationOutput<GetSendQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendQuotaOutputError>
}

public struct GetSendQuotaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSendQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendQuotaInput>
    public typealias MOutput = OperationOutput<GetSendQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendQuotaOutputError>
}

public struct GetSendQuotaInput: Equatable {

    public init() {}
}

extension GetSendQuotaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSendQuotaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSendQuotaOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSendQuotaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSendQuotaOutputResponse(max24HourSend: \(String(describing: max24HourSend)), maxSendRate: \(String(describing: maxSendRate)), sentLast24Hours: \(String(describing: sentLast24Hours)))"}
}

extension GetSendQuotaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSendQuotaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.max24HourSend = output.max24HourSend
            self.maxSendRate = output.maxSendRate
            self.sentLast24Hours = output.sentLast24Hours
        } else {
            self.max24HourSend = 0.0
            self.maxSendRate = 0.0
            self.sentLast24Hours = 0.0
        }
    }
}

/// <p>Represents your Amazon SES daily sending quota, maximum send rate, and the number of emails
///             you have sent in the last 24 hours.</p>
public struct GetSendQuotaOutputResponse: Equatable {
    /// <p>The maximum number of emails the user is allowed to send in a 24-hour interval. A
    ///             value of -1 signifies an unlimited quota.</p>
    public let max24HourSend: Double
    /// <p>The maximum number of emails that Amazon SES can accept from the user's account per
    ///             second.</p>
    ///         <note>
    ///             <p>The rate at which Amazon SES accepts the user's messages might be less than the maximum
    ///                 send rate.</p>
    ///         </note>
    public let maxSendRate: Double
    /// <p>The number of emails sent during the previous 24 hours.</p>
    public let sentLast24Hours: Double

    public init (
        max24HourSend: Double = 0.0,
        maxSendRate: Double = 0.0,
        sentLast24Hours: Double = 0.0
    )
    {
        self.max24HourSend = max24HourSend
        self.maxSendRate = maxSendRate
        self.sentLast24Hours = sentLast24Hours
    }
}

struct GetSendQuotaOutputResponseBody: Equatable {
    public let max24HourSend: Double
    public let maxSendRate: Double
    public let sentLast24Hours: Double
}

extension GetSendQuotaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case max24HourSend = "Max24HourSend"
        case maxSendRate = "MaxSendRate"
        case sentLast24Hours = "SentLast24Hours"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSendQuotaResult"))
        let max24HourSendDecoded = try containerValues.decode(Double.self, forKey: .max24HourSend)
        max24HourSend = max24HourSendDecoded
        let maxSendRateDecoded = try containerValues.decode(Double.self, forKey: .maxSendRate)
        maxSendRate = maxSendRateDecoded
        let sentLast24HoursDecoded = try containerValues.decode(Double.self, forKey: .sentLast24Hours)
        sentLast24Hours = sentLast24HoursDecoded
    }
}

public struct GetSendStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetSendStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendStatisticsInput>
    public typealias MOutput = OperationOutput<GetSendStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendStatisticsOutputError>
}

extension GetSendStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSendStatisticsInput()"}
}

extension GetSendStatisticsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetSendStatistics", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetSendStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSendStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendStatisticsInput>
    public typealias MOutput = OperationOutput<GetSendStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendStatisticsOutputError>
}

public struct GetSendStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSendStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSendStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSendStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSendStatisticsInput>
    public typealias MOutput = OperationOutput<GetSendStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSendStatisticsOutputError>
}

public struct GetSendStatisticsInput: Equatable {

    public init() {}
}

extension GetSendStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSendStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSendStatisticsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSendStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSendStatisticsOutputResponse(sendDataPoints: \(String(describing: sendDataPoints)))"}
}

extension GetSendStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSendStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sendDataPoints = output.sendDataPoints
        } else {
            self.sendDataPoints = nil
        }
    }
}

/// <p>Represents a list of data points. This list contains aggregated data from the previous
///             two weeks of your sending activity with Amazon SES.</p>
public struct GetSendStatisticsOutputResponse: Equatable {
    /// <p>A list of data points, each of which represents 15 minutes of activity.</p>
    public let sendDataPoints: [SendDataPoint]?

    public init (
        sendDataPoints: [SendDataPoint]? = nil
    )
    {
        self.sendDataPoints = sendDataPoints
    }
}

struct GetSendStatisticsOutputResponseBody: Equatable {
    public let sendDataPoints: [SendDataPoint]?
}

extension GetSendStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendDataPoints = "SendDataPoints"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSendStatisticsResult"))
        if containerValues.contains(.sendDataPoints) {
            struct KeyVal0{struct member{}}
            let sendDataPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sendDataPoints)
            if let sendDataPointsWrappedContainer = sendDataPointsWrappedContainer {
                let sendDataPointsContainer = try sendDataPointsWrappedContainer.decodeIfPresent([SendDataPoint].self, forKey: .member)
                var sendDataPointsBuffer:[SendDataPoint]? = nil
                if let sendDataPointsContainer = sendDataPointsContainer {
                    sendDataPointsBuffer = [SendDataPoint]()
                    for structureContainer0 in sendDataPointsContainer {
                        sendDataPointsBuffer?.append(structureContainer0)
                    }
                }
                sendDataPoints = sendDataPointsBuffer
            } else {
                sendDataPoints = []
            }
        } else {
            sendDataPoints = nil
        }
    }
}

public struct GetTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

extension GetTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateInput(templateName: \(String(describing: templateName)))"}
}

extension GetTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("GetTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct GetTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

public struct GetTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTemplateInput>
    public typealias MOutput = OperationOutput<GetTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTemplateOutputError>
}

public struct GetTemplateInput: Equatable {
    /// <p>The name of the template you want to retrieve.</p>
    public let templateName: String?

    public init (
        templateName: String? = nil
    )
    {
        self.templateName = templateName
    }
}

extension GetTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TemplateDoesNotExistException" : self = .templateDoesNotExistException(try TemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTemplateOutputError: Equatable {
    case templateDoesNotExistException(TemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTemplateOutputResponse(template: \(String(describing: template)))"}
}

extension GetTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.template = output.template
        } else {
            self.template = nil
        }
    }
}

public struct GetTemplateOutputResponse: Equatable {
    /// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
    ///             part.</p>
    public let template: Template?

    public init (
        template: Template? = nil
    )
    {
        self.template = template
    }
}

struct GetTemplateOutputResponseBody: Equatable {
    public let template: Template?
}

extension GetTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case template = "Template"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetTemplateResult"))
        let templateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .template)
        template = templateDecoded
    }
}

extension IdentityDkimAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dkimEnabled = "DkimEnabled"
        case dkimTokens = "DkimTokens"
        case dkimVerificationStatus = "DkimVerificationStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if dkimEnabled != false {
            try container.encode(dkimEnabled, forKey: Key("DkimEnabled"))
        }
        if let dkimTokens = dkimTokens {
            var dkimTokensContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DkimTokens"))
            for (index0, verificationtoken0) in dkimTokens.enumerated() {
                try dkimTokensContainer.encode(verificationtoken0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dkimVerificationStatus = dkimVerificationStatus {
            try container.encode(dkimVerificationStatus, forKey: Key("DkimVerificationStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dkimEnabledDecoded = try containerValues.decode(Bool.self, forKey: .dkimEnabled)
        dkimEnabled = dkimEnabledDecoded
        let dkimVerificationStatusDecoded = try containerValues.decodeIfPresent(VerificationStatus.self, forKey: .dkimVerificationStatus)
        dkimVerificationStatus = dkimVerificationStatusDecoded
        if containerValues.contains(.dkimTokens) {
            struct KeyVal0{struct member{}}
            let dkimTokensWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dkimTokens)
            if let dkimTokensWrappedContainer = dkimTokensWrappedContainer {
                let dkimTokensContainer = try dkimTokensWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var dkimTokensBuffer:[String]? = nil
                if let dkimTokensContainer = dkimTokensContainer {
                    dkimTokensBuffer = [String]()
                    for stringContainer0 in dkimTokensContainer {
                        dkimTokensBuffer?.append(stringContainer0)
                    }
                }
                dkimTokens = dkimTokensBuffer
            } else {
                dkimTokens = []
            }
        } else {
            dkimTokens = nil
        }
    }
}

extension IdentityDkimAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityDkimAttributes(dkimEnabled: \(String(describing: dkimEnabled)), dkimTokens: \(String(describing: dkimTokens)), dkimVerificationStatus: \(String(describing: dkimVerificationStatus)))"}
}

/// <p>Represents the DKIM attributes of a verified email address or a domain.</p>
public struct IdentityDkimAttributes: Equatable {
    /// <p>Is true if DKIM signing is enabled for email sent from the identity. It's false
    ///             otherwise. The default value is true.</p>
    public let dkimEnabled: Bool
    /// <p>A set of character strings that represent the domain's identity. Using these tokens,
    ///             you need to create DNS CNAME records that point to DKIM public keys that are hosted by
    ///             Amazon SES. Amazon Web Services eventually detects that you've updated your DNS records. This detection
    ///             process might take up to 72 hours. After successful detection, Amazon SES is able to
    ///             DKIM-sign email originating from that domain. (This only applies to domain identities,
    ///             not email address identities.)</p>
    ///         <p>For more information about creating DNS records using DKIM tokens, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let dkimTokens: [String]?
    /// <p>Describes whether Amazon SES has successfully verified the DKIM DNS records (tokens)
    ///             published in the domain name's DNS. (This only applies to domain identities, not email
    ///             address identities.)</p>
    public let dkimVerificationStatus: VerificationStatus?

    public init (
        dkimEnabled: Bool = false,
        dkimTokens: [String]? = nil,
        dkimVerificationStatus: VerificationStatus? = nil
    )
    {
        self.dkimEnabled = dkimEnabled
        self.dkimTokens = dkimTokens
        self.dkimVerificationStatus = dkimVerificationStatus
    }
}

extension IdentityMailFromDomainAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behaviorOnMXFailure = "BehaviorOnMXFailure"
        case mailFromDomain = "MailFromDomain"
        case mailFromDomainStatus = "MailFromDomainStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let behaviorOnMXFailure = behaviorOnMXFailure {
            try container.encode(behaviorOnMXFailure, forKey: Key("BehaviorOnMXFailure"))
        }
        if let mailFromDomain = mailFromDomain {
            try container.encode(mailFromDomain, forKey: Key("MailFromDomain"))
        }
        if let mailFromDomainStatus = mailFromDomainStatus {
            try container.encode(mailFromDomainStatus, forKey: Key("MailFromDomainStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailFromDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mailFromDomain)
        mailFromDomain = mailFromDomainDecoded
        let mailFromDomainStatusDecoded = try containerValues.decodeIfPresent(CustomMailFromStatus.self, forKey: .mailFromDomainStatus)
        mailFromDomainStatus = mailFromDomainStatusDecoded
        let behaviorOnMXFailureDecoded = try containerValues.decodeIfPresent(BehaviorOnMXFailure.self, forKey: .behaviorOnMXFailure)
        behaviorOnMXFailure = behaviorOnMXFailureDecoded
    }
}

extension IdentityMailFromDomainAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityMailFromDomainAttributes(behaviorOnMXFailure: \(String(describing: behaviorOnMXFailure)), mailFromDomain: \(String(describing: mailFromDomain)), mailFromDomainStatus: \(String(describing: mailFromDomainStatus)))"}
}

/// <p>Represents the custom MAIL FROM domain attributes of a verified identity (email
///             address or domain).</p>
public struct IdentityMailFromDomainAttributes: Equatable {
    /// <p>The action that Amazon SES takes if it cannot successfully read the required MX record when
    ///             you send an email. A value of <code>UseDefaultValue</code> indicates that if Amazon SES
    ///             cannot read the required MX record, it uses amazonses.com (or a subdomain of that) as
    ///             the MAIL FROM domain. A value of <code>RejectMessage</code> indicates that if Amazon SES
    ///             cannot read the required MX record, Amazon SES returns a
    ///                 <code>MailFromDomainNotVerified</code> error and does not send the email.</p>
    ///         <p>The custom MAIL FROM setup states that result in this behavior are
    ///                 <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>.</p>
    public let behaviorOnMXFailure: BehaviorOnMXFailure?
    /// <p>The custom MAIL FROM domain that the identity is configured to use.</p>
    public let mailFromDomain: String?
    /// <p>The state that indicates whether Amazon SES has successfully read the MX record required
    ///             for custom MAIL FROM domain setup. If the state is <code>Success</code>, Amazon SES uses the
    ///             specified custom MAIL FROM domain when the verified identity sends an email. All other
    ///             states indicate that Amazon SES takes the action described by
    ///                 <code>BehaviorOnMXFailure</code>.</p>
    public let mailFromDomainStatus: CustomMailFromStatus?

    public init (
        behaviorOnMXFailure: BehaviorOnMXFailure? = nil,
        mailFromDomain: String? = nil,
        mailFromDomainStatus: CustomMailFromStatus? = nil
    )
    {
        self.behaviorOnMXFailure = behaviorOnMXFailure
        self.mailFromDomain = mailFromDomain
        self.mailFromDomainStatus = mailFromDomainStatus
    }
}

extension IdentityNotificationAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bounceTopic = "BounceTopic"
        case complaintTopic = "ComplaintTopic"
        case deliveryTopic = "DeliveryTopic"
        case forwardingEnabled = "ForwardingEnabled"
        case headersInBounceNotificationsEnabled = "HeadersInBounceNotificationsEnabled"
        case headersInComplaintNotificationsEnabled = "HeadersInComplaintNotificationsEnabled"
        case headersInDeliveryNotificationsEnabled = "HeadersInDeliveryNotificationsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bounceTopic = bounceTopic {
            try container.encode(bounceTopic, forKey: Key("BounceTopic"))
        }
        if let complaintTopic = complaintTopic {
            try container.encode(complaintTopic, forKey: Key("ComplaintTopic"))
        }
        if let deliveryTopic = deliveryTopic {
            try container.encode(deliveryTopic, forKey: Key("DeliveryTopic"))
        }
        if forwardingEnabled != false {
            try container.encode(forwardingEnabled, forKey: Key("ForwardingEnabled"))
        }
        if headersInBounceNotificationsEnabled != false {
            try container.encode(headersInBounceNotificationsEnabled, forKey: Key("HeadersInBounceNotificationsEnabled"))
        }
        if headersInComplaintNotificationsEnabled != false {
            try container.encode(headersInComplaintNotificationsEnabled, forKey: Key("HeadersInComplaintNotificationsEnabled"))
        }
        if headersInDeliveryNotificationsEnabled != false {
            try container.encode(headersInDeliveryNotificationsEnabled, forKey: Key("HeadersInDeliveryNotificationsEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bounceTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bounceTopic)
        bounceTopic = bounceTopicDecoded
        let complaintTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complaintTopic)
        complaintTopic = complaintTopicDecoded
        let deliveryTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryTopic)
        deliveryTopic = deliveryTopicDecoded
        let forwardingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .forwardingEnabled)
        forwardingEnabled = forwardingEnabledDecoded
        let headersInBounceNotificationsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .headersInBounceNotificationsEnabled)
        headersInBounceNotificationsEnabled = headersInBounceNotificationsEnabledDecoded
        let headersInComplaintNotificationsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .headersInComplaintNotificationsEnabled)
        headersInComplaintNotificationsEnabled = headersInComplaintNotificationsEnabledDecoded
        let headersInDeliveryNotificationsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .headersInDeliveryNotificationsEnabled)
        headersInDeliveryNotificationsEnabled = headersInDeliveryNotificationsEnabledDecoded
    }
}

extension IdentityNotificationAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityNotificationAttributes(bounceTopic: \(String(describing: bounceTopic)), complaintTopic: \(String(describing: complaintTopic)), deliveryTopic: \(String(describing: deliveryTopic)), forwardingEnabled: \(String(describing: forwardingEnabled)), headersInBounceNotificationsEnabled: \(String(describing: headersInBounceNotificationsEnabled)), headersInComplaintNotificationsEnabled: \(String(describing: headersInComplaintNotificationsEnabled)), headersInDeliveryNotificationsEnabled: \(String(describing: headersInDeliveryNotificationsEnabled)))"}
}

/// <p>Represents the notification attributes of an identity, including whether an identity
///             has Amazon Simple Notification Service (Amazon SNS) topics set for bounce, complaint, and/or delivery notifications,
///             and whether feedback forwarding is enabled for bounce and complaint
///             notifications.</p>
public struct IdentityNotificationAttributes: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic where Amazon SES will publish bounce
    ///             notifications.</p>
    public let bounceTopic: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic where Amazon SES will publish complaint
    ///             notifications.</p>
    public let complaintTopic: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic where Amazon SES will publish delivery
    ///             notifications.</p>
    public let deliveryTopic: String?
    /// <p>Describes whether Amazon SES will forward bounce and complaint notifications as email.
    ///                 <code>true</code> indicates that Amazon SES will forward bounce and complaint
    ///             notifications as email, while <code>false</code> indicates that bounce and complaint
    ///             notifications will be published only to the specified bounce and complaint Amazon SNS
    ///             topics.</p>
    public let forwardingEnabled: Bool
    /// <p>Describes whether Amazon SES includes the original email headers in Amazon SNS notifications of
    ///             type <code>Bounce</code>. A value of <code>true</code> specifies that Amazon SES will include
    ///             headers in bounce notifications, and a value of <code>false</code> specifies that Amazon SES
    ///             will not include headers in bounce notifications.</p>
    public let headersInBounceNotificationsEnabled: Bool
    /// <p>Describes whether Amazon SES includes the original email headers in Amazon SNS notifications of
    ///             type <code>Complaint</code>. A value of <code>true</code> specifies that Amazon SES will
    ///             include headers in complaint notifications, and a value of <code>false</code> specifies
    ///             that Amazon SES will not include headers in complaint notifications.</p>
    public let headersInComplaintNotificationsEnabled: Bool
    /// <p>Describes whether Amazon SES includes the original email headers in Amazon SNS notifications of
    ///             type <code>Delivery</code>. A value of <code>true</code> specifies that Amazon SES will
    ///             include headers in delivery notifications, and a value of <code>false</code> specifies
    ///             that Amazon SES will not include headers in delivery notifications.</p>
    public let headersInDeliveryNotificationsEnabled: Bool

    public init (
        bounceTopic: String? = nil,
        complaintTopic: String? = nil,
        deliveryTopic: String? = nil,
        forwardingEnabled: Bool = false,
        headersInBounceNotificationsEnabled: Bool = false,
        headersInComplaintNotificationsEnabled: Bool = false,
        headersInDeliveryNotificationsEnabled: Bool = false
    )
    {
        self.bounceTopic = bounceTopic
        self.complaintTopic = complaintTopic
        self.deliveryTopic = deliveryTopic
        self.forwardingEnabled = forwardingEnabled
        self.headersInBounceNotificationsEnabled = headersInBounceNotificationsEnabled
        self.headersInComplaintNotificationsEnabled = headersInComplaintNotificationsEnabled
        self.headersInDeliveryNotificationsEnabled = headersInDeliveryNotificationsEnabled
    }
}

public enum IdentityType {
    case domain
    case emailaddress
    case sdkUnknown(String)
}

extension IdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityType] {
        return [
            .domain,
            .emailaddress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .domain: return "Domain"
        case .emailaddress: return "EmailAddress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
    }
}

extension IdentityVerificationAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case verificationStatus = "VerificationStatus"
        case verificationToken = "VerificationToken"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let verificationStatus = verificationStatus {
            try container.encode(verificationStatus, forKey: Key("VerificationStatus"))
        }
        if let verificationToken = verificationToken {
            try container.encode(verificationToken, forKey: Key("VerificationToken"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let verificationStatusDecoded = try containerValues.decodeIfPresent(VerificationStatus.self, forKey: .verificationStatus)
        verificationStatus = verificationStatusDecoded
        let verificationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verificationToken)
        verificationToken = verificationTokenDecoded
    }
}

extension IdentityVerificationAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityVerificationAttributes(verificationStatus: \(String(describing: verificationStatus)), verificationToken: \(String(describing: verificationToken)))"}
}

/// <p>Represents the verification attributes of a single identity.</p>
public struct IdentityVerificationAttributes: Equatable {
    /// <p>The verification status of the identity: "Pending", "Success", "Failed", or
    ///             "TemporaryFailure".</p>
    public let verificationStatus: VerificationStatus?
    /// <p>The verification token for a domain identity. Null for email address
    ///             identities.</p>
    public let verificationToken: String?

    public init (
        verificationStatus: VerificationStatus? = nil,
        verificationToken: String? = nil
    )
    {
        self.verificationStatus = verificationStatus
        self.verificationToken = verificationToken
    }
}

extension InvalidCloudWatchDestinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCloudWatchDestinationException(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)), message: \(String(describing: message)))"}
}

extension InvalidCloudWatchDestinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidCloudWatchDestinationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.eventDestinationName = output.error.eventDestinationName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.eventDestinationName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Amazon CloudWatch destination is invalid. See the error message for
///             details.</p>
public struct InvalidCloudWatchDestinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    /// <p>Indicates that the event destination does not exist.</p>
    public var eventDestinationName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.message = message
    }
}

struct InvalidCloudWatchDestinationExceptionBody: Equatable {
    public let configurationSetName: String?
    public let eventDestinationName: String?
    public let message: String?
}

extension InvalidCloudWatchDestinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationSetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationSetException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationSetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidConfigurationSetExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the configuration set is invalid. See the error message for
///             details.</p>
public struct InvalidConfigurationSetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationSetExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationSetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeliveryOptionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeliveryOptionsException(message: \(String(describing: message)))"}
}

extension InvalidDeliveryOptionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDeliveryOptionsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that provided delivery option is invalid.</p>
public struct InvalidDeliveryOptionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeliveryOptionsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeliveryOptionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFirehoseDestinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFirehoseDestinationException(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)), message: \(String(describing: message)))"}
}

extension InvalidFirehoseDestinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidFirehoseDestinationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.eventDestinationName = output.error.eventDestinationName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.eventDestinationName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Amazon Kinesis Firehose destination is invalid. See the error
///             message for details.</p>
public struct InvalidFirehoseDestinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    /// <p>Indicates that the event destination does not exist.</p>
    public var eventDestinationName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.message = message
    }
}

struct InvalidFirehoseDestinationExceptionBody: Equatable {
    public let configurationSetName: String?
    public let eventDestinationName: String?
    public let message: String?
}

extension InvalidFirehoseDestinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLambdaFunctionException(functionArn: \(String(describing: functionArn)), message: \(String(describing: message)))"}
}

extension InvalidLambdaFunctionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidLambdaFunctionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionArn = output.error.functionArn
            self.message = output.error.message
        } else {
            self.functionArn = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided AWS Lambda function is invalid, or that Amazon SES could
///             not execute the provided function, possibly due to permissions issues. For information
///             about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct InvalidLambdaFunctionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the ARN of the function was not found.</p>
    public var functionArn: String?
    public var message: String?

    public init (
        functionArn: String? = nil,
        message: String? = nil
    )
    {
        self.functionArn = functionArn
        self.message = message
    }
}

struct InvalidLambdaFunctionExceptionBody: Equatable {
    public let functionArn: String?
    public let message: String?
}

extension InvalidLambdaFunctionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyException(message: \(String(describing: message)))"}
}

extension InvalidPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidPolicyExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided policy is invalid. Check the error stack for more
///             information about what caused the error.</p>
public struct InvalidPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRenderingParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRenderingParameterException(templateName: \(String(describing: templateName)), message: \(String(describing: message)))"}
}

extension InvalidRenderingParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRenderingParameterExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.templateName = output.error.templateName
        } else {
            self.templateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that one or more of the replacement values you provided is invalid. This
///             error may occur when the TemplateData object contains invalid JSON.</p>
public struct InvalidRenderingParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var templateName: String?

    public init (
        message: String? = nil,
        templateName: String? = nil
    )
    {
        self.message = message
        self.templateName = templateName
    }
}

struct InvalidRenderingParameterExceptionBody: Equatable {
    public let templateName: String?
    public let message: String?
}

extension InvalidRenderingParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateName = "TemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3ConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3ConfigurationException(bucket: \(String(describing: bucket)), message: \(String(describing: message)))"}
}

extension InvalidS3ConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidS3ConfigurationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.bucket = output.error.bucket
            self.message = output.error.message
        } else {
            self.bucket = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided Amazon S3 bucket or AWS KMS encryption key is invalid, or
///             that Amazon SES could not publish to the bucket, possibly due to permissions issues. For
///             information about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct InvalidS3ConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicated that the S3 Bucket was not found.</p>
    public var bucket: String?
    public var message: String?

    public init (
        bucket: String? = nil,
        message: String? = nil
    )
    {
        self.bucket = bucket
        self.message = message
    }
}

struct InvalidS3ConfigurationExceptionBody: Equatable {
    public let bucket: String?
    public let message: String?
}

extension InvalidS3ConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSNSDestinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSNSDestinationException(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)), message: \(String(describing: message)))"}
}

extension InvalidSNSDestinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSNSDestinationExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.eventDestinationName = output.error.eventDestinationName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.eventDestinationName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Amazon Simple Notification Service (Amazon SNS) destination is
///             invalid. See the error message for details.</p>
public struct InvalidSNSDestinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that the configuration set does not exist.</p>
    public var configurationSetName: String?
    /// <p>Indicates that the event destination does not exist.</p>
    public var eventDestinationName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.message = message
    }
}

struct InvalidSNSDestinationExceptionBody: Equatable {
    public let configurationSetName: String?
    public let eventDestinationName: String?
    public let message: String?
}

extension InvalidSNSDestinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case eventDestinationName = "EventDestinationName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSnsTopicException(topic: \(String(describing: topic)), message: \(String(describing: message)))"}
}

extension InvalidSnsTopicException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSnsTopicExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.topic = output.error.topic
        } else {
            self.topic = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided Amazon SNS topic is invalid, or that Amazon SES could not
///             publish to the topic, possibly due to permissions issues. For information about giving
///             permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct InvalidSnsTopicException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates that the topic does not exist.</p>
    public var topic: String?

    public init (
        message: String? = nil,
        topic: String? = nil
    )
    {
        self.message = message
        self.topic = topic
    }
}

struct InvalidSnsTopicExceptionBody: Equatable {
    public let topic: String?
    public let message: String?
}

extension InvalidSnsTopicExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case topic = "Topic"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTemplateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTemplateException(templateName: \(String(describing: templateName)), message: \(String(describing: message)))"}
}

extension InvalidTemplateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTemplateExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.templateName = output.error.templateName
        } else {
            self.templateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the template that you specified could not be rendered. This issue may
///             occur when a template refers to a partial that does not exist.</p>
public struct InvalidTemplateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var templateName: String?

    public init (
        message: String? = nil,
        templateName: String? = nil
    )
    {
        self.message = message
        self.templateName = templateName
    }
}

struct InvalidTemplateExceptionBody: Equatable {
    public let templateName: String?
    public let message: String?
}

extension InvalidTemplateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateName = "TemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTrackingOptionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTrackingOptionsException(message: \(String(describing: message)))"}
}

extension InvalidTrackingOptionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTrackingOptionsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the custom domain to be used for open and click tracking redirects is
///             invalid. This error appears most often in the following situations:</p>
///         <ul>
///             <li>
///                 <p>When the tracking domain you specified is not verified in Amazon SES.</p>
///             </li>
///             <li>
///                 <p>When the tracking domain you specified is not a valid domain or
///                     subdomain.</p>
///             </li>
///          </ul>
public struct InvalidTrackingOptionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTrackingOptionsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTrackingOptionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum InvocationType {
    case event
    case requestresponse
    case sdkUnknown(String)
}

extension InvocationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InvocationType] {
        return [
            .event,
            .requestresponse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "Event"
        case .requestresponse: return "RequestResponse"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
    }
}

extension KinesisFirehoseDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStreamARN = "DeliveryStreamARN"
        case iAMRoleARN = "IAMRoleARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let deliveryStreamARN = deliveryStreamARN {
            try container.encode(deliveryStreamARN, forKey: Key("DeliveryStreamARN"))
        }
        if let iAMRoleARN = iAMRoleARN {
            try container.encode(iAMRoleARN, forKey: Key("IAMRoleARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iAMRoleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iAMRoleARN)
        iAMRoleARN = iAMRoleARNDecoded
        let deliveryStreamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamARN)
        deliveryStreamARN = deliveryStreamARNDecoded
    }
}

extension KinesisFirehoseDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseDestination(deliveryStreamARN: \(String(describing: deliveryStreamARN)), iAMRoleARN: \(String(describing: iAMRoleARN)))"}
}

/// <p>Contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event
///             destination.</p>
///         <p>Event destinations, such as Amazon Kinesis Firehose, are associated with configuration sets, which enable
///             you to publish email sending events. For information about using configuration sets, see
///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct KinesisFirehoseDestination: Equatable {
    /// <p>The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.</p>
    public let deliveryStreamARN: String?
    /// <p>The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose
    ///             stream.</p>
    public let iAMRoleARN: String?

    public init (
        deliveryStreamARN: String? = nil,
        iAMRoleARN: String? = nil
    )
    {
        self.deliveryStreamARN = deliveryStreamARN
        self.iAMRoleARN = iAMRoleARN
    }
}

extension LambdaAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionArn = "FunctionArn"
        case invocationType = "InvocationType"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let functionArn = functionArn {
            try container.encode(functionArn, forKey: Key("FunctionArn"))
        }
        if let invocationType = invocationType {
            try container.encode(invocationType, forKey: Key("InvocationType"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let invocationTypeDecoded = try containerValues.decodeIfPresent(InvocationType.self, forKey: .invocationType)
        invocationType = invocationTypeDecoded
    }
}

extension LambdaAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaAction(functionArn: \(String(describing: functionArn)), invocationType: \(String(describing: invocationType)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action calls an AWS Lambda function and,
///             optionally, publishes a notification to Amazon Simple Notification Service (Amazon SNS).</p>
///         <p>To enable Amazon SES to call your AWS Lambda function or to publish to an Amazon SNS topic of
///             another account, Amazon SES must have permission to access those resources. For information
///             about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer
///                 Guide</a>.</p>
///         <p>For information about using AWS Lambda actions in receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-lambda.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct LambdaAction: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Lambda function. An example of an AWS Lambda
    ///             function ARN is <code>arn:aws:lambda:us-west-2:account-id:function:MyFunction</code>.
    ///             For more information about AWS Lambda, see the <a href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html">AWS Lambda Developer Guide</a>.</p>
    public let functionArn: String?
    /// <p>The invocation type of the AWS Lambda function. An invocation type of
    ///                 <code>RequestResponse</code> means that the execution of the function will
    ///             immediately result in a response, and a value of <code>Event</code> means that the
    ///             function will be invoked asynchronously. The default value is <code>Event</code>. For
    ///             information about AWS Lambda invocation types, see the <a href="https://docs.aws.amazon.com/lambda/latest/dg/API_Invoke.html">AWS Lambda Developer Guide</a>.</p>
    ///         <important>
    ///             <p>There is a 30-second timeout on <code>RequestResponse</code> invocations. You
    ///                 should use <code>Event</code> invocation in most cases. Use
    ///                     <code>RequestResponse</code> only when you want to make a mail flow decision,
    ///                 such as whether to stop the receipt rule or the receipt rule set.</p>
    ///         </important>
    public let invocationType: InvocationType?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to notify when the Lambda action is
    ///             taken. An example of an Amazon SNS topic ARN is
    ///                 <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more information about
    ///             Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        functionArn: String? = nil,
        invocationType: InvocationType? = nil,
        topicArn: String? = nil
    )
    {
        self.functionArn = functionArn
        self.invocationType = invocationType
        self.topicArn = topicArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LimitExceededExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that a resource could not be created because of service limits. For a list
///             of Amazon SES limits, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/limits.html">Amazon SES Developer
///             Guide</a>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListConfigurationSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

extension ListConfigurationSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsInput(maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationSetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListConfigurationSets", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListConfigurationSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

/// <p>Represents a request to list the configuration sets associated with your AWS account.
///             Configuration sets enable you to publish email sending events. For information about
///             using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ListConfigurationSetsInput: Equatable {
    /// <p>The number of configuration sets to return.</p>
    public let maxItems: Int?
    /// <p>A token returned from a previous call to <code>ListConfigurationSets</code> to
    ///             indicate the position of the configuration set in the configuration set list.</p>
    public let nextToken: String?

    public init (
        maxItems: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

extension ListConfigurationSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsOutputResponse(configurationSets: \(String(describing: configurationSets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of configuration sets associated with your AWS account. Configuration sets
///             enable you to publish email sending events. For information about using configuration
///             sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ListConfigurationSetsOutputResponse: Equatable {
    /// <p>A list of configuration sets.</p>
    public let configurationSets: [ConfigurationSet]?
    /// <p>A token indicating that there are additional configuration sets available to be
    ///             listed. Pass this token to successive calls of <code>ListConfigurationSets</code>.
    ///         </p>
    public let nextToken: String?

    public init (
        configurationSets: [ConfigurationSet]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Equatable {
    public let configurationSets: [ConfigurationSet]?
    public let nextToken: String?
}

extension ListConfigurationSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListConfigurationSetsResult"))
        if containerValues.contains(.configurationSets) {
            struct KeyVal0{struct member{}}
            let configurationSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .configurationSets)
            if let configurationSetsWrappedContainer = configurationSetsWrappedContainer {
                let configurationSetsContainer = try configurationSetsWrappedContainer.decodeIfPresent([ConfigurationSet].self, forKey: .member)
                var configurationSetsBuffer:[ConfigurationSet]? = nil
                if let configurationSetsContainer = configurationSetsContainer {
                    configurationSetsBuffer = [ConfigurationSet]()
                    for structureContainer0 in configurationSetsContainer {
                        configurationSetsBuffer?.append(structureContainer0)
                    }
                }
                configurationSets = configurationSetsBuffer
            } else {
                configurationSets = []
            }
        } else {
            configurationSets = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCustomVerificationEmailTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "ListCustomVerificationEmailTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomVerificationEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomVerificationEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomVerificationEmailTemplatesOutputError>
}

extension ListCustomVerificationEmailTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomVerificationEmailTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomVerificationEmailTemplatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListCustomVerificationEmailTemplates", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListCustomVerificationEmailTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCustomVerificationEmailTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomVerificationEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomVerificationEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomVerificationEmailTemplatesOutputError>
}

public struct ListCustomVerificationEmailTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCustomVerificationEmailTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCustomVerificationEmailTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCustomVerificationEmailTemplatesInput>
    public typealias MOutput = OperationOutput<ListCustomVerificationEmailTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCustomVerificationEmailTemplatesOutputError>
}

/// <p>Represents a request to list the existing custom verification email templates for your
///             account.</p>
///         <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html">Using Custom
///                 Verification Email Templates</a> in the <i>Amazon SES Developer
///                 Guide</i>.</p>
public struct ListCustomVerificationEmailTemplatesInput: Equatable {
    /// <p>The maximum number of custom verification email templates to return. This value must
    ///             be at least 1 and less than or equal to 50. If you do not specify a value, or if you
    ///             specify a value less than 1 or greater than 50, the operation will return up to 50
    ///             results.</p>
    public let maxResults: Int?
    /// <p>An array the contains the name and creation time stamp for each template in your Amazon SES
    ///             account.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListCustomVerificationEmailTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCustomVerificationEmailTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCustomVerificationEmailTemplatesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomVerificationEmailTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCustomVerificationEmailTemplatesOutputResponse(customVerificationEmailTemplates: \(String(describing: customVerificationEmailTemplates)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCustomVerificationEmailTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCustomVerificationEmailTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customVerificationEmailTemplates = output.customVerificationEmailTemplates
            self.nextToken = output.nextToken
        } else {
            self.customVerificationEmailTemplates = nil
            self.nextToken = nil
        }
    }
}

/// <p>A paginated list of custom verification email templates.</p>
public struct ListCustomVerificationEmailTemplatesOutputResponse: Equatable {
    /// <p>A list of the custom verification email templates that exist in your account.</p>
    public let customVerificationEmailTemplates: [CustomVerificationEmailTemplate]?
    /// <p>A token indicating that there are additional custom verification email templates
    ///             available to be listed. Pass this token to a subsequent call to
    ///                 <code>ListTemplates</code> to retrieve the next 50 custom verification email
    ///             templates.</p>
    public let nextToken: String?

    public init (
        customVerificationEmailTemplates: [CustomVerificationEmailTemplate]? = nil,
        nextToken: String? = nil
    )
    {
        self.customVerificationEmailTemplates = customVerificationEmailTemplates
        self.nextToken = nextToken
    }
}

struct ListCustomVerificationEmailTemplatesOutputResponseBody: Equatable {
    public let customVerificationEmailTemplates: [CustomVerificationEmailTemplate]?
    public let nextToken: String?
}

extension ListCustomVerificationEmailTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customVerificationEmailTemplates = "CustomVerificationEmailTemplates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListCustomVerificationEmailTemplatesResult"))
        if containerValues.contains(.customVerificationEmailTemplates) {
            struct KeyVal0{struct member{}}
            let customVerificationEmailTemplatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customVerificationEmailTemplates)
            if let customVerificationEmailTemplatesWrappedContainer = customVerificationEmailTemplatesWrappedContainer {
                let customVerificationEmailTemplatesContainer = try customVerificationEmailTemplatesWrappedContainer.decodeIfPresent([CustomVerificationEmailTemplate].self, forKey: .member)
                var customVerificationEmailTemplatesBuffer:[CustomVerificationEmailTemplate]? = nil
                if let customVerificationEmailTemplatesContainer = customVerificationEmailTemplatesContainer {
                    customVerificationEmailTemplatesBuffer = [CustomVerificationEmailTemplate]()
                    for structureContainer0 in customVerificationEmailTemplatesContainer {
                        customVerificationEmailTemplatesBuffer?.append(structureContainer0)
                    }
                }
                customVerificationEmailTemplates = customVerificationEmailTemplatesBuffer
            } else {
                customVerificationEmailTemplates = []
            }
        } else {
            customVerificationEmailTemplates = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIdentitiesInputBodyMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

extension ListIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentitiesInput(identityType: \(String(describing: identityType)), maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentitiesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identityType = identityType {
            try container.encode(identityType, forKey: Key("IdentityType"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListIdentities", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

public struct ListIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

/// <p>Represents a request to return a list of all identities (email addresses and domains)
///             that you have attempted to verify under your AWS account, regardless of verification
///             status.</p>
public struct ListIdentitiesInput: Equatable {
    /// <p>The type of the identities to list. Possible values are "EmailAddress" and "Domain".
    ///             If this parameter is omitted, then all identities will be listed.</p>
    public let identityType: IdentityType?
    /// <p>The maximum number of identities per page. Possible values are 1-1000
    ///             inclusive.</p>
    public let maxItems: Int?
    /// <p>The token to use for pagination.</p>
    public let nextToken: String?

    public init (
        identityType: IdentityType? = nil,
        maxItems: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.identityType = identityType
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

extension ListIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentitiesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentitiesOutputResponse(identities: \(String(describing: identities)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identities = output.identities
            self.nextToken = output.nextToken
        } else {
            self.identities = nil
            self.nextToken = nil
        }
    }
}

/// <p>A list of all identities that you have attempted to verify under your AWS account,
///             regardless of verification status.</p>
public struct ListIdentitiesOutputResponse: Equatable {
    /// <p>A list of identities.</p>
    public let identities: [String]?
    /// <p>The token used for pagination.</p>
    public let nextToken: String?

    public init (
        identities: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.identities = identities
        self.nextToken = nextToken
    }
}

struct ListIdentitiesOutputResponseBody: Equatable {
    public let identities: [String]?
    public let nextToken: String?
}

extension ListIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identities = "Identities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListIdentitiesResult"))
        if containerValues.contains(.identities) {
            struct KeyVal0{struct member{}}
            let identitiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .identities)
            if let identitiesWrappedContainer = identitiesWrappedContainer {
                let identitiesContainer = try identitiesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var identitiesBuffer:[String]? = nil
                if let identitiesContainer = identitiesContainer {
                    identitiesBuffer = [String]()
                    for stringContainer0 in identitiesContainer {
                        identitiesBuffer?.append(stringContainer0)
                    }
                }
                identities = identitiesBuffer
            } else {
                identities = []
            }
        } else {
            identities = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIdentityPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListIdentityPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<ListIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoliciesOutputError>
}

extension ListIdentityPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoliciesInput(identity: \(String(describing: identity)))"}
}

extension ListIdentityPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        try container.encode("ListIdentityPolicies", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListIdentityPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentityPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<ListIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoliciesOutputError>
}

public struct ListIdentityPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentityPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoliciesInput>
    public typealias MOutput = OperationOutput<ListIdentityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoliciesOutputError>
}

/// <p>Represents a request to return a list of sending authorization policies that are
///             attached to an identity. Sending authorization is an Amazon SES feature that enables you to
///             authorize other senders to use your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
public struct ListIdentityPoliciesInput: Equatable {
    /// <p>The identity that is associated with the policy for which the policies will be listed.
    ///             You can specify an identity by using its name or by using its Amazon Resource Name
    ///             (ARN). Examples: <code>user@example.com</code>, <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    ///         <p>To successfully call this API, you must own the identity.</p>
    public let identity: String?

    public init (
        identity: String? = nil
    )
    {
        self.identity = identity
    }
}

extension ListIdentityPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListIdentityPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoliciesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoliciesOutputResponse(policyNames: \(String(describing: policyNames)))"}
}

extension ListIdentityPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyNames = output.policyNames
        } else {
            self.policyNames = nil
        }
    }
}

/// <p>A list of names of sending authorization policies that apply to an identity.</p>
public struct ListIdentityPoliciesOutputResponse: Equatable {
    /// <p>A list of names of policies that apply to the specified identity.</p>
    public let policyNames: [String]?

    public init (
        policyNames: [String]? = nil
    )
    {
        self.policyNames = policyNames
    }
}

struct ListIdentityPoliciesOutputResponseBody: Equatable {
    public let policyNames: [String]?
}

extension ListIdentityPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListIdentityPoliciesResult"))
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var policyNamesBuffer:[String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

public struct ListReceiptFiltersInputBodyMiddleware: Middleware {
    public let id: String = "ListReceiptFiltersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptFiltersInput>
    public typealias MOutput = OperationOutput<ListReceiptFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptFiltersOutputError>
}

extension ListReceiptFiltersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceiptFiltersInput()"}
}

extension ListReceiptFiltersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListReceiptFilters", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListReceiptFiltersInputHeadersMiddleware: Middleware {
    public let id: String = "ListReceiptFiltersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptFiltersInput>
    public typealias MOutput = OperationOutput<ListReceiptFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptFiltersOutputError>
}

public struct ListReceiptFiltersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReceiptFiltersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptFiltersInput>
    public typealias MOutput = OperationOutput<ListReceiptFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptFiltersOutputError>
}

/// <p>Represents a request to list the IP address filters that exist under your AWS account.
///             You use IP address filters when you receive email with Amazon SES. For more information, see
///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ListReceiptFiltersInput: Equatable {

    public init() {}
}

extension ListReceiptFiltersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListReceiptFiltersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceiptFiltersOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceiptFiltersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceiptFiltersOutputResponse(filters: \(String(describing: filters)))"}
}

extension ListReceiptFiltersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReceiptFiltersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.filters = output.filters
        } else {
            self.filters = nil
        }
    }
}

/// <p>A list of IP address filters that exist under your AWS account.</p>
public struct ListReceiptFiltersOutputResponse: Equatable {
    /// <p>A list of IP address filter data structures, which each consist of a name, an IP
    ///             address range, and whether to allow or block mail from it.</p>
    public let filters: [ReceiptFilter]?

    public init (
        filters: [ReceiptFilter]? = nil
    )
    {
        self.filters = filters
    }
}

struct ListReceiptFiltersOutputResponseBody: Equatable {
    public let filters: [ReceiptFilter]?
}

extension ListReceiptFiltersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListReceiptFiltersResult"))
        if containerValues.contains(.filters) {
            struct KeyVal0{struct member{}}
            let filtersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .filters)
            if let filtersWrappedContainer = filtersWrappedContainer {
                let filtersContainer = try filtersWrappedContainer.decodeIfPresent([ReceiptFilter].self, forKey: .member)
                var filtersBuffer:[ReceiptFilter]? = nil
                if let filtersContainer = filtersContainer {
                    filtersBuffer = [ReceiptFilter]()
                    for structureContainer0 in filtersContainer {
                        filtersBuffer?.append(structureContainer0)
                    }
                }
                filters = filtersBuffer
            } else {
                filters = []
            }
        } else {
            filters = nil
        }
    }
}

public struct ListReceiptRuleSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListReceiptRuleSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptRuleSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptRuleSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptRuleSetsInput>
    public typealias MOutput = OperationOutput<ListReceiptRuleSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptRuleSetsOutputError>
}

extension ListReceiptRuleSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceiptRuleSetsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListReceiptRuleSetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListReceiptRuleSets", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListReceiptRuleSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReceiptRuleSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptRuleSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptRuleSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptRuleSetsInput>
    public typealias MOutput = OperationOutput<ListReceiptRuleSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptRuleSetsOutputError>
}

public struct ListReceiptRuleSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReceiptRuleSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReceiptRuleSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReceiptRuleSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReceiptRuleSetsInput>
    public typealias MOutput = OperationOutput<ListReceiptRuleSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReceiptRuleSetsOutputError>
}

/// <p>Represents a request to list the receipt rule sets that exist under your AWS account.
///             You use receipt rule sets to receive email with Amazon SES. For more information, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ListReceiptRuleSetsInput: Equatable {
    /// <p>A token returned from a previous call to <code>ListReceiptRuleSets</code> to indicate
    ///             the position in the receipt rule set list.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListReceiptRuleSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListReceiptRuleSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReceiptRuleSetsOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReceiptRuleSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReceiptRuleSetsOutputResponse(nextToken: \(String(describing: nextToken)), ruleSets: \(String(describing: ruleSets)))"}
}

extension ListReceiptRuleSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReceiptRuleSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.ruleSets = output.ruleSets
        } else {
            self.nextToken = nil
            self.ruleSets = nil
        }
    }
}

/// <p>A list of receipt rule sets that exist under your AWS account.</p>
public struct ListReceiptRuleSetsOutputResponse: Equatable {
    /// <p>A token indicating that there are additional receipt rule sets available to be listed.
    ///             Pass this token to successive calls of <code>ListReceiptRuleSets</code> to retrieve up
    ///             to 100 receipt rule sets at a time.</p>
    public let nextToken: String?
    /// <p>The metadata for the currently active receipt rule set. The metadata consists of the
    ///             rule set name and the timestamp of when the rule set was created.</p>
    public let ruleSets: [ReceiptRuleSetMetadata]?

    public init (
        nextToken: String? = nil,
        ruleSets: [ReceiptRuleSetMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleSets = ruleSets
    }
}

struct ListReceiptRuleSetsOutputResponseBody: Equatable {
    public let ruleSets: [ReceiptRuleSetMetadata]?
    public let nextToken: String?
}

extension ListReceiptRuleSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case ruleSets = "RuleSets"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListReceiptRuleSetsResult"))
        if containerValues.contains(.ruleSets) {
            struct KeyVal0{struct member{}}
            let ruleSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ruleSets)
            if let ruleSetsWrappedContainer = ruleSetsWrappedContainer {
                let ruleSetsContainer = try ruleSetsWrappedContainer.decodeIfPresent([ReceiptRuleSetMetadata].self, forKey: .member)
                var ruleSetsBuffer:[ReceiptRuleSetMetadata]? = nil
                if let ruleSetsContainer = ruleSetsContainer {
                    ruleSetsBuffer = [ReceiptRuleSetMetadata]()
                    for structureContainer0 in ruleSetsContainer {
                        ruleSetsBuffer?.append(structureContainer0)
                    }
                }
                ruleSets = ruleSetsBuffer
            } else {
                ruleSets = []
            }
        } else {
            ruleSets = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "ListTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

extension ListTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesInput(maxItems: \(String(describing: maxItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTemplatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("MaxItems"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: Key("NextToken"))
        }
        try container.encode("ListTemplates", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInput: Equatable {
    /// <p>The maximum number of templates to return. This value must be at least 1 and less than
    ///             or equal to 10. If you do not specify a value, or if you specify a value less than 1 or
    ///             greater than 10, the operation will return up to 10 results.</p>
    public let maxItems: Int?
    /// <p>A token returned from a previous call to <code>ListTemplates</code> to indicate the
    ///             position in the list of email templates.</p>
    public let nextToken: String?

    public init (
        maxItems: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

extension ListTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplatesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesOutputResponse(nextToken: \(String(describing: nextToken)), templatesMetadata: \(String(describing: templatesMetadata)))"}
}

extension ListTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.templatesMetadata = output.templatesMetadata
        } else {
            self.nextToken = nil
            self.templatesMetadata = nil
        }
    }
}

public struct ListTemplatesOutputResponse: Equatable {
    /// <p>A token indicating that there are additional email templates available to be listed.
    ///             Pass this token to a subsequent call to <code>ListTemplates</code> to retrieve the next
    ///             50 email templates.</p>
    public let nextToken: String?
    /// <p>An array the contains the name and creation time stamp for each template in your Amazon SES
    ///             account.</p>
    public let templatesMetadata: [TemplateMetadata]?

    public init (
        nextToken: String? = nil,
        templatesMetadata: [TemplateMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.templatesMetadata = templatesMetadata
    }
}

struct ListTemplatesOutputResponseBody: Equatable {
    public let templatesMetadata: [TemplateMetadata]?
    public let nextToken: String?
}

extension ListTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case templatesMetadata = "TemplatesMetadata"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListTemplatesResult"))
        if containerValues.contains(.templatesMetadata) {
            struct KeyVal0{struct member{}}
            let templatesMetadataWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .templatesMetadata)
            if let templatesMetadataWrappedContainer = templatesMetadataWrappedContainer {
                let templatesMetadataContainer = try templatesMetadataWrappedContainer.decodeIfPresent([TemplateMetadata].self, forKey: .member)
                var templatesMetadataBuffer:[TemplateMetadata]? = nil
                if let templatesMetadataContainer = templatesMetadataContainer {
                    templatesMetadataBuffer = [TemplateMetadata]()
                    for structureContainer0 in templatesMetadataContainer {
                        templatesMetadataBuffer?.append(structureContainer0)
                    }
                }
                templatesMetadata = templatesMetadataBuffer
            } else {
                templatesMetadata = []
            }
        } else {
            templatesMetadata = nil
        }
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListVerifiedEmailAddressesInputBodyMiddleware: Middleware {
    public let id: String = "ListVerifiedEmailAddressesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVerifiedEmailAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVerifiedEmailAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVerifiedEmailAddressesInput>
    public typealias MOutput = OperationOutput<ListVerifiedEmailAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVerifiedEmailAddressesOutputError>
}

extension ListVerifiedEmailAddressesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVerifiedEmailAddressesInput()"}
}

extension ListVerifiedEmailAddressesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("ListVerifiedEmailAddresses", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ListVerifiedEmailAddressesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVerifiedEmailAddressesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVerifiedEmailAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVerifiedEmailAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVerifiedEmailAddressesInput>
    public typealias MOutput = OperationOutput<ListVerifiedEmailAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVerifiedEmailAddressesOutputError>
}

public struct ListVerifiedEmailAddressesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVerifiedEmailAddressesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVerifiedEmailAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVerifiedEmailAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVerifiedEmailAddressesInput>
    public typealias MOutput = OperationOutput<ListVerifiedEmailAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVerifiedEmailAddressesOutputError>
}

public struct ListVerifiedEmailAddressesInput: Equatable {

    public init() {}
}

extension ListVerifiedEmailAddressesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListVerifiedEmailAddressesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVerifiedEmailAddressesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVerifiedEmailAddressesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVerifiedEmailAddressesOutputResponse(verifiedEmailAddresses: \(String(describing: verifiedEmailAddresses)))"}
}

extension ListVerifiedEmailAddressesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVerifiedEmailAddressesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.verifiedEmailAddresses = output.verifiedEmailAddresses
        } else {
            self.verifiedEmailAddresses = nil
        }
    }
}

/// <p>A list of email addresses that you have verified with Amazon SES under your AWS
///             account.</p>
public struct ListVerifiedEmailAddressesOutputResponse: Equatable {
    /// <p>A list of email addresses that have been verified.</p>
    public let verifiedEmailAddresses: [String]?

    public init (
        verifiedEmailAddresses: [String]? = nil
    )
    {
        self.verifiedEmailAddresses = verifiedEmailAddresses
    }
}

struct ListVerifiedEmailAddressesOutputResponseBody: Equatable {
    public let verifiedEmailAddresses: [String]?
}

extension ListVerifiedEmailAddressesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case verifiedEmailAddresses = "VerifiedEmailAddresses"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ListVerifiedEmailAddressesResult"))
        if containerValues.contains(.verifiedEmailAddresses) {
            struct KeyVal0{struct member{}}
            let verifiedEmailAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .verifiedEmailAddresses)
            if let verifiedEmailAddressesWrappedContainer = verifiedEmailAddressesWrappedContainer {
                let verifiedEmailAddressesContainer = try verifiedEmailAddressesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var verifiedEmailAddressesBuffer:[String]? = nil
                if let verifiedEmailAddressesContainer = verifiedEmailAddressesContainer {
                    verifiedEmailAddressesBuffer = [String]()
                    for stringContainer0 in verifiedEmailAddressesContainer {
                        verifiedEmailAddressesBuffer?.append(stringContainer0)
                    }
                }
                verifiedEmailAddresses = verifiedEmailAddressesBuffer
            } else {
                verifiedEmailAddresses = []
            }
        } else {
            verifiedEmailAddresses = nil
        }
    }
}

extension MailFromDomainNotVerifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailFromDomainNotVerifiedException(message: \(String(describing: message)))"}
}

extension MailFromDomainNotVerifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MailFromDomainNotVerifiedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Indicates that the message could not be sent because Amazon SES could not read the MX
///             record required to use the specified MAIL FROM domain. For information about editing the
///             custom MAIL FROM domain settings for an identity, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from-edit.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct MailFromDomainNotVerifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MailFromDomainNotVerifiedExceptionBody: Equatable {
    public let message: String?
}

extension MailFromDomainNotVerifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case subject = "Subject"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let body = body {
            try container.encode(body, forKey: Key("Body"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: Key("Subject"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Content.self, forKey: .subject)
        subject = subjectDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Body.self, forKey: .body)
        body = bodyDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(body: \(String(describing: body)), subject: \(String(describing: subject)))"}
}

/// <p>Represents the message to be sent, composed of a subject and a body.</p>
public struct Message: Equatable {
    /// <p>The message body.</p>
    public let body: Body?
    /// <p>The subject of the message: A short summary of the content, which will appear in the
    ///             recipient's inbox.</p>
    public let subject: Content?

    public init (
        body: Body? = nil,
        subject: Content? = nil
    )
    {
        self.body = body
        self.subject = subject
    }
}

extension MessageDsn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrivalDate = "ArrivalDate"
        case extensionFields = "ExtensionFields"
        case reportingMta = "ReportingMta"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arrivalDate = arrivalDate {
            try container.encode(TimestampWrapper(arrivalDate, format: .dateTime), forKey: Key("arrivalDate"))
        }
        if let extensionFields = extensionFields {
            var extensionFieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExtensionFields"))
            for (index0, extensionfield0) in extensionFields.enumerated() {
                try extensionFieldsContainer.encode(extensionfield0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let reportingMta = reportingMta {
            try container.encode(reportingMta, forKey: Key("ReportingMta"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportingMtaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reportingMta)
        reportingMta = reportingMtaDecoded
        let arrivalDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arrivalDate)
        var arrivalDateBuffer:Date? = nil
        if let arrivalDateDecoded = arrivalDateDecoded {
            arrivalDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(arrivalDateDecoded, format: .dateTime)
        }
        arrivalDate = arrivalDateBuffer
        if containerValues.contains(.extensionFields) {
            struct KeyVal0{struct member{}}
            let extensionFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .extensionFields)
            if let extensionFieldsWrappedContainer = extensionFieldsWrappedContainer {
                let extensionFieldsContainer = try extensionFieldsWrappedContainer.decodeIfPresent([ExtensionField].self, forKey: .member)
                var extensionFieldsBuffer:[ExtensionField]? = nil
                if let extensionFieldsContainer = extensionFieldsContainer {
                    extensionFieldsBuffer = [ExtensionField]()
                    for structureContainer0 in extensionFieldsContainer {
                        extensionFieldsBuffer?.append(structureContainer0)
                    }
                }
                extensionFields = extensionFieldsBuffer
            } else {
                extensionFields = []
            }
        } else {
            extensionFields = nil
        }
    }
}

extension MessageDsn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageDsn(arrivalDate: \(String(describing: arrivalDate)), extensionFields: \(String(describing: extensionFields)), reportingMta: \(String(describing: reportingMta)))"}
}

/// <p>Message-related information to include in the Delivery Status Notification (DSN) when
///             an email that Amazon SES receives on your behalf bounces.</p>
///         <p>For information about receiving email through Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct MessageDsn: Equatable {
    /// <p>When the message was received by the reporting mail transfer agent (MTA), in <a href="https://www.ietf.org/rfc/rfc0822.txt">RFC 822</a> date-time format.</p>
    public let arrivalDate: Date?
    /// <p>Additional X-headers to include in the DSN.</p>
    public let extensionFields: [ExtensionField]?
    /// <p>The reporting MTA that attempted to deliver the message, formatted as specified in
    ///                 <a href="https://tools.ietf.org/html/rfc3464">RFC 3464</a>
    ///                 (<code>mta-name-type; mta-name</code>). The default value is <code>dns;
    ///                 inbound-smtp.[region].amazonaws.com</code>.</p>
    public let reportingMta: String?

    public init (
        arrivalDate: Date? = nil,
        extensionFields: [ExtensionField]? = nil,
        reportingMta: String? = nil
    )
    {
        self.arrivalDate = arrivalDate
        self.extensionFields = extensionFields
        self.reportingMta = reportingMta
    }
}

extension MessageRejected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageRejected(message: \(String(describing: message)))"}
}

extension MessageRejected: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MessageRejectedBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the action failed, and the message could not be sent. Check the error
///             stack for more information about what caused the error.</p>
public struct MessageRejected: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Equatable {
    public let message: String?
}

extension MessageRejectedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MessageTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageTag(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains the name and value of a tag that you can provide to <code>SendEmail</code> or
///                 <code>SendRawEmail</code> to apply to an email.</p>
///         <p>Message tags, which you use with configuration sets, enable you to publish email
///             sending events. For information about using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer Guide</a>.</p>
public struct MessageTag: Equatable {
    /// <p>The name of the tag. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>The value of the tag. The value must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 256 characters.</p>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension MissingRenderingAttributeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingRenderingAttributeException(templateName: \(String(describing: templateName)), message: \(String(describing: message)))"}
}

extension MissingRenderingAttributeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MissingRenderingAttributeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.templateName = output.error.templateName
        } else {
            self.templateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that one or more of the replacement values for the specified template was
///             not specified. Ensure that the TemplateData object contains references to all of the
///             replacement tags in the specified template.</p>
public struct MissingRenderingAttributeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var templateName: String?

    public init (
        message: String? = nil,
        templateName: String? = nil
    )
    {
        self.message = message
        self.templateName = templateName
    }
}

struct MissingRenderingAttributeExceptionBody: Equatable {
    public let templateName: String?
    public let message: String?
}

extension MissingRenderingAttributeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateName = "TemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum NotificationType {
    case bounce
    case complaint
    case delivery
    case sdkUnknown(String)
}

extension NotificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationType] {
        return [
            .bounce,
            .complaint,
            .delivery,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bounce: return "Bounce"
        case .complaint: return "Complaint"
        case .delivery: return "Delivery"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
    }
}

extension ProductionAccessNotGrantedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductionAccessNotGrantedException(message: \(String(describing: message)))"}
}

extension ProductionAccessNotGrantedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ProductionAccessNotGrantedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the account has not been granted production access.</p>
public struct ProductionAccessNotGrantedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ProductionAccessNotGrantedExceptionBody: Equatable {
    public let message: String?
}

extension ProductionAccessNotGrantedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutConfigurationSetDeliveryOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

extension PutConfigurationSetDeliveryOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsInput(configurationSetName: \(String(describing: configurationSetName)), deliveryOptions: \(String(describing: deliveryOptions)))"}
}

extension PutConfigurationSetDeliveryOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let deliveryOptions = deliveryOptions {
            try container.encode(deliveryOptions, forKey: Key("DeliveryOptions"))
        }
        try container.encode("PutConfigurationSetDeliveryOptions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct PutConfigurationSetDeliveryOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

public struct PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutConfigurationSetDeliveryOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutConfigurationSetDeliveryOptionsInput>
    public typealias MOutput = OperationOutput<PutConfigurationSetDeliveryOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutConfigurationSetDeliveryOptionsOutputError>
}

/// <p>A request to modify the delivery options for a configuration set.</p>
public struct PutConfigurationSetDeliveryOptionsInput: Equatable {
    /// <p>The name of the configuration set that you want to specify the delivery options
    ///             for.</p>
    public let configurationSetName: String?
    /// <p>Specifies whether messages that use the configuration set are required to use
    ///             Transport Layer Security (TLS).</p>
    public let deliveryOptions: DeliveryOptions?

    public init (
        configurationSetName: String? = nil,
        deliveryOptions: DeliveryOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.deliveryOptions = deliveryOptions
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutConfigurationSetDeliveryOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeliveryOptionsException" : self = .invalidDeliveryOptionsException(try InvalidDeliveryOptionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConfigurationSetDeliveryOptionsOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case invalidDeliveryOptionsException(InvalidDeliveryOptionsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutConfigurationSetDeliveryOptionsOutputResponse()"}
}

extension PutConfigurationSetDeliveryOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
///             fails.</p>
public struct PutConfigurationSetDeliveryOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutConfigurationSetDeliveryOptionsOutputResponseBody: Equatable {
}

extension PutConfigurationSetDeliveryOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutIdentityPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutIdentityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIdentityPolicyInput>
    public typealias MOutput = OperationOutput<PutIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIdentityPolicyOutputError>
}

extension PutIdentityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIdentityPolicyInput(identity: \(String(describing: identity)), policy: \(String(describing: policy)), policyName: \(String(describing: policyName)))"}
}

extension PutIdentityPolicyInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: Key("PolicyName"))
        }
        try container.encode("PutIdentityPolicy", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct PutIdentityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutIdentityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIdentityPolicyInput>
    public typealias MOutput = OperationOutput<PutIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIdentityPolicyOutputError>
}

public struct PutIdentityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutIdentityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutIdentityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutIdentityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutIdentityPolicyInput>
    public typealias MOutput = OperationOutput<PutIdentityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutIdentityPolicyOutputError>
}

/// <p>Represents a request to add or update a sending authorization policy for an identity.
///             Sending authorization is an Amazon SES feature that enables you to authorize other senders to
///             use your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct PutIdentityPolicyInput: Equatable {
    /// <p>The identity that the policy will apply to. You can specify an identity by using its
    ///             name or by using its Amazon Resource Name (ARN). Examples:
    ///             <code>user@example.com</code>, <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    ///         <p>To successfully call this API, you must own the identity.</p>
    public let identity: String?
    /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
    ///         <p>For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
    ///                 Guide</a>. </p>
    public let policy: String?
    /// <p>The name of the policy.</p>
    ///         <p>The policy name cannot exceed 64 characters and can only include alphanumeric
    ///             characters, dashes, and underscores.</p>
    public let policyName: String?

    public init (
        identity: String? = nil,
        policy: String? = nil,
        policyName: String? = nil
    )
    {
        self.identity = identity
        self.policy = policy
        self.policyName = policyName
    }
}

extension PutIdentityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PutIdentityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPolicyException" : self = .invalidPolicyException(try InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIdentityPolicyOutputError: Equatable {
    case invalidPolicyException(InvalidPolicyException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIdentityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutIdentityPolicyOutputResponse()"}
}

extension PutIdentityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct PutIdentityPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutIdentityPolicyOutputResponseBody: Equatable {
}

extension PutIdentityPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RawMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let data = data {
            try container.encode(data.base64EncodedString(), forKey: Key("Data"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.data) {
            do {
                let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
                data = dataDecoded
            } catch {
                data = "".data(using: .utf8)
            }
        } else {
            data = nil
        }
    }
}

extension RawMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RawMessage(data: \(String(describing: data)))"}
}

/// <p>Represents the raw data of the message.</p>
public struct RawMessage: Equatable {
    /// <p>The raw data of the message. This data needs to base64-encoded if you are accessing
    ///             Amazon SES directly through the HTTPS interface. If you are accessing Amazon SES using an AWS
    ///             SDK, the SDK takes care of the base 64-encoding for you. In all cases, the client must
    ///             ensure that the message format complies with Internet email standards regarding email
    ///             header fields, MIME types, and MIME encoding.</p>
    ///         <p>The To:, CC:, and BCC: headers in the raw message can contain a group list.</p>
    ///         <p>If you are using <code>SendRawEmail</code> with sending authorization, you can include
    ///             X-headers in the raw message to specify the "Source," "From," and "Return-Path"
    ///             addresses. For more information, see the documentation for <code>SendRawEmail</code>. </p>
    ///         <important>
    ///             <p>Do not include these X-headers in the DKIM signature, because they are removed by
    ///                 Amazon SES before sending the email.</p>
    ///         </important>
    ///         <p>For more information, go to the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-raw.html">Amazon SES Developer
    ///             Guide</a>.</p>
    public let data: Data?

    public init (
        data: Data? = nil
    )
    {
        self.data = data
    }
}

extension ReceiptAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addHeaderAction = "AddHeaderAction"
        case bounceAction = "BounceAction"
        case lambdaAction = "LambdaAction"
        case s3Action = "S3Action"
        case sNSAction = "SNSAction"
        case stopAction = "StopAction"
        case workmailAction = "WorkmailAction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let addHeaderAction = addHeaderAction {
            try container.encode(addHeaderAction, forKey: Key("AddHeaderAction"))
        }
        if let bounceAction = bounceAction {
            try container.encode(bounceAction, forKey: Key("BounceAction"))
        }
        if let lambdaAction = lambdaAction {
            try container.encode(lambdaAction, forKey: Key("LambdaAction"))
        }
        if let s3Action = s3Action {
            try container.encode(s3Action, forKey: Key("S3Action"))
        }
        if let sNSAction = sNSAction {
            try container.encode(sNSAction, forKey: Key("SNSAction"))
        }
        if let stopAction = stopAction {
            try container.encode(stopAction, forKey: Key("StopAction"))
        }
        if let workmailAction = workmailAction {
            try container.encode(workmailAction, forKey: Key("WorkmailAction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ActionDecoded = try containerValues.decodeIfPresent(S3Action.self, forKey: .s3Action)
        s3Action = s3ActionDecoded
        let bounceActionDecoded = try containerValues.decodeIfPresent(BounceAction.self, forKey: .bounceAction)
        bounceAction = bounceActionDecoded
        let workmailActionDecoded = try containerValues.decodeIfPresent(WorkmailAction.self, forKey: .workmailAction)
        workmailAction = workmailActionDecoded
        let lambdaActionDecoded = try containerValues.decodeIfPresent(LambdaAction.self, forKey: .lambdaAction)
        lambdaAction = lambdaActionDecoded
        let stopActionDecoded = try containerValues.decodeIfPresent(StopAction.self, forKey: .stopAction)
        stopAction = stopActionDecoded
        let addHeaderActionDecoded = try containerValues.decodeIfPresent(AddHeaderAction.self, forKey: .addHeaderAction)
        addHeaderAction = addHeaderActionDecoded
        let sNSActionDecoded = try containerValues.decodeIfPresent(SNSAction.self, forKey: .sNSAction)
        sNSAction = sNSActionDecoded
    }
}

extension ReceiptAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceiptAction(addHeaderAction: \(String(describing: addHeaderAction)), bounceAction: \(String(describing: bounceAction)), lambdaAction: \(String(describing: lambdaAction)), s3Action: \(String(describing: s3Action)), sNSAction: \(String(describing: sNSAction)), stopAction: \(String(describing: stopAction)), workmailAction: \(String(describing: workmailAction)))"}
}

/// <p>An action that Amazon SES can take when it receives an email on behalf of one or more email
///             addresses or domains that you own. An instance of this data type can represent only one
///             action.</p>
///         <p>For information about setting up receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rules.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ReceiptAction: Equatable {
    /// <p>Adds a header to the received email.</p>
    public let addHeaderAction: AddHeaderAction?
    /// <p>Rejects the received email by returning a bounce response to the sender and,
    ///             optionally, publishes a notification to Amazon Simple Notification Service (Amazon SNS).</p>
    public let bounceAction: BounceAction?
    /// <p>Calls an AWS Lambda function, and optionally, publishes a notification to Amazon SNS.</p>
    public let lambdaAction: LambdaAction?
    /// <p>Saves the received message to an Amazon Simple Storage Service (Amazon S3) bucket and, optionally, publishes a
    ///             notification to Amazon SNS.</p>
    public let s3Action: S3Action?
    /// <p>Publishes the email content within a notification to Amazon SNS.</p>
    public let sNSAction: SNSAction?
    /// <p>Terminates the evaluation of the receipt rule set and optionally publishes a
    ///             notification to Amazon SNS.</p>
    public let stopAction: StopAction?
    /// <p>Calls Amazon WorkMail and, optionally, publishes a notification to Amazon
    ///             Amazon SNS.</p>
    public let workmailAction: WorkmailAction?

    public init (
        addHeaderAction: AddHeaderAction? = nil,
        bounceAction: BounceAction? = nil,
        lambdaAction: LambdaAction? = nil,
        s3Action: S3Action? = nil,
        sNSAction: SNSAction? = nil,
        stopAction: StopAction? = nil,
        workmailAction: WorkmailAction? = nil
    )
    {
        self.addHeaderAction = addHeaderAction
        self.bounceAction = bounceAction
        self.lambdaAction = lambdaAction
        self.s3Action = s3Action
        self.sNSAction = sNSAction
        self.stopAction = stopAction
        self.workmailAction = workmailAction
    }
}

extension ReceiptFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipFilter = "IpFilter"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ipFilter = ipFilter {
            try container.encode(ipFilter, forKey: Key("IpFilter"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ipFilterDecoded = try containerValues.decodeIfPresent(ReceiptIpFilter.self, forKey: .ipFilter)
        ipFilter = ipFilterDecoded
    }
}

extension ReceiptFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceiptFilter(ipFilter: \(String(describing: ipFilter)), name: \(String(describing: name)))"}
}

/// <p>A receipt IP address filter enables you to specify whether to accept or reject mail
///             originating from an IP address or range of IP addresses.</p>
///         <p>For information about setting up IP address filters, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-ip-filters.html">Amazon SES Developer Guide</a>.</p>
public struct ReceiptFilter: Equatable {
    /// <p>A structure that provides the IP addresses to block or allow, and whether to block or
    ///             allow incoming mail from them.</p>
    public let ipFilter: ReceiptIpFilter?
    /// <p>The name of the IP address filter. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Start and end with a letter or number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?

    public init (
        ipFilter: ReceiptIpFilter? = nil,
        name: String? = nil
    )
    {
        self.ipFilter = ipFilter
        self.name = name
    }
}

public enum ReceiptFilterPolicy {
    case allow
    case block
    case sdkUnknown(String)
}

extension ReceiptFilterPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReceiptFilterPolicy] {
        return [
            .allow,
            .block,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "Allow"
        case .block: return "Block"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReceiptFilterPolicy(rawValue: rawValue) ?? ReceiptFilterPolicy.sdkUnknown(rawValue)
    }
}

extension ReceiptIpFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cidr = "Cidr"
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let cidr = cidr {
            try container.encode(cidr, forKey: Key("Cidr"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ReceiptFilterPolicy.self, forKey: .policy)
        policy = policyDecoded
        let cidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension ReceiptIpFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceiptIpFilter(cidr: \(String(describing: cidr)), policy: \(String(describing: policy)))"}
}

/// <p>A receipt IP address filter enables you to specify whether to accept or reject mail
///             originating from an IP address or range of IP addresses.</p>
///         <p>For information about setting up IP address filters, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-ip-filters.html">Amazon SES Developer Guide</a>.</p>
public struct ReceiptIpFilter: Equatable {
    /// <p>A single IP address or a range of IP addresses that you want to block or allow,
    ///             specified in Classless Inter-Domain Routing (CIDR) notation. An example of a single
    ///             email address is 10.0.0.1. An example of a range of IP addresses is 10.0.0.1/24. For
    ///             more information about CIDR notation, see <a href="https://tools.ietf.org/html/rfc2317">RFC 2317</a>.</p>
    public let cidr: String?
    /// <p>Indicates whether to block or allow incoming mail from the specified IP
    ///             addresses.</p>
    public let policy: ReceiptFilterPolicy?

    public init (
        cidr: String? = nil,
        policy: ReceiptFilterPolicy? = nil
    )
    {
        self.cidr = cidr
        self.policy = policy
    }
}

extension ReceiptRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case enabled = "Enabled"
        case name = "Name"
        case recipients = "Recipients"
        case scanEnabled = "ScanEnabled"
        case tlsPolicy = "TlsPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Actions"))
            for (index0, receiptaction0) in actions.enumerated() {
                try actionsContainer.encode(receiptaction0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let recipients = recipients {
            var recipientsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Recipients"))
            for (index0, recipient0) in recipients.enumerated() {
                try recipientsContainer.encode(recipient0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if scanEnabled != false {
            try container.encode(scanEnabled, forKey: Key("ScanEnabled"))
        }
        if let tlsPolicy = tlsPolicy {
            try container.encode(tlsPolicy, forKey: Key("TlsPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tlsPolicyDecoded = try containerValues.decodeIfPresent(TlsPolicy.self, forKey: .tlsPolicy)
        tlsPolicy = tlsPolicyDecoded
        if containerValues.contains(.recipients) {
            struct KeyVal0{struct member{}}
            let recipientsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .recipients)
            if let recipientsWrappedContainer = recipientsWrappedContainer {
                let recipientsContainer = try recipientsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var recipientsBuffer:[String]? = nil
                if let recipientsContainer = recipientsContainer {
                    recipientsBuffer = [String]()
                    for stringContainer0 in recipientsContainer {
                        recipientsBuffer?.append(stringContainer0)
                    }
                }
                recipients = recipientsBuffer
            } else {
                recipients = []
            }
        } else {
            recipients = nil
        }
        if containerValues.contains(.actions) {
            struct KeyVal0{struct member{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([ReceiptAction].self, forKey: .member)
                var actionsBuffer:[ReceiptAction]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [ReceiptAction]()
                    for structureContainer0 in actionsContainer {
                        actionsBuffer?.append(structureContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let scanEnabledDecoded = try containerValues.decode(Bool.self, forKey: .scanEnabled)
        scanEnabled = scanEnabledDecoded
    }
}

extension ReceiptRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceiptRule(actions: \(String(describing: actions)), enabled: \(String(describing: enabled)), name: \(String(describing: name)), recipients: \(String(describing: recipients)), scanEnabled: \(String(describing: scanEnabled)), tlsPolicy: \(String(describing: tlsPolicy)))"}
}

/// <p>Receipt rules enable you to specify which actions Amazon SES should take when it receives
///             mail on behalf of one or more email addresses or domains that you own.</p>
///         <p>Each receipt rule defines a set of email addresses or domains that it applies to. If
///             the email addresses or domains match at least one recipient address of the message,
///             Amazon SES executes all of the receipt rule's actions on the message.</p>
///         <p>For information about setting up receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rules.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct ReceiptRule: Equatable {
    /// <p>An ordered list of actions to perform on messages that match at least one of the
    ///             recipient email addresses or domains specified in the receipt rule.</p>
    public let actions: [ReceiptAction]?
    /// <p>If <code>true</code>, the receipt rule is active. The default value is
    ///                 <code>false</code>.</p>
    public let enabled: Bool
    /// <p>The name of the receipt rule. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Start and end with a letter or number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>The recipient domains and email addresses that the receipt rule applies to. If this
    ///             field is not specified, this rule will match all recipients under all verified
    ///             domains.</p>
    public let recipients: [String]?
    /// <p>If <code>true</code>, then messages that this receipt rule applies to are scanned for
    ///             spam and viruses. The default value is <code>false</code>.</p>
    public let scanEnabled: Bool
    /// <p>Specifies whether Amazon SES should require that incoming email is delivered over a
    ///             connection encrypted with Transport Layer Security (TLS). If this parameter is set to
    ///                 <code>Require</code>, Amazon SES will bounce emails that are not received over TLS. The
    ///             default is <code>Optional</code>.</p>
    public let tlsPolicy: TlsPolicy?

    public init (
        actions: [ReceiptAction]? = nil,
        enabled: Bool = false,
        name: String? = nil,
        recipients: [String]? = nil,
        scanEnabled: Bool = false,
        tlsPolicy: TlsPolicy? = nil
    )
    {
        self.actions = actions
        self.enabled = enabled
        self.name = name
        self.recipients = recipients
        self.scanEnabled = scanEnabled
        self.tlsPolicy = tlsPolicy
    }
}

extension ReceiptRuleSetMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createdTimestamp = createdTimestamp {
            try container.encode(TimestampWrapper(createdTimestamp, format: .dateTime), forKey: Key("createdTimestamp"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTimestamp)
        var createdTimestampBuffer:Date? = nil
        if let createdTimestampDecoded = createdTimestampDecoded {
            createdTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimestampDecoded, format: .dateTime)
        }
        createdTimestamp = createdTimestampBuffer
    }
}

extension ReceiptRuleSetMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReceiptRuleSetMetadata(createdTimestamp: \(String(describing: createdTimestamp)), name: \(String(describing: name)))"}
}

/// <p>Information about a receipt rule set.</p>
///         <p>A receipt rule set is a collection of rules that specify what Amazon SES should do with
///             mail it receives on behalf of your account's verified domains.</p>
///         <p>For information about setting up receipt rule sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-receipt-rule-set.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct ReceiptRuleSetMetadata: Equatable {
    /// <p>The date and time the receipt rule set was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name of the receipt rule set. The name must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>This value can only contain ASCII letters (a-z, A-Z), numbers (0-9),
    ///                     underscores (_), or dashes (-).</p>
    ///             </li>
    ///             <li>
    ///                 <p>Start and end with a letter or number.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Contain less than 64 characters.</p>
    ///             </li>
    ///          </ul>
    public let name: String?

    public init (
        createdTimestamp: Date? = nil,
        name: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.name = name
    }
}

extension RecipientDsnFields: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case diagnosticCode = "DiagnosticCode"
        case extensionFields = "ExtensionFields"
        case finalRecipient = "FinalRecipient"
        case lastAttemptDate = "LastAttemptDate"
        case remoteMta = "RemoteMta"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let action = action {
            try container.encode(action, forKey: Key("Action"))
        }
        if let diagnosticCode = diagnosticCode {
            try container.encode(diagnosticCode, forKey: Key("DiagnosticCode"))
        }
        if let extensionFields = extensionFields {
            var extensionFieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ExtensionFields"))
            for (index0, extensionfield0) in extensionFields.enumerated() {
                try extensionFieldsContainer.encode(extensionfield0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let finalRecipient = finalRecipient {
            try container.encode(finalRecipient, forKey: Key("FinalRecipient"))
        }
        if let lastAttemptDate = lastAttemptDate {
            try container.encode(TimestampWrapper(lastAttemptDate, format: .dateTime), forKey: Key("lastAttemptDate"))
        }
        if let remoteMta = remoteMta {
            try container.encode(remoteMta, forKey: Key("RemoteMta"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("Status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finalRecipientDecoded = try containerValues.decodeIfPresent(String.self, forKey: .finalRecipient)
        finalRecipient = finalRecipientDecoded
        let actionDecoded = try containerValues.decodeIfPresent(DsnAction.self, forKey: .action)
        action = actionDecoded
        let remoteMtaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remoteMta)
        remoteMta = remoteMtaDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let diagnosticCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diagnosticCode)
        diagnosticCode = diagnosticCodeDecoded
        let lastAttemptDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAttemptDate)
        var lastAttemptDateBuffer:Date? = nil
        if let lastAttemptDateDecoded = lastAttemptDateDecoded {
            lastAttemptDateBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastAttemptDateDecoded, format: .dateTime)
        }
        lastAttemptDate = lastAttemptDateBuffer
        if containerValues.contains(.extensionFields) {
            struct KeyVal0{struct member{}}
            let extensionFieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .extensionFields)
            if let extensionFieldsWrappedContainer = extensionFieldsWrappedContainer {
                let extensionFieldsContainer = try extensionFieldsWrappedContainer.decodeIfPresent([ExtensionField].self, forKey: .member)
                var extensionFieldsBuffer:[ExtensionField]? = nil
                if let extensionFieldsContainer = extensionFieldsContainer {
                    extensionFieldsBuffer = [ExtensionField]()
                    for structureContainer0 in extensionFieldsContainer {
                        extensionFieldsBuffer?.append(structureContainer0)
                    }
                }
                extensionFields = extensionFieldsBuffer
            } else {
                extensionFields = []
            }
        } else {
            extensionFields = nil
        }
    }
}

extension RecipientDsnFields: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecipientDsnFields(action: \(String(describing: action)), diagnosticCode: \(String(describing: diagnosticCode)), extensionFields: \(String(describing: extensionFields)), finalRecipient: \(String(describing: finalRecipient)), lastAttemptDate: \(String(describing: lastAttemptDate)), remoteMta: \(String(describing: remoteMta)), status: \(String(describing: status)))"}
}

/// <p>Recipient-related information to include in the Delivery Status Notification (DSN)
///             when an email that Amazon SES receives on your behalf bounces.</p>
///         <p>For information about receiving email through Amazon SES, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct RecipientDsnFields: Equatable {
    /// <p>The action performed by the reporting mail transfer agent (MTA) as a result of its
    ///             attempt to deliver the message to the recipient address. This is required by <a href="https://tools.ietf.org/html/rfc3464">RFC 3464</a>.</p>
    public let action: DsnAction?
    /// <p>An extended explanation of what went wrong; this is usually an SMTP response. See
    ///                 <a href="https://tools.ietf.org/html/rfc3463">RFC 3463</a> for the correct
    ///             formatting of this parameter.</p>
    public let diagnosticCode: String?
    /// <p>Additional X-headers to include in the DSN.</p>
    public let extensionFields: [ExtensionField]?
    /// <p>The email address that the message was ultimately delivered to. This corresponds to
    ///             the <code>Final-Recipient</code> in the DSN. If not specified,
    ///                 <code>FinalRecipient</code> will be set to the <code>Recipient</code> specified in
    ///             the <code>BouncedRecipientInfo</code> structure. Either <code>FinalRecipient</code> or
    ///             the recipient in <code>BouncedRecipientInfo</code> must be a recipient of the original
    ///             bounced message.</p>
    ///         <note>
    ///             <p>Do not prepend the <code>FinalRecipient</code> email address with <code>rfc
    ///                     822;</code>, as described in <a href="https://tools.ietf.org/html/rfc3798">RFC 3798</a>.</p>
    ///         </note>
    public let finalRecipient: String?
    /// <p>The time the final delivery attempt was made, in <a href="https://www.ietf.org/rfc/rfc0822.txt">RFC 822</a> date-time format.</p>
    public let lastAttemptDate: Date?
    /// <p>The MTA to which the remote MTA attempted to deliver the message, formatted as
    ///             specified in <a href="https://tools.ietf.org/html/rfc3464">RFC 3464</a>
    ///                 (<code>mta-name-type; mta-name</code>). This parameter typically applies only to
    ///             propagating synchronous bounces.</p>
    public let remoteMta: String?
    /// <p>The status code that indicates what went wrong. This is required by <a href="https://tools.ietf.org/html/rfc3464">RFC 3464</a>.</p>
    public let status: String?

    public init (
        action: DsnAction? = nil,
        diagnosticCode: String? = nil,
        extensionFields: [ExtensionField]? = nil,
        finalRecipient: String? = nil,
        lastAttemptDate: Date? = nil,
        remoteMta: String? = nil,
        status: String? = nil
    )
    {
        self.action = action
        self.diagnosticCode = diagnosticCode
        self.extensionFields = extensionFields
        self.finalRecipient = finalRecipient
        self.lastAttemptDate = lastAttemptDate
        self.remoteMta = remoteMta
        self.status = status
    }
}

public struct ReorderReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "ReorderReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReorderReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ReorderReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReorderReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<ReorderReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReorderReceiptRuleSetOutputError>
}

extension ReorderReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReorderReceiptRuleSetInput(ruleNames: \(String(describing: ruleNames)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension ReorderReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleNames = ruleNames {
            var ruleNamesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RuleNames"))
            for (index0, receiptrulename0) in ruleNames.enumerated() {
                try ruleNamesContainer.encode(receiptrulename0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("ReorderReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct ReorderReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "ReorderReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReorderReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ReorderReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReorderReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<ReorderReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReorderReceiptRuleSetOutputError>
}

public struct ReorderReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "ReorderReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReorderReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<ReorderReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReorderReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<ReorderReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReorderReceiptRuleSetOutputError>
}

/// <p>Represents a request to reorder the receipt rules within a receipt rule set. You use
///             receipt rule sets to receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct ReorderReceiptRuleSetInput: Equatable {
    /// <p>A list of the specified receipt rule set's receipt rules in the order that you want to
    ///             put them.</p>
    public let ruleNames: [String]?
    /// <p>The name of the receipt rule set to reorder.</p>
    public let ruleSetName: String?

    public init (
        ruleNames: [String]? = nil,
        ruleSetName: String? = nil
    )
    {
        self.ruleNames = ruleNames
        self.ruleSetName = ruleSetName
    }
}

extension ReorderReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ReorderReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleDoesNotExistException" : self = .ruleDoesNotExistException(try RuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReorderReceiptRuleSetOutputError: Equatable {
    case ruleDoesNotExistException(RuleDoesNotExistException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReorderReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReorderReceiptRuleSetOutputResponse()"}
}

extension ReorderReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct ReorderReceiptRuleSetOutputResponse: Equatable {

    public init() {}
}

struct ReorderReceiptRuleSetOutputResponseBody: Equatable {
}

extension ReorderReceiptRuleSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReputationOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastFreshStart = "LastFreshStart"
        case reputationMetricsEnabled = "ReputationMetricsEnabled"
        case sendingEnabled = "SendingEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let lastFreshStart = lastFreshStart {
            try container.encode(TimestampWrapper(lastFreshStart, format: .dateTime), forKey: Key("lastFreshStart"))
        }
        if reputationMetricsEnabled != false {
            try container.encode(reputationMetricsEnabled, forKey: Key("ReputationMetricsEnabled"))
        }
        if sendingEnabled != false {
            try container.encode(sendingEnabled, forKey: Key("SendingEnabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sendingEnabled)
        sendingEnabled = sendingEnabledDecoded
        let reputationMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .reputationMetricsEnabled)
        reputationMetricsEnabled = reputationMetricsEnabledDecoded
        let lastFreshStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastFreshStart)
        var lastFreshStartBuffer:Date? = nil
        if let lastFreshStartDecoded = lastFreshStartDecoded {
            lastFreshStartBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastFreshStartDecoded, format: .dateTime)
        }
        lastFreshStart = lastFreshStartBuffer
    }
}

extension ReputationOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReputationOptions(lastFreshStart: \(String(describing: lastFreshStart)), reputationMetricsEnabled: \(String(describing: reputationMetricsEnabled)), sendingEnabled: \(String(describing: sendingEnabled)))"}
}

/// <p>Contains information about the reputation settings for a configuration set.</p>
public struct ReputationOptions: Equatable {
    /// <p>The date and time at which the reputation metrics for the configuration set were last
    ///             reset. Resetting these metrics is known as a <i>fresh start</i>.</p>
    ///         <p>When you disable email sending for a configuration set using <a>UpdateConfigurationSetSendingEnabled</a> and later re-enable it, the
    ///             reputation metrics for the configuration set (but not for the entire Amazon SES account) are
    ///             reset.</p>
    ///         <p>If email sending for the configuration set has never been disabled and later
    ///             re-enabled, the value of this attribute is <code>null</code>.</p>
    public let lastFreshStart: Date?
    /// <p>Describes whether or not Amazon SES publishes reputation metrics for the configuration set,
    ///             such as bounce and complaint rates, to Amazon CloudWatch.</p>
    ///         <p>If the value is <code>true</code>, reputation metrics are published. If the value is
    ///                 <code>false</code>, reputation metrics are not published. The default value is
    ///                 <code>false</code>.</p>
    public let reputationMetricsEnabled: Bool
    /// <p>Describes whether email sending is enabled or disabled for the configuration set. If
    ///             the value is <code>true</code>, then Amazon SES will send emails that use the configuration
    ///             set. If the value is <code>false</code>, Amazon SES will not send emails that use the
    ///             configuration set. The default value is <code>true</code>. You can change this setting
    ///             using <a>UpdateConfigurationSetSendingEnabled</a>.</p>
    public let sendingEnabled: Bool

    public init (
        lastFreshStart: Date? = nil,
        reputationMetricsEnabled: Bool = false,
        sendingEnabled: Bool = false
    )
    {
        self.lastFreshStart = lastFreshStart
        self.reputationMetricsEnabled = reputationMetricsEnabled
        self.sendingEnabled = sendingEnabled
    }
}

extension RuleDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleDoesNotExistException(name: \(String(describing: name)), message: \(String(describing: message)))"}
}

extension RuleDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RuleDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.name = output.error.name
        } else {
            self.name = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided receipt rule does not exist.</p>
public struct RuleDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates that the named receipt rule does not exist.</p>
    public var name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

struct RuleDoesNotExistExceptionBody: Equatable {
    public let name: String?
    public let message: String?
}

extension RuleDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RuleSetDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleSetDoesNotExistException(name: \(String(describing: name)), message: \(String(describing: message)))"}
}

extension RuleSetDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RuleSetDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.name = output.error.name
        } else {
            self.name = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the provided receipt rule set does not exist.</p>
public struct RuleSetDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates that the named receipt rule set does not exist.</p>
    public var name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

struct RuleSetDoesNotExistExceptionBody: Equatable {
    public let name: String?
    public let message: String?
}

extension RuleSetDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName = "BucketName"
        case kmsKeyArn = "KmsKeyArn"
        case objectKeyPrefix = "ObjectKeyPrefix"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bucketName = bucketName {
            try container.encode(bucketName, forKey: Key("BucketName"))
        }
        if let kmsKeyArn = kmsKeyArn {
            try container.encode(kmsKeyArn, forKey: Key("KmsKeyArn"))
        }
        if let objectKeyPrefix = objectKeyPrefix {
            try container.encode(objectKeyPrefix, forKey: Key("ObjectKeyPrefix"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectKeyPrefix)
        objectKeyPrefix = objectKeyPrefixDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension S3Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Action(bucketName: \(String(describing: bucketName)), kmsKeyArn: \(String(describing: kmsKeyArn)), objectKeyPrefix: \(String(describing: objectKeyPrefix)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action saves the received message to an Amazon Simple Storage Service
///             (Amazon S3) bucket and, optionally, publishes a notification to Amazon Simple Notification Service (Amazon SNS).</p>
///         <p>To enable Amazon SES to write emails to your Amazon S3 bucket, use an AWS KMS key to encrypt
///             your emails, or publish to an Amazon SNS topic of another account, Amazon SES must have permission
///             to access those resources. For information about giving permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer
///                 Guide</a>.</p>
///         <note>
///             <p>When you save your emails to an Amazon S3 bucket, the maximum email size (including
///                 headers) is 30 MB. Emails larger than that will bounce.</p>
///         </note>
///         <p>For information about specifying Amazon S3 actions in receipt rules, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-s3.html">Amazon SES Developer Guide</a>.</p>
public struct S3Action: Equatable {
    /// <p>The name of the Amazon S3 bucket that incoming email will be saved to.</p>
    public let bucketName: String?
    /// <p>The customer master key that Amazon SES should use to encrypt your emails before saving
    ///             them to the Amazon S3 bucket. You can use the default master key or a custom master key you
    ///             created in AWS KMS as follows:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>To use the default master key, provide an ARN in the form of
    ///                         <code>arn:aws:kms:REGION:ACCOUNT-ID-WITHOUT-HYPHENS:alias/aws/ses</code>.
    ///                     For example, if your AWS account ID is 123456789012 and you want to use the
    ///                     default master key in the US West (Oregon) region, the ARN of the default master
    ///                     key would be <code>arn:aws:kms:us-west-2:123456789012:alias/aws/ses</code>. If
    ///                     you use the default master key, you don't need to perform any extra steps to
    ///                     give Amazon SES permission to use the key.</p>
    ///             </li>
    ///             <li>
    ///                 <p>To use a custom master key you created in AWS KMS, provide the ARN of the
    ///                     master key and ensure that you add a statement to your key's policy to give
    ///                     Amazon SES permission to use it. For more information about giving permissions, see
    ///                     the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES
    ///                         Developer Guide</a>.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information about key policies, see the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html">AWS KMS Developer Guide</a>. If
    ///             you do not specify a master key, Amazon SES will not encrypt your emails.</p>
    ///         <important>
    ///             <p>Your mail is encrypted by Amazon SES using the Amazon S3 encryption client before the mail
    ///                 is submitted to Amazon S3 for storage. It is not encrypted using Amazon S3 server-side
    ///                 encryption. This means that you must use the Amazon S3 encryption client to decrypt the
    ///                 email after retrieving it from Amazon S3, as the service has no access to use your AWS
    ///                 KMS keys for decryption. This encryption client is currently available with the
    ///                     <a href="http://aws.amazon.com/sdk-for-java/">AWS SDK for Java</a> and <a href="http://aws.amazon.com/sdk-for-ruby/">AWS SDK for Ruby</a> only. For more
    ///                 information about client-side encryption using AWS KMS master keys, see the <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingClientSideEncryption.html">Amazon S3 Developer Guide</a>.</p>
    ///         </important>
    public let kmsKeyArn: String?
    /// <p>The key prefix of the Amazon S3 bucket. The key prefix is similar to a directory name that
    ///             enables you to store similar data under the same directory in a bucket.</p>
    public let objectKeyPrefix: String?
    /// <p>The ARN of the Amazon SNS topic to notify when the message is saved to the Amazon S3 bucket. An
    ///             example of an Amazon SNS topic ARN is
    ///             <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more information about
    ///             Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        bucketName: String? = nil,
        kmsKeyArn: String? = nil,
        objectKeyPrefix: String? = nil,
        topicArn: String? = nil
    )
    {
        self.bucketName = bucketName
        self.kmsKeyArn = kmsKeyArn
        self.objectKeyPrefix = objectKeyPrefix
        self.topicArn = topicArn
    }
}

extension SNSAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encoding = "Encoding"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let encoding = encoding {
            try container.encode(encoding, forKey: Key("Encoding"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(SNSActionEncoding.self, forKey: .encoding)
        encoding = encodingDecoded
    }
}

extension SNSAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSAction(encoding: \(String(describing: encoding)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action publishes a notification to Amazon Simple Notification Service
///             (Amazon SNS). This action includes a complete copy of the email content in the Amazon SNS
///             notifications. Amazon SNS notifications for all other actions simply provide information
///             about the email. They do not include the email content itself.</p>
///         <p>If you own the Amazon SNS topic, you don't need to do anything to give Amazon SES permission to
///             publish emails to it. However, if you don't own the Amazon SNS topic, you need to attach a
///             policy to the topic to give Amazon SES permissions to access it. For information about giving
///             permissions, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-permissions.html">Amazon SES Developer
///                 Guide</a>.</p>
///         <important>
///             <p>You can only publish emails that are 150 KB or less (including the header) to
///                 Amazon SNS. Larger emails will bounce. If you anticipate emails larger than 150 KB, use
///                 the S3 action instead.</p>
///         </important>
///         <p>For information about using a receipt rule to publish an Amazon SNS notification, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-sns.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SNSAction: Equatable {
    /// <p>The encoding to use for the email within the Amazon SNS notification. UTF-8 is easier to
    ///             use, but may not preserve all special characters when a message was encoded with a
    ///             different encoding format. Base64 preserves all special characters. The default value is
    ///             UTF-8.</p>
    public let encoding: SNSActionEncoding?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to notify. An example of an Amazon SNS
    ///             topic ARN is <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more
    ///             information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        encoding: SNSActionEncoding? = nil,
        topicArn: String? = nil
    )
    {
        self.encoding = encoding
        self.topicArn = topicArn
    }
}

public enum SNSActionEncoding {
    case base64
    case utf8
    case sdkUnknown(String)
}

extension SNSActionEncoding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SNSActionEncoding] {
        return [
            .base64,
            .utf8,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .base64: return "Base64"
        case .utf8: return "UTF-8"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SNSActionEncoding(rawValue: rawValue) ?? SNSActionEncoding.sdkUnknown(rawValue)
    }
}

extension SNSDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicARN = "TopicARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let topicARN = topicARN {
            try container.encode(topicARN, forKey: Key("TopicARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicARN)
        topicARN = topicARNDecoded
    }
}

extension SNSDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SNSDestination(topicARN: \(String(describing: topicARN)))"}
}

/// <p>Contains the topic ARN associated with an Amazon Simple Notification Service (Amazon SNS) event destination.</p>
///         <p>Event destinations, such as Amazon SNS, are associated with configuration sets, which
///             enable you to publish email sending events. For information about using configuration
///             sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SNSDestination: Equatable {
    /// <p>The ARN of the Amazon SNS topic that email sending events will be published to. An example
    ///             of an Amazon SNS topic ARN is <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For
    ///             more information about Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicARN: String?

    public init (
        topicARN: String? = nil
    )
    {
        self.topicARN = topicARN
    }
}

public struct SendBounceInputBodyMiddleware: Middleware {
    public let id: String = "SendBounceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBounceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBounceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBounceInput>
    public typealias MOutput = OperationOutput<SendBounceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBounceOutputError>
}

extension SendBounceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBounceInput(bounceSender: \(String(describing: bounceSender)), bounceSenderArn: \(String(describing: bounceSenderArn)), bouncedRecipientInfoList: \(String(describing: bouncedRecipientInfoList)), explanation: \(String(describing: explanation)), messageDsn: \(String(describing: messageDsn)), originalMessageId: \(String(describing: originalMessageId)))"}
}

extension SendBounceInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let bounceSender = bounceSender {
            try container.encode(bounceSender, forKey: Key("BounceSender"))
        }
        if let bounceSenderArn = bounceSenderArn {
            try container.encode(bounceSenderArn, forKey: Key("BounceSenderArn"))
        }
        if let bouncedRecipientInfoList = bouncedRecipientInfoList {
            var bouncedRecipientInfoListContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("BouncedRecipientInfoList"))
            for (index0, bouncedrecipientinfo0) in bouncedRecipientInfoList.enumerated() {
                try bouncedRecipientInfoListContainer.encode(bouncedrecipientinfo0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let explanation = explanation {
            try container.encode(explanation, forKey: Key("Explanation"))
        }
        if let messageDsn = messageDsn {
            try container.encode(messageDsn, forKey: Key("MessageDsn"))
        }
        if let originalMessageId = originalMessageId {
            try container.encode(originalMessageId, forKey: Key("OriginalMessageId"))
        }
        try container.encode("SendBounce", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendBounceInputHeadersMiddleware: Middleware {
    public let id: String = "SendBounceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBounceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBounceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBounceInput>
    public typealias MOutput = OperationOutput<SendBounceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBounceOutputError>
}

public struct SendBounceInputQueryItemMiddleware: Middleware {
    public let id: String = "SendBounceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBounceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBounceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBounceInput>
    public typealias MOutput = OperationOutput<SendBounceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBounceOutputError>
}

/// <p>Represents a request to send a bounce message to the sender of an email you received
///             through Amazon SES.</p>
public struct SendBounceInput: Equatable {
    /// <p>The address to use in the "From" header of the bounce message. This must be an
    ///             identity that you have verified with Amazon SES.</p>
    public let bounceSender: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             address in the "From" header of the bounce. For more information about sending
    ///             authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let bounceSenderArn: String?
    /// <p>A list of recipients of the bounced message, including the information required to
    ///             create the Delivery Status Notifications (DSNs) for the recipients. You must specify at
    ///             least one <code>BouncedRecipientInfo</code> in the list.</p>
    public let bouncedRecipientInfoList: [BouncedRecipientInfo]?
    /// <p>Human-readable text for the bounce message to explain the failure. If not specified,
    ///             the text will be auto-generated based on the bounced recipient information.</p>
    public let explanation: String?
    /// <p>Message-related DSN fields. If not specified, Amazon SES will choose the values.</p>
    public let messageDsn: MessageDsn?
    /// <p>The message ID of the message to be bounced.</p>
    public let originalMessageId: String?

    public init (
        bounceSender: String? = nil,
        bounceSenderArn: String? = nil,
        bouncedRecipientInfoList: [BouncedRecipientInfo]? = nil,
        explanation: String? = nil,
        messageDsn: MessageDsn? = nil,
        originalMessageId: String? = nil
    )
    {
        self.bounceSender = bounceSender
        self.bounceSenderArn = bounceSenderArn
        self.bouncedRecipientInfoList = bouncedRecipientInfoList
        self.explanation = explanation
        self.messageDsn = messageDsn
        self.originalMessageId = originalMessageId
    }
}

extension SendBounceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendBounceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendBounceOutputError: Equatable {
    case messageRejected(MessageRejected)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendBounceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBounceOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendBounceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendBounceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>Represents a unique message ID.</p>
public struct SendBounceOutputResponse: Equatable {
    /// <p>The message ID of the bounce message.</p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendBounceOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendBounceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendBounceResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

public struct SendBulkTemplatedEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendBulkTemplatedEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendBulkTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkTemplatedEmailOutputError>
}

extension SendBulkTemplatedEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBulkTemplatedEmailInput(configurationSetName: \(String(describing: configurationSetName)), defaultTags: \(String(describing: defaultTags)), defaultTemplateData: \(String(describing: defaultTemplateData)), destinations: \(String(describing: destinations)), replyToAddresses: \(String(describing: replyToAddresses)), returnPath: \(String(describing: returnPath)), returnPathArn: \(String(describing: returnPathArn)), source: \(String(describing: source)), sourceArn: \(String(describing: sourceArn)), template: \(String(describing: template)), templateArn: \(String(describing: templateArn)))"}
}

extension SendBulkTemplatedEmailInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let defaultTags = defaultTags {
            var defaultTagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DefaultTags"))
            for (index0, messagetag0) in defaultTags.enumerated() {
                try defaultTagsContainer.encode(messagetag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultTemplateData = defaultTemplateData {
            try container.encode(defaultTemplateData, forKey: Key("DefaultTemplateData"))
        }
        if let destinations = destinations {
            var destinationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Destinations"))
            for (index0, bulkemaildestination0) in destinations.enumerated() {
                try destinationsContainer.encode(bulkemaildestination0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplyToAddresses"))
            for (index0, address0) in replyToAddresses.enumerated() {
                try replyToAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let returnPath = returnPath {
            try container.encode(returnPath, forKey: Key("ReturnPath"))
        }
        if let returnPathArn = returnPathArn {
            try container.encode(returnPathArn, forKey: Key("ReturnPathArn"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let template = template {
            try container.encode(template, forKey: Key("Template"))
        }
        if let templateArn = templateArn {
            try container.encode(templateArn, forKey: Key("TemplateArn"))
        }
        try container.encode("SendBulkTemplatedEmail", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendBulkTemplatedEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendBulkTemplatedEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendBulkTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkTemplatedEmailOutputError>
}

public struct SendBulkTemplatedEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendBulkTemplatedEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendBulkTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendBulkTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendBulkTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendBulkTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendBulkTemplatedEmailOutputError>
}

/// <p>Represents a request to send a templated email to multiple destinations using Amazon SES.
///             For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SendBulkTemplatedEmailInput: Equatable {
    /// <p>The name of the configuration set to use when you send an email using
    ///                 <code>SendBulkTemplatedEmail</code>.</p>
    public let configurationSetName: String?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send to
    ///             a destination using <code>SendBulkTemplatedEmail</code>.</p>
    public let defaultTags: [MessageTag]?
    /// <p>A list of replacement values to apply to the template when replacement data is not
    ///             specified in a Destination object. These values act as a default or fallback option when
    ///             no other data is available.</p>
    ///         <p>The template data is a JSON object, typically consisting of key-value pairs in which
    ///             the keys correspond to replacement tags in the email template.</p>
    public let defaultTemplateData: String?
    /// <p>One or more <code>Destination</code> objects. All of the recipients in a
    ///                 <code>Destination</code> will receive the same version of the email. You can specify
    ///             up to 50 <code>Destination</code> objects within a <code>Destinations</code>
    ///             array.</p>
    public let destinations: [BulkEmailDestination]?
    /// <p>The reply-to email address(es) for the message. If the recipient replies to the
    ///             message, each reply-to address will receive the reply.</p>
    public let replyToAddresses: [String]?
    /// <p>The email address that bounces and complaints will be forwarded to when feedback
    ///             forwarding is enabled. If the message cannot be delivered to the recipient, then an
    ///             error message will be returned from the recipient's ISP; this message will then be
    ///             forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
    ///                 <code>ReturnPath</code> parameter is never overwritten. This email address must be
    ///             either individually verified with Amazon SES, or from a domain that has been verified with
    ///             Amazon SES. </p>
    public let returnPath: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>ReturnPath</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to use <code>feedback@example.com</code>, then you
    ///             would specify the <code>ReturnPathArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let returnPathArn: String?
    /// <p>The email address that is sending the email. This email address must be either
    ///             individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
    ///             For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///         <p>If you are sending on behalf of another user and have been permitted to do so by a
    ///             sending authorization policy, then you must also specify the <code>SourceArn</code>
    ///             parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                     <i>local part</i> of a source email address (the part of the email
    ///                 address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the <i>domain part</i> of an address (the
    ///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
    ///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
    ///                     name</i>) may contain non-ASCII characters. These characters must be
    ///                 encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
    ///                 syntax uses the following form:
    ///                 <code>=?charset?encoding?encoded-text?=</code>.</p>
    ///         </note>
    public let source: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to send for
    ///             the email address specified in the <code>Source</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to send from <code>user@example.com</code>, then you
    ///             would specify the <code>SourceArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>Source</code> to be <code>user@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let sourceArn: String?
    /// <p>The template to use when sending this email.</p>
    public let template: String?
    /// <p>The ARN of the template to use when sending this email.</p>
    public let templateArn: String?

    public init (
        configurationSetName: String? = nil,
        defaultTags: [MessageTag]? = nil,
        defaultTemplateData: String? = nil,
        destinations: [BulkEmailDestination]? = nil,
        replyToAddresses: [String]? = nil,
        returnPath: String? = nil,
        returnPathArn: String? = nil,
        source: String? = nil,
        sourceArn: String? = nil,
        template: String? = nil,
        templateArn: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.defaultTags = defaultTags
        self.defaultTemplateData = defaultTemplateData
        self.destinations = destinations
        self.replyToAddresses = replyToAddresses
        self.returnPath = returnPath
        self.returnPathArn = returnPathArn
        self.source = source
        self.sourceArn = sourceArn
        self.template = template
        self.templateArn = templateArn
    }
}

extension SendBulkTemplatedEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendBulkTemplatedEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSendingPausedException" : self = .accountSendingPausedException(try AccountSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetSendingPausedException" : self = .configurationSetSendingPausedException(try ConfigurationSetSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplateDoesNotExistException" : self = .templateDoesNotExistException(try TemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendBulkTemplatedEmailOutputError: Equatable {
    case accountSendingPausedException(AccountSendingPausedException)
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case configurationSetSendingPausedException(ConfigurationSetSendingPausedException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case templateDoesNotExistException(TemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendBulkTemplatedEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendBulkTemplatedEmailOutputResponse(status: \(String(describing: status)))"}
}

extension SendBulkTemplatedEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendBulkTemplatedEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct SendBulkTemplatedEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the <code>SendBulkTemplatedEmail</code>
    ///             action.</p>
    public let status: [BulkEmailDestinationStatus]?

    public init (
        status: [BulkEmailDestinationStatus]? = nil
    )
    {
        self.status = status
    }
}

struct SendBulkTemplatedEmailOutputResponseBody: Equatable {
    public let status: [BulkEmailDestinationStatus]?
}

extension SendBulkTemplatedEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendBulkTemplatedEmailResult"))
        if containerValues.contains(.status) {
            struct KeyVal0{struct member{}}
            let statusWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .status)
            if let statusWrappedContainer = statusWrappedContainer {
                let statusContainer = try statusWrappedContainer.decodeIfPresent([BulkEmailDestinationStatus].self, forKey: .member)
                var statusBuffer:[BulkEmailDestinationStatus]? = nil
                if let statusContainer = statusContainer {
                    statusBuffer = [BulkEmailDestinationStatus]()
                    for structureContainer0 in statusContainer {
                        statusBuffer?.append(structureContainer0)
                    }
                }
                status = statusBuffer
            } else {
                status = []
            }
        } else {
            status = nil
        }
    }
}

public struct SendCustomVerificationEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

extension SendCustomVerificationEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCustomVerificationEmailInput(configurationSetName: \(String(describing: configurationSetName)), emailAddress: \(String(describing: emailAddress)), templateName: \(String(describing: templateName)))"}
}

extension SendCustomVerificationEmailInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: Key("EmailAddress"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("SendCustomVerificationEmail", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendCustomVerificationEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

public struct SendCustomVerificationEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendCustomVerificationEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCustomVerificationEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCustomVerificationEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCustomVerificationEmailInput>
    public typealias MOutput = OperationOutput<SendCustomVerificationEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCustomVerificationEmailOutputError>
}

/// <p>Represents a request to send a custom verification email to a specified
///             recipient.</p>
public struct SendCustomVerificationEmailInput: Equatable {
    /// <p>Name of a configuration set to use when sending the verification email.</p>
    public let configurationSetName: String?
    /// <p>The email address to verify.</p>
    public let emailAddress: String?
    /// <p>The name of the custom verification email template to use when sending the
    ///             verification email.</p>
    public let templateName: String?

    public init (
        configurationSetName: String? = nil,
        emailAddress: String? = nil,
        templateName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.emailAddress = emailAddress
        self.templateName = templateName
    }
}

extension SendCustomVerificationEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendCustomVerificationEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomVerificationEmailTemplateDoesNotExistException" : self = .customVerificationEmailTemplateDoesNotExistException(try CustomVerificationEmailTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FromEmailAddressNotVerifiedException" : self = .fromEmailAddressNotVerifiedException(try FromEmailAddressNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProductionAccessNotGrantedException" : self = .productionAccessNotGrantedException(try ProductionAccessNotGrantedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCustomVerificationEmailOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case customVerificationEmailTemplateDoesNotExistException(CustomVerificationEmailTemplateDoesNotExistException)
    case fromEmailAddressNotVerifiedException(FromEmailAddressNotVerifiedException)
    case messageRejected(MessageRejected)
    case productionAccessNotGrantedException(ProductionAccessNotGrantedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCustomVerificationEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCustomVerificationEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendCustomVerificationEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendCustomVerificationEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>The response received when attempting to send the custom verification email.</p>
public struct SendCustomVerificationEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the
    ///                 <code>SendCustomVerificationEmail</code> operation.</p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendCustomVerificationEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendCustomVerificationEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendCustomVerificationEmailResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SendDataPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bounces = "Bounces"
        case complaints = "Complaints"
        case deliveryAttempts = "DeliveryAttempts"
        case rejects = "Rejects"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if bounces != 0 {
            try container.encode(bounces, forKey: Key("Bounces"))
        }
        if complaints != 0 {
            try container.encode(complaints, forKey: Key("Complaints"))
        }
        if deliveryAttempts != 0 {
            try container.encode(deliveryAttempts, forKey: Key("DeliveryAttempts"))
        }
        if rejects != 0 {
            try container.encode(rejects, forKey: Key("Rejects"))
        }
        if let timestamp = timestamp {
            try container.encode(TimestampWrapper(timestamp, format: .dateTime), forKey: Key("timestamp"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        var timestampBuffer:Date? = nil
        if let timestampDecoded = timestampDecoded {
            timestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(timestampDecoded, format: .dateTime)
        }
        timestamp = timestampBuffer
        let deliveryAttemptsDecoded = try containerValues.decode(Int.self, forKey: .deliveryAttempts)
        deliveryAttempts = deliveryAttemptsDecoded
        let bouncesDecoded = try containerValues.decode(Int.self, forKey: .bounces)
        bounces = bouncesDecoded
        let complaintsDecoded = try containerValues.decode(Int.self, forKey: .complaints)
        complaints = complaintsDecoded
        let rejectsDecoded = try containerValues.decode(Int.self, forKey: .rejects)
        rejects = rejectsDecoded
    }
}

extension SendDataPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendDataPoint(bounces: \(String(describing: bounces)), complaints: \(String(describing: complaints)), deliveryAttempts: \(String(describing: deliveryAttempts)), rejects: \(String(describing: rejects)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Represents sending statistics data. Each <code>SendDataPoint</code> contains
///             statistics for a 15-minute period of sending activity. </p>
public struct SendDataPoint: Equatable {
    /// <p>Number of emails that have bounced.</p>
    public let bounces: Int
    /// <p>Number of unwanted emails that were rejected by recipients.</p>
    public let complaints: Int
    /// <p>Number of emails that have been sent.</p>
    public let deliveryAttempts: Int
    /// <p>Number of emails rejected by Amazon SES.</p>
    public let rejects: Int
    /// <p>Time of the data point.</p>
    public let timestamp: Date?

    public init (
        bounces: Int = 0,
        complaints: Int = 0,
        deliveryAttempts: Int = 0,
        rejects: Int = 0,
        timestamp: Date? = nil
    )
    {
        self.bounces = bounces
        self.complaints = complaints
        self.deliveryAttempts = deliveryAttempts
        self.rejects = rejects
        self.timestamp = timestamp
    }
}

public struct SendEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

extension SendEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailInput(configurationSetName: \(String(describing: configurationSetName)), destination: \(String(describing: destination)), message: \(String(describing: message)), replyToAddresses: \(String(describing: replyToAddresses)), returnPath: \(String(describing: returnPath)), returnPathArn: \(String(describing: returnPathArn)), source: \(String(describing: source)), sourceArn: \(String(describing: sourceArn)), tags: \(String(describing: tags)))"}
}

extension SendEmailInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("Destination"))
        }
        if let message = message {
            try container.encode(message, forKey: Key("Message"))
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplyToAddresses"))
            for (index0, address0) in replyToAddresses.enumerated() {
                try replyToAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let returnPath = returnPath {
            try container.encode(returnPath, forKey: Key("ReturnPath"))
        }
        if let returnPathArn = returnPathArn {
            try container.encode(returnPathArn, forKey: Key("ReturnPathArn"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, messagetag0) in tags.enumerated() {
                try tagsContainer.encode(messagetag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SendEmail", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

public struct SendEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendEmailInput>
    public typealias MOutput = OperationOutput<SendEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendEmailOutputError>
}

/// <p>Represents a request to send a single formatted email using Amazon SES. For more
///             information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-formatted.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SendEmailInput: Equatable {
    /// <p>The name of the configuration set to use when you send an email using
    ///                 <code>SendEmail</code>.</p>
    public let configurationSetName: String?
    /// <p>The destination for this email, composed of To:, CC:, and BCC: fields.</p>
    public let destination: Destination?
    /// <p>The message to be sent.</p>
    public let message: Message?
    /// <p>The reply-to email address(es) for the message. If the recipient replies to the
    ///             message, each reply-to address will receive the reply.</p>
    public let replyToAddresses: [String]?
    /// <p>The email address that bounces and complaints will be forwarded to when feedback
    ///             forwarding is enabled. If the message cannot be delivered to the recipient, then an
    ///             error message will be returned from the recipient's ISP; this message will then be
    ///             forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
    ///                 <code>ReturnPath</code> parameter is never overwritten. This email address must be
    ///             either individually verified with Amazon SES, or from a domain that has been verified with
    ///             Amazon SES. </p>
    public let returnPath: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>ReturnPath</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to use <code>feedback@example.com</code>, then you
    ///             would specify the <code>ReturnPathArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let returnPathArn: String?
    /// <p>The email address that is sending the email. This email address must be either
    ///             individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
    ///             For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///         <p>If you are sending on behalf of another user and have been permitted to do so by a
    ///             sending authorization policy, then you must also specify the <code>SourceArn</code>
    ///             parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                     <i>local part</i> of a source email address (the part of the email
    ///                 address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the <i>domain part</i> of an address (the
    ///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
    ///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
    ///                     name</i>) may contain non-ASCII characters. These characters must be
    ///                 encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
    ///                 syntax uses the following form:
    ///                 <code>=?charset?encoding?encoded-text?=</code>.</p>
    ///         </note>
    public let source: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to send for
    ///             the email address specified in the <code>Source</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to send from <code>user@example.com</code>, then you
    ///             would specify the <code>SourceArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>Source</code> to be <code>user@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let sourceArn: String?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using <code>SendEmail</code>. Tags correspond to characteristics of the email that you
    ///             define, so that you can publish email sending events.</p>
    public let tags: [MessageTag]?

    public init (
        configurationSetName: String? = nil,
        destination: Destination? = nil,
        message: Message? = nil,
        replyToAddresses: [String]? = nil,
        returnPath: String? = nil,
        returnPathArn: String? = nil,
        source: String? = nil,
        sourceArn: String? = nil,
        tags: [MessageTag]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.destination = destination
        self.message = message
        self.replyToAddresses = replyToAddresses
        self.returnPath = returnPath
        self.returnPathArn = returnPathArn
        self.source = source
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

extension SendEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSendingPausedException" : self = .accountSendingPausedException(try AccountSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetSendingPausedException" : self = .configurationSetSendingPausedException(try ConfigurationSetSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEmailOutputError: Equatable {
    case accountSendingPausedException(AccountSendingPausedException)
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case configurationSetSendingPausedException(ConfigurationSetSendingPausedException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>Represents a unique message ID.</p>
public struct SendEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the <code>SendEmail</code> action. </p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendEmailResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

public struct SendRawEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendRawEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendRawEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendRawEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendRawEmailInput>
    public typealias MOutput = OperationOutput<SendRawEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendRawEmailOutputError>
}

extension SendRawEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendRawEmailInput(configurationSetName: \(String(describing: configurationSetName)), destinations: \(String(describing: destinations)), fromArn: \(String(describing: fromArn)), rawMessage: \(String(describing: rawMessage)), returnPathArn: \(String(describing: returnPathArn)), source: \(String(describing: source)), sourceArn: \(String(describing: sourceArn)), tags: \(String(describing: tags)))"}
}

extension SendRawEmailInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let destinations = destinations {
            var destinationsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Destinations"))
            for (index0, address0) in destinations.enumerated() {
                try destinationsContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let fromArn = fromArn {
            try container.encode(fromArn, forKey: Key("FromArn"))
        }
        if let rawMessage = rawMessage {
            try container.encode(rawMessage, forKey: Key("RawMessage"))
        }
        if let returnPathArn = returnPathArn {
            try container.encode(returnPathArn, forKey: Key("ReturnPathArn"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, messagetag0) in tags.enumerated() {
                try tagsContainer.encode(messagetag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SendRawEmail", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendRawEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendRawEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendRawEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendRawEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendRawEmailInput>
    public typealias MOutput = OperationOutput<SendRawEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendRawEmailOutputError>
}

public struct SendRawEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendRawEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendRawEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendRawEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendRawEmailInput>
    public typealias MOutput = OperationOutput<SendRawEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendRawEmailOutputError>
}

/// <p>Represents a request to send a single raw email using Amazon SES. For more information, see
///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-raw.html">Amazon SES Developer Guide</a>.</p>
public struct SendRawEmailInput: Equatable {
    /// <p>The name of the configuration set to use when you send an email using
    ///                 <code>SendRawEmail</code>.</p>
    public let configurationSetName: String?
    /// <p>A list of destinations for the message, consisting of To:, CC:, and BCC:
    ///             addresses.</p>
    public let destinations: [String]?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to specify a
    ///             particular "From" address in the header of the raw email.</p>
    ///         <p>Instead of using this parameter, you can use the X-header <code>X-SES-FROM-ARN</code>
    ///             in the raw message of the email. If you use both the <code>FromArn</code> parameter and
    ///             the corresponding X-header, Amazon SES uses the value of the <code>FromArn</code>
    ///             parameter.</p>
    ///         <note>
    ///             <p>For information about when to use this parameter, see the description of
    ///                     <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
    ///         </note>
    public let fromArn: String?
    /// <p>The raw email message itself. The message has to meet the following criteria:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The message has to contain a header and a body, separated by a blank
    ///                     line.</p>
    ///             </li>
    ///             <li>
    ///                 <p>All of the required header fields must be present in the message.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Attachments must be of a content type that Amazon SES supports. For a list on
    ///                     unsupported content types, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mime-types.html">Unsupported Attachment
    ///                         Types</a> in the <i>Amazon SES Developer Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The entire message must be base64-encoded.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If any of the MIME parts in your message contain content that is outside of
    ///                     the 7-bit ASCII character range, we highly recommend that you encode that
    ///                     content. For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-raw.html">Sending Raw Email</a> in the <i>Amazon SES Developer
    ///                     Guide</i>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Per <a href="https://tools.ietf.org/html/rfc5321#section-4.5.3.1.6">RFC
    ///                         5321</a>, the maximum length of each line of text, including the
    ///                     <CRLF>, must not exceed 1,000 characters.</p>
    ///             </li>
    ///          </ul>
    public let rawMessage: RawMessage?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>ReturnPath</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to use <code>feedback@example.com</code>, then you
    ///             would specify the <code>ReturnPathArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
    ///         <p>Instead of using this parameter, you can use the X-header
    ///                 <code>X-SES-RETURN-PATH-ARN</code> in the raw message of the email. If you use both
    ///             the <code>ReturnPathArn</code> parameter and the corresponding X-header, Amazon SES uses the
    ///             value of the <code>ReturnPathArn</code> parameter.</p>
    ///         <note>
    ///             <p>For information about when to use this parameter, see the description of
    ///                     <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
    ///         </note>
    public let returnPathArn: String?
    /// <p>The identity's email address. If you do not provide a value for this parameter, you
    ///             must specify a "From" address in the raw text of the message. (You can also specify
    ///             both.)</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in<a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                     <i>local part</i> of a source email address (the part of the email
    ///                 address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the <i>domain part</i> of an address (the
    ///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
    ///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
    ///                     name</i>) may contain non-ASCII characters. These characters must be
    ///                 encoded using MIME encoded-word syntax, as described in <a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
    ///                 syntax uses the following form:
    ///                 <code>=?charset?encoding?encoded-text?=</code>.</p>
    ///         </note>
    ///
    ///         <p>If you specify the <code>Source</code> parameter and have feedback forwarding enabled,
    ///             then bounces and complaints will be sent to this email address. This takes precedence
    ///             over any Return-Path header that you might include in the raw text of the
    ///             message.</p>
    public let source: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to send for
    ///             the email address specified in the <code>Source</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to send from <code>user@example.com</code>, then you
    ///             would specify the <code>SourceArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>Source</code> to be <code>user@example.com</code>.</p>
    ///         <p>Instead of using this parameter, you can use the X-header
    ///                 <code>X-SES-SOURCE-ARN</code> in the raw message of the email. If you use both the
    ///                 <code>SourceArn</code> parameter and the corresponding X-header, Amazon SES uses the
    ///             value of the <code>SourceArn</code> parameter.</p>
    ///         <note>
    ///             <p>For information about when to use this parameter, see the description of
    ///                     <code>SendRawEmail</code> in this guide, or see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-delegate-sender-tasks-email.html">Amazon SES Developer Guide</a>.</p>
    ///         </note>
    public let sourceArn: String?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using <code>SendRawEmail</code>. Tags correspond to characteristics of the email that
    ///             you define, so that you can publish email sending events.</p>
    public let tags: [MessageTag]?

    public init (
        configurationSetName: String? = nil,
        destinations: [String]? = nil,
        fromArn: String? = nil,
        rawMessage: RawMessage? = nil,
        returnPathArn: String? = nil,
        source: String? = nil,
        sourceArn: String? = nil,
        tags: [MessageTag]? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.destinations = destinations
        self.fromArn = fromArn
        self.rawMessage = rawMessage
        self.returnPathArn = returnPathArn
        self.source = source
        self.sourceArn = sourceArn
        self.tags = tags
    }
}

extension SendRawEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendRawEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSendingPausedException" : self = .accountSendingPausedException(try AccountSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetSendingPausedException" : self = .configurationSetSendingPausedException(try ConfigurationSetSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendRawEmailOutputError: Equatable {
    case accountSendingPausedException(AccountSendingPausedException)
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case configurationSetSendingPausedException(ConfigurationSetSendingPausedException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendRawEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendRawEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendRawEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendRawEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// <p>Represents a unique message ID.</p>
public struct SendRawEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the <code>SendRawEmail</code> action.
    ///         </p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendRawEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendRawEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendRawEmailResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

public struct SendTemplatedEmailInputBodyMiddleware: Middleware {
    public let id: String = "SendTemplatedEmailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTemplatedEmailOutputError>
}

extension SendTemplatedEmailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTemplatedEmailInput(configurationSetName: \(String(describing: configurationSetName)), destination: \(String(describing: destination)), replyToAddresses: \(String(describing: replyToAddresses)), returnPath: \(String(describing: returnPath)), returnPathArn: \(String(describing: returnPathArn)), source: \(String(describing: source)), sourceArn: \(String(describing: sourceArn)), tags: \(String(describing: tags)), template: \(String(describing: template)), templateArn: \(String(describing: templateArn)), templateData: \(String(describing: templateData)))"}
}

extension SendTemplatedEmailInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let destination = destination {
            try container.encode(destination, forKey: Key("Destination"))
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ReplyToAddresses"))
            for (index0, address0) in replyToAddresses.enumerated() {
                try replyToAddressesContainer.encode(address0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let returnPath = returnPath {
            try container.encode(returnPath, forKey: Key("ReturnPath"))
        }
        if let returnPathArn = returnPathArn {
            try container.encode(returnPathArn, forKey: Key("ReturnPathArn"))
        }
        if let source = source {
            try container.encode(source, forKey: Key("Source"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: Key("SourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, messagetag0) in tags.enumerated() {
                try tagsContainer.encode(messagetag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let template = template {
            try container.encode(template, forKey: Key("Template"))
        }
        if let templateArn = templateArn {
            try container.encode(templateArn, forKey: Key("TemplateArn"))
        }
        if let templateData = templateData {
            try container.encode(templateData, forKey: Key("TemplateData"))
        }
        try container.encode("SendTemplatedEmail", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SendTemplatedEmailInputHeadersMiddleware: Middleware {
    public let id: String = "SendTemplatedEmailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTemplatedEmailOutputError>
}

public struct SendTemplatedEmailInputQueryItemMiddleware: Middleware {
    public let id: String = "SendTemplatedEmailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendTemplatedEmailInput>,
                  next: H) -> Swift.Result<OperationOutput<SendTemplatedEmailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendTemplatedEmailInput>
    public typealias MOutput = OperationOutput<SendTemplatedEmailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendTemplatedEmailOutputError>
}

/// <p>Represents a request to send a templated email using Amazon SES. For more information, see
///             the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SendTemplatedEmailInput: Equatable {
    /// <p>The name of the configuration set to use when you send an email using
    ///                 <code>SendTemplatedEmail</code>.</p>
    public let configurationSetName: String?
    /// <p>The destination for this email, composed of To:, CC:, and BCC: fields. A Destination
    ///             can include up to 50 recipients across these three fields.</p>
    public let destination: Destination?
    /// <p>The reply-to email address(es) for the message. If the recipient replies to the
    ///             message, each reply-to address will receive the reply.</p>
    public let replyToAddresses: [String]?
    /// <p>The email address that bounces and complaints will be forwarded to when feedback
    ///             forwarding is enabled. If the message cannot be delivered to the recipient, then an
    ///             error message will be returned from the recipient's ISP; this message will then be
    ///             forwarded to the email address specified by the <code>ReturnPath</code> parameter. The
    ///                 <code>ReturnPath</code> parameter is never overwritten. This email address must be
    ///             either individually verified with Amazon SES, or from a domain that has been verified with
    ///             Amazon SES. </p>
    public let returnPath: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to use the
    ///             email address specified in the <code>ReturnPath</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to use <code>feedback@example.com</code>, then you
    ///             would specify the <code>ReturnPathArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>ReturnPath</code> to be <code>feedback@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let returnPathArn: String?
    /// <p>The email address that is sending the email. This email address must be either
    ///             individually verified with Amazon SES, or from a domain that has been verified with Amazon SES.
    ///             For information about verifying identities, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-addresses-and-domains.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    ///         <p>If you are sending on behalf of another user and have been permitted to do so by a
    ///             sending authorization policy, then you must also specify the <code>SourceArn</code>
    ///             parameter. For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer Guide</a>.</p>
    ///         <note>
    ///             <p>Amazon SES does not support the SMTPUTF8 extension, as described in <a href="https://tools.ietf.org/html/rfc6531">RFC6531</a>. For this reason, the
    ///                     <i>local part</i> of a source email address (the part of the email
    ///                 address that precedes the @ sign) may only contain <a href="https://en.wikipedia.org/wiki/Email_address#Local-part">7-bit ASCII
    ///                     characters</a>. If the <i>domain part</i> of an address (the
    ///                 part after the @ sign) contains non-ASCII characters, they must be encoded using
    ///                 Punycode, as described in <a href="https://tools.ietf.org/html/rfc3492.html">RFC3492</a>. The sender name (also known as the <i>friendly
    ///                     name</i>) may contain non-ASCII characters. These characters must be
    ///                 encoded using MIME encoded-word syntax, as described in<a href="https://tools.ietf.org/html/rfc2047">RFC 2047</a>. MIME encoded-word
    ///                 syntax uses the following form:
    ///                 <code>=?charset?encoding?encoded-text?=</code>.</p>
    ///         </note>
    public let source: String?
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    ///             that is associated with the sending authorization policy that permits you to send for
    ///             the email address specified in the <code>Source</code> parameter.</p>
    ///         <p>For example, if the owner of <code>example.com</code> (which has ARN
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>) attaches a
    ///             policy to it that authorizes you to send from <code>user@example.com</code>, then you
    ///             would specify the <code>SourceArn</code> to be
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>, and the
    ///                 <code>Source</code> to be <code>user@example.com</code>.</p>
    ///         <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let sourceArn: String?
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    ///             using <code>SendTemplatedEmail</code>. Tags correspond to characteristics of the email
    ///             that you define, so that you can publish email sending events.</p>
    public let tags: [MessageTag]?
    /// <p>The template to use when sending this email.</p>
    public let template: String?
    /// <p>The ARN of the template to use when sending this email.</p>
    public let templateArn: String?
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    ///             object, typically consisting of key-value pairs in which the keys correspond to
    ///             replacement tags in the email template.</p>
    public let templateData: String?

    public init (
        configurationSetName: String? = nil,
        destination: Destination? = nil,
        replyToAddresses: [String]? = nil,
        returnPath: String? = nil,
        returnPathArn: String? = nil,
        source: String? = nil,
        sourceArn: String? = nil,
        tags: [MessageTag]? = nil,
        template: String? = nil,
        templateArn: String? = nil,
        templateData: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.destination = destination
        self.replyToAddresses = replyToAddresses
        self.returnPath = returnPath
        self.returnPathArn = returnPathArn
        self.source = source
        self.sourceArn = sourceArn
        self.tags = tags
        self.template = template
        self.templateArn = templateArn
        self.templateData = templateData
    }
}

extension SendTemplatedEmailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SendTemplatedEmailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccountSendingPausedException" : self = .accountSendingPausedException(try AccountSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConfigurationSetSendingPausedException" : self = .configurationSetSendingPausedException(try ConfigurationSetSendingPausedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailFromDomainNotVerifiedException" : self = .mailFromDomainNotVerifiedException(try MailFromDomainNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplateDoesNotExistException" : self = .templateDoesNotExistException(try TemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendTemplatedEmailOutputError: Equatable {
    case accountSendingPausedException(AccountSendingPausedException)
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case configurationSetSendingPausedException(ConfigurationSetSendingPausedException)
    case mailFromDomainNotVerifiedException(MailFromDomainNotVerifiedException)
    case messageRejected(MessageRejected)
    case templateDoesNotExistException(TemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendTemplatedEmailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendTemplatedEmailOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendTemplatedEmailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendTemplatedEmailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendTemplatedEmailOutputResponse: Equatable {
    /// <p>The unique message identifier returned from the <code>SendTemplatedEmail</code>
    ///             action. </p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendTemplatedEmailOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendTemplatedEmailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SendTemplatedEmailResult"))
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

public struct SetActiveReceiptRuleSetInputBodyMiddleware: Middleware {
    public let id: String = "SetActiveReceiptRuleSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<SetActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<SetActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetActiveReceiptRuleSetOutputError>
}

extension SetActiveReceiptRuleSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetActiveReceiptRuleSetInput(ruleSetName: \(String(describing: ruleSetName)))"}
}

extension SetActiveReceiptRuleSetInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("SetActiveReceiptRuleSet", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetActiveReceiptRuleSetInputHeadersMiddleware: Middleware {
    public let id: String = "SetActiveReceiptRuleSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<SetActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<SetActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetActiveReceiptRuleSetOutputError>
}

public struct SetActiveReceiptRuleSetInputQueryItemMiddleware: Middleware {
    public let id: String = "SetActiveReceiptRuleSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetActiveReceiptRuleSetInput>,
                  next: H) -> Swift.Result<OperationOutput<SetActiveReceiptRuleSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetActiveReceiptRuleSetInput>
    public typealias MOutput = OperationOutput<SetActiveReceiptRuleSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetActiveReceiptRuleSetOutputError>
}

/// <p>Represents a request to set a receipt rule set as the active receipt rule set. You use
///             receipt rule sets to receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct SetActiveReceiptRuleSetInput: Equatable {
    /// <p>The name of the receipt rule set to make active. Setting this value to null disables
    ///             all email receiving.</p>
    public let ruleSetName: String?

    public init (
        ruleSetName: String? = nil
    )
    {
        self.ruleSetName = ruleSetName
    }
}

extension SetActiveReceiptRuleSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetActiveReceiptRuleSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetActiveReceiptRuleSetOutputError: Equatable {
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetActiveReceiptRuleSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetActiveReceiptRuleSetOutputResponse()"}
}

extension SetActiveReceiptRuleSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetActiveReceiptRuleSetOutputResponse: Equatable {

    public init() {}
}

struct SetActiveReceiptRuleSetOutputResponseBody: Equatable {
}

extension SetActiveReceiptRuleSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityDkimEnabledInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityDkimEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityDkimEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityDkimEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityDkimEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityDkimEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityDkimEnabledOutputError>
}

extension SetIdentityDkimEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityDkimEnabledInput(dkimEnabled: \(String(describing: dkimEnabled)), identity: \(String(describing: identity)))"}
}

extension SetIdentityDkimEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if dkimEnabled != false {
            try container.encode(dkimEnabled, forKey: Key("DkimEnabled"))
        }
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        try container.encode("SetIdentityDkimEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetIdentityDkimEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityDkimEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityDkimEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityDkimEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityDkimEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityDkimEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityDkimEnabledOutputError>
}

public struct SetIdentityDkimEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityDkimEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityDkimEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityDkimEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityDkimEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityDkimEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityDkimEnabledOutputError>
}

/// <p>Represents a request to enable or disable Amazon SES Easy DKIM signing for an identity. For
///             more information about setting up Easy DKIM, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer Guide</a>.</p>
public struct SetIdentityDkimEnabledInput: Equatable {
    /// <p>Sets whether DKIM signing is enabled for an identity. Set to <code>true</code> to
    ///             enable DKIM signing for this identity; <code>false</code> to disable it. </p>
    public let dkimEnabled: Bool
    /// <p>The identity for which DKIM signing should be enabled or disabled.</p>
    public let identity: String?

    public init (
        dkimEnabled: Bool = false,
        identity: String? = nil
    )
    {
        self.dkimEnabled = dkimEnabled
        self.identity = identity
    }
}

extension SetIdentityDkimEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIdentityDkimEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityDkimEnabledOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityDkimEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityDkimEnabledOutputResponse()"}
}

extension SetIdentityDkimEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetIdentityDkimEnabledOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityDkimEnabledOutputResponseBody: Equatable {
}

extension SetIdentityDkimEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityFeedbackForwardingEnabledInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityFeedbackForwardingEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityFeedbackForwardingEnabledOutputError>
}

extension SetIdentityFeedbackForwardingEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityFeedbackForwardingEnabledInput(forwardingEnabled: \(String(describing: forwardingEnabled)), identity: \(String(describing: identity)))"}
}

extension SetIdentityFeedbackForwardingEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if forwardingEnabled != false {
            try container.encode(forwardingEnabled, forKey: Key("ForwardingEnabled"))
        }
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        try container.encode("SetIdentityFeedbackForwardingEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetIdentityFeedbackForwardingEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityFeedbackForwardingEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityFeedbackForwardingEnabledOutputError>
}

public struct SetIdentityFeedbackForwardingEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityFeedbackForwardingEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityFeedbackForwardingEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityFeedbackForwardingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityFeedbackForwardingEnabledOutputError>
}

/// <p>Represents a request to enable or disable whether Amazon SES forwards you bounce and
///             complaint notifications through email. For information about email feedback forwarding,
///             see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications-via-email.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SetIdentityFeedbackForwardingEnabledInput: Equatable {
    /// <p>Sets whether Amazon SES will forward bounce and complaint notifications as email.
    ///                 <code>true</code> specifies that Amazon SES will forward bounce and complaint
    ///             notifications as email, in addition to any Amazon SNS topic publishing otherwise specified.
    ///                 <code>false</code> specifies that Amazon SES will publish bounce and complaint
    ///             notifications only through Amazon SNS. This value can only be set to <code>false</code> when
    ///             Amazon SNS topics are set for both <code>Bounce</code> and <code>Complaint</code>
    ///             notification types.</p>
    public let forwardingEnabled: Bool
    /// <p>The identity for which to set bounce and complaint notification forwarding. Examples:
    ///                 <code>user@example.com</code>, <code>example.com</code>.</p>
    public let identity: String?

    public init (
        forwardingEnabled: Bool = false,
        identity: String? = nil
    )
    {
        self.forwardingEnabled = forwardingEnabled
        self.identity = identity
    }
}

extension SetIdentityFeedbackForwardingEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIdentityFeedbackForwardingEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityFeedbackForwardingEnabledOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityFeedbackForwardingEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityFeedbackForwardingEnabledOutputResponse()"}
}

extension SetIdentityFeedbackForwardingEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetIdentityFeedbackForwardingEnabledOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityFeedbackForwardingEnabledOutputResponseBody: Equatable {
}

extension SetIdentityFeedbackForwardingEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityHeadersInNotificationsEnabledInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityHeadersInNotificationsEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityHeadersInNotificationsEnabledOutputError>
}

extension SetIdentityHeadersInNotificationsEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityHeadersInNotificationsEnabledInput(enabled: \(String(describing: enabled)), identity: \(String(describing: identity)), notificationType: \(String(describing: notificationType)))"}
}

extension SetIdentityHeadersInNotificationsEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let notificationType = notificationType {
            try container.encode(notificationType, forKey: Key("NotificationType"))
        }
        try container.encode("SetIdentityHeadersInNotificationsEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetIdentityHeadersInNotificationsEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityHeadersInNotificationsEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityHeadersInNotificationsEnabledOutputError>
}

public struct SetIdentityHeadersInNotificationsEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityHeadersInNotificationsEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityHeadersInNotificationsEnabledInput>
    public typealias MOutput = OperationOutput<SetIdentityHeadersInNotificationsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityHeadersInNotificationsEnabledOutputError>
}

/// <p>Represents a request to set whether Amazon SES includes the original email headers in the
///             Amazon SNS notifications of a specified type. For information about notifications, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications-via-sns.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SetIdentityHeadersInNotificationsEnabledInput: Equatable {
    /// <p>Sets whether Amazon SES includes the original email headers in Amazon SNS notifications of the
    ///             specified notification type. A value of <code>true</code> specifies that Amazon SES will
    ///             include headers in notifications, and a value of <code>false</code> specifies that Amazon SES
    ///             will not include headers in notifications.</p>
    ///         <p>This value can only be set when <code>NotificationType</code> is already set to use a
    ///             particular Amazon SNS topic.</p>
    public let enabled: Bool
    /// <p>The identity for which to enable or disable headers in notifications. Examples:
    ///                 <code>user@example.com</code>, <code>example.com</code>.</p>
    public let identity: String?
    /// <p>The notification type for which to enable or disable headers in notifications. </p>
    public let notificationType: NotificationType?

    public init (
        enabled: Bool = false,
        identity: String? = nil,
        notificationType: NotificationType? = nil
    )
    {
        self.enabled = enabled
        self.identity = identity
        self.notificationType = notificationType
    }
}

extension SetIdentityHeadersInNotificationsEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIdentityHeadersInNotificationsEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityHeadersInNotificationsEnabledOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityHeadersInNotificationsEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityHeadersInNotificationsEnabledOutputResponse()"}
}

extension SetIdentityHeadersInNotificationsEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetIdentityHeadersInNotificationsEnabledOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityHeadersInNotificationsEnabledOutputResponseBody: Equatable {
}

extension SetIdentityHeadersInNotificationsEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityMailFromDomainInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityMailFromDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityMailFromDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityMailFromDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityMailFromDomainInput>
    public typealias MOutput = OperationOutput<SetIdentityMailFromDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityMailFromDomainOutputError>
}

extension SetIdentityMailFromDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityMailFromDomainInput(behaviorOnMXFailure: \(String(describing: behaviorOnMXFailure)), identity: \(String(describing: identity)), mailFromDomain: \(String(describing: mailFromDomain)))"}
}

extension SetIdentityMailFromDomainInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let behaviorOnMXFailure = behaviorOnMXFailure {
            try container.encode(behaviorOnMXFailure, forKey: Key("BehaviorOnMXFailure"))
        }
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let mailFromDomain = mailFromDomain {
            try container.encode(mailFromDomain, forKey: Key("MailFromDomain"))
        }
        try container.encode("SetIdentityMailFromDomain", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetIdentityMailFromDomainInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityMailFromDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityMailFromDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityMailFromDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityMailFromDomainInput>
    public typealias MOutput = OperationOutput<SetIdentityMailFromDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityMailFromDomainOutputError>
}

public struct SetIdentityMailFromDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityMailFromDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityMailFromDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityMailFromDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityMailFromDomainInput>
    public typealias MOutput = OperationOutput<SetIdentityMailFromDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityMailFromDomainOutputError>
}

/// <p>Represents a request to enable or disable the Amazon SES custom MAIL FROM domain setup for
///             a verified identity. For information about using a custom MAIL FROM domain, see the
///                 <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct SetIdentityMailFromDomainInput: Equatable {
    /// <p>The action that you want Amazon SES to take if it cannot successfully read the required MX
    ///             record when you send an email. If you choose <code>UseDefaultValue</code>, Amazon SES will
    ///             use amazonses.com (or a subdomain of that) as the MAIL FROM domain. If you choose
    ///                 <code>RejectMessage</code>, Amazon SES will return a
    ///                 <code>MailFromDomainNotVerified</code> error and not send the email.</p>
    ///         <p>The action specified in <code>BehaviorOnMXFailure</code> is taken when the custom MAIL
    ///             FROM domain setup is in the <code>Pending</code>, <code>Failed</code>, and
    ///                 <code>TemporaryFailure</code> states.</p>
    public let behaviorOnMXFailure: BehaviorOnMXFailure?
    /// <p>The verified identity for which you want to enable or disable the specified custom
    ///             MAIL FROM domain.</p>
    public let identity: String?
    /// <p>The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
    ///             domain must 1) be a subdomain of the verified identity, 2) not be used in a "From"
    ///             address if the MAIL FROM domain is the destination of email feedback forwarding (for
    ///             more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mail-from.html">Amazon SES Developer Guide</a>), and
    ///             3) not be used to receive emails. A value of <code>null</code> disables the custom MAIL
    ///             FROM setting for the identity.</p>
    public let mailFromDomain: String?

    public init (
        behaviorOnMXFailure: BehaviorOnMXFailure? = nil,
        identity: String? = nil,
        mailFromDomain: String? = nil
    )
    {
        self.behaviorOnMXFailure = behaviorOnMXFailure
        self.identity = identity
        self.mailFromDomain = mailFromDomain
    }
}

extension SetIdentityMailFromDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIdentityMailFromDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityMailFromDomainOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityMailFromDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityMailFromDomainOutputResponse()"}
}

extension SetIdentityMailFromDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetIdentityMailFromDomainOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityMailFromDomainOutputResponseBody: Equatable {
}

extension SetIdentityMailFromDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetIdentityNotificationTopicInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityNotificationTopicInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityNotificationTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityNotificationTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityNotificationTopicInput>
    public typealias MOutput = OperationOutput<SetIdentityNotificationTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityNotificationTopicOutputError>
}

extension SetIdentityNotificationTopicInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityNotificationTopicInput(identity: \(String(describing: identity)), notificationType: \(String(describing: notificationType)), snsTopic: \(String(describing: snsTopic)))"}
}

extension SetIdentityNotificationTopicInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let identity = identity {
            try container.encode(identity, forKey: Key("Identity"))
        }
        if let notificationType = notificationType {
            try container.encode(notificationType, forKey: Key("NotificationType"))
        }
        if let snsTopic = snsTopic {
            try container.encode(snsTopic, forKey: Key("SnsTopic"))
        }
        try container.encode("SetIdentityNotificationTopic", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetIdentityNotificationTopicInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityNotificationTopicInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityNotificationTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityNotificationTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityNotificationTopicInput>
    public typealias MOutput = OperationOutput<SetIdentityNotificationTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityNotificationTopicOutputError>
}

public struct SetIdentityNotificationTopicInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityNotificationTopicInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityNotificationTopicInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityNotificationTopicOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityNotificationTopicInput>
    public typealias MOutput = OperationOutput<SetIdentityNotificationTopicOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityNotificationTopicOutputError>
}

/// <p>Represents a request to specify the Amazon SNS topic to which Amazon SES will publish bounce,
///             complaint, or delivery notifications for emails sent with that identity as the Source.
///             For information about Amazon SES notifications, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/notifications-via-sns.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct SetIdentityNotificationTopicInput: Equatable {
    /// <p>The identity (email address or domain) that you want to set the Amazon SNS topic
    ///             for.</p>
    ///         <important>
    ///             <p>You can only specify a verified identity for this parameter.</p>
    ///         </important>
    ///         <p>You can specify an identity by using its name or by using its Amazon Resource Name
    ///             (ARN). The following examples are all valid identities: <code>sender@example.com</code>,
    ///                 <code>example.com</code>,
    ///                 <code>arn:aws:ses:us-east-1:123456789012:identity/example.com</code>.</p>
    public let identity: String?
    /// <p>The type of notifications that will be published to the specified Amazon SNS topic.</p>
    public let notificationType: NotificationType?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic. If the parameter is omitted from
    ///             the request or a null value is passed, <code>SnsTopic</code> is cleared and publishing
    ///             is disabled.</p>
    public let snsTopic: String?

    public init (
        identity: String? = nil,
        notificationType: NotificationType? = nil,
        snsTopic: String? = nil
    )
    {
        self.identity = identity
        self.notificationType = notificationType
        self.snsTopic = snsTopic
    }
}

extension SetIdentityNotificationTopicOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIdentityNotificationTopicOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityNotificationTopicOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityNotificationTopicOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityNotificationTopicOutputResponse()"}
}

extension SetIdentityNotificationTopicOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetIdentityNotificationTopicOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityNotificationTopicOutputResponseBody: Equatable {
}

extension SetIdentityNotificationTopicOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetReceiptRulePositionInputBodyMiddleware: Middleware {
    public let id: String = "SetReceiptRulePositionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetReceiptRulePositionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetReceiptRulePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetReceiptRulePositionInput>
    public typealias MOutput = OperationOutput<SetReceiptRulePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetReceiptRulePositionOutputError>
}

extension SetReceiptRulePositionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetReceiptRulePositionInput(after: \(String(describing: after)), ruleName: \(String(describing: ruleName)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension SetReceiptRulePositionInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let after = after {
            try container.encode(after, forKey: Key("After"))
        }
        if let ruleName = ruleName {
            try container.encode(ruleName, forKey: Key("RuleName"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("SetReceiptRulePosition", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct SetReceiptRulePositionInputHeadersMiddleware: Middleware {
    public let id: String = "SetReceiptRulePositionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetReceiptRulePositionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetReceiptRulePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetReceiptRulePositionInput>
    public typealias MOutput = OperationOutput<SetReceiptRulePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetReceiptRulePositionOutputError>
}

public struct SetReceiptRulePositionInputQueryItemMiddleware: Middleware {
    public let id: String = "SetReceiptRulePositionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetReceiptRulePositionInput>,
                  next: H) -> Swift.Result<OperationOutput<SetReceiptRulePositionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetReceiptRulePositionInput>
    public typealias MOutput = OperationOutput<SetReceiptRulePositionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetReceiptRulePositionOutputError>
}

/// <p>Represents a request to set the position of a receipt rule in a receipt rule set. You
///             use receipt rule sets to receive email with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer Guide</a>.</p>
public struct SetReceiptRulePositionInput: Equatable {
    /// <p>The name of the receipt rule after which to place the specified receipt rule.</p>
    public let after: String?
    /// <p>The name of the receipt rule to reposition.</p>
    public let ruleName: String?
    /// <p>The name of the receipt rule set that contains the receipt rule to reposition.</p>
    public let ruleSetName: String?

    public init (
        after: String? = nil,
        ruleName: String? = nil,
        ruleSetName: String? = nil
    )
    {
        self.after = after
        self.ruleName = ruleName
        self.ruleSetName = ruleSetName
    }
}

extension SetReceiptRulePositionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetReceiptRulePositionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RuleDoesNotExistException" : self = .ruleDoesNotExistException(try RuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetReceiptRulePositionOutputError: Equatable {
    case ruleDoesNotExistException(RuleDoesNotExistException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetReceiptRulePositionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetReceiptRulePositionOutputResponse()"}
}

extension SetReceiptRulePositionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct SetReceiptRulePositionOutputResponse: Equatable {

    public init() {}
}

struct SetReceiptRulePositionOutputResponseBody: Equatable {
}

extension SetReceiptRulePositionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scope = "Scope"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let scope = scope {
            try container.encode(scope, forKey: Key("Scope"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(StopScope.self, forKey: .scope)
        scope = scopeDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension StopAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAction(scope: \(String(describing: scope)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action terminates the evaluation of the receipt
///             rule set and, optionally, publishes a notification to Amazon Simple Notification Service (Amazon SNS).</p>
///         <p>For information about setting a stop action in a receipt rule, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-stop.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct StopAction: Equatable {
    /// <p>The scope of the StopAction. The only acceptable value is <code>RuleSet</code>.</p>
    public let scope: StopScope?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to notify when the stop action is
    ///             taken. An example of an Amazon SNS topic ARN is
    ///                 <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more information about
    ///             Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        scope: StopScope? = nil,
        topicArn: String? = nil
    )
    {
        self.scope = scope
        self.topicArn = topicArn
    }
}

public enum StopScope {
    case ruleSet
    case sdkUnknown(String)
}

extension StopScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StopScope] {
        return [
            .ruleSet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ruleSet: return "RuleSet"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StopScope(rawValue: rawValue) ?? StopScope.sdkUnknown(rawValue)
    }
}

extension Template: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case htmlPart = "HtmlPart"
        case subjectPart = "SubjectPart"
        case templateName = "TemplateName"
        case textPart = "TextPart"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let htmlPart = htmlPart {
            try container.encode(htmlPart, forKey: Key("HtmlPart"))
        }
        if let subjectPart = subjectPart {
            try container.encode(subjectPart, forKey: Key("SubjectPart"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let textPart = textPart {
            try container.encode(textPart, forKey: Key("TextPart"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let subjectPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subjectPart)
        subjectPart = subjectPartDecoded
        let textPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textPart)
        textPart = textPartDecoded
        let htmlPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .htmlPart)
        htmlPart = htmlPartDecoded
    }
}

extension Template: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Template(htmlPart: \(String(describing: htmlPart)), subjectPart: \(String(describing: subjectPart)), templateName: \(String(describing: templateName)), textPart: \(String(describing: textPart)))"}
}

/// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
///             part.</p>
public struct Template: Equatable {
    /// <p>The HTML body of the email.</p>
    public let htmlPart: String?
    /// <p>The subject line of the email.</p>
    public let subjectPart: String?
    /// <p>The name of the template. You will refer to this name when you send email using the
    ///                 <code>SendTemplatedEmail</code> or <code>SendBulkTemplatedEmail</code>
    ///             operations.</p>
    public let templateName: String?
    /// <p>The email body that will be visible to recipients whose email clients do not display
    ///             HTML.</p>
    public let textPart: String?

    public init (
        htmlPart: String? = nil,
        subjectPart: String? = nil,
        templateName: String? = nil,
        textPart: String? = nil
    )
    {
        self.htmlPart = htmlPart
        self.subjectPart = subjectPart
        self.templateName = templateName
        self.textPart = textPart
    }
}

extension TemplateDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateDoesNotExistException(templateName: \(String(describing: templateName)), message: \(String(describing: message)))"}
}

extension TemplateDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TemplateDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
            self.templateName = output.error.templateName
        } else {
            self.templateName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Template object you specified does not exist in your Amazon SES
///             account.</p>
public struct TemplateDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var templateName: String?

    public init (
        message: String? = nil,
        templateName: String? = nil
    )
    {
        self.message = message
        self.templateName = templateName
    }
}

struct TemplateDoesNotExistExceptionBody: Equatable {
    public let templateName: String?
    public let message: String?
}

extension TemplateDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateName = "TemplateName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TemplateMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let createdTimestamp = createdTimestamp {
            try container.encode(TimestampWrapper(createdTimestamp, format: .dateTime), forKey: Key("createdTimestamp"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTimestamp)
        var createdTimestampBuffer:Date? = nil
        if let createdTimestampDecoded = createdTimestampDecoded {
            createdTimestampBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimestampDecoded, format: .dateTime)
        }
        createdTimestamp = createdTimestampBuffer
    }
}

extension TemplateMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateMetadata(createdTimestamp: \(String(describing: createdTimestamp)), name: \(String(describing: name)))"}
}

/// <p>Contains information about an email template.</p>
public struct TemplateMetadata: Equatable {
    /// <p>The time and date the template was created.</p>
    public let createdTimestamp: Date?
    /// <p>The name of the template.</p>
    public let name: String?

    public init (
        createdTimestamp: Date? = nil,
        name: String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.name = name
    }
}

public struct TestRenderTemplateInputBodyMiddleware: Middleware {
    public let id: String = "TestRenderTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderTemplateOutputError>
}

extension TestRenderTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRenderTemplateInput(templateData: \(String(describing: templateData)), templateName: \(String(describing: templateName)))"}
}

extension TestRenderTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let templateData = templateData {
            try container.encode(templateData, forKey: Key("TemplateData"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        try container.encode("TestRenderTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct TestRenderTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "TestRenderTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderTemplateOutputError>
}

public struct TestRenderTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "TestRenderTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRenderTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRenderTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRenderTemplateInput>
    public typealias MOutput = OperationOutput<TestRenderTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRenderTemplateOutputError>
}

public struct TestRenderTemplateInput: Equatable {
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    ///             object, typically consisting of key-value pairs in which the keys correspond to
    ///             replacement tags in the email template.</p>
    public let templateData: String?
    /// <p>The name of the template that you want to render.</p>
    public let templateName: String?

    public init (
        templateData: String? = nil,
        templateName: String? = nil
    )
    {
        self.templateData = templateData
        self.templateName = templateName
    }
}

extension TestRenderTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TestRenderTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRenderingParameterException" : self = .invalidRenderingParameterException(try InvalidRenderingParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRenderingAttributeException" : self = .missingRenderingAttributeException(try MissingRenderingAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplateDoesNotExistException" : self = .templateDoesNotExistException(try TemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestRenderTemplateOutputError: Equatable {
    case invalidRenderingParameterException(InvalidRenderingParameterException)
    case missingRenderingAttributeException(MissingRenderingAttributeException)
    case templateDoesNotExistException(TemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRenderTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRenderTemplateOutputResponse(renderedTemplate: \(String(describing: renderedTemplate)))"}
}

extension TestRenderTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestRenderTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.renderedTemplate = output.renderedTemplate
        } else {
            self.renderedTemplate = nil
        }
    }
}

public struct TestRenderTemplateOutputResponse: Equatable {
    /// <p>The complete MIME message rendered by applying the data in the TemplateData parameter
    ///             to the template specified in the TemplateName parameter.</p>
    public let renderedTemplate: String?

    public init (
        renderedTemplate: String? = nil
    )
    {
        self.renderedTemplate = renderedTemplate
    }
}

struct TestRenderTemplateOutputResponseBody: Equatable {
    public let renderedTemplate: String?
}

extension TestRenderTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case renderedTemplate = "RenderedTemplate"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("TestRenderTemplateResult"))
        let renderedTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .renderedTemplate)
        renderedTemplate = renderedTemplateDecoded
    }
}

public enum TlsPolicy {
    case `optional`
    case require
    case sdkUnknown(String)
}

extension TlsPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TlsPolicy] {
        return [
            .optional,
            .require,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .optional: return "Optional"
        case .require: return "Require"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TlsPolicy(rawValue: rawValue) ?? TlsPolicy.sdkUnknown(rawValue)
    }
}

extension TrackingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRedirectDomain = "CustomRedirectDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customRedirectDomain = customRedirectDomain {
            try container.encode(customRedirectDomain, forKey: Key("CustomRedirectDomain"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRedirectDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRedirectDomain)
        customRedirectDomain = customRedirectDomainDecoded
    }
}

extension TrackingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingOptions(customRedirectDomain: \(String(describing: customRedirectDomain)))"}
}

/// <p>A domain that is used to redirect email recipients to an Amazon SES-operated domain. This
///             domain captures open and click events generated by Amazon SES emails.</p>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Configuring
///                 Custom Domains to Handle Open and Click Tracking</a> in the <i>Amazon SES
///                 Developer Guide</i>.</p>
public struct TrackingOptions: Equatable {
    /// <p>The custom subdomain that will be used to redirect email recipients to the Amazon SES
    ///             event tracking domain.</p>
    public let customRedirectDomain: String?

    public init (
        customRedirectDomain: String? = nil
    )
    {
        self.customRedirectDomain = customRedirectDomain
    }
}

extension TrackingOptionsAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingOptionsAlreadyExistsException(configurationSetName: \(String(describing: configurationSetName)), message: \(String(describing: message)))"}
}

extension TrackingOptionsAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TrackingOptionsAlreadyExistsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the configuration set you specified already contains a TrackingOptions
///             object.</p>
public struct TrackingOptionsAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that a TrackingOptions object already exists in the specified configuration
    ///             set.</p>
    public var configurationSetName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.message = message
    }
}

struct TrackingOptionsAlreadyExistsExceptionBody: Equatable {
    public let configurationSetName: String?
    public let message: String?
}

extension TrackingOptionsAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrackingOptionsDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrackingOptionsDoesNotExistException(configurationSetName: \(String(describing: configurationSetName)), message: \(String(describing: message)))"}
}

extension TrackingOptionsDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TrackingOptionsDoesNotExistExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSetName = output.error.configurationSetName
            self.message = output.error.message
        } else {
            self.configurationSetName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the TrackingOptions object you specified does not exist.</p>
public struct TrackingOptionsDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Indicates that a TrackingOptions object does not exist in the specified configuration
    ///             set.</p>
    public var configurationSetName: String?
    public var message: String?

    public init (
        configurationSetName: String? = nil,
        message: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.message = message
    }
}

struct TrackingOptionsDoesNotExistExceptionBody: Equatable {
    public let configurationSetName: String?
    public let message: String?
}

extension TrackingOptionsDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateAccountSendingEnabledInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccountSendingEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSendingEnabledOutputError>
}

extension UpdateAccountSendingEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountSendingEnabledInput(enabled: \(String(describing: enabled)))"}
}

extension UpdateAccountSendingEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        try container.encode("UpdateAccountSendingEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateAccountSendingEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccountSendingEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSendingEnabledOutputError>
}

public struct UpdateAccountSendingEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccountSendingEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccountSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccountSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccountSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateAccountSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccountSendingEnabledOutputError>
}

/// <p>Represents a request to enable or disable the email sending capabilities for your
///             entire Amazon SES account.</p>
public struct UpdateAccountSendingEnabledInput: Equatable {
    /// <p>Describes whether email sending is enabled or disabled for your Amazon SES account in the
    ///             current AWS Region.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension UpdateAccountSendingEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateAccountSendingEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountSendingEnabledOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountSendingEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccountSendingEnabledOutputResponse()"}
}

extension UpdateAccountSendingEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccountSendingEnabledOutputResponse: Equatable {

    public init() {}
}

struct UpdateAccountSendingEnabledOutputResponseBody: Equatable {
}

extension UpdateAccountSendingEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

extension UpdateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)))"}
}

extension UpdateConfigurationSetEventDestinationInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let eventDestination = eventDestination {
            try container.encode(eventDestination, forKey: Key("EventDestination"))
        }
        try container.encode("UpdateConfigurationSetEventDestination", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

public struct UpdateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

/// <p>Represents a request to update the event destination of a configuration set.
///             Configuration sets enable you to publish email sending events. For information about
///             using configuration sets, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/monitor-sending-activity.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct UpdateConfigurationSetEventDestinationInput: Equatable {
    /// <p>The name of the configuration set that contains the event destination that you want to
    ///             update.</p>
    public let configurationSetName: String?
    /// <p>The event destination object that you want to apply to the specified configuration
    ///             set.</p>
    public let eventDestination: EventDestination?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestination? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventDestinationDoesNotExistException" : self = .eventDestinationDoesNotExistException(try EventDestinationDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchDestinationException" : self = .invalidCloudWatchDestinationException(try InvalidCloudWatchDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFirehoseDestinationException" : self = .invalidFirehoseDestinationException(try InvalidFirehoseDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSNSDestinationException" : self = .invalidSNSDestinationException(try InvalidSNSDestinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case eventDestinationDoesNotExistException(EventDestinationDoesNotExistException)
    case invalidCloudWatchDestinationException(InvalidCloudWatchDestinationException)
    case invalidFirehoseDestinationException(InvalidFirehoseDestinationException)
    case invalidSNSDestinationException(InvalidSNSDestinationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationOutputResponse()"}
}

extension UpdateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct UpdateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetReputationMetricsEnabledInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetReputationMetricsEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetReputationMetricsEnabledOutputError>
}

extension UpdateConfigurationSetReputationMetricsEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetReputationMetricsEnabledInput(configurationSetName: \(String(describing: configurationSetName)), enabled: \(String(describing: enabled)))"}
}

extension UpdateConfigurationSetReputationMetricsEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        try container.encode("UpdateConfigurationSetReputationMetricsEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateConfigurationSetReputationMetricsEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetReputationMetricsEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetReputationMetricsEnabledOutputError>
}

public struct UpdateConfigurationSetReputationMetricsEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetReputationMetricsEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetReputationMetricsEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetReputationMetricsEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetReputationMetricsEnabledOutputError>
}

/// <p>Represents a request to modify the reputation metric publishing settings for a
///             configuration set.</p>
public struct UpdateConfigurationSetReputationMetricsEnabledInput: Equatable {
    /// <p>The name of the configuration set that you want to update.</p>
    public let configurationSetName: String?
    /// <p>Describes whether or not Amazon SES will publish reputation metrics for the configuration
    ///             set, such as bounce and complaint rates, to Amazon CloudWatch.</p>
    public let enabled: Bool

    public init (
        configurationSetName: String? = nil,
        enabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.enabled = enabled
    }
}

extension UpdateConfigurationSetReputationMetricsEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateConfigurationSetReputationMetricsEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetReputationMetricsEnabledOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetReputationMetricsEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetReputationMetricsEnabledOutputResponse()"}
}

extension UpdateConfigurationSetReputationMetricsEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConfigurationSetReputationMetricsEnabledOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetReputationMetricsEnabledOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetReputationMetricsEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetSendingEnabledInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetSendingEnabledInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetSendingEnabledOutputError>
}

extension UpdateConfigurationSetSendingEnabledInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetSendingEnabledInput(configurationSetName: \(String(describing: configurationSetName)), enabled: \(String(describing: enabled)))"}
}

extension UpdateConfigurationSetSendingEnabledInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
        try container.encode("UpdateConfigurationSetSendingEnabled", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateConfigurationSetSendingEnabledInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetSendingEnabledInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetSendingEnabledOutputError>
}

public struct UpdateConfigurationSetSendingEnabledInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetSendingEnabledInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetSendingEnabledInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetSendingEnabledOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetSendingEnabledOutputError>
}

/// <p>Represents a request to enable or disable the email sending capabilities for a
///             specific configuration set.</p>
public struct UpdateConfigurationSetSendingEnabledInput: Equatable {
    /// <p>The name of the configuration set that you want to update.</p>
    public let configurationSetName: String?
    /// <p>Describes whether email sending is enabled or disabled for the configuration set.
    ///         </p>
    public let enabled: Bool

    public init (
        configurationSetName: String? = nil,
        enabled: Bool = false
    )
    {
        self.configurationSetName = configurationSetName
        self.enabled = enabled
    }
}

extension UpdateConfigurationSetSendingEnabledOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateConfigurationSetSendingEnabledOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetSendingEnabledOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetSendingEnabledOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetSendingEnabledOutputResponse()"}
}

extension UpdateConfigurationSetSendingEnabledOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConfigurationSetSendingEnabledOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetSendingEnabledOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetSendingEnabledOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConfigurationSetTrackingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetTrackingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetTrackingOptionsOutputError>
}

extension UpdateConfigurationSetTrackingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetTrackingOptionsInput(configurationSetName: \(String(describing: configurationSetName)), trackingOptions: \(String(describing: trackingOptions)))"}
}

extension UpdateConfigurationSetTrackingOptionsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let configurationSetName = configurationSetName {
            try container.encode(configurationSetName, forKey: Key("ConfigurationSetName"))
        }
        if let trackingOptions = trackingOptions {
            try container.encode(trackingOptions, forKey: Key("TrackingOptions"))
        }
        try container.encode("UpdateConfigurationSetTrackingOptions", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateConfigurationSetTrackingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetTrackingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetTrackingOptionsOutputError>
}

public struct UpdateConfigurationSetTrackingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetTrackingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetTrackingOptionsInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetTrackingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetTrackingOptionsOutputError>
}

/// <p>Represents a request to update the tracking options for a configuration set. </p>
public struct UpdateConfigurationSetTrackingOptionsInput: Equatable {
    /// <p>The name of the configuration set for which you want to update the custom tracking
    ///             domain.</p>
    public let configurationSetName: String?
    /// <p>A domain that is used to redirect email recipients to an Amazon SES-operated domain. This
    ///             domain captures open and click events generated by Amazon SES emails.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/configure-custom-open-click-domains.html">Configuring
    ///                 Custom Domains to Handle Open and Click Tracking</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let trackingOptions: TrackingOptions?

    public init (
        configurationSetName: String? = nil,
        trackingOptions: TrackingOptions? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.trackingOptions = trackingOptions
    }
}

extension UpdateConfigurationSetTrackingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateConfigurationSetTrackingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConfigurationSetDoesNotExistException" : self = .configurationSetDoesNotExistException(try ConfigurationSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrackingOptionsException" : self = .invalidTrackingOptionsException(try InvalidTrackingOptionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrackingOptionsDoesNotExistException" : self = .trackingOptionsDoesNotExistException(try TrackingOptionsDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetTrackingOptionsOutputError: Equatable {
    case configurationSetDoesNotExistException(ConfigurationSetDoesNotExistException)
    case invalidTrackingOptionsException(InvalidTrackingOptionsException)
    case trackingOptionsDoesNotExistException(TrackingOptionsDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetTrackingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetTrackingOptionsOutputResponse()"}
}

extension UpdateConfigurationSetTrackingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct UpdateConfigurationSetTrackingOptionsOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetTrackingOptionsOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetTrackingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCustomVerificationEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

extension UpdateCustomVerificationEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomVerificationEmailTemplateInput(failureRedirectionURL: \(String(describing: failureRedirectionURL)), fromEmailAddress: \(String(describing: fromEmailAddress)), successRedirectionURL: \(String(describing: successRedirectionURL)), templateContent: \(String(describing: templateContent)), templateName: \(String(describing: templateName)), templateSubject: \(String(describing: templateSubject)))"}
}

extension UpdateCustomVerificationEmailTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let failureRedirectionURL = failureRedirectionURL {
            try container.encode(failureRedirectionURL, forKey: Key("FailureRedirectionURL"))
        }
        if let fromEmailAddress = fromEmailAddress {
            try container.encode(fromEmailAddress, forKey: Key("FromEmailAddress"))
        }
        if let successRedirectionURL = successRedirectionURL {
            try container.encode(successRedirectionURL, forKey: Key("SuccessRedirectionURL"))
        }
        if let templateContent = templateContent {
            try container.encode(templateContent, forKey: Key("TemplateContent"))
        }
        if let templateName = templateName {
            try container.encode(templateName, forKey: Key("TemplateName"))
        }
        if let templateSubject = templateSubject {
            try container.encode(templateSubject, forKey: Key("TemplateSubject"))
        }
        try container.encode("UpdateCustomVerificationEmailTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateCustomVerificationEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

public struct UpdateCustomVerificationEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCustomVerificationEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCustomVerificationEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateCustomVerificationEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCustomVerificationEmailTemplateOutputError>
}

/// <p>Represents a request to update an existing custom verification email template.</p>
public struct UpdateCustomVerificationEmailTemplateInput: Equatable {
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is not successfully verified.</p>
    public let failureRedirectionURL: String?
    /// <p>The email address that the custom verification email is sent from.</p>
    public let fromEmailAddress: String?
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    ///             is successfully verified.</p>
    public let successRedirectionURL: String?
    /// <p>The content of the custom verification email. The total size of the email must be less
    ///             than 10 MB. The message body may contain HTML, with some limitations. For more
    ///             information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/custom-verification-emails.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    ///                 Developer Guide</i>.</p>
    public let templateContent: String?
    /// <p>The name of the custom verification email template that you want to update.</p>
    public let templateName: String?
    /// <p>The subject line of the custom verification email.</p>
    public let templateSubject: String?

    public init (
        failureRedirectionURL: String? = nil,
        fromEmailAddress: String? = nil,
        successRedirectionURL: String? = nil,
        templateContent: String? = nil,
        templateName: String? = nil,
        templateSubject: String? = nil
    )
    {
        self.failureRedirectionURL = failureRedirectionURL
        self.fromEmailAddress = fromEmailAddress
        self.successRedirectionURL = successRedirectionURL
        self.templateContent = templateContent
        self.templateName = templateName
        self.templateSubject = templateSubject
    }
}

extension UpdateCustomVerificationEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCustomVerificationEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomVerificationEmailInvalidContentException" : self = .customVerificationEmailInvalidContentException(try CustomVerificationEmailInvalidContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomVerificationEmailTemplateDoesNotExistException" : self = .customVerificationEmailTemplateDoesNotExistException(try CustomVerificationEmailTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FromEmailAddressNotVerifiedException" : self = .fromEmailAddressNotVerifiedException(try FromEmailAddressNotVerifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCustomVerificationEmailTemplateOutputError: Equatable {
    case customVerificationEmailInvalidContentException(CustomVerificationEmailInvalidContentException)
    case customVerificationEmailTemplateDoesNotExistException(CustomVerificationEmailTemplateDoesNotExistException)
    case fromEmailAddressNotVerifiedException(FromEmailAddressNotVerifiedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomVerificationEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCustomVerificationEmailTemplateOutputResponse()"}
}

extension UpdateCustomVerificationEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCustomVerificationEmailTemplateOutputResponse: Equatable {

    public init() {}
}

struct UpdateCustomVerificationEmailTemplateOutputResponseBody: Equatable {
}

extension UpdateCustomVerificationEmailTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateReceiptRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReceiptRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReceiptRuleInput>
    public typealias MOutput = OperationOutput<UpdateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReceiptRuleOutputError>
}

extension UpdateReceiptRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReceiptRuleInput(rule: \(String(describing: rule)), ruleSetName: \(String(describing: ruleSetName)))"}
}

extension UpdateReceiptRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let rule = rule {
            try container.encode(rule, forKey: Key("Rule"))
        }
        if let ruleSetName = ruleSetName {
            try container.encode(ruleSetName, forKey: Key("RuleSetName"))
        }
        try container.encode("UpdateReceiptRule", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateReceiptRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReceiptRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReceiptRuleInput>
    public typealias MOutput = OperationOutput<UpdateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReceiptRuleOutputError>
}

public struct UpdateReceiptRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReceiptRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReceiptRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReceiptRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReceiptRuleInput>
    public typealias MOutput = OperationOutput<UpdateReceiptRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReceiptRuleOutputError>
}

/// <p>Represents a request to update a receipt rule. You use receipt rules to receive email
///             with Amazon SES. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-concepts.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct UpdateReceiptRuleInput: Equatable {
    /// <p>A data structure that contains the updated receipt rule information.</p>
    public let rule: ReceiptRule?
    /// <p>The name of the receipt rule set that the receipt rule belongs to.</p>
    public let ruleSetName: String?

    public init (
        rule: ReceiptRule? = nil,
        ruleSetName: String? = nil
    )
    {
        self.rule = rule
        self.ruleSetName = ruleSetName
    }
}

extension UpdateReceiptRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateReceiptRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLambdaFunctionException" : self = .invalidLambdaFunctionException(try InvalidLambdaFunctionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3ConfigurationException" : self = .invalidS3ConfigurationException(try InvalidS3ConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicException" : self = .invalidSnsTopicException(try InvalidSnsTopicException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleDoesNotExistException" : self = .ruleDoesNotExistException(try RuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleSetDoesNotExistException" : self = .ruleSetDoesNotExistException(try RuleSetDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReceiptRuleOutputError: Equatable {
    case invalidLambdaFunctionException(InvalidLambdaFunctionException)
    case invalidS3ConfigurationException(InvalidS3ConfigurationException)
    case invalidSnsTopicException(InvalidSnsTopicException)
    case limitExceededException(LimitExceededException)
    case ruleDoesNotExistException(RuleDoesNotExistException)
    case ruleSetDoesNotExistException(RuleSetDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReceiptRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReceiptRuleOutputResponse()"}
}

extension UpdateReceiptRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct UpdateReceiptRuleOutputResponse: Equatable {

    public init() {}
}

struct UpdateReceiptRuleOutputResponseBody: Equatable {
}

extension UpdateReceiptRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

extension UpdateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateInput(template: \(String(describing: template)))"}
}

extension UpdateTemplateInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let template = template {
            try container.encode(template, forKey: Key("Template"))
        }
        try container.encode("UpdateTemplate", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct UpdateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

public struct UpdateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateInput>
    public typealias MOutput = OperationOutput<UpdateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateOutputError>
}

public struct UpdateTemplateInput: Equatable {
    /// <p>The content of the email, composed of a subject line, an HTML part, and a text-only
    ///             part.</p>
    public let template: Template?

    public init (
        template: Template? = nil
    )
    {
        self.template = template
    }
}

extension UpdateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTemplateException" : self = .invalidTemplateException(try InvalidTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemplateDoesNotExistException" : self = .templateDoesNotExistException(try TemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateOutputError: Equatable {
    case invalidTemplateException(InvalidTemplateException)
    case templateDoesNotExistException(TemplateDoesNotExistException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateOutputResponse()"}
}

extension UpdateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTemplateOutputResponse: Equatable {

    public init() {}
}

struct UpdateTemplateOutputResponseBody: Equatable {
}

extension UpdateTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum VerificationStatus {
    case failed
    case notstarted
    case pending
    case success
    case temporaryfailure
    case sdkUnknown(String)
}

extension VerificationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VerificationStatus] {
        return [
            .failed,
            .notstarted,
            .pending,
            .success,
            .temporaryfailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .notstarted: return "NotStarted"
        case .pending: return "Pending"
        case .success: return "Success"
        case .temporaryfailure: return "TemporaryFailure"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VerificationStatus(rawValue: rawValue) ?? VerificationStatus.sdkUnknown(rawValue)
    }
}

public struct VerifyDomainDkimInputBodyMiddleware: Middleware {
    public let id: String = "VerifyDomainDkimInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainDkimInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainDkimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainDkimInput>
    public typealias MOutput = OperationOutput<VerifyDomainDkimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainDkimOutputError>
}

extension VerifyDomainDkimInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyDomainDkimInput(domain: \(String(describing: domain)))"}
}

extension VerifyDomainDkimInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        try container.encode("VerifyDomainDkim", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct VerifyDomainDkimInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyDomainDkimInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainDkimInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainDkimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainDkimInput>
    public typealias MOutput = OperationOutput<VerifyDomainDkimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainDkimOutputError>
}

public struct VerifyDomainDkimInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyDomainDkimInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainDkimInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainDkimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainDkimInput>
    public typealias MOutput = OperationOutput<VerifyDomainDkimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainDkimOutputError>
}

/// <p>Represents a request to generate the CNAME records needed to set up Easy DKIM with
///             Amazon SES. For more information about setting up Easy DKIM, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct VerifyDomainDkimInput: Equatable {
    /// <p>The name of the domain to be verified for Easy DKIM signing.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

extension VerifyDomainDkimOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifyDomainDkimOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyDomainDkimOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyDomainDkimOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyDomainDkimOutputResponse(dkimTokens: \(String(describing: dkimTokens)))"}
}

extension VerifyDomainDkimOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VerifyDomainDkimOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dkimTokens = output.dkimTokens
        } else {
            self.dkimTokens = nil
        }
    }
}

/// <p>Returns CNAME records that you must publish to the DNS server of your domain to set up
///             Easy DKIM with Amazon SES.</p>
public struct VerifyDomainDkimOutputResponse: Equatable {
    /// <p>A set of character strings that represent the domain's identity. If the identity is an
    ///             email address, the tokens represent the domain of that address.</p>
    ///         <p>Using these tokens, you need to create DNS CNAME records that point to DKIM public
    ///             keys that are hosted by Amazon SES. Amazon Web Services eventually detects that you've updated your DNS
    ///             records. This detection process might take up to 72 hours. After successful detection,
    ///             Amazon SES is able to DKIM-sign email originating from that domain. (This only applies to
    ///             domain identities, not email address identities.)</p>
    ///         <p>For more information about creating DNS records using DKIM tokens, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Amazon SES Developer
    ///                 Guide</a>.</p>
    public let dkimTokens: [String]?

    public init (
        dkimTokens: [String]? = nil
    )
    {
        self.dkimTokens = dkimTokens
    }
}

struct VerifyDomainDkimOutputResponseBody: Equatable {
    public let dkimTokens: [String]?
}

extension VerifyDomainDkimOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dkimTokens = "DkimTokens"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("VerifyDomainDkimResult"))
        if containerValues.contains(.dkimTokens) {
            struct KeyVal0{struct member{}}
            let dkimTokensWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dkimTokens)
            if let dkimTokensWrappedContainer = dkimTokensWrappedContainer {
                let dkimTokensContainer = try dkimTokensWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var dkimTokensBuffer:[String]? = nil
                if let dkimTokensContainer = dkimTokensContainer {
                    dkimTokensBuffer = [String]()
                    for stringContainer0 in dkimTokensContainer {
                        dkimTokensBuffer?.append(stringContainer0)
                    }
                }
                dkimTokens = dkimTokensBuffer
            } else {
                dkimTokens = []
            }
        } else {
            dkimTokens = nil
        }
    }
}

public struct VerifyDomainIdentityInputBodyMiddleware: Middleware {
    public let id: String = "VerifyDomainIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainIdentityInput>
    public typealias MOutput = OperationOutput<VerifyDomainIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainIdentityOutputError>
}

extension VerifyDomainIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyDomainIdentityInput(domain: \(String(describing: domain)))"}
}

extension VerifyDomainIdentityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: Key("Domain"))
        }
        try container.encode("VerifyDomainIdentity", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct VerifyDomainIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyDomainIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainIdentityInput>
    public typealias MOutput = OperationOutput<VerifyDomainIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainIdentityOutputError>
}

public struct VerifyDomainIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyDomainIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyDomainIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyDomainIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyDomainIdentityInput>
    public typealias MOutput = OperationOutput<VerifyDomainIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyDomainIdentityOutputError>
}

/// <p>Represents a request to begin Amazon SES domain verification and to generate the TXT
///             records that you must publish to the DNS server of your domain to complete the
///             verification. For information about domain verification, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html">Amazon SES
///                 Developer Guide</a>.</p>
public struct VerifyDomainIdentityInput: Equatable {
    /// <p>The domain to be verified.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

extension VerifyDomainIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifyDomainIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyDomainIdentityOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyDomainIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyDomainIdentityOutputResponse(verificationToken: \(String(describing: verificationToken)))"}
}

extension VerifyDomainIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VerifyDomainIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.verificationToken = output.verificationToken
        } else {
            self.verificationToken = nil
        }
    }
}

/// <p>Returns a TXT record that you must publish to the DNS server of your domain to
///             complete domain verification with Amazon SES.</p>
public struct VerifyDomainIdentityOutputResponse: Equatable {
    /// <p>A TXT record that you must place in the DNS settings of the domain to complete domain
    ///             verification with Amazon SES.</p>
    ///         <p>As Amazon SES searches for the TXT record, the domain's verification status is "Pending".
    ///             When Amazon SES detects the record, the domain's verification status changes to "Success". If
    ///             Amazon SES is unable to detect the record within 72 hours, the domain's verification status
    ///             changes to "Failed." In that case, if you still want to verify the domain, you must
    ///             restart the verification process from the beginning.</p>
    public let verificationToken: String?

    public init (
        verificationToken: String? = nil
    )
    {
        self.verificationToken = verificationToken
    }
}

struct VerifyDomainIdentityOutputResponseBody: Equatable {
    public let verificationToken: String?
}

extension VerifyDomainIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case verificationToken = "VerificationToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("VerifyDomainIdentityResult"))
        let verificationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verificationToken)
        verificationToken = verificationTokenDecoded
    }
}

public struct VerifyEmailAddressInputBodyMiddleware: Middleware {
    public let id: String = "VerifyEmailAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailAddressInput>
    public typealias MOutput = OperationOutput<VerifyEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailAddressOutputError>
}

extension VerifyEmailAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyEmailAddressInput(emailAddress: \(String(describing: emailAddress)))"}
}

extension VerifyEmailAddressInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: Key("EmailAddress"))
        }
        try container.encode("VerifyEmailAddress", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct VerifyEmailAddressInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyEmailAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailAddressInput>
    public typealias MOutput = OperationOutput<VerifyEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailAddressOutputError>
}

public struct VerifyEmailAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyEmailAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailAddressInput>
    public typealias MOutput = OperationOutput<VerifyEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailAddressOutputError>
}

/// <p>Represents a request to begin email address verification with Amazon SES. For information
///             about email address verification, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct VerifyEmailAddressInput: Equatable {
    /// <p>The email address to be verified.</p>
    public let emailAddress: String?

    public init (
        emailAddress: String? = nil
    )
    {
        self.emailAddress = emailAddress
    }
}

extension VerifyEmailAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifyEmailAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyEmailAddressOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyEmailAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyEmailAddressOutputResponse()"}
}

extension VerifyEmailAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct VerifyEmailAddressOutputResponse: Equatable {

    public init() {}
}

struct VerifyEmailAddressOutputResponseBody: Equatable {
}

extension VerifyEmailAddressOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct VerifyEmailIdentityInputBodyMiddleware: Middleware {
    public let id: String = "VerifyEmailIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailIdentityInput>
    public typealias MOutput = OperationOutput<VerifyEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailIdentityOutputError>
}

extension VerifyEmailIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyEmailIdentityInput(emailAddress: \(String(describing: emailAddress)))"}
}

extension VerifyEmailIdentityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let emailAddress = emailAddress {
            try container.encode(emailAddress, forKey: Key("EmailAddress"))
        }
        try container.encode("VerifyEmailIdentity", forKey:Key("Action"))
        try container.encode("2010-12-01", forKey:Key("Version"))
    }
}

public struct VerifyEmailIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyEmailIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailIdentityInput>
    public typealias MOutput = OperationOutput<VerifyEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailIdentityOutputError>
}

public struct VerifyEmailIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyEmailIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyEmailIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyEmailIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyEmailIdentityInput>
    public typealias MOutput = OperationOutput<VerifyEmailIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyEmailIdentityOutputError>
}

/// <p>Represents a request to begin email address verification with Amazon SES. For information
///             about email address verification, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct VerifyEmailIdentityInput: Equatable {
    /// <p>The email address to be verified.</p>
    public let emailAddress: String?

    public init (
        emailAddress: String? = nil
    )
    {
        self.emailAddress = emailAddress
    }
}

extension VerifyEmailIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension VerifyEmailIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyEmailIdentityOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyEmailIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyEmailIdentityOutputResponse()"}
}

extension VerifyEmailIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>An empty element returned on a successful request.</p>
public struct VerifyEmailIdentityOutputResponse: Equatable {

    public init() {}
}

struct VerifyEmailIdentityOutputResponseBody: Equatable {
}

extension VerifyEmailIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension WorkmailAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationArn = "OrganizationArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let organizationArn = organizationArn {
            try container.encode(organizationArn, forKey: Key("OrganizationArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: Key("TopicArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let organizationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationArn)
        organizationArn = organizationArnDecoded
    }
}

extension WorkmailAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkmailAction(organizationArn: \(String(describing: organizationArn)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>When included in a receipt rule, this action calls Amazon WorkMail and, optionally,
///             publishes a notification to Amazon Simple Notification Service (Amazon SNS). You will typically not use this action
///             directly because Amazon WorkMail adds the rule automatically during its setup
///             procedure.</p>
///         <p>For information using a receipt rule to call Amazon WorkMail, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-workmail.html">Amazon SES Developer
///                 Guide</a>.</p>
public struct WorkmailAction: Equatable {
    /// <p>The ARN of the Amazon WorkMail organization. An example of an Amazon WorkMail
    ///             organization ARN is
    ///                 <code>arn:aws:workmail:us-west-2:123456789012:organization/m-68755160c4cb4e29a2b2f8fb58f359d7</code>.
    ///             For information about Amazon WorkMail organizations, see the <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/organizations_overview.html">Amazon WorkMail
    ///                 Administrator Guide</a>.</p>
    public let organizationArn: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to notify when the WorkMail action
    ///             is called. An example of an Amazon SNS topic ARN is
    ///                 <code>arn:aws:sns:us-west-2:123456789012:MyTopic</code>. For more information about
    ///             Amazon SNS topics, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html">Amazon SNS Developer Guide</a>.</p>
    public let topicArn: String?

    public init (
        organizationArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.organizationArn = organizationArn
        self.topicArn = topicArn
    }
}
