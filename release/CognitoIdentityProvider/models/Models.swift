// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountRecoverySettingType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recoveryMechanisms = "RecoveryMechanisms"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryMechanisms = recoveryMechanisms {
            var recoveryMechanismsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryMechanisms)
            for recoverymechanismstype0 in recoveryMechanisms {
                try recoveryMechanismsContainer.encode(recoverymechanismstype0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryMechanismsContainer = try containerValues.decodeIfPresent([RecoveryOptionType?].self, forKey: .recoveryMechanisms)
        var recoveryMechanismsDecoded0:[RecoveryOptionType]? = nil
        if let recoveryMechanismsContainer = recoveryMechanismsContainer {
            recoveryMechanismsDecoded0 = [RecoveryOptionType]()
            for structure0 in recoveryMechanismsContainer {
                if let structure0 = structure0 {
                    recoveryMechanismsDecoded0?.append(structure0)
                }
            }
        }
        recoveryMechanisms = recoveryMechanismsDecoded0
    }
}

extension AccountRecoverySettingType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountRecoverySettingType(recoveryMechanisms: \(String(describing: recoveryMechanisms)))"}
}

/// <p>The data type for <code>AccountRecoverySetting</code>.</p>
public struct AccountRecoverySettingType: Equatable {
    /// <p>The list of <code>RecoveryOptionTypes</code>.</p>
    public let recoveryMechanisms: [RecoveryOptionType]?

    public init (
        recoveryMechanisms: [RecoveryOptionType]? = nil
    )
    {
        self.recoveryMechanisms = recoveryMechanisms
    }
}

extension AccountTakeoverActionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventAction = "EventAction"
        case notify = "Notify"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventAction = eventAction {
            try encodeContainer.encode(eventAction.rawValue, forKey: .eventAction)
        }
        if notify != false {
            try encodeContainer.encode(notify, forKey: .notify)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyDecoded = try containerValues.decode(Bool.self, forKey: .notify)
        notify = notifyDecoded
        let eventActionDecoded = try containerValues.decodeIfPresent(AccountTakeoverEventActionType.self, forKey: .eventAction)
        eventAction = eventActionDecoded
    }
}

extension AccountTakeoverActionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountTakeoverActionType(eventAction: \(String(describing: eventAction)), notify: \(String(describing: notify)))"}
}

/// <p>Account takeover action type.</p>
public struct AccountTakeoverActionType: Equatable {
    /// <p>The event action.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>BLOCK</code> Choosing this action will block the request.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_IF_CONFIGURED</code> Throw MFA challenge if user has configured it,
    ///                     else allow the request.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_REQUIRED</code> Throw MFA challenge if user has configured it, else
    ///                     block the request.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NO_ACTION</code> Allow the user sign-in.</p>
    ///             </li>
    ///          </ul>
    public let eventAction: AccountTakeoverEventActionType?
    /// <p>Flag specifying whether to send a notification.</p>
    public let notify: Bool

    public init (
        eventAction: AccountTakeoverEventActionType? = nil,
        notify: Bool = false
    )
    {
        self.eventAction = eventAction
        self.notify = notify
    }
}

extension AccountTakeoverActionsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case highAction = "HighAction"
        case lowAction = "LowAction"
        case mediumAction = "MediumAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highAction = highAction {
            try encodeContainer.encode(highAction, forKey: .highAction)
        }
        if let lowAction = lowAction {
            try encodeContainer.encode(lowAction, forKey: .lowAction)
        }
        if let mediumAction = mediumAction {
            try encodeContainer.encode(mediumAction, forKey: .mediumAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowActionDecoded = try containerValues.decodeIfPresent(AccountTakeoverActionType.self, forKey: .lowAction)
        lowAction = lowActionDecoded
        let mediumActionDecoded = try containerValues.decodeIfPresent(AccountTakeoverActionType.self, forKey: .mediumAction)
        mediumAction = mediumActionDecoded
        let highActionDecoded = try containerValues.decodeIfPresent(AccountTakeoverActionType.self, forKey: .highAction)
        highAction = highActionDecoded
    }
}

extension AccountTakeoverActionsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountTakeoverActionsType(highAction: \(String(describing: highAction)), lowAction: \(String(describing: lowAction)), mediumAction: \(String(describing: mediumAction)))"}
}

/// <p>Account takeover actions type.</p>
public struct AccountTakeoverActionsType: Equatable {
    /// <p>Action to take for a high risk.</p>
    public let highAction: AccountTakeoverActionType?
    /// <p>Action to take for a low risk.</p>
    public let lowAction: AccountTakeoverActionType?
    /// <p>Action to take for a medium risk.</p>
    public let mediumAction: AccountTakeoverActionType?

    public init (
        highAction: AccountTakeoverActionType? = nil,
        lowAction: AccountTakeoverActionType? = nil,
        mediumAction: AccountTakeoverActionType? = nil
    )
    {
        self.highAction = highAction
        self.lowAction = lowAction
        self.mediumAction = mediumAction
    }
}

public enum AccountTakeoverEventActionType {
    case block
    case mfaIfConfigured
    case mfaRequired
    case noAction
    case sdkUnknown(String)
}

extension AccountTakeoverEventActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccountTakeoverEventActionType] {
        return [
            .block,
            .mfaIfConfigured,
            .mfaRequired,
            .noAction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .block: return "BLOCK"
        case .mfaIfConfigured: return "MFA_IF_CONFIGURED"
        case .mfaRequired: return "MFA_REQUIRED"
        case .noAction: return "NO_ACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccountTakeoverEventActionType(rawValue: rawValue) ?? AccountTakeoverEventActionType.sdkUnknown(rawValue)
    }
}

extension AccountTakeoverRiskConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case notifyConfiguration = "NotifyConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            try encodeContainer.encode(actions, forKey: .actions)
        }
        if let notifyConfiguration = notifyConfiguration {
            try encodeContainer.encode(notifyConfiguration, forKey: .notifyConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notifyConfigurationDecoded = try containerValues.decodeIfPresent(NotifyConfigurationType.self, forKey: .notifyConfiguration)
        notifyConfiguration = notifyConfigurationDecoded
        let actionsDecoded = try containerValues.decodeIfPresent(AccountTakeoverActionsType.self, forKey: .actions)
        actions = actionsDecoded
    }
}

extension AccountTakeoverRiskConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountTakeoverRiskConfigurationType(actions: \(String(describing: actions)), notifyConfiguration: \(String(describing: notifyConfiguration)))"}
}

/// <p>Configuration for mitigation actions and notification for different levels of risk
///             detected for a potential account takeover.</p>
public struct AccountTakeoverRiskConfigurationType: Equatable {
    /// <p>Account takeover risk configuration actions</p>
    public let actions: AccountTakeoverActionsType?
    /// <p>The notify configuration used to construct email notifications.</p>
    public let notifyConfiguration: NotifyConfigurationType?

    public init (
        actions: AccountTakeoverActionsType? = nil,
        notifyConfiguration: NotifyConfigurationType? = nil
    )
    {
        self.actions = actions
        self.notifyConfiguration = notifyConfiguration
    }
}

public struct AddCustomAttributesInputBodyMiddleware: Middleware {
    public let id: String = "AddCustomAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomAttributesInput>
    public typealias MOutput = OperationOutput<AddCustomAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomAttributesOutputError>
}

extension AddCustomAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCustomAttributesInput(customAttributes: \(String(describing: customAttributes)), userPoolId: \(String(describing: userPoolId)))"}
}

extension AddCustomAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customAttributes = "CustomAttributes"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customAttributes = customAttributes {
            var customAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAttributes)
            for customattributeslisttype0 in customAttributes {
                try customAttributesContainer.encode(customattributeslisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct AddCustomAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "AddCustomAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomAttributesInput>
    public typealias MOutput = OperationOutput<AddCustomAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomAttributesOutputError>
}

public struct AddCustomAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "AddCustomAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCustomAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCustomAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCustomAttributesInput>
    public typealias MOutput = OperationOutput<AddCustomAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCustomAttributesOutputError>
}

/// <p>Represents the request to add custom attributes.</p>
public struct AddCustomAttributesInput: Equatable {
    /// <p>An array of custom attributes, such as Mutable and Name.</p>
    public let customAttributes: [SchemaAttributeType]?
    /// <p>The user pool ID for the user pool where you want to add custom attributes.</p>
    public let userPoolId: String?

    public init (
        customAttributes: [SchemaAttributeType]? = nil,
        userPoolId: String? = nil
    )
    {
        self.customAttributes = customAttributes
        self.userPoolId = userPoolId
    }
}

struct AddCustomAttributesInputBody: Equatable {
    public let userPoolId: String?
    public let customAttributes: [SchemaAttributeType]?
}

extension AddCustomAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customAttributes = "CustomAttributes"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let customAttributesContainer = try containerValues.decodeIfPresent([SchemaAttributeType?].self, forKey: .customAttributes)
        var customAttributesDecoded0:[SchemaAttributeType]? = nil
        if let customAttributesContainer = customAttributesContainer {
            customAttributesDecoded0 = [SchemaAttributeType]()
            for structure0 in customAttributesContainer {
                if let structure0 = structure0 {
                    customAttributesDecoded0?.append(structure0)
                }
            }
        }
        customAttributes = customAttributesDecoded0
    }
}

extension AddCustomAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCustomAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserImportInProgressException" : self = .userImportInProgressException(try UserImportInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCustomAttributesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userImportInProgressException(UserImportInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCustomAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCustomAttributesOutputResponse()"}
}

extension AddCustomAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server for the request to add custom
///             attributes.</p>
public struct AddCustomAttributesOutputResponse: Equatable {

    public init() {}
}

struct AddCustomAttributesOutputResponseBody: Equatable {
}

extension AddCustomAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminAddUserToGroupInputBodyMiddleware: Middleware {
    public let id: String = "AdminAddUserToGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminAddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminAddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminAddUserToGroupInput>
    public typealias MOutput = OperationOutput<AdminAddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminAddUserToGroupOutputError>
}

extension AdminAddUserToGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminAddUserToGroupInput(groupName: \(String(describing: groupName)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminAddUserToGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminAddUserToGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AdminAddUserToGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminAddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminAddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminAddUserToGroupInput>
    public typealias MOutput = OperationOutput<AdminAddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminAddUserToGroupOutputError>
}

public struct AdminAddUserToGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminAddUserToGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminAddUserToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminAddUserToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminAddUserToGroupInput>
    public typealias MOutput = OperationOutput<AdminAddUserToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminAddUserToGroupOutputError>
}

public struct AdminAddUserToGroupInput: Equatable {
    /// <p>The group name.</p>
    public let groupName: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?
    /// <p>The username for the user.</p>
    public let username: String?

    public init (
        groupName: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.groupName = groupName
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminAddUserToGroupInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let groupName: String?
}

extension AdminAddUserToGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension AdminAddUserToGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminAddUserToGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminAddUserToGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminAddUserToGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminAddUserToGroupOutputResponse()"}
}

extension AdminAddUserToGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminAddUserToGroupOutputResponse: Equatable {

    public init() {}
}

struct AdminAddUserToGroupOutputResponseBody: Equatable {
}

extension AdminAddUserToGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminConfirmSignUpInputBodyMiddleware: Middleware {
    public let id: String = "AdminConfirmSignUpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminConfirmSignUpInput>
    public typealias MOutput = OperationOutput<AdminConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminConfirmSignUpOutputError>
}

extension AdminConfirmSignUpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminConfirmSignUpInput(clientMetadata: \(String(describing: clientMetadata)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminConfirmSignUpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminConfirmSignUpInputHeadersMiddleware: Middleware {
    public let id: String = "AdminConfirmSignUpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminConfirmSignUpInput>
    public typealias MOutput = OperationOutput<AdminConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminConfirmSignUpOutputError>
}

public struct AdminConfirmSignUpInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminConfirmSignUpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminConfirmSignUpInput>
    public typealias MOutput = OperationOutput<AdminConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminConfirmSignUpOutputError>
}

/// <p>Represents the request to confirm user registration.</p>
public struct AdminConfirmSignUpInput: Equatable {
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>If your user pool configuration includes triggers, the AdminConfirmSignUp API action
    ///             invokes the AWS Lambda function that is specified for the <i>post
    ///                 confirmation</i> trigger. When Amazon Cognito invokes this function, it
    ///             passes a JSON payload, which the function receives as input. In this payload, the
    ///                 <code>clientMetadata</code> attribute provides the data that you assigned to the
    ///             ClientMetadata parameter in your AdminConfirmSignUp request. In your function code in
    ///             AWS Lambda, you can process the ClientMetadata value to enhance your workflow for your
    ///             specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The user pool ID for which you want to confirm user registration.</p>
    public let userPoolId: String?
    /// <p>The user name for which you want to confirm user registration.</p>
    public let username: String?

    public init (
        clientMetadata: [String:String]? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.clientMetadata = clientMetadata
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminConfirmSignUpInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let clientMetadata: [String:String]?
}

extension AdminConfirmSignUpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension AdminConfirmSignUpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminConfirmSignUpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFailedAttemptsException" : self = .tooManyFailedAttemptsException(try TooManyFailedAttemptsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminConfirmSignUpOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyFailedAttemptsException(TooManyFailedAttemptsException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminConfirmSignUpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminConfirmSignUpOutputResponse()"}
}

extension AdminConfirmSignUpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server for the request to confirm
///             registration.</p>
public struct AdminConfirmSignUpOutputResponse: Equatable {

    public init() {}
}

struct AdminConfirmSignUpOutputResponseBody: Equatable {
}

extension AdminConfirmSignUpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AdminCreateUserConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowAdminCreateUserOnly = "AllowAdminCreateUserOnly"
        case inviteMessageTemplate = "InviteMessageTemplate"
        case unusedAccountValidityDays = "UnusedAccountValidityDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowAdminCreateUserOnly != false {
            try encodeContainer.encode(allowAdminCreateUserOnly, forKey: .allowAdminCreateUserOnly)
        }
        if let inviteMessageTemplate = inviteMessageTemplate {
            try encodeContainer.encode(inviteMessageTemplate, forKey: .inviteMessageTemplate)
        }
        if unusedAccountValidityDays != 0 {
            try encodeContainer.encode(unusedAccountValidityDays, forKey: .unusedAccountValidityDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowAdminCreateUserOnlyDecoded = try containerValues.decode(Bool.self, forKey: .allowAdminCreateUserOnly)
        allowAdminCreateUserOnly = allowAdminCreateUserOnlyDecoded
        let unusedAccountValidityDaysDecoded = try containerValues.decode(Int.self, forKey: .unusedAccountValidityDays)
        unusedAccountValidityDays = unusedAccountValidityDaysDecoded
        let inviteMessageTemplateDecoded = try containerValues.decodeIfPresent(MessageTemplateType.self, forKey: .inviteMessageTemplate)
        inviteMessageTemplate = inviteMessageTemplateDecoded
    }
}

extension AdminCreateUserConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminCreateUserConfigType(allowAdminCreateUserOnly: \(String(describing: allowAdminCreateUserOnly)), inviteMessageTemplate: \(String(describing: inviteMessageTemplate)), unusedAccountValidityDays: \(String(describing: unusedAccountValidityDays)))"}
}

/// <p>The configuration for creating a new user profile.</p>
public struct AdminCreateUserConfigType: Equatable {
    /// <p>Set to <code>True</code> if only the administrator is allowed to create user profiles.
    ///             Set to <code>False</code> if users can sign themselves up via an app.</p>
    public let allowAdminCreateUserOnly: Bool
    /// <p>The message template to be used for the welcome message to new users.</p>
    ///         <p>See also <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-message-customizations.html#cognito-user-pool-settings-user-invitation-message-customization">Customizing User Invitation Messages</a>.</p>
    public let inviteMessageTemplate: MessageTemplateType?
    /// <p>The user account expiration limit, in days, after which the account is no longer
    ///             usable. To reset the account after that time limit, you must call
    ///                 <code>AdminCreateUser</code> again, specifying <code>"RESEND"</code> for the
    ///                 <code>MessageAction</code> parameter. The default value for this parameter is 7. </p>
    ///         <note>
    ///             <p>If you set a value for <code>TemporaryPasswordValidityDays</code> in
    ///                     <code>PasswordPolicy</code>, that value will be used and
    ///                     <code>UnusedAccountValidityDays</code> will be deprecated for that user pool.
    ///             </p>
    ///         </note>
    public let unusedAccountValidityDays: Int

    public init (
        allowAdminCreateUserOnly: Bool = false,
        inviteMessageTemplate: MessageTemplateType? = nil,
        unusedAccountValidityDays: Int = 0
    )
    {
        self.allowAdminCreateUserOnly = allowAdminCreateUserOnly
        self.inviteMessageTemplate = inviteMessageTemplate
        self.unusedAccountValidityDays = unusedAccountValidityDays
    }
}

public struct AdminCreateUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminCreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminCreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminCreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminCreateUserInput>
    public typealias MOutput = OperationOutput<AdminCreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminCreateUserOutputError>
}

extension AdminCreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminCreateUserInput(clientMetadata: \(String(describing: clientMetadata)), desiredDeliveryMediums: \(String(describing: desiredDeliveryMediums)), forceAliasCreation: \(String(describing: forceAliasCreation)), messageAction: \(String(describing: messageAction)), temporaryPassword: \(String(describing: temporaryPassword)), userAttributes: \(String(describing: userAttributes)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)), validationData: \(String(describing: validationData)))"}
}

extension AdminCreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case desiredDeliveryMediums = "DesiredDeliveryMediums"
        case forceAliasCreation = "ForceAliasCreation"
        case messageAction = "MessageAction"
        case temporaryPassword = "TemporaryPassword"
        case userAttributes = "UserAttributes"
        case userPoolId = "UserPoolId"
        case username = "Username"
        case validationData = "ValidationData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let desiredDeliveryMediums = desiredDeliveryMediums {
            var desiredDeliveryMediumsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .desiredDeliveryMediums)
            for deliverymediumlisttype0 in desiredDeliveryMediums {
                try desiredDeliveryMediumsContainer.encode(deliverymediumlisttype0.rawValue)
            }
        }
        if forceAliasCreation != false {
            try encodeContainer.encode(forceAliasCreation, forKey: .forceAliasCreation)
        }
        if let messageAction = messageAction {
            try encodeContainer.encode(messageAction.rawValue, forKey: .messageAction)
        }
        if let temporaryPassword = temporaryPassword {
            try encodeContainer.encode(temporaryPassword, forKey: .temporaryPassword)
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelisttype0 in userAttributes {
                try userAttributesContainer.encode(attributelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let validationData = validationData {
            var validationDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationData)
            for attributelisttype0 in validationData {
                try validationDataContainer.encode(attributelisttype0)
            }
        }
    }
}

public struct AdminCreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminCreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminCreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminCreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminCreateUserInput>
    public typealias MOutput = OperationOutput<AdminCreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminCreateUserOutputError>
}

public struct AdminCreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminCreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminCreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminCreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminCreateUserInput>
    public typealias MOutput = OperationOutput<AdminCreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminCreateUserOutputError>
}

/// <p>Represents the request to create a user in the specified user pool.</p>
public struct AdminCreateUserInput: Equatable {
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the AdminCreateUser API action, Amazon Cognito invokes the function that is
    ///             assigned to the <i>pre sign-up</i> trigger. When Amazon Cognito invokes
    ///             this function, it passes a JSON payload, which the function receives as input. This
    ///             payload contains a <code>clientMetadata</code> attribute, which provides the data that
    ///             you assigned to the ClientMetadata parameter in your AdminCreateUser request. In your
    ///             function code in AWS Lambda, you can process the <code>clientMetadata</code> value to
    ///             enhance your workflow for your specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>Specify <code>"EMAIL"</code> if email will be used to send the welcome message.
    ///             Specify <code>"SMS"</code> if the phone number will be used. The default value is
    ///                 <code>"SMS"</code>. More than one value can be specified.</p>
    public let desiredDeliveryMediums: [DeliveryMediumType]?
    /// <p>This parameter is only used if the <code>phone_number_verified</code> or
    ///                 <code>email_verified</code> attribute is set to <code>True</code>. Otherwise, it is
    ///             ignored.</p>
    ///         <p>If this parameter is set to <code>True</code> and the phone number or email address
    ///             specified in the UserAttributes parameter already exists as an alias with a different
    ///             user, the API call will migrate the alias from the previous user to the newly created
    ///             user. The previous user will no longer be able to log in using that alias.</p>
    ///         <p>If this parameter is set to <code>False</code>, the API throws an
    ///                 <code>AliasExistsException</code> error if the alias already exists. The default
    ///             value is <code>False</code>.</p>
    public let forceAliasCreation: Bool
    /// <p>Set to <code>"RESEND"</code> to resend the invitation message to a user that already
    ///             exists and reset the expiration limit on the user's account. Set to
    ///                 <code>"SUPPRESS"</code> to suppress sending the message. Only one value can be
    ///             specified.</p>
    public let messageAction: MessageActionType?
    /// <p>The user's temporary password. This password must conform to the password policy that
    ///             you specified when you created the user pool.</p>
    ///         <p>The temporary password is valid only once. To complete the Admin Create User flow, the
    ///             user must enter the temporary password in the sign-in page along with a new password to
    ///             be used in all future sign-ins.</p>
    ///         <p>This parameter is not required. If you do not specify a value, Amazon Cognito
    ///             generates one for you.</p>
    ///         <p>The temporary password can only be used until the user account expiration limit that
    ///             you specified when you created the user pool. To reset the account after that time
    ///             limit, you must call <code>AdminCreateUser</code> again, specifying
    ///                 <code>"RESEND"</code> for the <code>MessageAction</code> parameter.</p>
    public let temporaryPassword: String?
    /// <p>An array of name-value pairs that contain user attributes and attribute values to be
    ///             set for the user to be created. You can create a user without specifying any attributes
    ///             other than <code>Username</code>. However, any attributes that you specify as required
    ///             (when creating a user pool or in the <b>Attributes</b> tab of
    ///             the console) must be supplied either by you (in your call to
    ///                 <code>AdminCreateUser</code>) or by the user (when he or she signs up in response to
    ///             your welcome message).</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    ///         <p>To send a message inviting the user to sign up, you must specify the user's email
    ///             address or phone number. This can be done in your call to AdminCreateUser or in the
    ///                 <b>Users</b> tab of the Amazon Cognito console for
    ///             managing your user pools.</p>
    ///         <p>In your call to <code>AdminCreateUser</code>, you can set the
    ///                 <code>email_verified</code> attribute to <code>True</code>, and you can set the
    ///                 <code>phone_number_verified</code> attribute to <code>True</code>. (You can also do
    ///             this by calling <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminUpdateUserAttributes.html">AdminUpdateUserAttributes</a>.)</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>email</b>: The email address of the user to whom
    ///                     the message that contains the code and username will be sent. Required if the
    ///                         <code>email_verified</code> attribute is set to <code>True</code>, or if
    ///                         <code>"EMAIL"</code> is specified in the <code>DesiredDeliveryMediums</code>
    ///                     parameter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>phone_number</b>: The phone number of the user to
    ///                     whom the message that contains the code and username will be sent. Required if
    ///                     the <code>phone_number_verified</code> attribute is set to <code>True</code>, or
    ///                     if <code>"SMS"</code> is specified in the <code>DesiredDeliveryMediums</code>
    ///                     parameter.</p>
    ///             </li>
    ///          </ul>
    public let userAttributes: [AttributeType]?
    /// <p>The user pool ID for the user pool where the user will be created.</p>
    public let userPoolId: String?
    /// <p>The username for the user. Must be unique within the user pool. Must be a UTF-8 string
    ///             between 1 and 128 characters. After the user is created, the username cannot be
    ///             changed.</p>
    public let username: String?
    /// <p>The user's validation data. This is an array of name-value pairs that contain user
    ///             attributes and attribute values that you can use for custom validation, such as
    ///             restricting the types of user accounts that can be registered. For example, you might
    ///             choose to allow or disallow user sign-up based on the user's domain.</p>
    ///         <p>To configure custom validation, you must create a Pre Sign-up Lambda trigger for the
    ///             user pool as described in the Amazon Cognito Developer Guide. The Lambda trigger
    ///             receives the validation data and uses it in the validation process.</p>
    ///         <p>The user's validation data is not persisted.</p>
    public let validationData: [AttributeType]?

    public init (
        clientMetadata: [String:String]? = nil,
        desiredDeliveryMediums: [DeliveryMediumType]? = nil,
        forceAliasCreation: Bool = false,
        messageAction: MessageActionType? = nil,
        temporaryPassword: String? = nil,
        userAttributes: [AttributeType]? = nil,
        userPoolId: String? = nil,
        username: String? = nil,
        validationData: [AttributeType]? = nil
    )
    {
        self.clientMetadata = clientMetadata
        self.desiredDeliveryMediums = desiredDeliveryMediums
        self.forceAliasCreation = forceAliasCreation
        self.messageAction = messageAction
        self.temporaryPassword = temporaryPassword
        self.userAttributes = userAttributes
        self.userPoolId = userPoolId
        self.username = username
        self.validationData = validationData
    }
}

struct AdminCreateUserInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let userAttributes: [AttributeType]?
    public let validationData: [AttributeType]?
    public let temporaryPassword: String?
    public let forceAliasCreation: Bool
    public let messageAction: MessageActionType?
    public let desiredDeliveryMediums: [DeliveryMediumType]?
    public let clientMetadata: [String:String]?
}

extension AdminCreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case desiredDeliveryMediums = "DesiredDeliveryMediums"
        case forceAliasCreation = "ForceAliasCreation"
        case messageAction = "MessageAction"
        case temporaryPassword = "TemporaryPassword"
        case userAttributes = "UserAttributes"
        case userPoolId = "UserPoolId"
        case username = "Username"
        case validationData = "ValidationData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let validationDataContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .validationData)
        var validationDataDecoded0:[AttributeType]? = nil
        if let validationDataContainer = validationDataContainer {
            validationDataDecoded0 = [AttributeType]()
            for structure0 in validationDataContainer {
                if let structure0 = structure0 {
                    validationDataDecoded0?.append(structure0)
                }
            }
        }
        validationData = validationDataDecoded0
        let temporaryPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .temporaryPassword)
        temporaryPassword = temporaryPasswordDecoded
        let forceAliasCreationDecoded = try containerValues.decode(Bool.self, forKey: .forceAliasCreation)
        forceAliasCreation = forceAliasCreationDecoded
        let messageActionDecoded = try containerValues.decodeIfPresent(MessageActionType.self, forKey: .messageAction)
        messageAction = messageActionDecoded
        let desiredDeliveryMediumsContainer = try containerValues.decodeIfPresent([DeliveryMediumType?].self, forKey: .desiredDeliveryMediums)
        var desiredDeliveryMediumsDecoded0:[DeliveryMediumType]? = nil
        if let desiredDeliveryMediumsContainer = desiredDeliveryMediumsContainer {
            desiredDeliveryMediumsDecoded0 = [DeliveryMediumType]()
            for string0 in desiredDeliveryMediumsContainer {
                if let string0 = string0 {
                    desiredDeliveryMediumsDecoded0?.append(string0)
                }
            }
        }
        desiredDeliveryMediums = desiredDeliveryMediumsDecoded0
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension AdminCreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminCreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedUserStateException" : self = .unsupportedUserStateException(try UnsupportedUserStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsernameExistsException" : self = .usernameExistsException(try UsernameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminCreateUserOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case unsupportedUserStateException(UnsupportedUserStateException)
    case userLambdaValidationException(UserLambdaValidationException)
    case usernameExistsException(UsernameExistsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminCreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminCreateUserOutputResponse(user: \(String(describing: user)))"}
}

extension AdminCreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminCreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

/// <p>Represents the response from the server to the request to create the user.</p>
public struct AdminCreateUserOutputResponse: Equatable {
    /// <p>The newly created user.</p>
    public let user: UserType?

    public init (
        user: UserType? = nil
    )
    {
        self.user = user
    }
}

struct AdminCreateUserOutputResponseBody: Equatable {
    public let user: UserType?
}

extension AdminCreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(UserType.self, forKey: .user)
        user = userDecoded
    }
}

public struct AdminDeleteUserAttributesInputBodyMiddleware: Middleware {
    public let id: String = "AdminDeleteUserAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserAttributesOutputError>
}

extension AdminDeleteUserAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDeleteUserAttributesInput(userAttributeNames: \(String(describing: userAttributeNames)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminDeleteUserAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userAttributeNames = "UserAttributeNames"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userAttributeNames = userAttributeNames {
            var userAttributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributeNames)
            for attributenamelisttype0 in userAttributeNames {
                try userAttributeNamesContainer.encode(attributenamelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminDeleteUserAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "AdminDeleteUserAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserAttributesOutputError>
}

public struct AdminDeleteUserAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminDeleteUserAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserAttributesOutputError>
}

/// <p>Represents the request to delete user attributes as an administrator.</p>
public struct AdminDeleteUserAttributesInput: Equatable {
    /// <p>An array of strings representing the user attribute names you wish to delete.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributeNames: [String]?
    /// <p>The user pool ID for the user pool where you want to delete user attributes.</p>
    public let userPoolId: String?
    /// <p>The user name of the user from which you would like to delete attributes.</p>
    public let username: String?

    public init (
        userAttributeNames: [String]? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userAttributeNames = userAttributeNames
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminDeleteUserAttributesInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let userAttributeNames: [String]?
}

extension AdminDeleteUserAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userAttributeNames = "UserAttributeNames"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userAttributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userAttributeNames)
        var userAttributeNamesDecoded0:[String]? = nil
        if let userAttributeNamesContainer = userAttributeNamesContainer {
            userAttributeNamesDecoded0 = [String]()
            for string0 in userAttributeNamesContainer {
                if let string0 = string0 {
                    userAttributeNamesDecoded0?.append(string0)
                }
            }
        }
        userAttributeNames = userAttributeNamesDecoded0
    }
}

extension AdminDeleteUserAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminDeleteUserAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminDeleteUserAttributesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminDeleteUserAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDeleteUserAttributesOutputResponse()"}
}

extension AdminDeleteUserAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response received from the server for a request to delete user
///             attributes.</p>
public struct AdminDeleteUserAttributesOutputResponse: Equatable {

    public init() {}
}

struct AdminDeleteUserAttributesOutputResponseBody: Equatable {
}

extension AdminDeleteUserAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminDeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminDeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserOutputError>
}

extension AdminDeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDeleteUserInput(userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminDeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminDeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminDeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserOutputError>
}

public struct AdminDeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminDeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDeleteUserInput>
    public typealias MOutput = OperationOutput<AdminDeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDeleteUserOutputError>
}

/// <p>Represents the request to delete a user as an administrator.</p>
public struct AdminDeleteUserInput: Equatable {
    /// <p>The user pool ID for the user pool where you want to delete the user.</p>
    public let userPoolId: String?
    /// <p>The user name of the user you wish to delete.</p>
    public let username: String?

    public init (
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminDeleteUserInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
}

extension AdminDeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminDeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminDeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminDeleteUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminDeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDeleteUserOutputResponse()"}
}

extension AdminDeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminDeleteUserOutputResponse: Equatable {

    public init() {}
}

struct AdminDeleteUserOutputResponseBody: Equatable {
}

extension AdminDeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminDisableProviderForUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminDisableProviderForUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminDisableProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableProviderForUserOutputError>
}

extension AdminDisableProviderForUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDisableProviderForUserInput(user: \(String(describing: user)), userPoolId: \(String(describing: userPoolId)))"}
}

extension AdminDisableProviderForUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case user = "User"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct AdminDisableProviderForUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminDisableProviderForUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminDisableProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableProviderForUserOutputError>
}

public struct AdminDisableProviderForUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminDisableProviderForUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminDisableProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableProviderForUserOutputError>
}

public struct AdminDisableProviderForUserInput: Equatable {
    /// <p>The user to be disabled.</p>
    public let user: ProviderUserIdentifierType?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        user: ProviderUserIdentifierType? = nil,
        userPoolId: String? = nil
    )
    {
        self.user = user
        self.userPoolId = userPoolId
    }
}

struct AdminDisableProviderForUserInputBody: Equatable {
    public let userPoolId: String?
    public let user: ProviderUserIdentifierType?
}

extension AdminDisableProviderForUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case user = "User"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(ProviderUserIdentifierType.self, forKey: .user)
        user = userDecoded
    }
}

extension AdminDisableProviderForUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminDisableProviderForUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminDisableProviderForUserOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminDisableProviderForUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDisableProviderForUserOutputResponse()"}
}

extension AdminDisableProviderForUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminDisableProviderForUserOutputResponse: Equatable {

    public init() {}
}

struct AdminDisableProviderForUserOutputResponseBody: Equatable {
}

extension AdminDisableProviderForUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminDisableUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminDisableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableUserInput>
    public typealias MOutput = OperationOutput<AdminDisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableUserOutputError>
}

extension AdminDisableUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDisableUserInput(userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminDisableUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminDisableUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminDisableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableUserInput>
    public typealias MOutput = OperationOutput<AdminDisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableUserOutputError>
}

public struct AdminDisableUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminDisableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminDisableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminDisableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminDisableUserInput>
    public typealias MOutput = OperationOutput<AdminDisableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminDisableUserOutputError>
}

/// <p>Represents the request to disable the user as an administrator.</p>
public struct AdminDisableUserInput: Equatable {
    /// <p>The user pool ID for the user pool where you want to disable the user.</p>
    public let userPoolId: String?
    /// <p>The user name of the user you wish to disable.</p>
    public let username: String?

    public init (
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminDisableUserInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
}

extension AdminDisableUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminDisableUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminDisableUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminDisableUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminDisableUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminDisableUserOutputResponse()"}
}

extension AdminDisableUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response received from the server to disable the user as an
///             administrator.</p>
public struct AdminDisableUserOutputResponse: Equatable {

    public init() {}
}

struct AdminDisableUserOutputResponseBody: Equatable {
}

extension AdminDisableUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminEnableUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminEnableUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminEnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminEnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminEnableUserInput>
    public typealias MOutput = OperationOutput<AdminEnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminEnableUserOutputError>
}

extension AdminEnableUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminEnableUserInput(userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminEnableUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminEnableUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminEnableUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminEnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminEnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminEnableUserInput>
    public typealias MOutput = OperationOutput<AdminEnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminEnableUserOutputError>
}

public struct AdminEnableUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminEnableUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminEnableUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminEnableUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminEnableUserInput>
    public typealias MOutput = OperationOutput<AdminEnableUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminEnableUserOutputError>
}

/// <p>Represents the request that enables the user as an administrator.</p>
public struct AdminEnableUserInput: Equatable {
    /// <p>The user pool ID for the user pool where you want to enable the user.</p>
    public let userPoolId: String?
    /// <p>The user name of the user you wish to enable.</p>
    public let username: String?

    public init (
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminEnableUserInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
}

extension AdminEnableUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminEnableUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminEnableUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminEnableUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminEnableUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminEnableUserOutputResponse()"}
}

extension AdminEnableUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server for the request to enable a user as an
///             administrator.</p>
public struct AdminEnableUserOutputResponse: Equatable {

    public init() {}
}

struct AdminEnableUserOutputResponseBody: Equatable {
}

extension AdminEnableUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminForgetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "AdminForgetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminForgetDeviceInput>
    public typealias MOutput = OperationOutput<AdminForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminForgetDeviceOutputError>
}

extension AdminForgetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminForgetDeviceInput(deviceKey: \(String(describing: deviceKey)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminForgetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminForgetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "AdminForgetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminForgetDeviceInput>
    public typealias MOutput = OperationOutput<AdminForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminForgetDeviceOutputError>
}

public struct AdminForgetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminForgetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminForgetDeviceInput>
    public typealias MOutput = OperationOutput<AdminForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminForgetDeviceOutputError>
}

/// <p>Sends the forgot device request, as an administrator.</p>
public struct AdminForgetDeviceInput: Equatable {
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user name.</p>
    public let username: String?

    public init (
        deviceKey: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.deviceKey = deviceKey
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminForgetDeviceInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let deviceKey: String?
}

extension AdminForgetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
    }
}

extension AdminForgetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminForgetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminForgetDeviceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminForgetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminForgetDeviceOutputResponse()"}
}

extension AdminForgetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminForgetDeviceOutputResponse: Equatable {

    public init() {}
}

struct AdminForgetDeviceOutputResponseBody: Equatable {
}

extension AdminForgetDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminGetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "AdminGetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetDeviceInput>
    public typealias MOutput = OperationOutput<AdminGetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetDeviceOutputError>
}

extension AdminGetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminGetDeviceInput(deviceKey: \(String(describing: deviceKey)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminGetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminGetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "AdminGetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetDeviceInput>
    public typealias MOutput = OperationOutput<AdminGetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetDeviceOutputError>
}

public struct AdminGetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminGetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetDeviceInput>
    public typealias MOutput = OperationOutput<AdminGetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetDeviceOutputError>
}

/// <p>Represents the request to get the device, as an administrator.</p>
public struct AdminGetDeviceInput: Equatable {
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user name.</p>
    public let username: String?

    public init (
        deviceKey: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.deviceKey = deviceKey
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminGetDeviceInputBody: Equatable {
    public let deviceKey: String?
    public let userPoolId: String?
    public let username: String?
}

extension AdminGetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminGetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminGetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminGetDeviceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminGetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminGetDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension AdminGetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminGetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

/// <p>Gets the device response, as an administrator.</p>
public struct AdminGetDeviceOutputResponse: Equatable {
    /// <p>The device.</p>
    public let device: DeviceType?

    public init (
        device: DeviceType? = nil
    )
    {
        self.device = device
    }
}

struct AdminGetDeviceOutputResponseBody: Equatable {
    public let device: DeviceType?
}

extension AdminGetDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct AdminGetUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminGetUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetUserInput>
    public typealias MOutput = OperationOutput<AdminGetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetUserOutputError>
}

extension AdminGetUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminGetUserInput(userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminGetUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminGetUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminGetUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetUserInput>
    public typealias MOutput = OperationOutput<AdminGetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetUserOutputError>
}

public struct AdminGetUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminGetUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminGetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminGetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminGetUserInput>
    public typealias MOutput = OperationOutput<AdminGetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminGetUserOutputError>
}

/// <p>Represents the request to get the specified user as an administrator.</p>
public struct AdminGetUserInput: Equatable {
    /// <p>The user pool ID for the user pool where you want to get information about the
    ///             user.</p>
    public let userPoolId: String?
    /// <p>The user name of the user you wish to retrieve.</p>
    public let username: String?

    public init (
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminGetUserInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
}

extension AdminGetUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminGetUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminGetUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminGetUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminGetUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminGetUserOutputResponse(enabled: \(String(describing: enabled)), mFAOptions: \(String(describing: mFAOptions)), preferredMfaSetting: \(String(describing: preferredMfaSetting)), userAttributes: \(String(describing: userAttributes)), userCreateDate: \(String(describing: userCreateDate)), userLastModifiedDate: \(String(describing: userLastModifiedDate)), userMFASettingList: \(String(describing: userMFASettingList)), userStatus: \(String(describing: userStatus)), username: \(String(describing: username)))"}
}

extension AdminGetUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminGetUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.enabled = output.enabled
            self.mFAOptions = output.mFAOptions
            self.preferredMfaSetting = output.preferredMfaSetting
            self.userAttributes = output.userAttributes
            self.userCreateDate = output.userCreateDate
            self.userLastModifiedDate = output.userLastModifiedDate
            self.userMFASettingList = output.userMFASettingList
            self.userStatus = output.userStatus
            self.username = output.username
        } else {
            self.enabled = false
            self.mFAOptions = nil
            self.preferredMfaSetting = nil
            self.userAttributes = nil
            self.userCreateDate = nil
            self.userLastModifiedDate = nil
            self.userMFASettingList = nil
            self.userStatus = nil
            self.username = nil
        }
    }
}

/// <p>Represents the response from the server from the request to get the specified user as
///             an administrator.</p>
public struct AdminGetUserOutputResponse: Equatable {
    /// <p>Indicates that the status is enabled.</p>
    public let enabled: Bool
    /// <p>
    ///             <i>This response parameter is no longer supported.</i> It provides
    ///             information only about SMS MFA configurations. It doesn't provide information about TOTP
    ///             software token MFA configurations. To look up information about either type of MFA
    ///             configuration, use UserMFASettingList instead.</p>
    public let mFAOptions: [MFAOptionType]?
    /// <p>The user's preferred MFA setting.</p>
    public let preferredMfaSetting: String?
    /// <p>An array of name-value pairs representing user attributes.</p>
    public let userAttributes: [AttributeType]?
    /// <p>The date the user was created.</p>
    public let userCreateDate: Date?
    /// <p>The date the user was last modified.</p>
    public let userLastModifiedDate: Date?
    /// <p>The MFA options that are enabled for the user. The possible values in this list are
    ///                 <code>SMS_MFA</code> and <code>SOFTWARE_TOKEN_MFA</code>.</p>
    public let userMFASettingList: [String]?
    /// <p>The user status. Can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>UNCONFIRMED - User has been created but not confirmed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CONFIRMED - User has been confirmed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARCHIVED - User is no longer active.</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPROMISED - User is disabled due to a potential security threat.</p>
    ///             </li>
    ///             <li>
    ///                 <p>UNKNOWN - User status is not known.</p>
    ///             </li>
    ///             <li>
    ///                 <p>RESET_REQUIRED - User is confirmed, but the user must request a code and reset
    ///                     his or her password before he or she can sign in.</p>
    ///             </li>
    ///             <li>
    ///                 <p>FORCE_CHANGE_PASSWORD - The user is confirmed and the user can sign in using a
    ///                     temporary password, but on first sign-in, the user must change his or her
    ///                     password to a new value before doing anything else. </p>
    ///             </li>
    ///          </ul>
    public let userStatus: UserStatusType?
    /// <p>The user name of the user about whom you are receiving information.</p>
    public let username: String?

    public init (
        enabled: Bool = false,
        mFAOptions: [MFAOptionType]? = nil,
        preferredMfaSetting: String? = nil,
        userAttributes: [AttributeType]? = nil,
        userCreateDate: Date? = nil,
        userLastModifiedDate: Date? = nil,
        userMFASettingList: [String]? = nil,
        userStatus: UserStatusType? = nil,
        username: String? = nil
    )
    {
        self.enabled = enabled
        self.mFAOptions = mFAOptions
        self.preferredMfaSetting = preferredMfaSetting
        self.userAttributes = userAttributes
        self.userCreateDate = userCreateDate
        self.userLastModifiedDate = userLastModifiedDate
        self.userMFASettingList = userMFASettingList
        self.userStatus = userStatus
        self.username = username
    }
}

struct AdminGetUserOutputResponseBody: Equatable {
    public let username: String?
    public let userAttributes: [AttributeType]?
    public let userCreateDate: Date?
    public let userLastModifiedDate: Date?
    public let enabled: Bool
    public let userStatus: UserStatusType?
    public let mFAOptions: [MFAOptionType]?
    public let preferredMfaSetting: String?
    public let userMFASettingList: [String]?
}

extension AdminGetUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case mFAOptions = "MFAOptions"
        case preferredMfaSetting = "PreferredMfaSetting"
        case userAttributes = "UserAttributes"
        case userCreateDate = "UserCreateDate"
        case userLastModifiedDate = "UserLastModifiedDate"
        case userMFASettingList = "UserMFASettingList"
        case userStatus = "UserStatus"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let userCreateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .userCreateDate)
        userCreateDate = userCreateDateDecoded
        let userLastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .userLastModifiedDate)
        userLastModifiedDate = userLastModifiedDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let userStatusDecoded = try containerValues.decodeIfPresent(UserStatusType.self, forKey: .userStatus)
        userStatus = userStatusDecoded
        let mFAOptionsContainer = try containerValues.decodeIfPresent([MFAOptionType?].self, forKey: .mFAOptions)
        var mFAOptionsDecoded0:[MFAOptionType]? = nil
        if let mFAOptionsContainer = mFAOptionsContainer {
            mFAOptionsDecoded0 = [MFAOptionType]()
            for structure0 in mFAOptionsContainer {
                if let structure0 = structure0 {
                    mFAOptionsDecoded0?.append(structure0)
                }
            }
        }
        mFAOptions = mFAOptionsDecoded0
        let preferredMfaSettingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMfaSetting)
        preferredMfaSetting = preferredMfaSettingDecoded
        let userMFASettingListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userMFASettingList)
        var userMFASettingListDecoded0:[String]? = nil
        if let userMFASettingListContainer = userMFASettingListContainer {
            userMFASettingListDecoded0 = [String]()
            for string0 in userMFASettingListContainer {
                if let string0 = string0 {
                    userMFASettingListDecoded0?.append(string0)
                }
            }
        }
        userMFASettingList = userMFASettingListDecoded0
    }
}

public struct AdminInitiateAuthInputBodyMiddleware: Middleware {
    public let id: String = "AdminInitiateAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminInitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminInitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminInitiateAuthInput>
    public typealias MOutput = OperationOutput<AdminInitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminInitiateAuthOutputError>
}

extension AdminInitiateAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminInitiateAuthInput(analyticsMetadata: \(String(describing: analyticsMetadata)), authFlow: \(String(describing: authFlow)), authParameters: \(String(describing: authParameters)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), contextData: \(String(describing: contextData)), userPoolId: \(String(describing: userPoolId)))"}
}

extension AdminInitiateAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case authFlow = "AuthFlow"
        case authParameters = "AuthParameters"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case contextData = "ContextData"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let authFlow = authFlow {
            try encodeContainer.encode(authFlow.rawValue, forKey: .authFlow)
        }
        if let authParameters = authParameters {
            var authParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .authParameters)
            for (dictKey0, authparameterstype0) in authParameters {
                try authParametersContainer.encode(authparameterstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let contextData = contextData {
            try encodeContainer.encode(contextData, forKey: .contextData)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct AdminInitiateAuthInputHeadersMiddleware: Middleware {
    public let id: String = "AdminInitiateAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminInitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminInitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminInitiateAuthInput>
    public typealias MOutput = OperationOutput<AdminInitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminInitiateAuthOutputError>
}

public struct AdminInitiateAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminInitiateAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminInitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminInitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminInitiateAuthInput>
    public typealias MOutput = OperationOutput<AdminInitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminInitiateAuthOutputError>
}

/// <p>Initiates the authorization request, as an administrator.</p>
public struct AdminInitiateAuthInput: Equatable {
    /// <p>The analytics metadata for collecting Amazon Pinpoint metrics for
    ///                 <code>AdminInitiateAuth</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The authentication flow for this call to execute. The API action will depend on this
    ///             value. For example:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>REFRESH_TOKEN_AUTH</code> will take in a valid refresh token and return
    ///                     new tokens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_SRP_AUTH</code> will take in <code>USERNAME</code> and
    ///                         <code>SRP_A</code> and return the SRP variables to be used for next
    ///                     challenge execution.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_PASSWORD_AUTH</code> will take in <code>USERNAME</code> and
    ///                         <code>PASSWORD</code> and return the next challenge or tokens.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_SRP_AUTH</code>: Authentication flow for the Secure Remote Password
    ///                     (SRP) protocol.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>REFRESH_TOKEN_AUTH</code>/<code>REFRESH_TOKEN</code>: Authentication
    ///                     flow for refreshing the access token and ID token by supplying a valid refresh
    ///                     token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CUSTOM_AUTH</code>: Custom authentication flow.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ADMIN_NO_SRP_AUTH</code>: Non-SRP authentication flow; you can pass in
    ///                     the USERNAME and PASSWORD directly if the flow is enabled for calling the app
    ///                     client.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_PASSWORD_AUTH</code>: Non-SRP authentication flow; USERNAME and
    ///                     PASSWORD are passed directly. If a user migration Lambda trigger is set, this
    ///                     flow will invoke the user migration Lambda if the USERNAME is not found in the
    ///                     user pool. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ADMIN_USER_PASSWORD_AUTH</code>: Admin-based user password
    ///                     authentication. This replaces the <code>ADMIN_NO_SRP_AUTH</code> authentication
    ///                     flow. In this flow, Cognito receives the password in the request instead of
    ///                     using the SRP process to verify passwords.</p>
    ///             </li>
    ///          </ul>
    public let authFlow: AuthFlowType?
    /// <p>The authentication parameters. These are inputs corresponding to the
    ///                 <code>AuthFlow</code> that you are invoking. The required values depend on the value
    ///             of <code>AuthFlow</code>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For <code>USER_SRP_AUTH</code>: <code>USERNAME</code> (required),
    ///                         <code>SRP_A</code> (required), <code>SECRET_HASH</code> (required if the app
    ///                     client is configured with a client secret), <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For <code>REFRESH_TOKEN_AUTH/REFRESH_TOKEN</code>: <code>REFRESH_TOKEN</code>
    ///                     (required), <code>SECRET_HASH</code> (required if the app client is configured
    ///                     with a client secret), <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For <code>ADMIN_NO_SRP_AUTH</code>: <code>USERNAME</code> (required),
    ///                         <code>SECRET_HASH</code> (if app client is configured with client secret),
    ///                         <code>PASSWORD</code> (required), <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For <code>CUSTOM_AUTH</code>: <code>USERNAME</code> (required),
    ///                         <code>SECRET_HASH</code> (if app client is configured with client secret),
    ///                         <code>DEVICE_KEY</code>. To start the authentication flow with password
    ///                     verification, include <code>ChallengeName: SRP_A</code> and <code>SRP_A: (The
    ///                         SRP_A Value)</code>.</p>
    ///             </li>
    ///          </ul>
    public let authParameters: [String:String]?
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for certain custom
    ///             workflows that this action triggers.</p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the AdminInitiateAuth API action, Amazon Cognito invokes the AWS Lambda
    ///             functions that are specified for various triggers. The ClientMetadata value is passed as
    ///             input to the functions for only the following triggers:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Pre signup</p>
    ///             </li>
    ///             <li>
    ///                 <p>Pre authentication</p>
    ///             </li>
    ///             <li>
    ///                 <p>User migration</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>When Amazon Cognito invokes the functions for these triggers, it passes a JSON
    ///             payload, which the function receives as input. This payload contains a
    ///                 <code>validationData</code> attribute, which provides the data that you assigned to
    ///             the ClientMetadata parameter in your AdminInitiateAuth request. In your function code in
    ///             AWS Lambda, you can process the <code>validationData</code> value to enhance your
    ///             workflow for your specific needs.</p>
    ///
    ///         <p>When you use the AdminInitiateAuth API action, Amazon Cognito also invokes the
    ///             functions for the following triggers, but it does not provide the ClientMetadata value
    ///             as input:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Post authentication</p>
    ///             </li>
    ///             <li>
    ///                 <p>Custom message</p>
    ///             </li>
    ///             <li>
    ///                 <p>Pre token generation</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create auth challenge</p>
    ///             </li>
    ///             <li>
    ///                 <p>Define auth challenge</p>
    ///             </li>
    ///             <li>
    ///                 <p>Verify auth challenge</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let contextData: ContextDataType?
    /// <p>The ID of the Amazon Cognito user pool.</p>
    public let userPoolId: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        authFlow: AuthFlowType? = nil,
        authParameters: [String:String]? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        contextData: ContextDataType? = nil,
        userPoolId: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.authFlow = authFlow
        self.authParameters = authParameters
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.contextData = contextData
        self.userPoolId = userPoolId
    }
}

struct AdminInitiateAuthInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
    public let authFlow: AuthFlowType?
    public let authParameters: [String:String]?
    public let clientMetadata: [String:String]?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let contextData: ContextDataType?
}

extension AdminInitiateAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case authFlow = "AuthFlow"
        case authParameters = "AuthParameters"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case contextData = "ContextData"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let authFlowDecoded = try containerValues.decodeIfPresent(AuthFlowType.self, forKey: .authFlow)
        authFlow = authFlowDecoded
        let authParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .authParameters)
        var authParametersDecoded0: [String:String]? = nil
        if let authParametersContainer = authParametersContainer {
            authParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in authParametersContainer {
                if let stringtype0 = stringtype0 {
                    authParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        authParameters = authParametersDecoded0
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let contextDataDecoded = try containerValues.decodeIfPresent(ContextDataType.self, forKey: .contextData)
        contextData = contextDataDecoded
    }
}

extension AdminInitiateAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminInitiateAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MFAMethodNotFoundException" : self = .mFAMethodNotFoundException(try MFAMethodNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminInitiateAuthOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case mFAMethodNotFoundException(MFAMethodNotFoundException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminInitiateAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminInitiateAuthOutputResponse(authenticationResult: \(String(describing: authenticationResult)), challengeName: \(String(describing: challengeName)), challengeParameters: \(String(describing: challengeParameters)), session: \(String(describing: session)))"}
}

extension AdminInitiateAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminInitiateAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationResult = output.authenticationResult
            self.challengeName = output.challengeName
            self.challengeParameters = output.challengeParameters
            self.session = output.session
        } else {
            self.authenticationResult = nil
            self.challengeName = nil
            self.challengeParameters = nil
            self.session = nil
        }
    }
}

/// <p>Initiates the authentication response, as an administrator.</p>
public struct AdminInitiateAuthOutputResponse: Equatable {
    /// <p>The result of the authentication response. This is only returned if the caller does
    ///             not need to pass another challenge. If the caller does need to pass another challenge
    ///             before it gets tokens, <code>ChallengeName</code>, <code>ChallengeParameters</code>, and
    ///                 <code>Session</code> are returned.</p>
    public let authenticationResult: AuthenticationResultType?
    /// <p>The name of the challenge which you are responding to with this call. This is returned
    ///             to you in the <code>AdminInitiateAuth</code> response if you need to pass another
    ///             challenge.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_SETUP</code>: If MFA is required, users who do not have at least one
    ///                     of the MFA methods set up are presented with an <code>MFA_SETUP</code>
    ///                     challenge. The user must set up at least one MFA type to continue to
    ///                     authenticate.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SELECT_MFA_TYPE</code>: Selects the MFA type. Valid MFA options are
    ///                         <code>SMS_MFA</code> for text SMS MFA, and <code>SOFTWARE_TOKEN_MFA</code>
    ///                     for TOTP software token MFA.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SMS_MFA</code>: Next challenge is to supply an
    ///                     <code>SMS_MFA_CODE</code>, delivered via SMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PASSWORD_VERIFIER</code>: Next challenge is to supply
    ///                         <code>PASSWORD_CLAIM_SIGNATURE</code>,
    ///                         <code>PASSWORD_CLAIM_SECRET_BLOCK</code>, and <code>TIMESTAMP</code> after
    ///                     the client-side SRP calculations.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CUSTOM_CHALLENGE</code>: This is returned if your custom authentication
    ///                     flow determines that the user should pass another challenge before tokens are
    ///                     issued.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_SRP_AUTH</code>: If device tracking was enabled on your user pool
    ///                     and the previous challenges were passed, this challenge is returned so that
    ///                     Amazon Cognito can start tracking this device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_PASSWORD_VERIFIER</code>: Similar to
    ///                         <code>PASSWORD_VERIFIER</code>, but for devices only.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ADMIN_NO_SRP_AUTH</code>: This is returned if you need to authenticate
    ///                     with <code>USERNAME</code> and <code>PASSWORD</code> directly. An app client
    ///                     must be enabled to use this flow.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NEW_PASSWORD_REQUIRED</code>: For users who are required to change their
    ///                     passwords after successful first login. This challenge should be passed with
    ///                         <code>NEW_PASSWORD</code> and any other required attributes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_SETUP</code>: For users who are required to setup an MFA factor
    ///                     before they can sign-in. The MFA types enabled for the user pool will be listed
    ///                     in the challenge parameters <code>MFA_CAN_SETUP</code> value. </p>
    ///                 <p> To setup software token MFA, use the session returned here from
    ///                         <code>InitiateAuth</code> as an input to
    ///                     <code>AssociateSoftwareToken</code>, and use the session returned by
    ///                         <code>VerifySoftwareToken</code> as an input to
    ///                         <code>RespondToAuthChallenge</code> with challenge name
    ///                         <code>MFA_SETUP</code> to complete sign-in. To setup SMS MFA, users will
    ///                     need help from an administrator to add a phone number to their account and then
    ///                     call <code>InitiateAuth</code> again to restart sign-in.</p>
    ///             </li>
    ///          </ul>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge parameters. These are returned to you in the
    ///                 <code>AdminInitiateAuth</code> response if you need to pass another challenge. The
    ///             responses in this parameter should be used to compute inputs to the next call
    ///                 (<code>AdminRespondToAuthChallenge</code>).</p>
    ///         <p>All challenges require <code>USERNAME</code> and <code>SECRET_HASH</code> (if
    ///             applicable).</p>
    ///         <p>The value of the <code>USER_ID_FOR_SRP</code> attribute will be the user's actual
    ///             username, not an alias (such as email address or phone number), even if you specified an
    ///             alias in your call to <code>AdminInitiateAuth</code>. This is because, in the
    ///                 <code>AdminRespondToAuthChallenge</code> API <code>ChallengeResponses</code>, the
    ///                 <code>USERNAME</code> attribute cannot be an alias.</p>
    public let challengeParameters: [String:String]?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If <code>AdminInitiateAuth</code> or <code>AdminRespondToAuthChallenge</code>
    ///             API call determines that the caller needs to go through another challenge, they return a
    ///             session with other challenge parameters. This session should be passed as it is to the
    ///             next <code>AdminRespondToAuthChallenge</code> API call.</p>
    public let session: String?

    public init (
        authenticationResult: AuthenticationResultType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeParameters: [String:String]? = nil,
        session: String? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.challengeName = challengeName
        self.challengeParameters = challengeParameters
        self.session = session
    }
}

struct AdminInitiateAuthOutputResponseBody: Equatable {
    public let challengeName: ChallengeNameType?
    public let session: String?
    public let challengeParameters: [String:String]?
    public let authenticationResult: AuthenticationResultType?
}

extension AdminInitiateAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationResult = "AuthenticationResult"
        case challengeName = "ChallengeName"
        case challengeParameters = "ChallengeParameters"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let challengeParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeParameters)
        var challengeParametersDecoded0: [String:String]? = nil
        if let challengeParametersContainer = challengeParametersContainer {
            challengeParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeParametersContainer {
                if let stringtype0 = stringtype0 {
                    challengeParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeParameters = challengeParametersDecoded0
        let authenticationResultDecoded = try containerValues.decodeIfPresent(AuthenticationResultType.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
    }
}

public struct AdminLinkProviderForUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminLinkProviderForUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminLinkProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminLinkProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminLinkProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminLinkProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminLinkProviderForUserOutputError>
}

extension AdminLinkProviderForUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminLinkProviderForUserInput(destinationUser: \(String(describing: destinationUser)), sourceUser: \(String(describing: sourceUser)), userPoolId: \(String(describing: userPoolId)))"}
}

extension AdminLinkProviderForUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationUser = "DestinationUser"
        case sourceUser = "SourceUser"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationUser = destinationUser {
            try encodeContainer.encode(destinationUser, forKey: .destinationUser)
        }
        if let sourceUser = sourceUser {
            try encodeContainer.encode(sourceUser, forKey: .sourceUser)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct AdminLinkProviderForUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminLinkProviderForUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminLinkProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminLinkProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminLinkProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminLinkProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminLinkProviderForUserOutputError>
}

public struct AdminLinkProviderForUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminLinkProviderForUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminLinkProviderForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminLinkProviderForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminLinkProviderForUserInput>
    public typealias MOutput = OperationOutput<AdminLinkProviderForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminLinkProviderForUserOutputError>
}

public struct AdminLinkProviderForUserInput: Equatable {
    /// <p>The existing user in the user pool to be linked to the external identity provider user
    ///             account. Can be a native (Username + Password) Cognito User Pools user or a federated
    ///             user (for example, a SAML or Facebook user). If the user doesn't exist, an exception is
    ///             thrown. This is the user that is returned when the new user (with the linked identity
    ///             provider attribute) signs in.</p>
    ///         <p>For a native username + password user, the <code>ProviderAttributeValue</code> for the
    ///                 <code>DestinationUser</code> should be the username in the user pool. For a
    ///             federated user, it should be the provider-specific <code>user_id</code>.</p>
    ///         <p>The <code>ProviderAttributeName</code> of the <code>DestinationUser</code> is
    ///             ignored.</p>
    ///         <p>The <code>ProviderName</code> should be set to <code>Cognito</code> for users in
    ///             Cognito user pools.</p>
    public let destinationUser: ProviderUserIdentifierType?
    /// <p>An external identity provider account for a user who does not currently exist yet in
    ///             the user pool. This user must be a federated user (for example, a SAML or Facebook
    ///             user), not another native user.</p>
    ///         <p>If the <code>SourceUser</code> is a federated social identity provider user (Facebook,
    ///             Google, or Login with Amazon), you must set the <code>ProviderAttributeName</code> to
    ///                 <code>Cognito_Subject</code>. For social identity providers, the
    ///                 <code>ProviderName</code> will be <code>Facebook</code>, <code>Google</code>, or
    ///                 <code>LoginWithAmazon</code>, and Cognito will automatically parse the Facebook,
    ///             Google, and Login with Amazon tokens for <code>id</code>, <code>sub</code>, and
    ///                 <code>user_id</code>, respectively. The <code>ProviderAttributeValue</code> for the
    ///             user must be the same value as the <code>id</code>, <code>sub</code>, or
    ///                 <code>user_id</code> value found in the social identity provider token.</p>
    ///         <p></p>
    ///         <p>For SAML, the <code>ProviderAttributeName</code> can be any value that matches a claim
    ///             in the SAML assertion. If you wish to link SAML users based on the subject of the SAML
    ///             assertion, you should map the subject to a claim through the SAML identity provider and
    ///             submit that claim name as the <code>ProviderAttributeName</code>. If you set
    ///                 <code>ProviderAttributeName</code> to <code>Cognito_Subject</code>, Cognito will
    ///             automatically parse the default unique identifier found in the subject from the SAML
    ///             token.</p>
    public let sourceUser: ProviderUserIdentifierType?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        destinationUser: ProviderUserIdentifierType? = nil,
        sourceUser: ProviderUserIdentifierType? = nil,
        userPoolId: String? = nil
    )
    {
        self.destinationUser = destinationUser
        self.sourceUser = sourceUser
        self.userPoolId = userPoolId
    }
}

struct AdminLinkProviderForUserInputBody: Equatable {
    public let userPoolId: String?
    public let destinationUser: ProviderUserIdentifierType?
    public let sourceUser: ProviderUserIdentifierType?
}

extension AdminLinkProviderForUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationUser = "DestinationUser"
        case sourceUser = "SourceUser"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let destinationUserDecoded = try containerValues.decodeIfPresent(ProviderUserIdentifierType.self, forKey: .destinationUser)
        destinationUser = destinationUserDecoded
        let sourceUserDecoded = try containerValues.decodeIfPresent(ProviderUserIdentifierType.self, forKey: .sourceUser)
        sourceUser = sourceUserDecoded
    }
}

extension AdminLinkProviderForUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminLinkProviderForUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminLinkProviderForUserOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminLinkProviderForUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminLinkProviderForUserOutputResponse()"}
}

extension AdminLinkProviderForUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminLinkProviderForUserOutputResponse: Equatable {

    public init() {}
}

struct AdminLinkProviderForUserOutputResponseBody: Equatable {
}

extension AdminLinkProviderForUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminListDevicesInputBodyMiddleware: Middleware {
    public let id: String = "AdminListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListDevicesInput>
    public typealias MOutput = OperationOutput<AdminListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListDevicesOutputError>
}

extension AdminListDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListDevicesInput(limit: \(String(describing: limit)), paginationToken: \(String(describing: paginationToken)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminListDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminListDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "AdminListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListDevicesInput>
    public typealias MOutput = OperationOutput<AdminListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListDevicesOutputError>
}

public struct AdminListDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListDevicesInput>
    public typealias MOutput = OperationOutput<AdminListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListDevicesOutputError>
}

/// <p>Represents the request to list devices, as an administrator.</p>
public struct AdminListDevicesInput: Equatable {
    /// <p>The limit of the devices request.</p>
    public let limit: Int?
    /// <p>The pagination token.</p>
    public let paginationToken: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user name.</p>
    public let username: String?

    public init (
        limit: Int? = nil,
        paginationToken: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.limit = limit
        self.paginationToken = paginationToken
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminListDevicesInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let limit: Int?
    public let paginationToken: String?
}

extension AdminListDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension AdminListDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminListDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminListDevicesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminListDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListDevicesOutputResponse(devices: \(String(describing: devices)), paginationToken: \(String(describing: paginationToken)))"}
}

extension AdminListDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.paginationToken = output.paginationToken
        } else {
            self.devices = nil
            self.paginationToken = nil
        }
    }
}

/// <p>Lists the device's response, as an administrator.</p>
public struct AdminListDevicesOutputResponse: Equatable {
    /// <p>The devices in the list of devices response.</p>
    public let devices: [DeviceType]?
    /// <p>The pagination token.</p>
    public let paginationToken: String?

    public init (
        devices: [DeviceType]? = nil,
        paginationToken: String? = nil
    )
    {
        self.devices = devices
        self.paginationToken = paginationToken
    }
}

struct AdminListDevicesOutputResponseBody: Equatable {
    public let devices: [DeviceType]?
    public let paginationToken: String?
}

extension AdminListDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceType?].self, forKey: .devices)
        var devicesDecoded0:[DeviceType]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceType]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

public struct AdminListGroupsForUserInputBodyMiddleware: Middleware {
    public let id: String = "AdminListGroupsForUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListGroupsForUserInput>
    public typealias MOutput = OperationOutput<AdminListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListGroupsForUserOutputError>
}

extension AdminListGroupsForUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListGroupsForUserInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminListGroupsForUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminListGroupsForUserInputHeadersMiddleware: Middleware {
    public let id: String = "AdminListGroupsForUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListGroupsForUserInput>
    public typealias MOutput = OperationOutput<AdminListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListGroupsForUserOutputError>
}

public struct AdminListGroupsForUserInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminListGroupsForUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListGroupsForUserInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListGroupsForUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListGroupsForUserInput>
    public typealias MOutput = OperationOutput<AdminListGroupsForUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListGroupsForUserOutputError>
}

public struct AdminListGroupsForUserInput: Equatable {
    /// <p>The limit of the request to list groups.</p>
    public let limit: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?
    /// <p>The username for the user.</p>
    public let username: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminListGroupsForUserInputBody: Equatable {
    public let username: String?
    public let userPoolId: String?
    public let limit: Int?
    public let nextToken: String?
}

extension AdminListGroupsForUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AdminListGroupsForUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminListGroupsForUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminListGroupsForUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminListGroupsForUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListGroupsForUserOutputResponse(groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension AdminListGroupsForUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminListGroupsForUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct AdminListGroupsForUserOutputResponse: Equatable {
    /// <p>The groups that the user belongs to.</p>
    public let groups: [GroupType]?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        groups: [GroupType]? = nil,
        nextToken: String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct AdminListGroupsForUserOutputResponseBody: Equatable {
    public let groups: [GroupType]?
    public let nextToken: String?
}

extension AdminListGroupsForUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupType?].self, forKey: .groups)
        var groupsDecoded0:[GroupType]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupType]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct AdminListUserAuthEventsInputBodyMiddleware: Middleware {
    public let id: String = "AdminListUserAuthEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListUserAuthEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListUserAuthEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListUserAuthEventsInput>
    public typealias MOutput = OperationOutput<AdminListUserAuthEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListUserAuthEventsOutputError>
}

extension AdminListUserAuthEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListUserAuthEventsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminListUserAuthEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminListUserAuthEventsInputHeadersMiddleware: Middleware {
    public let id: String = "AdminListUserAuthEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListUserAuthEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListUserAuthEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListUserAuthEventsInput>
    public typealias MOutput = OperationOutput<AdminListUserAuthEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListUserAuthEventsOutputError>
}

public struct AdminListUserAuthEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminListUserAuthEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminListUserAuthEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminListUserAuthEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminListUserAuthEventsInput>
    public typealias MOutput = OperationOutput<AdminListUserAuthEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminListUserAuthEventsOutputError>
}

public struct AdminListUserAuthEventsInput: Equatable {
    /// <p>The maximum number of authentication events to return.</p>
    public let maxResults: Int?
    /// <p>A pagination token.</p>
    public let nextToken: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user pool username or an alias.</p>
    public let username: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminListUserAuthEventsInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension AdminListUserAuthEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AdminListUserAuthEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminListUserAuthEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolAddOnNotEnabledException" : self = .userPoolAddOnNotEnabledException(try UserPoolAddOnNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminListUserAuthEventsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case userPoolAddOnNotEnabledException(UserPoolAddOnNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminListUserAuthEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminListUserAuthEventsOutputResponse(authEvents: \(String(describing: authEvents)), nextToken: \(String(describing: nextToken)))"}
}

extension AdminListUserAuthEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminListUserAuthEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authEvents = output.authEvents
            self.nextToken = output.nextToken
        } else {
            self.authEvents = nil
            self.nextToken = nil
        }
    }
}

public struct AdminListUserAuthEventsOutputResponse: Equatable {
    /// <p>The response object. It includes the <code>EventID</code>, <code>EventType</code>,
    ///                 <code>CreationDate</code>, <code>EventRisk</code>, and
    ///             <code>EventResponse</code>.</p>
    public let authEvents: [AuthEventType]?
    /// <p>A pagination token.</p>
    public let nextToken: String?

    public init (
        authEvents: [AuthEventType]? = nil,
        nextToken: String? = nil
    )
    {
        self.authEvents = authEvents
        self.nextToken = nextToken
    }
}

struct AdminListUserAuthEventsOutputResponseBody: Equatable {
    public let authEvents: [AuthEventType]?
    public let nextToken: String?
}

extension AdminListUserAuthEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authEvents = "AuthEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authEventsContainer = try containerValues.decodeIfPresent([AuthEventType?].self, forKey: .authEvents)
        var authEventsDecoded0:[AuthEventType]? = nil
        if let authEventsContainer = authEventsContainer {
            authEventsDecoded0 = [AuthEventType]()
            for structure0 in authEventsContainer {
                if let structure0 = structure0 {
                    authEventsDecoded0?.append(structure0)
                }
            }
        }
        authEvents = authEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct AdminRemoveUserFromGroupInputBodyMiddleware: Middleware {
    public let id: String = "AdminRemoveUserFromGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<AdminRemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRemoveUserFromGroupOutputError>
}

extension AdminRemoveUserFromGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminRemoveUserFromGroupInput(groupName: \(String(describing: groupName)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminRemoveUserFromGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminRemoveUserFromGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AdminRemoveUserFromGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<AdminRemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRemoveUserFromGroupOutputError>
}

public struct AdminRemoveUserFromGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminRemoveUserFromGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRemoveUserFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRemoveUserFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRemoveUserFromGroupInput>
    public typealias MOutput = OperationOutput<AdminRemoveUserFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRemoveUserFromGroupOutputError>
}

public struct AdminRemoveUserFromGroupInput: Equatable {
    /// <p>The group name.</p>
    public let groupName: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?
    /// <p>The username for the user.</p>
    public let username: String?

    public init (
        groupName: String? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.groupName = groupName
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminRemoveUserFromGroupInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let groupName: String?
}

extension AdminRemoveUserFromGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension AdminRemoveUserFromGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminRemoveUserFromGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminRemoveUserFromGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminRemoveUserFromGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminRemoveUserFromGroupOutputResponse()"}
}

extension AdminRemoveUserFromGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminRemoveUserFromGroupOutputResponse: Equatable {

    public init() {}
}

struct AdminRemoveUserFromGroupOutputResponseBody: Equatable {
}

extension AdminRemoveUserFromGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminResetUserPasswordInputBodyMiddleware: Middleware {
    public let id: String = "AdminResetUserPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminResetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminResetUserPasswordOutputError>
}

extension AdminResetUserPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminResetUserPasswordInput(clientMetadata: \(String(describing: clientMetadata)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminResetUserPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminResetUserPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "AdminResetUserPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminResetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminResetUserPasswordOutputError>
}

public struct AdminResetUserPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminResetUserPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminResetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminResetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminResetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminResetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminResetUserPasswordOutputError>
}

/// <p>Represents the request to reset a user's password as an administrator.</p>
public struct AdminResetUserPasswordInput: Equatable {
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the AdminResetUserPassword API action, Amazon Cognito invokes the function
    ///             that is assigned to the <i>custom message</i> trigger. When Amazon Cognito
    ///             invokes this function, it passes a JSON payload, which the function receives as input.
    ///             This payload contains a <code>clientMetadata</code> attribute, which provides the data
    ///             that you assigned to the ClientMetadata parameter in your AdminResetUserPassword
    ///             request. In your function code in AWS Lambda, you can process the
    ///                 <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The user pool ID for the user pool where you want to reset the user's password.</p>
    public let userPoolId: String?
    /// <p>The user name of the user whose password you wish to reset.</p>
    public let username: String?

    public init (
        clientMetadata: [String:String]? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.clientMetadata = clientMetadata
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminResetUserPasswordInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let clientMetadata: [String:String]?
}

extension AdminResetUserPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension AdminResetUserPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminResetUserPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminResetUserPasswordOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminResetUserPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminResetUserPasswordOutputResponse()"}
}

extension AdminResetUserPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server to reset a user password as an
///             administrator.</p>
public struct AdminResetUserPasswordOutputResponse: Equatable {

    public init() {}
}

struct AdminResetUserPasswordOutputResponseBody: Equatable {
}

extension AdminResetUserPasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminRespondToAuthChallengeInputBodyMiddleware: Middleware {
    public let id: String = "AdminRespondToAuthChallengeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<AdminRespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRespondToAuthChallengeOutputError>
}

extension AdminRespondToAuthChallengeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminRespondToAuthChallengeInput(analyticsMetadata: \(String(describing: analyticsMetadata)), challengeName: \(String(describing: challengeName)), challengeResponses: \(String(describing: challengeResponses)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), contextData: \(String(describing: contextData)), session: \(String(describing: session)), userPoolId: \(String(describing: userPoolId)))"}
}

extension AdminRespondToAuthChallengeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case challengeName = "ChallengeName"
        case challengeResponses = "ChallengeResponses"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case contextData = "ContextData"
        case session = "Session"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let challengeName = challengeName {
            try encodeContainer.encode(challengeName.rawValue, forKey: .challengeName)
        }
        if let challengeResponses = challengeResponses {
            var challengeResponsesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .challengeResponses)
            for (dictKey0, challengeresponsestype0) in challengeResponses {
                try challengeResponsesContainer.encode(challengeresponsestype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let contextData = contextData {
            try encodeContainer.encode(contextData, forKey: .contextData)
        }
        if let session = session {
            try encodeContainer.encode(session, forKey: .session)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct AdminRespondToAuthChallengeInputHeadersMiddleware: Middleware {
    public let id: String = "AdminRespondToAuthChallengeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<AdminRespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRespondToAuthChallengeOutputError>
}

public struct AdminRespondToAuthChallengeInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminRespondToAuthChallengeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminRespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminRespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminRespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<AdminRespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminRespondToAuthChallengeOutputError>
}

/// <p>The request to respond to the authentication challenge, as an administrator.</p>
public struct AdminRespondToAuthChallengeInput: Equatable {
    /// <p>The analytics metadata for collecting Amazon Pinpoint metrics for
    ///                 <code>AdminRespondToAuthChallenge</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The challenge name. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminInitiateAuth.html">AdminInitiateAuth</a>.</p>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge responses. These are inputs corresponding to the value of
    ///                 <code>ChallengeName</code>, for example:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SMS_MFA</code>: <code>SMS_MFA_CODE</code>, <code>USERNAME</code>,
    ///                         <code>SECRET_HASH</code> (if app client is configured with client
    ///                     secret).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PASSWORD_VERIFIER</code>: <code>PASSWORD_CLAIM_SIGNATURE</code>,
    ///                         <code>PASSWORD_CLAIM_SECRET_BLOCK</code>, <code>TIMESTAMP</code>,
    ///                         <code>USERNAME</code>, <code>SECRET_HASH</code> (if app client is configured
    ///                     with client secret).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ADMIN_NO_SRP_AUTH</code>: <code>PASSWORD</code>, <code>USERNAME</code>,
    ///                         <code>SECRET_HASH</code> (if app client is configured with client secret).
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>NEW_PASSWORD_REQUIRED</code>: <code>NEW_PASSWORD</code>, any other
    ///                     required attributes, <code>USERNAME</code>, <code>SECRET_HASH</code> (if app
    ///                     client is configured with client secret). </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_SETUP</code> requires <code>USERNAME</code>, plus you need to use
    ///                     the session value returned by <code>VerifySoftwareToken</code> in the
    ///                         <code>Session</code> parameter.</p>
    ///             </li>
    ///          </ul>
    ///         <p>The value of the <code>USERNAME</code> attribute must be the user's actual username,
    ///             not an alias (such as email address or phone number). To make this easier, the
    ///                 <code>AdminInitiateAuth</code> response includes the actual username value in the
    ///                 <code>USERNAMEUSER_ID_FOR_SRP</code> attribute, even if you specified an alias in
    ///             your call to <code>AdminInitiateAuth</code>.</p>
    public let challengeResponses: [String:String]?
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the AdminRespondToAuthChallenge API action, Amazon Cognito invokes any
    ///             functions that are assigned to the following triggers: <i>pre sign-up</i>,
    ///                 <i>custom message</i>, <i>post authentication</i>,
    ///                 <i>user migration</i>, <i>pre token generation</i>,
    ///                 <i>define auth challenge</i>, <i>create auth
    ///                 challenge</i>, and <i>verify auth challenge response</i>. When
    ///             Amazon Cognito invokes any of these functions, it passes a JSON payload, which the
    ///             function receives as input. This payload contains a <code>clientMetadata</code>
    ///             attribute, which provides the data that you assigned to the ClientMetadata parameter in
    ///             your AdminRespondToAuthChallenge request. In your function code in AWS Lambda, you can
    ///             process the <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let contextData: ContextDataType?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If <code>InitiateAuth</code> or <code>RespondToAuthChallenge</code> API call
    ///             determines that the caller needs to go through another challenge, they return a session
    ///             with other challenge parameters. This session should be passed as it is to the next
    ///                 <code>RespondToAuthChallenge</code> API call.</p>
    public let session: String?
    /// <p>The ID of the Amazon Cognito user pool.</p>
    public let userPoolId: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeResponses: [String:String]? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        contextData: ContextDataType? = nil,
        session: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.challengeName = challengeName
        self.challengeResponses = challengeResponses
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.contextData = contextData
        self.session = session
        self.userPoolId = userPoolId
    }
}

struct AdminRespondToAuthChallengeInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
    public let challengeName: ChallengeNameType?
    public let challengeResponses: [String:String]?
    public let session: String?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let contextData: ContextDataType?
    public let clientMetadata: [String:String]?
}

extension AdminRespondToAuthChallengeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case challengeName = "ChallengeName"
        case challengeResponses = "ChallengeResponses"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case contextData = "ContextData"
        case session = "Session"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let challengeResponsesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeResponses)
        var challengeResponsesDecoded0: [String:String]? = nil
        if let challengeResponsesContainer = challengeResponsesContainer {
            challengeResponsesDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeResponsesContainer {
                if let stringtype0 = stringtype0 {
                    challengeResponsesDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeResponses = challengeResponsesDecoded0
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let contextDataDecoded = try containerValues.decodeIfPresent(ContextDataType.self, forKey: .contextData)
        contextData = contextDataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension AdminRespondToAuthChallengeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminRespondToAuthChallengeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MFAMethodNotFoundException" : self = .mFAMethodNotFoundException(try MFAMethodNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SoftwareTokenMFANotFoundException" : self = .softwareTokenMFANotFoundException(try SoftwareTokenMFANotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminRespondToAuthChallengeOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case mFAMethodNotFoundException(MFAMethodNotFoundException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case softwareTokenMFANotFoundException(SoftwareTokenMFANotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminRespondToAuthChallengeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminRespondToAuthChallengeOutputResponse(authenticationResult: \(String(describing: authenticationResult)), challengeName: \(String(describing: challengeName)), challengeParameters: \(String(describing: challengeParameters)), session: \(String(describing: session)))"}
}

extension AdminRespondToAuthChallengeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AdminRespondToAuthChallengeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationResult = output.authenticationResult
            self.challengeName = output.challengeName
            self.challengeParameters = output.challengeParameters
            self.session = output.session
        } else {
            self.authenticationResult = nil
            self.challengeName = nil
            self.challengeParameters = nil
            self.session = nil
        }
    }
}

/// <p>Responds to the authentication challenge, as an administrator.</p>
public struct AdminRespondToAuthChallengeOutputResponse: Equatable {
    /// <p>The result returned by the server in response to the authentication request.</p>
    public let authenticationResult: AuthenticationResultType?
    /// <p>The name of the challenge. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminInitiateAuth.html">AdminInitiateAuth</a>.</p>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge parameters. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminInitiateAuth.html">AdminInitiateAuth</a>.</p>
    public let challengeParameters: [String:String]?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If the caller needs to go through another challenge, they return a session with
    ///             other challenge parameters. This session should be passed as it is to the next
    ///                 <code>RespondToAuthChallenge</code> API call.</p>
    public let session: String?

    public init (
        authenticationResult: AuthenticationResultType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeParameters: [String:String]? = nil,
        session: String? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.challengeName = challengeName
        self.challengeParameters = challengeParameters
        self.session = session
    }
}

struct AdminRespondToAuthChallengeOutputResponseBody: Equatable {
    public let challengeName: ChallengeNameType?
    public let session: String?
    public let challengeParameters: [String:String]?
    public let authenticationResult: AuthenticationResultType?
}

extension AdminRespondToAuthChallengeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationResult = "AuthenticationResult"
        case challengeName = "ChallengeName"
        case challengeParameters = "ChallengeParameters"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let challengeParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeParameters)
        var challengeParametersDecoded0: [String:String]? = nil
        if let challengeParametersContainer = challengeParametersContainer {
            challengeParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeParametersContainer {
                if let stringtype0 = stringtype0 {
                    challengeParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeParameters = challengeParametersDecoded0
        let authenticationResultDecoded = try containerValues.decodeIfPresent(AuthenticationResultType.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
    }
}

public struct AdminSetUserMFAPreferenceInputBodyMiddleware: Middleware {
    public let id: String = "AdminSetUserMFAPreferenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<AdminSetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserMFAPreferenceOutputError>
}

extension AdminSetUserMFAPreferenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserMFAPreferenceInput(sMSMfaSettings: \(String(describing: sMSMfaSettings)), softwareTokenMfaSettings: \(String(describing: softwareTokenMfaSettings)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminSetUserMFAPreferenceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sMSMfaSettings = "SMSMfaSettings"
        case softwareTokenMfaSettings = "SoftwareTokenMfaSettings"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sMSMfaSettings = sMSMfaSettings {
            try encodeContainer.encode(sMSMfaSettings, forKey: .sMSMfaSettings)
        }
        if let softwareTokenMfaSettings = softwareTokenMfaSettings {
            try encodeContainer.encode(softwareTokenMfaSettings, forKey: .softwareTokenMfaSettings)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminSetUserMFAPreferenceInputHeadersMiddleware: Middleware {
    public let id: String = "AdminSetUserMFAPreferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<AdminSetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserMFAPreferenceOutputError>
}

public struct AdminSetUserMFAPreferenceInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminSetUserMFAPreferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<AdminSetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserMFAPreferenceOutputError>
}

public struct AdminSetUserMFAPreferenceInput: Equatable {
    /// <p>The SMS text message MFA settings.</p>
    public let sMSMfaSettings: SMSMfaSettingsType?
    /// <p>The time-based one-time password software token MFA settings.</p>
    public let softwareTokenMfaSettings: SoftwareTokenMfaSettingsType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user pool username or alias.</p>
    public let username: String?

    public init (
        sMSMfaSettings: SMSMfaSettingsType? = nil,
        softwareTokenMfaSettings: SoftwareTokenMfaSettingsType? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.sMSMfaSettings = sMSMfaSettings
        self.softwareTokenMfaSettings = softwareTokenMfaSettings
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminSetUserMFAPreferenceInputBody: Equatable {
    public let sMSMfaSettings: SMSMfaSettingsType?
    public let softwareTokenMfaSettings: SoftwareTokenMfaSettingsType?
    public let username: String?
    public let userPoolId: String?
}

extension AdminSetUserMFAPreferenceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSMfaSettings = "SMSMfaSettings"
        case softwareTokenMfaSettings = "SoftwareTokenMfaSettings"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSMfaSettingsDecoded = try containerValues.decodeIfPresent(SMSMfaSettingsType.self, forKey: .sMSMfaSettings)
        sMSMfaSettings = sMSMfaSettingsDecoded
        let softwareTokenMfaSettingsDecoded = try containerValues.decodeIfPresent(SoftwareTokenMfaSettingsType.self, forKey: .softwareTokenMfaSettings)
        softwareTokenMfaSettings = softwareTokenMfaSettingsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension AdminSetUserMFAPreferenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminSetUserMFAPreferenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminSetUserMFAPreferenceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminSetUserMFAPreferenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserMFAPreferenceOutputResponse()"}
}

extension AdminSetUserMFAPreferenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminSetUserMFAPreferenceOutputResponse: Equatable {

    public init() {}
}

struct AdminSetUserMFAPreferenceOutputResponseBody: Equatable {
}

extension AdminSetUserMFAPreferenceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminSetUserPasswordInputBodyMiddleware: Middleware {
    public let id: String = "AdminSetUserPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminSetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserPasswordOutputError>
}

extension AdminSetUserPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserPasswordInput(password: \(String(describing: password)), permanent: \(String(describing: permanent)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminSetUserPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case permanent = "Permanent"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if permanent != false {
            try encodeContainer.encode(permanent, forKey: .permanent)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminSetUserPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "AdminSetUserPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminSetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserPasswordOutputError>
}

public struct AdminSetUserPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminSetUserPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserPasswordInput>
    public typealias MOutput = OperationOutput<AdminSetUserPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserPasswordOutputError>
}

public struct AdminSetUserPasswordInput: Equatable {
    /// <p>The password for the user.</p>
    public let password: String?
    /// <p>
    ///             <code>True</code> if the password is permanent, <code>False</code> if it is
    ///             temporary.</p>
    public let permanent: Bool
    /// <p>The user pool ID for the user pool where you want to set the user's password.</p>
    public let userPoolId: String?
    /// <p>The user name of the user whose password you wish to set.</p>
    public let username: String?

    public init (
        password: String? = nil,
        permanent: Bool = false,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.permanent = permanent
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminSetUserPasswordInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let password: String?
    public let permanent: Bool
}

extension AdminSetUserPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case permanent = "Permanent"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let permanentDecoded = try containerValues.decode(Bool.self, forKey: .permanent)
        permanent = permanentDecoded
    }
}

extension AdminSetUserPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminSetUserPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminSetUserPasswordOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminSetUserPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserPasswordOutputResponse()"}
}

extension AdminSetUserPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminSetUserPasswordOutputResponse: Equatable {

    public init() {}
}

struct AdminSetUserPasswordOutputResponseBody: Equatable {
}

extension AdminSetUserPasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminSetUserSettingsInputBodyMiddleware: Middleware {
    public let id: String = "AdminSetUserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserSettingsInput>
    public typealias MOutput = OperationOutput<AdminSetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserSettingsOutputError>
}

extension AdminSetUserSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserSettingsInput(mFAOptions: \(String(describing: mFAOptions)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminSetUserSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mFAOptions = "MFAOptions"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mFAOptions = mFAOptions {
            var mFAOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mFAOptions)
            for mfaoptionlisttype0 in mFAOptions {
                try mFAOptionsContainer.encode(mfaoptionlisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminSetUserSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "AdminSetUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserSettingsInput>
    public typealias MOutput = OperationOutput<AdminSetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserSettingsOutputError>
}

public struct AdminSetUserSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminSetUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminSetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminSetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminSetUserSettingsInput>
    public typealias MOutput = OperationOutput<AdminSetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminSetUserSettingsOutputError>
}

/// <p>You can use this parameter to set an MFA configuration that uses the SMS delivery
///             medium.</p>
public struct AdminSetUserSettingsInput: Equatable {
    /// <p>You can use this parameter only to set an SMS configuration that uses SMS for
    ///             delivery.</p>
    public let mFAOptions: [MFAOptionType]?
    /// <p>The ID of the user pool that contains the user that you are setting options
    ///             for.</p>
    public let userPoolId: String?
    /// <p>The user name of the user that you are setting options for.</p>
    public let username: String?

    public init (
        mFAOptions: [MFAOptionType]? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.mFAOptions = mFAOptions
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminSetUserSettingsInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let mFAOptions: [MFAOptionType]?
}

extension AdminSetUserSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mFAOptions = "MFAOptions"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let mFAOptionsContainer = try containerValues.decodeIfPresent([MFAOptionType?].self, forKey: .mFAOptions)
        var mFAOptionsDecoded0:[MFAOptionType]? = nil
        if let mFAOptionsContainer = mFAOptionsContainer {
            mFAOptionsDecoded0 = [MFAOptionType]()
            for structure0 in mFAOptionsContainer {
                if let structure0 = structure0 {
                    mFAOptionsDecoded0?.append(structure0)
                }
            }
        }
        mFAOptions = mFAOptionsDecoded0
    }
}

extension AdminSetUserSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminSetUserSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminSetUserSettingsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminSetUserSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminSetUserSettingsOutputResponse()"}
}

extension AdminSetUserSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server to set user settings as an
///             administrator.</p>
public struct AdminSetUserSettingsOutputResponse: Equatable {

    public init() {}
}

struct AdminSetUserSettingsOutputResponseBody: Equatable {
}

extension AdminSetUserSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminUpdateAuthEventFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "AdminUpdateAuthEventFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateAuthEventFeedbackOutputError>
}

extension AdminUpdateAuthEventFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateAuthEventFeedbackInput(eventId: \(String(describing: eventId)), feedbackValue: \(String(describing: feedbackValue)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminUpdateAuthEventFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId = "EventId"
        case feedbackValue = "FeedbackValue"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let feedbackValue = feedbackValue {
            try encodeContainer.encode(feedbackValue.rawValue, forKey: .feedbackValue)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminUpdateAuthEventFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "AdminUpdateAuthEventFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateAuthEventFeedbackOutputError>
}

public struct AdminUpdateAuthEventFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminUpdateAuthEventFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<AdminUpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateAuthEventFeedbackOutputError>
}

public struct AdminUpdateAuthEventFeedbackInput: Equatable {
    /// <p>The authentication event ID.</p>
    public let eventId: String?
    /// <p>The authentication event feedback value.</p>
    public let feedbackValue: FeedbackValueType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user pool username.</p>
    public let username: String?

    public init (
        eventId: String? = nil,
        feedbackValue: FeedbackValueType? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.eventId = eventId
        self.feedbackValue = feedbackValue
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminUpdateAuthEventFeedbackInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let eventId: String?
    public let feedbackValue: FeedbackValueType?
}

extension AdminUpdateAuthEventFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventId = "EventId"
        case feedbackValue = "FeedbackValue"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let feedbackValueDecoded = try containerValues.decodeIfPresent(FeedbackValueType.self, forKey: .feedbackValue)
        feedbackValue = feedbackValueDecoded
    }
}

extension AdminUpdateAuthEventFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminUpdateAuthEventFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolAddOnNotEnabledException" : self = .userPoolAddOnNotEnabledException(try UserPoolAddOnNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminUpdateAuthEventFeedbackOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case userPoolAddOnNotEnabledException(UserPoolAddOnNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminUpdateAuthEventFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateAuthEventFeedbackOutputResponse()"}
}

extension AdminUpdateAuthEventFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AdminUpdateAuthEventFeedbackOutputResponse: Equatable {

    public init() {}
}

struct AdminUpdateAuthEventFeedbackOutputResponseBody: Equatable {
}

extension AdminUpdateAuthEventFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminUpdateDeviceStatusInputBodyMiddleware: Middleware {
    public let id: String = "AdminUpdateDeviceStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<AdminUpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateDeviceStatusOutputError>
}

extension AdminUpdateDeviceStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateDeviceStatusInput(deviceKey: \(String(describing: deviceKey)), deviceRememberedStatus: \(String(describing: deviceRememberedStatus)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminUpdateDeviceStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case deviceRememberedStatus = "DeviceRememberedStatus"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let deviceRememberedStatus = deviceRememberedStatus {
            try encodeContainer.encode(deviceRememberedStatus.rawValue, forKey: .deviceRememberedStatus)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminUpdateDeviceStatusInputHeadersMiddleware: Middleware {
    public let id: String = "AdminUpdateDeviceStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<AdminUpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateDeviceStatusOutputError>
}

public struct AdminUpdateDeviceStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminUpdateDeviceStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<AdminUpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateDeviceStatusOutputError>
}

/// <p>The request to update the device status, as an administrator.</p>
public struct AdminUpdateDeviceStatusInput: Equatable {
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The status indicating whether a device has been remembered or not.</p>
    public let deviceRememberedStatus: DeviceRememberedStatusType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user name.</p>
    public let username: String?

    public init (
        deviceKey: String? = nil,
        deviceRememberedStatus: DeviceRememberedStatusType? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.deviceKey = deviceKey
        self.deviceRememberedStatus = deviceRememberedStatus
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminUpdateDeviceStatusInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let deviceKey: String?
    public let deviceRememberedStatus: DeviceRememberedStatusType?
}

extension AdminUpdateDeviceStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceKey = "DeviceKey"
        case deviceRememberedStatus = "DeviceRememberedStatus"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let deviceRememberedStatusDecoded = try containerValues.decodeIfPresent(DeviceRememberedStatusType.self, forKey: .deviceRememberedStatus)
        deviceRememberedStatus = deviceRememberedStatusDecoded
    }
}

extension AdminUpdateDeviceStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminUpdateDeviceStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminUpdateDeviceStatusOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminUpdateDeviceStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateDeviceStatusOutputResponse()"}
}

extension AdminUpdateDeviceStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The status response from the request to update the device, as an administrator.</p>
public struct AdminUpdateDeviceStatusOutputResponse: Equatable {

    public init() {}
}

struct AdminUpdateDeviceStatusOutputResponseBody: Equatable {
}

extension AdminUpdateDeviceStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminUpdateUserAttributesInputBodyMiddleware: Middleware {
    public let id: String = "AdminUpdateUserAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminUpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateUserAttributesOutputError>
}

extension AdminUpdateUserAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateUserAttributesInput(clientMetadata: \(String(describing: clientMetadata)), userAttributes: \(String(describing: userAttributes)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminUpdateUserAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userAttributes = "UserAttributes"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelisttype0 in userAttributes {
                try userAttributesContainer.encode(attributelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminUpdateUserAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "AdminUpdateUserAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminUpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateUserAttributesOutputError>
}

public struct AdminUpdateUserAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminUpdateUserAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<AdminUpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUpdateUserAttributesOutputError>
}

/// <p>Represents the request to update the user's attributes as an administrator.</p>
public struct AdminUpdateUserAttributesInput: Equatable {
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the AdminUpdateUserAttributes API action, Amazon Cognito invokes the
    ///             function that is assigned to the <i>custom message</i> trigger. When
    ///             Amazon Cognito invokes this function, it passes a JSON payload, which the function
    ///             receives as input. This payload contains a <code>clientMetadata</code> attribute, which
    ///             provides the data that you assigned to the ClientMetadata parameter in your
    ///             AdminUpdateUserAttributes request. In your function code in AWS Lambda, you can process
    ///             the <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>An array of name-value pairs representing user attributes.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributes: [AttributeType]?
    /// <p>The user pool ID for the user pool where you want to update user attributes.</p>
    public let userPoolId: String?
    /// <p>The user name of the user for whom you want to update user attributes.</p>
    public let username: String?

    public init (
        clientMetadata: [String:String]? = nil,
        userAttributes: [AttributeType]? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.clientMetadata = clientMetadata
        self.userAttributes = userAttributes
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminUpdateUserAttributesInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let userAttributes: [AttributeType]?
    public let clientMetadata: [String:String]?
}

extension AdminUpdateUserAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientMetadata = "ClientMetadata"
        case userAttributes = "UserAttributes"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension AdminUpdateUserAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminUpdateUserAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminUpdateUserAttributesOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminUpdateUserAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUpdateUserAttributesOutputResponse()"}
}

extension AdminUpdateUserAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server for the request to update user attributes as
///             an administrator.</p>
public struct AdminUpdateUserAttributesOutputResponse: Equatable {

    public init() {}
}

struct AdminUpdateUserAttributesOutputResponseBody: Equatable {
}

extension AdminUpdateUserAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AdminUserGlobalSignOutInputBodyMiddleware: Middleware {
    public let id: String = "AdminUserGlobalSignOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUserGlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUserGlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUserGlobalSignOutInput>
    public typealias MOutput = OperationOutput<AdminUserGlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUserGlobalSignOutOutputError>
}

extension AdminUserGlobalSignOutInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUserGlobalSignOutInput(userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension AdminUserGlobalSignOutInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct AdminUserGlobalSignOutInputHeadersMiddleware: Middleware {
    public let id: String = "AdminUserGlobalSignOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUserGlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUserGlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUserGlobalSignOutInput>
    public typealias MOutput = OperationOutput<AdminUserGlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUserGlobalSignOutOutputError>
}

public struct AdminUserGlobalSignOutInputQueryItemMiddleware: Middleware {
    public let id: String = "AdminUserGlobalSignOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AdminUserGlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<AdminUserGlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AdminUserGlobalSignOutInput>
    public typealias MOutput = OperationOutput<AdminUserGlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AdminUserGlobalSignOutOutputError>
}

/// <p>The request to sign out of all devices, as an administrator.</p>
public struct AdminUserGlobalSignOutInput: Equatable {
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user name.</p>
    public let username: String?

    public init (
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct AdminUserGlobalSignOutInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
}

extension AdminUserGlobalSignOutInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension AdminUserGlobalSignOutOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AdminUserGlobalSignOutOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AdminUserGlobalSignOutOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AdminUserGlobalSignOutOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminUserGlobalSignOutOutputResponse()"}
}

extension AdminUserGlobalSignOutOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The global sign-out response, as an administrator.</p>
public struct AdminUserGlobalSignOutOutputResponse: Equatable {

    public init() {}
}

struct AdminUserGlobalSignOutOutputResponseBody: Equatable {
}

extension AdminUserGlobalSignOutOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum AdvancedSecurityModeType {
    case audit
    case enforced
    case off
    case sdkUnknown(String)
}

extension AdvancedSecurityModeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdvancedSecurityModeType] {
        return [
            .audit,
            .enforced,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .audit: return "AUDIT"
        case .enforced: return "ENFORCED"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdvancedSecurityModeType(rawValue: rawValue) ?? AdvancedSecurityModeType.sdkUnknown(rawValue)
    }
}

public enum AliasAttributeType {
    case email
    case phoneNumber
    case preferredUsername
    case sdkUnknown(String)
}

extension AliasAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AliasAttributeType] {
        return [
            .email,
            .phoneNumber,
            .preferredUsername,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "email"
        case .phoneNumber: return "phone_number"
        case .preferredUsername: return "preferred_username"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AliasAttributeType(rawValue: rawValue) ?? AliasAttributeType.sdkUnknown(rawValue)
    }
}

extension AliasExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AliasExistsException(message: \(String(describing: message)))"}
}

extension AliasExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AliasExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user tries to confirm the account with an email or
///             phone number that has already been supplied as an alias from a different account. This
///             exception tells user that an account with this email or phone already exists.</p>
public struct AliasExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message sent to the user when an alias exists.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AliasExistsExceptionBody: Equatable {
    public let message: String?
}

extension AliasExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AnalyticsConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationArn = "ApplicationArn"
        case applicationId = "ApplicationId"
        case externalId = "ExternalId"
        case roleArn = "RoleArn"
        case userDataShared = "UserDataShared"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if userDataShared != false {
            try encodeContainer.encode(userDataShared, forKey: .userDataShared)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let userDataSharedDecoded = try containerValues.decode(Bool.self, forKey: .userDataShared)
        userDataShared = userDataSharedDecoded
    }
}

extension AnalyticsConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsConfigurationType(applicationArn: \(String(describing: applicationArn)), applicationId: \(String(describing: applicationId)), externalId: \(String(describing: externalId)), roleArn: \(String(describing: roleArn)), userDataShared: \(String(describing: userDataShared)))"}
}

/// <p>The Amazon Pinpoint analytics configuration for collecting metrics for a user
///             pool.</p>
///         <note>
///             <p>In regions where Pinpoint is not available, Cognito User Pools only supports
///                 sending events to Amazon Pinpoint projects in us-east-1. In regions where Pinpoint
///                 is available, Cognito User Pools will support sending events to Amazon Pinpoint
///                 projects within that same region. </p>
///         </note>
public struct AnalyticsConfigurationType: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an Amazon Pinpoint project. You can use the Amazon
    ///             Pinpoint project for Pinpoint integration with the chosen User Pool Client. Amazon
    ///             Cognito publishes events to the pinpoint project declared by the app ARN.</p>
    public let applicationArn: String?
    /// <p>The application ID for an Amazon Pinpoint application.</p>
    public let applicationId: String?
    /// <p>The external ID.</p>
    public let externalId: String?
    /// <p>The ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon
    ///             Pinpoint analytics.</p>
    public let roleArn: String?
    /// <p>If <code>UserDataShared</code> is <code>true</code>, Amazon Cognito will include user
    ///             data in the events it publishes to Amazon Pinpoint analytics.</p>
    public let userDataShared: Bool

    public init (
        applicationArn: String? = nil,
        applicationId: String? = nil,
        externalId: String? = nil,
        roleArn: String? = nil,
        userDataShared: Bool = false
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.externalId = externalId
        self.roleArn = roleArn
        self.userDataShared = userDataShared
    }
}

extension AnalyticsMetadataType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsEndpointId = "AnalyticsEndpointId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsEndpointId = analyticsEndpointId {
            try encodeContainer.encode(analyticsEndpointId, forKey: .analyticsEndpointId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyticsEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyticsEndpointId)
        analyticsEndpointId = analyticsEndpointIdDecoded
    }
}

extension AnalyticsMetadataType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyticsMetadataType(analyticsEndpointId: \(String(describing: analyticsEndpointId)))"}
}

/// <p>An Amazon Pinpoint analytics endpoint.</p>
///         <p>An endpoint uniquely identifies a mobile device, email address, or phone number that
///             can receive messages from Amazon Pinpoint analytics.</p>
///         <note>
///             <p>Cognito User Pools only supports sending events to Amazon Pinpoint projects in the
///                 US East (N. Virginia) us-east-1 Region, regardless of the region in which the user
///                 pool resides.</p>
///         </note>
public struct AnalyticsMetadataType: Equatable {
    /// <p>The endpoint ID.</p>
    public let analyticsEndpointId: String?

    public init (
        analyticsEndpointId: String? = nil
    )
    {
        self.analyticsEndpointId = analyticsEndpointId
    }
}

public struct AssociateSoftwareTokenInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSoftwareTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSoftwareTokenInput>
    public typealias MOutput = OperationOutput<AssociateSoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSoftwareTokenOutputError>
}

extension AssociateSoftwareTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSoftwareTokenInput(accessToken: \(String(describing: accessToken)), session: \(String(describing: session)))"}
}

extension AssociateSoftwareTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case session = "Session"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let session = session {
            try encodeContainer.encode(session, forKey: .session)
        }
    }
}

public struct AssociateSoftwareTokenInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSoftwareTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSoftwareTokenInput>
    public typealias MOutput = OperationOutput<AssociateSoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSoftwareTokenOutputError>
}

public struct AssociateSoftwareTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSoftwareTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSoftwareTokenInput>
    public typealias MOutput = OperationOutput<AssociateSoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSoftwareTokenOutputError>
}

public struct AssociateSoftwareTokenInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. This allows authentication of the user as part of the MFA setup process.</p>
    public let session: String?

    public init (
        accessToken: String? = nil,
        session: String? = nil
    )
    {
        self.accessToken = accessToken
        self.session = session
    }
}

struct AssociateSoftwareTokenInputBody: Equatable {
    public let accessToken: String?
    public let session: String?
}

extension AssociateSoftwareTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
    }
}

extension AssociateSoftwareTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSoftwareTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SoftwareTokenMFANotFoundException" : self = .softwareTokenMFANotFoundException(try SoftwareTokenMFANotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSoftwareTokenOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case softwareTokenMFANotFoundException(SoftwareTokenMFANotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSoftwareTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSoftwareTokenOutputResponse(secretCode: \(String(describing: secretCode)), session: \(String(describing: session)))"}
}

extension AssociateSoftwareTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateSoftwareTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.secretCode = output.secretCode
            self.session = output.session
        } else {
            self.secretCode = nil
            self.session = nil
        }
    }
}

public struct AssociateSoftwareTokenOutputResponse: Equatable {
    /// <p>A unique generated shared secret code that is used in the TOTP algorithm to generate a
    ///             one time code.</p>
    public let secretCode: String?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. This allows authentication of the user as part of the MFA setup process.</p>
    public let session: String?

    public init (
        secretCode: String? = nil,
        session: String? = nil
    )
    {
        self.secretCode = secretCode
        self.session = session
    }
}

struct AssociateSoftwareTokenOutputResponseBody: Equatable {
    public let secretCode: String?
    public let session: String?
}

extension AssociateSoftwareTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case secretCode = "SecretCode"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretCode)
        secretCode = secretCodeDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
    }
}

public enum AttributeDataType {
    case boolean
    case datetime
    case number
    case string
    case sdkUnknown(String)
}

extension AttributeDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttributeDataType] {
        return [
            .boolean,
            .datetime,
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "Boolean"
        case .datetime: return "DateTime"
        case .number: return "Number"
        case .string: return "String"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttributeDataType(rawValue: rawValue) ?? AttributeDataType.sdkUnknown(rawValue)
    }
}

extension AttributeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AttributeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeType(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Specifies whether the attribute is standard or custom.</p>
public struct AttributeType: Equatable {
    /// <p>The name of the attribute.</p>
    public let name: String?
    /// <p>The value of the attribute.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension AuthEventType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case challengeResponses = "ChallengeResponses"
        case creationDate = "CreationDate"
        case eventContextData = "EventContextData"
        case eventFeedback = "EventFeedback"
        case eventId = "EventId"
        case eventResponse = "EventResponse"
        case eventRisk = "EventRisk"
        case eventType = "EventType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let challengeResponses = challengeResponses {
            var challengeResponsesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .challengeResponses)
            for challengeresponselisttype0 in challengeResponses {
                try challengeResponsesContainer.encode(challengeresponselisttype0)
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let eventContextData = eventContextData {
            try encodeContainer.encode(eventContextData, forKey: .eventContextData)
        }
        if let eventFeedback = eventFeedback {
            try encodeContainer.encode(eventFeedback, forKey: .eventFeedback)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventResponse = eventResponse {
            try encodeContainer.encode(eventResponse.rawValue, forKey: .eventResponse)
        }
        if let eventRisk = eventRisk {
            try encodeContainer.encode(eventRisk, forKey: .eventRisk)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let eventResponseDecoded = try containerValues.decodeIfPresent(EventResponseType.self, forKey: .eventResponse)
        eventResponse = eventResponseDecoded
        let eventRiskDecoded = try containerValues.decodeIfPresent(EventRiskType.self, forKey: .eventRisk)
        eventRisk = eventRiskDecoded
        let challengeResponsesContainer = try containerValues.decodeIfPresent([ChallengeResponseType?].self, forKey: .challengeResponses)
        var challengeResponsesDecoded0:[ChallengeResponseType]? = nil
        if let challengeResponsesContainer = challengeResponsesContainer {
            challengeResponsesDecoded0 = [ChallengeResponseType]()
            for structure0 in challengeResponsesContainer {
                if let structure0 = structure0 {
                    challengeResponsesDecoded0?.append(structure0)
                }
            }
        }
        challengeResponses = challengeResponsesDecoded0
        let eventContextDataDecoded = try containerValues.decodeIfPresent(EventContextDataType.self, forKey: .eventContextData)
        eventContextData = eventContextDataDecoded
        let eventFeedbackDecoded = try containerValues.decodeIfPresent(EventFeedbackType.self, forKey: .eventFeedback)
        eventFeedback = eventFeedbackDecoded
    }
}

extension AuthEventType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthEventType(challengeResponses: \(String(describing: challengeResponses)), creationDate: \(String(describing: creationDate)), eventContextData: \(String(describing: eventContextData)), eventFeedback: \(String(describing: eventFeedback)), eventId: \(String(describing: eventId)), eventResponse: \(String(describing: eventResponse)), eventRisk: \(String(describing: eventRisk)), eventType: \(String(describing: eventType)))"}
}

/// <p>The authentication event type.</p>
public struct AuthEventType: Equatable {
    /// <p>The challenge responses.</p>
    public let challengeResponses: [ChallengeResponseType]?
    /// <p>The creation date</p>
    public let creationDate: Date?
    /// <p>The user context data captured at the time of an event request. It provides additional
    ///             information about the client from which event the request is received.</p>
    public let eventContextData: EventContextDataType?
    /// <p>A flag specifying the user feedback captured at the time of an event request is good
    ///             or bad. </p>
    public let eventFeedback: EventFeedbackType?
    /// <p>The event ID.</p>
    public let eventId: String?
    /// <p>The event response.</p>
    public let eventResponse: EventResponseType?
    /// <p>The event risk.</p>
    public let eventRisk: EventRiskType?
    /// <p>The event type.</p>
    public let eventType: EventType?

    public init (
        challengeResponses: [ChallengeResponseType]? = nil,
        creationDate: Date? = nil,
        eventContextData: EventContextDataType? = nil,
        eventFeedback: EventFeedbackType? = nil,
        eventId: String? = nil,
        eventResponse: EventResponseType? = nil,
        eventRisk: EventRiskType? = nil,
        eventType: EventType? = nil
    )
    {
        self.challengeResponses = challengeResponses
        self.creationDate = creationDate
        self.eventContextData = eventContextData
        self.eventFeedback = eventFeedback
        self.eventId = eventId
        self.eventResponse = eventResponse
        self.eventRisk = eventRisk
        self.eventType = eventType
    }
}

public enum AuthFlowType {
    case adminNoSrpAuth
    case adminUserPasswordAuth
    case customAuth
    case refreshToken
    case refreshTokenAuth
    case userPasswordAuth
    case userSrpAuth
    case sdkUnknown(String)
}

extension AuthFlowType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthFlowType] {
        return [
            .adminNoSrpAuth,
            .adminUserPasswordAuth,
            .customAuth,
            .refreshToken,
            .refreshTokenAuth,
            .userPasswordAuth,
            .userSrpAuth,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminNoSrpAuth: return "ADMIN_NO_SRP_AUTH"
        case .adminUserPasswordAuth: return "ADMIN_USER_PASSWORD_AUTH"
        case .customAuth: return "CUSTOM_AUTH"
        case .refreshToken: return "REFRESH_TOKEN"
        case .refreshTokenAuth: return "REFRESH_TOKEN_AUTH"
        case .userPasswordAuth: return "USER_PASSWORD_AUTH"
        case .userSrpAuth: return "USER_SRP_AUTH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthFlowType(rawValue: rawValue) ?? AuthFlowType.sdkUnknown(rawValue)
    }
}

extension AuthenticationResultType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case expiresIn = "ExpiresIn"
        case idToken = "IdToken"
        case newDeviceMetadata = "NewDeviceMetadata"
        case refreshToken = "RefreshToken"
        case tokenType = "TokenType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if expiresIn != 0 {
            try encodeContainer.encode(expiresIn, forKey: .expiresIn)
        }
        if let idToken = idToken {
            try encodeContainer.encode(idToken, forKey: .idToken)
        }
        if let newDeviceMetadata = newDeviceMetadata {
            try encodeContainer.encode(newDeviceMetadata, forKey: .newDeviceMetadata)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
        if let tokenType = tokenType {
            try encodeContainer.encode(tokenType, forKey: .tokenType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decode(Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let tokenTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenType)
        tokenType = tokenTypeDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idToken)
        idToken = idTokenDecoded
        let newDeviceMetadataDecoded = try containerValues.decodeIfPresent(NewDeviceMetadataType.self, forKey: .newDeviceMetadata)
        newDeviceMetadata = newDeviceMetadataDecoded
    }
}

extension AuthenticationResultType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthenticationResultType(accessToken: \(String(describing: accessToken)), expiresIn: \(String(describing: expiresIn)), idToken: \(String(describing: idToken)), newDeviceMetadata: \(String(describing: newDeviceMetadata)), refreshToken: \(String(describing: refreshToken)), tokenType: \(String(describing: tokenType)))"}
}

/// <p>The authentication result.</p>
public struct AuthenticationResultType: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The expiration period of the authentication result in seconds.</p>
    public let expiresIn: Int
    /// <p>The ID token.</p>
    public let idToken: String?
    /// <p>The new device metadata from an authentication result.</p>
    public let newDeviceMetadata: NewDeviceMetadataType?
    /// <p>The refresh token.</p>
    public let refreshToken: String?
    /// <p>The token type.</p>
    public let tokenType: String?

    public init (
        accessToken: String? = nil,
        expiresIn: Int = 0,
        idToken: String? = nil,
        newDeviceMetadata: NewDeviceMetadataType? = nil,
        refreshToken: String? = nil,
        tokenType: String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.idToken = idToken
        self.newDeviceMetadata = newDeviceMetadata
        self.refreshToken = refreshToken
        self.tokenType = tokenType
    }
}

public enum ChallengeName {
    case mfa
    case password
    case sdkUnknown(String)
}

extension ChallengeName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChallengeName] {
        return [
            .mfa,
            .password,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mfa: return "Mfa"
        case .password: return "Password"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChallengeName(rawValue: rawValue) ?? ChallengeName.sdkUnknown(rawValue)
    }
}

public enum ChallengeNameType {
    case adminNoSrpAuth
    case customChallenge
    case devicePasswordVerifier
    case deviceSrpAuth
    case mfaSetup
    case newPasswordRequired
    case passwordVerifier
    case selectMfaType
    case smsMfa
    case softwareTokenMfa
    case sdkUnknown(String)
}

extension ChallengeNameType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChallengeNameType] {
        return [
            .adminNoSrpAuth,
            .customChallenge,
            .devicePasswordVerifier,
            .deviceSrpAuth,
            .mfaSetup,
            .newPasswordRequired,
            .passwordVerifier,
            .selectMfaType,
            .smsMfa,
            .softwareTokenMfa,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminNoSrpAuth: return "ADMIN_NO_SRP_AUTH"
        case .customChallenge: return "CUSTOM_CHALLENGE"
        case .devicePasswordVerifier: return "DEVICE_PASSWORD_VERIFIER"
        case .deviceSrpAuth: return "DEVICE_SRP_AUTH"
        case .mfaSetup: return "MFA_SETUP"
        case .newPasswordRequired: return "NEW_PASSWORD_REQUIRED"
        case .passwordVerifier: return "PASSWORD_VERIFIER"
        case .selectMfaType: return "SELECT_MFA_TYPE"
        case .smsMfa: return "SMS_MFA"
        case .softwareTokenMfa: return "SOFTWARE_TOKEN_MFA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChallengeNameType(rawValue: rawValue) ?? ChallengeNameType.sdkUnknown(rawValue)
    }
}

public enum ChallengeResponse {
    case failure
    case success
    case sdkUnknown(String)
}

extension ChallengeResponse : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChallengeResponse] {
        return [
            .failure,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "Failure"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChallengeResponse(rawValue: rawValue) ?? ChallengeResponse.sdkUnknown(rawValue)
    }
}

extension ChallengeResponseType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case challengeName = "ChallengeName"
        case challengeResponse = "ChallengeResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let challengeName = challengeName {
            try encodeContainer.encode(challengeName.rawValue, forKey: .challengeName)
        }
        if let challengeResponse = challengeResponse {
            try encodeContainer.encode(challengeResponse.rawValue, forKey: .challengeResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeName.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let challengeResponseDecoded = try containerValues.decodeIfPresent(ChallengeResponse.self, forKey: .challengeResponse)
        challengeResponse = challengeResponseDecoded
    }
}

extension ChallengeResponseType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChallengeResponseType(challengeName: \(String(describing: challengeName)), challengeResponse: \(String(describing: challengeResponse)))"}
}

/// <p>The challenge response type.</p>
public struct ChallengeResponseType: Equatable {
    /// <p>The challenge name</p>
    public let challengeName: ChallengeName?
    /// <p>The challenge response.</p>
    public let challengeResponse: ChallengeResponse?

    public init (
        challengeName: ChallengeName? = nil,
        challengeResponse: ChallengeResponse? = nil
    )
    {
        self.challengeName = challengeName
        self.challengeResponse = challengeResponse
    }
}

public struct ChangePasswordInputBodyMiddleware: Middleware {
    public let id: String = "ChangePasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

extension ChangePasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangePasswordInput(accessToken: \(String(describing: accessToken)), previousPassword: \(String(describing: previousPassword)), proposedPassword: \(String(describing: proposedPassword)))"}
}

extension ChangePasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case previousPassword = "PreviousPassword"
        case proposedPassword = "ProposedPassword"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let previousPassword = previousPassword {
            try encodeContainer.encode(previousPassword, forKey: .previousPassword)
        }
        if let proposedPassword = proposedPassword {
            try encodeContainer.encode(proposedPassword, forKey: .proposedPassword)
        }
    }
}

public struct ChangePasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ChangePasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

public struct ChangePasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ChangePasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ChangePasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ChangePasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ChangePasswordInput>
    public typealias MOutput = OperationOutput<ChangePasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ChangePasswordOutputError>
}

/// <p>Represents the request to change a user password.</p>
public struct ChangePasswordInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The old password.</p>
    public let previousPassword: String?
    /// <p>The new password.</p>
    public let proposedPassword: String?

    public init (
        accessToken: String? = nil,
        previousPassword: String? = nil,
        proposedPassword: String? = nil
    )
    {
        self.accessToken = accessToken
        self.previousPassword = previousPassword
        self.proposedPassword = proposedPassword
    }
}

struct ChangePasswordInputBody: Equatable {
    public let previousPassword: String?
    public let proposedPassword: String?
    public let accessToken: String?
}

extension ChangePasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case previousPassword = "PreviousPassword"
        case proposedPassword = "ProposedPassword"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previousPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previousPassword)
        previousPassword = previousPasswordDecoded
        let proposedPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .proposedPassword)
        proposedPassword = proposedPasswordDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension ChangePasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChangePasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ChangePasswordOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangePasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangePasswordOutputResponse()"}
}

extension ChangePasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response from the server to the change password request.</p>
public struct ChangePasswordOutputResponse: Equatable {

    public init() {}
}

struct ChangePasswordOutputResponseBody: Equatable {
}

extension ChangePasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CodeDeliveryDetailsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case deliveryMedium = "DeliveryMedium"
        case destination = "Destination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let deliveryMedium = deliveryMedium {
            try encodeContainer.encode(deliveryMedium.rawValue, forKey: .deliveryMedium)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let deliveryMediumDecoded = try containerValues.decodeIfPresent(DeliveryMediumType.self, forKey: .deliveryMedium)
        deliveryMedium = deliveryMediumDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
    }
}

extension CodeDeliveryDetailsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeDeliveryDetailsType(attributeName: \(String(describing: attributeName)), deliveryMedium: \(String(describing: deliveryMedium)), destination: \(String(describing: destination)))"}
}

/// <p>The code delivery details being returned from the server.</p>
public struct CodeDeliveryDetailsType: Equatable {
    /// <p>The attribute name.</p>
    public let attributeName: String?
    /// <p>The delivery medium (email message or phone number).</p>
    public let deliveryMedium: DeliveryMediumType?
    /// <p>The destination for the code delivery details.</p>
    public let destination: String?

    public init (
        attributeName: String? = nil,
        deliveryMedium: DeliveryMediumType? = nil,
        destination: String? = nil
    )
    {
        self.attributeName = attributeName
        self.deliveryMedium = deliveryMedium
        self.destination = destination
    }
}

extension CodeDeliveryFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeDeliveryFailureException(message: \(String(describing: message)))"}
}

extension CodeDeliveryFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeDeliveryFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a verification code fails to deliver
///             successfully.</p>
public struct CodeDeliveryFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message sent when a verification code fails to deliver successfully.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CodeDeliveryFailureExceptionBody: Equatable {
    public let message: String?
}

extension CodeDeliveryFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeMismatchException(message: \(String(describing: message)))"}
}

extension CodeMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown if the provided code does not match what the server was
///             expecting.</p>
public struct CodeMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided when the code mismatch exception is thrown.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CodeMismatchExceptionBody: Equatable {
    public let message: String?
}

extension CodeMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CompromisedCredentialsActionsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventAction = "EventAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventAction = eventAction {
            try encodeContainer.encode(eventAction.rawValue, forKey: .eventAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventActionDecoded = try containerValues.decodeIfPresent(CompromisedCredentialsEventActionType.self, forKey: .eventAction)
        eventAction = eventActionDecoded
    }
}

extension CompromisedCredentialsActionsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompromisedCredentialsActionsType(eventAction: \(String(describing: eventAction)))"}
}

/// <p>The compromised credentials actions type</p>
public struct CompromisedCredentialsActionsType: Equatable {
    /// <p>The event action.</p>
    public let eventAction: CompromisedCredentialsEventActionType?

    public init (
        eventAction: CompromisedCredentialsEventActionType? = nil
    )
    {
        self.eventAction = eventAction
    }
}

public enum CompromisedCredentialsEventActionType {
    case block
    case noAction
    case sdkUnknown(String)
}

extension CompromisedCredentialsEventActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CompromisedCredentialsEventActionType] {
        return [
            .block,
            .noAction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .block: return "BLOCK"
        case .noAction: return "NO_ACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CompromisedCredentialsEventActionType(rawValue: rawValue) ?? CompromisedCredentialsEventActionType.sdkUnknown(rawValue)
    }
}

extension CompromisedCredentialsRiskConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case eventFilter = "EventFilter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            try encodeContainer.encode(actions, forKey: .actions)
        }
        if let eventFilter = eventFilter {
            var eventFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventFilter)
            for eventfilterstype0 in eventFilter {
                try eventFilterContainer.encode(eventfilterstype0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventFilterContainer = try containerValues.decodeIfPresent([EventFilterType?].self, forKey: .eventFilter)
        var eventFilterDecoded0:[EventFilterType]? = nil
        if let eventFilterContainer = eventFilterContainer {
            eventFilterDecoded0 = [EventFilterType]()
            for string0 in eventFilterContainer {
                if let string0 = string0 {
                    eventFilterDecoded0?.append(string0)
                }
            }
        }
        eventFilter = eventFilterDecoded0
        let actionsDecoded = try containerValues.decodeIfPresent(CompromisedCredentialsActionsType.self, forKey: .actions)
        actions = actionsDecoded
    }
}

extension CompromisedCredentialsRiskConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompromisedCredentialsRiskConfigurationType(actions: \(String(describing: actions)), eventFilter: \(String(describing: eventFilter)))"}
}

/// <p>The compromised credentials risk configuration type.</p>
public struct CompromisedCredentialsRiskConfigurationType: Equatable {
    /// <p>The compromised credentials risk configuration actions.</p>
    public let actions: CompromisedCredentialsActionsType?
    /// <p>Perform the action for these events. The default is to perform all events if no event
    ///             filter is specified.</p>
    public let eventFilter: [EventFilterType]?

    public init (
        actions: CompromisedCredentialsActionsType? = nil,
        eventFilter: [EventFilterType]? = nil
    )
    {
        self.actions = actions
        self.eventFilter = eventFilter
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown if two or more modifications are happening
///             concurrently.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided when the concurrent exception is thrown.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ConfirmDeviceInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmDeviceInput>
    public typealias MOutput = OperationOutput<ConfirmDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmDeviceOutputError>
}

extension ConfirmDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmDeviceInput(accessToken: \(String(describing: accessToken)), deviceKey: \(String(describing: deviceKey)), deviceName: \(String(describing: deviceName)), deviceSecretVerifierConfig: \(String(describing: deviceSecretVerifierConfig)))"}
}

extension ConfirmDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
        case deviceName = "DeviceName"
        case deviceSecretVerifierConfig = "DeviceSecretVerifierConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSecretVerifierConfig = deviceSecretVerifierConfig {
            try encodeContainer.encode(deviceSecretVerifierConfig, forKey: .deviceSecretVerifierConfig)
        }
    }
}

public struct ConfirmDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmDeviceInput>
    public typealias MOutput = OperationOutput<ConfirmDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmDeviceOutputError>
}

public struct ConfirmDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmDeviceInput>
    public typealias MOutput = OperationOutput<ConfirmDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmDeviceOutputError>
}

/// <p>Confirms the device request.</p>
public struct ConfirmDeviceInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The device name.</p>
    public let deviceName: String?
    /// <p>The configuration of the device secret verifier.</p>
    public let deviceSecretVerifierConfig: DeviceSecretVerifierConfigType?

    public init (
        accessToken: String? = nil,
        deviceKey: String? = nil,
        deviceName: String? = nil,
        deviceSecretVerifierConfig: DeviceSecretVerifierConfigType? = nil
    )
    {
        self.accessToken = accessToken
        self.deviceKey = deviceKey
        self.deviceName = deviceName
        self.deviceSecretVerifierConfig = deviceSecretVerifierConfig
    }
}

struct ConfirmDeviceInputBody: Equatable {
    public let accessToken: String?
    public let deviceKey: String?
    public let deviceSecretVerifierConfig: DeviceSecretVerifierConfigType?
    public let deviceName: String?
}

extension ConfirmDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
        case deviceName = "DeviceName"
        case deviceSecretVerifierConfig = "DeviceSecretVerifierConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let deviceSecretVerifierConfigDecoded = try containerValues.decodeIfPresent(DeviceSecretVerifierConfigType.self, forKey: .deviceSecretVerifierConfig)
        deviceSecretVerifierConfig = deviceSecretVerifierConfigDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
    }
}

extension ConfirmDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsernameExistsException" : self = .usernameExistsException(try UsernameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmDeviceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case usernameExistsException(UsernameExistsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmDeviceOutputResponse(userConfirmationNecessary: \(String(describing: userConfirmationNecessary)))"}
}

extension ConfirmDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfirmDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userConfirmationNecessary = output.userConfirmationNecessary
        } else {
            self.userConfirmationNecessary = false
        }
    }
}

/// <p>Confirms the device response.</p>
public struct ConfirmDeviceOutputResponse: Equatable {
    /// <p>Indicates whether the user confirmation is necessary to confirm the device
    ///             response.</p>
    public let userConfirmationNecessary: Bool

    public init (
        userConfirmationNecessary: Bool = false
    )
    {
        self.userConfirmationNecessary = userConfirmationNecessary
    }
}

struct ConfirmDeviceOutputResponseBody: Equatable {
    public let userConfirmationNecessary: Bool
}

extension ConfirmDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userConfirmationNecessary = "UserConfirmationNecessary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userConfirmationNecessaryDecoded = try containerValues.decode(Bool.self, forKey: .userConfirmationNecessary)
        userConfirmationNecessary = userConfirmationNecessaryDecoded
    }
}

public struct ConfirmForgotPasswordInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmForgotPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmForgotPasswordInput>
    public typealias MOutput = OperationOutput<ConfirmForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmForgotPasswordOutputError>
}

extension ConfirmForgotPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmForgotPasswordInput(analyticsMetadata: \(String(describing: analyticsMetadata)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), confirmationCode: \(String(describing: confirmationCode)), password: \(String(describing: password)), secretHash: \(String(describing: secretHash)), userContextData: \(String(describing: userContextData)), username: \(String(describing: username)))"}
}

extension ConfirmForgotPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case confirmationCode = "ConfirmationCode"
        case password = "Password"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let confirmationCode = confirmationCode {
            try encodeContainer.encode(confirmationCode, forKey: .confirmationCode)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let secretHash = secretHash {
            try encodeContainer.encode(secretHash, forKey: .secretHash)
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ConfirmForgotPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmForgotPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmForgotPasswordInput>
    public typealias MOutput = OperationOutput<ConfirmForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmForgotPasswordOutputError>
}

public struct ConfirmForgotPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmForgotPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmForgotPasswordInput>
    public typealias MOutput = OperationOutput<ConfirmForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmForgotPasswordOutputError>
}

/// <p>The request representing the confirmation for a password reset.</p>
public struct ConfirmForgotPasswordInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>ConfirmForgotPassword</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The app client ID of the app associated with the user pool.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the ConfirmForgotPassword API action, Amazon Cognito invokes the function
    ///             that is assigned to the <i>post confirmation</i> trigger. When Amazon
    ///             Cognito invokes this function, it passes a JSON payload, which the function receives as
    ///             input. This payload contains a <code>clientMetadata</code> attribute, which provides the
    ///             data that you assigned to the ClientMetadata parameter in your ConfirmForgotPassword
    ///             request. In your function code in AWS Lambda, you can process the
    ///                 <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The confirmation code sent by a user's request to retrieve a forgotten password. For
    ///             more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ForgotPassword.html">ForgotPassword</a>.</p>
    public let confirmationCode: String?
    /// <p>The password sent by a user's request to retrieve a forgotten password.</p>
    public let password: String?
    /// <p>A keyed-hash message authentication code (HMAC) calculated using the secret key of a
    ///             user pool client and username plus the client ID in the message.</p>
    public let secretHash: String?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?
    /// <p>The user name of the user for whom you want to enter a code to retrieve a forgotten
    ///             password.</p>
    public let username: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        confirmationCode: String? = nil,
        password: String? = nil,
        secretHash: String? = nil,
        userContextData: UserContextDataType? = nil,
        username: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.confirmationCode = confirmationCode
        self.password = password
        self.secretHash = secretHash
        self.userContextData = userContextData
        self.username = username
    }
}

struct ConfirmForgotPasswordInputBody: Equatable {
    public let clientId: String?
    public let secretHash: String?
    public let username: String?
    public let confirmationCode: String?
    public let password: String?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let userContextData: UserContextDataType?
    public let clientMetadata: [String:String]?
}

extension ConfirmForgotPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case confirmationCode = "ConfirmationCode"
        case password = "Password"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let secretHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretHash)
        secretHash = secretHashDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let confirmationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationCode)
        confirmationCode = confirmationCodeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension ConfirmForgotPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmForgotPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFailedAttemptsException" : self = .tooManyFailedAttemptsException(try TooManyFailedAttemptsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmForgotPasswordOutputError: Equatable {
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyFailedAttemptsException(TooManyFailedAttemptsException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmForgotPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmForgotPasswordOutputResponse()"}
}

extension ConfirmForgotPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response from the server that results from a user's request to retrieve a
///             forgotten password.</p>
public struct ConfirmForgotPasswordOutputResponse: Equatable {

    public init() {}
}

struct ConfirmForgotPasswordOutputResponseBody: Equatable {
}

extension ConfirmForgotPasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ConfirmSignUpInputBodyMiddleware: Middleware {
    public let id: String = "ConfirmSignUpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSignUpInput>
    public typealias MOutput = OperationOutput<ConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSignUpOutputError>
}

extension ConfirmSignUpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmSignUpInput(analyticsMetadata: \(String(describing: analyticsMetadata)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), confirmationCode: \(String(describing: confirmationCode)), forceAliasCreation: \(String(describing: forceAliasCreation)), secretHash: \(String(describing: secretHash)), userContextData: \(String(describing: userContextData)), username: \(String(describing: username)))"}
}

extension ConfirmSignUpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case confirmationCode = "ConfirmationCode"
        case forceAliasCreation = "ForceAliasCreation"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let confirmationCode = confirmationCode {
            try encodeContainer.encode(confirmationCode, forKey: .confirmationCode)
        }
        if forceAliasCreation != false {
            try encodeContainer.encode(forceAliasCreation, forKey: .forceAliasCreation)
        }
        if let secretHash = secretHash {
            try encodeContainer.encode(secretHash, forKey: .secretHash)
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ConfirmSignUpInputHeadersMiddleware: Middleware {
    public let id: String = "ConfirmSignUpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSignUpInput>
    public typealias MOutput = OperationOutput<ConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSignUpOutputError>
}

public struct ConfirmSignUpInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfirmSignUpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfirmSignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfirmSignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfirmSignUpInput>
    public typealias MOutput = OperationOutput<ConfirmSignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfirmSignUpOutputError>
}

/// <p>Represents the request to confirm registration of a user.</p>
public struct ConfirmSignUpInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>ConfirmSignUp</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The ID of the app client associated with the user pool.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the ConfirmSignUp API action, Amazon Cognito invokes the function that is
    ///             assigned to the <i>post confirmation</i> trigger. When Amazon Cognito
    ///             invokes this function, it passes a JSON payload, which the function receives as input.
    ///             This payload contains a <code>clientMetadata</code> attribute, which provides the data
    ///             that you assigned to the ClientMetadata parameter in your ConfirmSignUp request. In your
    ///             function code in AWS Lambda, you can process the <code>clientMetadata</code> value to
    ///             enhance your workflow for your specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The confirmation code sent by a user's request to confirm registration.</p>
    public let confirmationCode: String?
    /// <p>Boolean to be specified to force user confirmation irrespective of existing alias. By
    ///             default set to <code>False</code>. If this parameter is set to <code>True</code> and the
    ///             phone number/email used for sign up confirmation already exists as an alias with a
    ///             different user, the API call will migrate the alias from the previous user to the newly
    ///             created user being confirmed. If set to <code>False</code>, the API will throw an
    ///                 <b>AliasExistsException</b> error.</p>
    public let forceAliasCreation: Bool
    /// <p>A keyed-hash message authentication code (HMAC) calculated using the secret key of a
    ///             user pool client and username plus the client ID in the message.</p>
    public let secretHash: String?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?
    /// <p>The user name of the user whose registration you wish to confirm.</p>
    public let username: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        confirmationCode: String? = nil,
        forceAliasCreation: Bool = false,
        secretHash: String? = nil,
        userContextData: UserContextDataType? = nil,
        username: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.confirmationCode = confirmationCode
        self.forceAliasCreation = forceAliasCreation
        self.secretHash = secretHash
        self.userContextData = userContextData
        self.username = username
    }
}

struct ConfirmSignUpInputBody: Equatable {
    public let clientId: String?
    public let secretHash: String?
    public let username: String?
    public let confirmationCode: String?
    public let forceAliasCreation: Bool
    public let analyticsMetadata: AnalyticsMetadataType?
    public let userContextData: UserContextDataType?
    public let clientMetadata: [String:String]?
}

extension ConfirmSignUpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case confirmationCode = "ConfirmationCode"
        case forceAliasCreation = "ForceAliasCreation"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let secretHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretHash)
        secretHash = secretHashDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let confirmationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .confirmationCode)
        confirmationCode = confirmationCodeDecoded
        let forceAliasCreationDecoded = try containerValues.decode(Bool.self, forKey: .forceAliasCreation)
        forceAliasCreation = forceAliasCreationDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension ConfirmSignUpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfirmSignUpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFailedAttemptsException" : self = .tooManyFailedAttemptsException(try TooManyFailedAttemptsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfirmSignUpOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyFailedAttemptsException(TooManyFailedAttemptsException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfirmSignUpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfirmSignUpOutputResponse()"}
}

extension ConfirmSignUpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server for the registration confirmation.</p>
public struct ConfirmSignUpOutputResponse: Equatable {

    public init() {}
}

struct ConfirmSignUpOutputResponseBody: Equatable {
}

extension ConfirmSignUpOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ContextDataType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encodedData = "EncodedData"
        case httpHeaders = "HttpHeaders"
        case ipAddress = "IpAddress"
        case serverName = "ServerName"
        case serverPath = "ServerPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodedData = encodedData {
            try encodeContainer.encode(encodedData, forKey: .encodedData)
        }
        if let httpHeaders = httpHeaders {
            var httpHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpHeaders)
            for httpheaderlist0 in httpHeaders {
                try httpHeadersContainer.encode(httpheaderlist0)
            }
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverPath = serverPath {
            try encodeContainer.encode(serverPath, forKey: .serverPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverPath)
        serverPath = serverPathDecoded
        let httpHeadersContainer = try containerValues.decodeIfPresent([HttpHeader?].self, forKey: .httpHeaders)
        var httpHeadersDecoded0:[HttpHeader]? = nil
        if let httpHeadersContainer = httpHeadersContainer {
            httpHeadersDecoded0 = [HttpHeader]()
            for structure0 in httpHeadersContainer {
                if let structure0 = structure0 {
                    httpHeadersDecoded0?.append(structure0)
                }
            }
        }
        httpHeaders = httpHeadersDecoded0
        let encodedDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encodedData)
        encodedData = encodedDataDecoded
    }
}

extension ContextDataType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContextDataType(encodedData: \(String(describing: encodedData)), httpHeaders: \(String(describing: httpHeaders)), ipAddress: \(String(describing: ipAddress)), serverName: \(String(describing: serverName)), serverPath: \(String(describing: serverPath)))"}
}

/// <p>Contextual user data type used for evaluating the risk of an unexpected event by
///             Amazon Cognito advanced security.</p>
public struct ContextDataType: Equatable {
    /// <p>Encoded data containing device fingerprinting details, collected using the Amazon
    ///             Cognito context data collection library.</p>
    public let encodedData: String?
    /// <p>HttpHeaders received on your server in same order.</p>
    public let httpHeaders: [HttpHeader]?
    /// <p>Source IP address of your user.</p>
    public let ipAddress: String?
    /// <p>Your server endpoint where this API is invoked.</p>
    public let serverName: String?
    /// <p>Your server path where this API is invoked. </p>
    public let serverPath: String?

    public init (
        encodedData: String? = nil,
        httpHeaders: [HttpHeader]? = nil,
        ipAddress: String? = nil,
        serverName: String? = nil,
        serverPath: String? = nil
    )
    {
        self.encodedData = encodedData
        self.httpHeaders = httpHeaders
        self.ipAddress = ipAddress
        self.serverName = serverName
        self.serverPath = serverPath
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(description: \(String(describing: description)), groupName: \(String(describing: groupName)), precedence: \(String(describing: precedence)), roleArn: \(String(describing: roleArn)), userPoolId: \(String(describing: userPoolId)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
        case precedence = "Precedence"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let precedence = precedence {
            try encodeContainer.encode(precedence, forKey: .precedence)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// <p>A string containing the description of the group.</p>
    public let description: String?
    /// <p>The name of the group. Must be unique.</p>
    public let groupName: String?
    /// <p>A nonnegative integer value that specifies the precedence of this group relative to
    ///             the other groups that a user can belong to in the user pool. Zero is the highest
    ///             precedence value. Groups with lower <code>Precedence</code> values take precedence over
    ///             groups with higher or null <code>Precedence</code> values. If a user belongs to two or
    ///             more groups, it is the group with the lowest precedence value whose role ARN will be
    ///             used in the <code>cognito:roles</code> and <code>cognito:preferred_role</code> claims in
    ///             the user's tokens.</p>
    ///         <p>Two groups can have the same <code>Precedence</code> value. If this happens, neither
    ///             group takes precedence over the other. If two groups with the same
    ///                 <code>Precedence</code> have the same role ARN, that role is used in the
    ///                 <code>cognito:preferred_role</code> claim in tokens for users in each group. If the
    ///             two groups have different role ARNs, the <code>cognito:preferred_role</code> claim is
    ///             not set in users' tokens.</p>
    ///         <p>The default <code>Precedence</code> value is null.</p>
    public let precedence: Int?
    /// <p>The role ARN for the group.</p>
    public let roleArn: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        description: String? = nil,
        groupName: String? = nil,
        precedence: Int? = nil,
        roleArn: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.description = description
        self.groupName = groupName
        self.precedence = precedence
        self.roleArn = roleArn
        self.userPoolId = userPoolId
    }
}

struct CreateGroupInputBody: Equatable {
    public let groupName: String?
    public let userPoolId: String?
    public let description: String?
    public let roleArn: String?
    public let precedence: Int?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
        case precedence = "Precedence"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let precedenceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .precedence)
        precedence = precedenceDecoded
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GroupExistsException" : self = .groupExistsException(try GroupExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case groupExistsException(GroupExistsException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct CreateGroupOutputResponse: Equatable {
    /// <p>The group object for the group.</p>
    public let group: GroupType?

    public init (
        group: GroupType? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let group: GroupType?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(GroupType.self, forKey: .group)
        group = groupDecoded
    }
}

public struct CreateIdentityProviderInputBodyMiddleware: Middleware {
    public let id: String = "CreateIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityProviderOutputError>
}

extension CreateIdentityProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIdentityProviderInput(attributeMapping: \(String(describing: attributeMapping)), idpIdentifiers: \(String(describing: idpIdentifiers)), providerDetails: \(String(describing: providerDetails)), providerName: \(String(describing: providerName)), providerType: \(String(describing: providerType)), userPoolId: \(String(describing: userPoolId)))"}
}

extension CreateIdentityProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeMapping = "AttributeMapping"
        case idpIdentifiers = "IdpIdentifiers"
        case providerDetails = "ProviderDetails"
        case providerName = "ProviderName"
        case providerType = "ProviderType"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMapping = attributeMapping {
            var attributeMappingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributeMapping)
            for (dictKey0, attributemappingtype0) in attributeMapping {
                try attributeMappingContainer.encode(attributemappingtype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let idpIdentifiers = idpIdentifiers {
            var idpIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idpIdentifiers)
            for idpidentifierslisttype0 in idpIdentifiers {
                try idpIdentifiersContainer.encode(idpidentifierslisttype0)
            }
        }
        if let providerDetails = providerDetails {
            var providerDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .providerDetails)
            for (dictKey0, providerdetailstype0) in providerDetails {
                try providerDetailsContainer.encode(providerdetailstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct CreateIdentityProviderInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInput: Equatable {
    /// <p>A mapping of identity provider attributes to standard and custom user pool
    ///             attributes.</p>
    public let attributeMapping: [String:String]?
    /// <p>A list of identity provider identifiers.</p>
    public let idpIdentifiers: [String]?
    /// <p>The identity provider details. The following list describes the provider detail keys
    ///             for each identity provider type.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For Google and Login with Amazon:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For Facebook:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>api_version</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For Sign in with Apple:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>team_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>key_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>private_key</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For OIDC providers:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>attributes_request_method</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>oidc_issuer</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_url <i>if not available from discovery URL specified
    ///                                 by oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>token_url <i>if not available from discovery URL specified by
    ///                                 oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>attributes_url <i>if not available from discovery URL specified
    ///                                 by oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>jwks_uri <i>if not available from discovery URL specified by
    ///                                 oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For SAML providers:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>MetadataFile OR MetadataURL</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>IDPSignout <i>optional</i>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let providerDetails: [String:String]?
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The identity provider type.</p>
    public let providerType: IdentityProviderTypeType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        attributeMapping: [String:String]? = nil,
        idpIdentifiers: [String]? = nil,
        providerDetails: [String:String]? = nil,
        providerName: String? = nil,
        providerType: IdentityProviderTypeType? = nil,
        userPoolId: String? = nil
    )
    {
        self.attributeMapping = attributeMapping
        self.idpIdentifiers = idpIdentifiers
        self.providerDetails = providerDetails
        self.providerName = providerName
        self.providerType = providerType
        self.userPoolId = userPoolId
    }
}

struct CreateIdentityProviderInputBody: Equatable {
    public let userPoolId: String?
    public let providerName: String?
    public let providerType: IdentityProviderTypeType?
    public let providerDetails: [String:String]?
    public let attributeMapping: [String:String]?
    public let idpIdentifiers: [String]?
}

extension CreateIdentityProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeMapping = "AttributeMapping"
        case idpIdentifiers = "IdpIdentifiers"
        case providerDetails = "ProviderDetails"
        case providerName = "ProviderName"
        case providerType = "ProviderType"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderTypeType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let providerDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .providerDetails)
        var providerDetailsDecoded0: [String:String]? = nil
        if let providerDetailsContainer = providerDetailsContainer {
            providerDetailsDecoded0 = [String:String]()
            for (key0, stringtype0) in providerDetailsContainer {
                if let stringtype0 = stringtype0 {
                    providerDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        providerDetails = providerDetailsDecoded0
        let attributeMappingContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributeMapping)
        var attributeMappingDecoded0: [String:String]? = nil
        if let attributeMappingContainer = attributeMappingContainer {
            attributeMappingDecoded0 = [String:String]()
            for (key0, stringtype0) in attributeMappingContainer {
                if let stringtype0 = stringtype0 {
                    attributeMappingDecoded0?[key0] = stringtype0
                }
            }
        }
        attributeMapping = attributeMappingDecoded0
        let idpIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .idpIdentifiers)
        var idpIdentifiersDecoded0:[String]? = nil
        if let idpIdentifiersContainer = idpIdentifiersContainer {
            idpIdentifiersDecoded0 = [String]()
            for string0 in idpIdentifiersContainer {
                if let string0 = string0 {
                    idpIdentifiersDecoded0?.append(string0)
                }
            }
        }
        idpIdentifiers = idpIdentifiersDecoded0
    }
}

extension CreateIdentityProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateProviderException" : self = .duplicateProviderException(try DuplicateProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIdentityProviderOutputError: Equatable {
    case duplicateProviderException(DuplicateProviderException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIdentityProviderOutputResponse(identityProvider: \(String(describing: identityProvider)))"}
}

extension CreateIdentityProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct CreateIdentityProviderOutputResponse: Equatable {
    /// <p>The newly created identity provider object.</p>
    public let identityProvider: IdentityProviderType?

    public init (
        identityProvider: IdentityProviderType? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct CreateIdentityProviderOutputResponseBody: Equatable {
    public let identityProvider: IdentityProviderType?
}

extension CreateIdentityProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityProvider = "IdentityProvider"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

public struct CreateResourceServerInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceServerInput>
    public typealias MOutput = OperationOutput<CreateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceServerOutputError>
}

extension CreateResourceServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceServerInput(identifier: \(String(describing: identifier)), name: \(String(describing: name)), scopes: \(String(describing: scopes)), userPoolId: \(String(describing: userPoolId)))"}
}

extension CreateResourceServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case name = "Name"
        case scopes = "Scopes"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for resourceserverscopelisttype0 in scopes {
                try scopesContainer.encode(resourceserverscopelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct CreateResourceServerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceServerInput>
    public typealias MOutput = OperationOutput<CreateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceServerOutputError>
}

public struct CreateResourceServerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceServerInput>
    public typealias MOutput = OperationOutput<CreateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceServerOutputError>
}

public struct CreateResourceServerInput: Equatable {
    /// <p>A unique resource server identifier for the resource server. This could be an HTTPS
    ///             endpoint where the resource server is located. For example,
    ///                 <code>https://my-weather-api.example.com</code>.</p>
    public let identifier: String?
    /// <p>A friendly name for the resource server.</p>
    public let name: String?
    /// <p>A list of scopes. Each scope is map, where the keys are <code>name</code> and
    ///                 <code>description</code>.</p>
    public let scopes: [ResourceServerScopeType]?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        identifier: String? = nil,
        name: String? = nil,
        scopes: [ResourceServerScopeType]? = nil,
        userPoolId: String? = nil
    )
    {
        self.identifier = identifier
        self.name = name
        self.scopes = scopes
        self.userPoolId = userPoolId
    }
}

struct CreateResourceServerInputBody: Equatable {
    public let userPoolId: String?
    public let identifier: String?
    public let name: String?
    public let scopes: [ResourceServerScopeType]?
}

extension CreateResourceServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case name = "Name"
        case scopes = "Scopes"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopesContainer = try containerValues.decodeIfPresent([ResourceServerScopeType?].self, forKey: .scopes)
        var scopesDecoded0:[ResourceServerScopeType]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [ResourceServerScopeType]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension CreateResourceServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceServerOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceServerOutputResponse(resourceServer: \(String(describing: resourceServer)))"}
}

extension CreateResourceServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceServer = output.resourceServer
        } else {
            self.resourceServer = nil
        }
    }
}

public struct CreateResourceServerOutputResponse: Equatable {
    /// <p>The newly created resource server.</p>
    public let resourceServer: ResourceServerType?

    public init (
        resourceServer: ResourceServerType? = nil
    )
    {
        self.resourceServer = resourceServer
    }
}

struct CreateResourceServerOutputResponseBody: Equatable {
    public let resourceServer: ResourceServerType?
}

extension CreateResourceServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceServer = "ResourceServer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceServerDecoded = try containerValues.decodeIfPresent(ResourceServerType.self, forKey: .resourceServer)
        resourceServer = resourceServerDecoded
    }
}

public struct CreateUserImportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserImportJobInput>
    public typealias MOutput = OperationOutput<CreateUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserImportJobOutputError>
}

extension CreateUserImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserImportJobInput(cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), jobName: \(String(describing: jobName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension CreateUserImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case jobName = "JobName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct CreateUserImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserImportJobInput>
    public typealias MOutput = OperationOutput<CreateUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserImportJobOutputError>
}

public struct CreateUserImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserImportJobInput>
    public typealias MOutput = OperationOutput<CreateUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserImportJobOutputError>
}

/// <p>Represents the request to create the user import job.</p>
public struct CreateUserImportJobInput: Equatable {
    /// <p>The role ARN for the Amazon CloudWatch Logging role for the user import job.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>The job name for the user import job.</p>
    public let jobName: String?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        cloudWatchLogsRoleArn: String? = nil,
        jobName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.jobName = jobName
        self.userPoolId = userPoolId
    }
}

struct CreateUserImportJobInputBody: Equatable {
    public let jobName: String?
    public let userPoolId: String?
    public let cloudWatchLogsRoleArn: String?
}

extension CreateUserImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case jobName = "JobName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
    }
}

extension CreateUserImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserImportJobOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserImportJobOutputResponse(userImportJob: \(String(describing: userImportJob)))"}
}

extension CreateUserImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userImportJob = output.userImportJob
        } else {
            self.userImportJob = nil
        }
    }
}

/// <p>Represents the response from the server to the request to create the user import
///             job.</p>
public struct CreateUserImportJobOutputResponse: Equatable {
    /// <p>The job object that represents the user import job.</p>
    public let userImportJob: UserImportJobType?

    public init (
        userImportJob: UserImportJobType? = nil
    )
    {
        self.userImportJob = userImportJob
    }
}

struct CreateUserImportJobOutputResponseBody: Equatable {
    public let userImportJob: UserImportJobType?
}

extension CreateUserImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userImportJob = "UserImportJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userImportJobDecoded = try containerValues.decodeIfPresent(UserImportJobType.self, forKey: .userImportJob)
        userImportJob = userImportJobDecoded
    }
}

public struct CreateUserPoolClientInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserPoolClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolClientInput>
    public typealias MOutput = OperationOutput<CreateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolClientOutputError>
}

extension CreateUserPoolClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolClientInput(accessTokenValidity: \(String(describing: accessTokenValidity)), allowedOAuthFlows: \(String(describing: allowedOAuthFlows)), allowedOAuthFlowsUserPoolClient: \(String(describing: allowedOAuthFlowsUserPoolClient)), allowedOAuthScopes: \(String(describing: allowedOAuthScopes)), analyticsConfiguration: \(String(describing: analyticsConfiguration)), callbackURLs: \(String(describing: callbackURLs)), clientName: \(String(describing: clientName)), defaultRedirectURI: \(String(describing: defaultRedirectURI)), explicitAuthFlows: \(String(describing: explicitAuthFlows)), generateSecret: \(String(describing: generateSecret)), idTokenValidity: \(String(describing: idTokenValidity)), logoutURLs: \(String(describing: logoutURLs)), preventUserExistenceErrors: \(String(describing: preventUserExistenceErrors)), readAttributes: \(String(describing: readAttributes)), refreshTokenValidity: \(String(describing: refreshTokenValidity)), supportedIdentityProviders: \(String(describing: supportedIdentityProviders)), tokenValidityUnits: \(String(describing: tokenValidityUnits)), userPoolId: \(String(describing: userPoolId)), writeAttributes: \(String(describing: writeAttributes)))"}
}

extension CreateUserPoolClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessTokenValidity = "AccessTokenValidity"
        case allowedOAuthFlows = "AllowedOAuthFlows"
        case allowedOAuthFlowsUserPoolClient = "AllowedOAuthFlowsUserPoolClient"
        case allowedOAuthScopes = "AllowedOAuthScopes"
        case analyticsConfiguration = "AnalyticsConfiguration"
        case callbackURLs = "CallbackURLs"
        case clientName = "ClientName"
        case defaultRedirectURI = "DefaultRedirectURI"
        case explicitAuthFlows = "ExplicitAuthFlows"
        case generateSecret = "GenerateSecret"
        case idTokenValidity = "IdTokenValidity"
        case logoutURLs = "LogoutURLs"
        case preventUserExistenceErrors = "PreventUserExistenceErrors"
        case readAttributes = "ReadAttributes"
        case refreshTokenValidity = "RefreshTokenValidity"
        case supportedIdentityProviders = "SupportedIdentityProviders"
        case tokenValidityUnits = "TokenValidityUnits"
        case userPoolId = "UserPoolId"
        case writeAttributes = "WriteAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTokenValidity = accessTokenValidity {
            try encodeContainer.encode(accessTokenValidity, forKey: .accessTokenValidity)
        }
        if let allowedOAuthFlows = allowedOAuthFlows {
            var allowedOAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthFlows)
            for oauthflowstype0 in allowedOAuthFlows {
                try allowedOAuthFlowsContainer.encode(oauthflowstype0.rawValue)
            }
        }
        if allowedOAuthFlowsUserPoolClient != false {
            try encodeContainer.encode(allowedOAuthFlowsUserPoolClient, forKey: .allowedOAuthFlowsUserPoolClient)
        }
        if let allowedOAuthScopes = allowedOAuthScopes {
            var allowedOAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthScopes)
            for scopelisttype0 in allowedOAuthScopes {
                try allowedOAuthScopesContainer.encode(scopelisttype0)
            }
        }
        if let analyticsConfiguration = analyticsConfiguration {
            try encodeContainer.encode(analyticsConfiguration, forKey: .analyticsConfiguration)
        }
        if let callbackURLs = callbackURLs {
            var callbackURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callbackURLs)
            for callbackurlslisttype0 in callbackURLs {
                try callbackURLsContainer.encode(callbackurlslisttype0)
            }
        }
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let defaultRedirectURI = defaultRedirectURI {
            try encodeContainer.encode(defaultRedirectURI, forKey: .defaultRedirectURI)
        }
        if let explicitAuthFlows = explicitAuthFlows {
            var explicitAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .explicitAuthFlows)
            for explicitauthflowslisttype0 in explicitAuthFlows {
                try explicitAuthFlowsContainer.encode(explicitauthflowslisttype0.rawValue)
            }
        }
        if generateSecret != false {
            try encodeContainer.encode(generateSecret, forKey: .generateSecret)
        }
        if let idTokenValidity = idTokenValidity {
            try encodeContainer.encode(idTokenValidity, forKey: .idTokenValidity)
        }
        if let logoutURLs = logoutURLs {
            var logoutURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logoutURLs)
            for logouturlslisttype0 in logoutURLs {
                try logoutURLsContainer.encode(logouturlslisttype0)
            }
        }
        if let preventUserExistenceErrors = preventUserExistenceErrors {
            try encodeContainer.encode(preventUserExistenceErrors.rawValue, forKey: .preventUserExistenceErrors)
        }
        if let readAttributes = readAttributes {
            var readAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readAttributes)
            for clientpermissionlisttype0 in readAttributes {
                try readAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
        if refreshTokenValidity != 0 {
            try encodeContainer.encode(refreshTokenValidity, forKey: .refreshTokenValidity)
        }
        if let supportedIdentityProviders = supportedIdentityProviders {
            var supportedIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedIdentityProviders)
            for supportedidentityproviderslisttype0 in supportedIdentityProviders {
                try supportedIdentityProvidersContainer.encode(supportedidentityproviderslisttype0)
            }
        }
        if let tokenValidityUnits = tokenValidityUnits {
            try encodeContainer.encode(tokenValidityUnits, forKey: .tokenValidityUnits)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let writeAttributes = writeAttributes {
            var writeAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .writeAttributes)
            for clientpermissionlisttype0 in writeAttributes {
                try writeAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
    }
}

public struct CreateUserPoolClientInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserPoolClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolClientInput>
    public typealias MOutput = OperationOutput<CreateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolClientOutputError>
}

public struct CreateUserPoolClientInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserPoolClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolClientInput>
    public typealias MOutput = OperationOutput<CreateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolClientOutputError>
}

/// <p>Represents the request to create a user pool client.</p>
public struct CreateUserPoolClientInput: Equatable {
    /// <p>The time limit, between 5 minutes and 1 day, after which the access token is no longer
    ///             valid and cannot be used. This value will be overridden if you have entered a value in
    ///             TokenValidityUnits.</p>
    public let accessTokenValidity: Int?
    /// <p>The allowed OAuth flows.</p>
    ///         <p>Set to <code>code</code> to initiate a code grant flow, which provides an
    ///             authorization code as the response. This code can be exchanged for access tokens with
    ///             the token endpoint.</p>
    ///         <p>Set to <code>implicit</code> to specify that the client should get the access token
    ///             (and, optionally, ID token, based on scopes) directly.</p>
    ///         <p>Set to <code>client_credentials</code> to specify that the client should get the
    ///             access token (and, optionally, ID token, based on scopes) from the token endpoint using
    ///             a combination of client and client_secret.</p>
    public let allowedOAuthFlows: [OAuthFlowType]?
    /// <p>Set to true if the client is allowed to follow the OAuth protocol when interacting
    ///             with Cognito user pools.</p>
    public let allowedOAuthFlowsUserPoolClient: Bool
    /// <p>The allowed OAuth scopes. Possible values provided by OAuth are: <code>phone</code>,
    ///                 <code>email</code>, <code>openid</code>, and <code>profile</code>. Possible values
    ///             provided by AWS are: <code>aws.cognito.signin.user.admin</code>. Custom scopes created
    ///             in Resource Servers are also supported.</p>
    public let allowedOAuthScopes: [String]?
    /// <p>The Amazon Pinpoint analytics configuration for collecting metrics for this user
    ///             pool.</p>
    ///         <note>
    ///             <p>In regions where Pinpoint is not available, Cognito User Pools only supports
    ///                 sending events to Amazon Pinpoint projects in us-east-1. In regions where Pinpoint
    ///                 is available, Cognito User Pools will support sending events to Amazon Pinpoint
    ///                 projects within that same region. </p>
    ///         </note>
    public let analyticsConfiguration: AnalyticsConfigurationType?
    /// <p>A list of allowed redirect (callback) URLs for the identity providers.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let callbackURLs: [String]?
    /// <p>The client name for the user pool client you would like to create.</p>
    public let clientName: String?
    /// <p>The default redirect URI. Must be in the <code>CallbackURLs</code> list.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let defaultRedirectURI: String?
    /// <p>The authentication flows that are supported by the user pool clients. Flow names
    ///             without the <code>ALLOW_</code> prefix are deprecated in favor of new names with the
    ///                 <code>ALLOW_</code> prefix. Note that values with <code>ALLOW_</code> prefix cannot
    ///             be used along with values without <code>ALLOW_</code> prefix.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_ADMIN_USER_PASSWORD_AUTH</code>: Enable admin based user password
    ///                     authentication flow <code>ADMIN_USER_PASSWORD_AUTH</code>. This setting replaces
    ///                     the <code>ADMIN_NO_SRP_AUTH</code> setting. With this authentication flow,
    ///                     Cognito receives the password in the request instead of using the SRP (Secure
    ///                     Remote Password protocol) protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_CUSTOM_AUTH</code>: Enable Lambda trigger based
    ///                     authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_PASSWORD_AUTH</code>: Enable user password-based
    ///                     authentication. In this flow, Cognito receives the password in the request
    ///                     instead of using the SRP protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_SRP_AUTH</code>: Enable SRP based authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_REFRESH_TOKEN_AUTH</code>: Enable authflow to refresh
    ///                     tokens.</p>
    ///             </li>
    ///          </ul>
    public let explicitAuthFlows: [ExplicitAuthFlowsType]?
    /// <p>Boolean to specify whether you want to generate a secret for the user pool client
    ///             being created.</p>
    public let generateSecret: Bool
    /// <p>The time limit, between 5 minutes and 1 day, after which the ID token is no longer
    ///             valid and cannot be used. This value will be overridden if you have entered a value in
    ///             TokenValidityUnits.</p>
    public let idTokenValidity: Int?
    /// <p>A list of allowed logout URLs for the identity providers.</p>
    public let logoutURLs: [String]?
    /// <p>Use this setting to choose which errors and responses are returned by Cognito APIs
    ///             during authentication, account confirmation, and password recovery when the user does
    ///             not exist in the user pool. When set to <code>ENABLED</code> and the user does not
    ///             exist, authentication returns an error indicating either the username or password was
    ///             incorrect, and account confirmation and password recovery return a response indicating a
    ///             code was sent to a simulated destination. When set to <code>LEGACY</code>, those APIs
    ///             will return a <code>UserNotFoundException</code> exception if the user does not exist in
    ///             the user pool.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ENABLED</code> - This prevents user existence-related errors.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LEGACY</code> - This represents the old behavior of Cognito where user
    ///                     existence related errors are not prevented.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <note>
    ///             <p>After February 15th 2020, the value of <code>PreventUserExistenceErrors</code>
    ///                 will default to <code>ENABLED</code> for newly created user pool clients if no value
    ///                 is provided.</p>
    ///         </note>
    public let preventUserExistenceErrors: PreventUserExistenceErrorTypes?
    /// <p>The read attributes.</p>
    public let readAttributes: [String]?
    /// <p>The time limit, in days, after which the refresh token is no longer valid and cannot
    ///             be used.</p>
    public let refreshTokenValidity: Int
    /// <p>A list of provider names for the identity providers that are supported on this client.
    ///             The following are supported: <code>COGNITO</code>, <code>Facebook</code>,
    ///                 <code>Google</code> and <code>LoginWithAmazon</code>.</p>
    public let supportedIdentityProviders: [String]?
    /// <p>The units in which the validity times are represented in. Default for RefreshToken is
    ///             days, and default for ID and access tokens are hours.</p>
    public let tokenValidityUnits: TokenValidityUnitsType?
    /// <p>The user pool ID for the user pool where you want to create a user pool client.</p>
    public let userPoolId: String?
    /// <p>The user pool attributes that the app client can write to.</p>
    ///         <p>If your app client allows users to sign in through an identity provider, this array
    ///             must include all attributes that are mapped to identity provider attributes. Amazon
    ///             Cognito updates mapped attributes when users sign in to your application through an
    ///             identity provider. If your app client lacks write access to a mapped attribute, Amazon
    ///             Cognito throws an error when it attempts to update the attribute. For more information,
    ///             see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-specifying-attribute-mapping.html">Specifying Identity Provider Attribute Mappings for Your User
    ///                 Pool</a>.</p>
    public let writeAttributes: [String]?

    public init (
        accessTokenValidity: Int? = nil,
        allowedOAuthFlows: [OAuthFlowType]? = nil,
        allowedOAuthFlowsUserPoolClient: Bool = false,
        allowedOAuthScopes: [String]? = nil,
        analyticsConfiguration: AnalyticsConfigurationType? = nil,
        callbackURLs: [String]? = nil,
        clientName: String? = nil,
        defaultRedirectURI: String? = nil,
        explicitAuthFlows: [ExplicitAuthFlowsType]? = nil,
        generateSecret: Bool = false,
        idTokenValidity: Int? = nil,
        logoutURLs: [String]? = nil,
        preventUserExistenceErrors: PreventUserExistenceErrorTypes? = nil,
        readAttributes: [String]? = nil,
        refreshTokenValidity: Int = 0,
        supportedIdentityProviders: [String]? = nil,
        tokenValidityUnits: TokenValidityUnitsType? = nil,
        userPoolId: String? = nil,
        writeAttributes: [String]? = nil
    )
    {
        self.accessTokenValidity = accessTokenValidity
        self.allowedOAuthFlows = allowedOAuthFlows
        self.allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClient
        self.allowedOAuthScopes = allowedOAuthScopes
        self.analyticsConfiguration = analyticsConfiguration
        self.callbackURLs = callbackURLs
        self.clientName = clientName
        self.defaultRedirectURI = defaultRedirectURI
        self.explicitAuthFlows = explicitAuthFlows
        self.generateSecret = generateSecret
        self.idTokenValidity = idTokenValidity
        self.logoutURLs = logoutURLs
        self.preventUserExistenceErrors = preventUserExistenceErrors
        self.readAttributes = readAttributes
        self.refreshTokenValidity = refreshTokenValidity
        self.supportedIdentityProviders = supportedIdentityProviders
        self.tokenValidityUnits = tokenValidityUnits
        self.userPoolId = userPoolId
        self.writeAttributes = writeAttributes
    }
}

struct CreateUserPoolClientInputBody: Equatable {
    public let userPoolId: String?
    public let clientName: String?
    public let generateSecret: Bool
    public let refreshTokenValidity: Int
    public let accessTokenValidity: Int?
    public let idTokenValidity: Int?
    public let tokenValidityUnits: TokenValidityUnitsType?
    public let readAttributes: [String]?
    public let writeAttributes: [String]?
    public let explicitAuthFlows: [ExplicitAuthFlowsType]?
    public let supportedIdentityProviders: [String]?
    public let callbackURLs: [String]?
    public let logoutURLs: [String]?
    public let defaultRedirectURI: String?
    public let allowedOAuthFlows: [OAuthFlowType]?
    public let allowedOAuthScopes: [String]?
    public let allowedOAuthFlowsUserPoolClient: Bool
    public let analyticsConfiguration: AnalyticsConfigurationType?
    public let preventUserExistenceErrors: PreventUserExistenceErrorTypes?
}

extension CreateUserPoolClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessTokenValidity = "AccessTokenValidity"
        case allowedOAuthFlows = "AllowedOAuthFlows"
        case allowedOAuthFlowsUserPoolClient = "AllowedOAuthFlowsUserPoolClient"
        case allowedOAuthScopes = "AllowedOAuthScopes"
        case analyticsConfiguration = "AnalyticsConfiguration"
        case callbackURLs = "CallbackURLs"
        case clientName = "ClientName"
        case defaultRedirectURI = "DefaultRedirectURI"
        case explicitAuthFlows = "ExplicitAuthFlows"
        case generateSecret = "GenerateSecret"
        case idTokenValidity = "IdTokenValidity"
        case logoutURLs = "LogoutURLs"
        case preventUserExistenceErrors = "PreventUserExistenceErrors"
        case readAttributes = "ReadAttributes"
        case refreshTokenValidity = "RefreshTokenValidity"
        case supportedIdentityProviders = "SupportedIdentityProviders"
        case tokenValidityUnits = "TokenValidityUnits"
        case userPoolId = "UserPoolId"
        case writeAttributes = "WriteAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let generateSecretDecoded = try containerValues.decode(Bool.self, forKey: .generateSecret)
        generateSecret = generateSecretDecoded
        let refreshTokenValidityDecoded = try containerValues.decode(Int.self, forKey: .refreshTokenValidity)
        refreshTokenValidity = refreshTokenValidityDecoded
        let accessTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .accessTokenValidity)
        accessTokenValidity = accessTokenValidityDecoded
        let idTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idTokenValidity)
        idTokenValidity = idTokenValidityDecoded
        let tokenValidityUnitsDecoded = try containerValues.decodeIfPresent(TokenValidityUnitsType.self, forKey: .tokenValidityUnits)
        tokenValidityUnits = tokenValidityUnitsDecoded
        let readAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readAttributes)
        var readAttributesDecoded0:[String]? = nil
        if let readAttributesContainer = readAttributesContainer {
            readAttributesDecoded0 = [String]()
            for string0 in readAttributesContainer {
                if let string0 = string0 {
                    readAttributesDecoded0?.append(string0)
                }
            }
        }
        readAttributes = readAttributesDecoded0
        let writeAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .writeAttributes)
        var writeAttributesDecoded0:[String]? = nil
        if let writeAttributesContainer = writeAttributesContainer {
            writeAttributesDecoded0 = [String]()
            for string0 in writeAttributesContainer {
                if let string0 = string0 {
                    writeAttributesDecoded0?.append(string0)
                }
            }
        }
        writeAttributes = writeAttributesDecoded0
        let explicitAuthFlowsContainer = try containerValues.decodeIfPresent([ExplicitAuthFlowsType?].self, forKey: .explicitAuthFlows)
        var explicitAuthFlowsDecoded0:[ExplicitAuthFlowsType]? = nil
        if let explicitAuthFlowsContainer = explicitAuthFlowsContainer {
            explicitAuthFlowsDecoded0 = [ExplicitAuthFlowsType]()
            for string0 in explicitAuthFlowsContainer {
                if let string0 = string0 {
                    explicitAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        explicitAuthFlows = explicitAuthFlowsDecoded0
        let supportedIdentityProvidersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedIdentityProviders)
        var supportedIdentityProvidersDecoded0:[String]? = nil
        if let supportedIdentityProvidersContainer = supportedIdentityProvidersContainer {
            supportedIdentityProvidersDecoded0 = [String]()
            for string0 in supportedIdentityProvidersContainer {
                if let string0 = string0 {
                    supportedIdentityProvidersDecoded0?.append(string0)
                }
            }
        }
        supportedIdentityProviders = supportedIdentityProvidersDecoded0
        let callbackURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .callbackURLs)
        var callbackURLsDecoded0:[String]? = nil
        if let callbackURLsContainer = callbackURLsContainer {
            callbackURLsDecoded0 = [String]()
            for string0 in callbackURLsContainer {
                if let string0 = string0 {
                    callbackURLsDecoded0?.append(string0)
                }
            }
        }
        callbackURLs = callbackURLsDecoded0
        let logoutURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logoutURLs)
        var logoutURLsDecoded0:[String]? = nil
        if let logoutURLsContainer = logoutURLsContainer {
            logoutURLsDecoded0 = [String]()
            for string0 in logoutURLsContainer {
                if let string0 = string0 {
                    logoutURLsDecoded0?.append(string0)
                }
            }
        }
        logoutURLs = logoutURLsDecoded0
        let defaultRedirectURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultRedirectURI)
        defaultRedirectURI = defaultRedirectURIDecoded
        let allowedOAuthFlowsContainer = try containerValues.decodeIfPresent([OAuthFlowType?].self, forKey: .allowedOAuthFlows)
        var allowedOAuthFlowsDecoded0:[OAuthFlowType]? = nil
        if let allowedOAuthFlowsContainer = allowedOAuthFlowsContainer {
            allowedOAuthFlowsDecoded0 = [OAuthFlowType]()
            for string0 in allowedOAuthFlowsContainer {
                if let string0 = string0 {
                    allowedOAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthFlows = allowedOAuthFlowsDecoded0
        let allowedOAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedOAuthScopes)
        var allowedOAuthScopesDecoded0:[String]? = nil
        if let allowedOAuthScopesContainer = allowedOAuthScopesContainer {
            allowedOAuthScopesDecoded0 = [String]()
            for string0 in allowedOAuthScopesContainer {
                if let string0 = string0 {
                    allowedOAuthScopesDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthScopes = allowedOAuthScopesDecoded0
        let allowedOAuthFlowsUserPoolClientDecoded = try containerValues.decode(Bool.self, forKey: .allowedOAuthFlowsUserPoolClient)
        allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClientDecoded
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(AnalyticsConfigurationType.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
        let preventUserExistenceErrorsDecoded = try containerValues.decodeIfPresent(PreventUserExistenceErrorTypes.self, forKey: .preventUserExistenceErrors)
        preventUserExistenceErrors = preventUserExistenceErrorsDecoded
    }
}

extension CreateUserPoolClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserPoolClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOAuthFlowException" : self = .invalidOAuthFlowException(try InvalidOAuthFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScopeDoesNotExistException" : self = .scopeDoesNotExistException(try ScopeDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserPoolClientOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOAuthFlowException(InvalidOAuthFlowException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case scopeDoesNotExistException(ScopeDoesNotExistException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserPoolClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolClientOutputResponse(userPoolClient: \(String(describing: userPoolClient)))"}
}

extension CreateUserPoolClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserPoolClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userPoolClient = output.userPoolClient
        } else {
            self.userPoolClient = nil
        }
    }
}

/// <p>Represents the response from the server to create a user pool client.</p>
public struct CreateUserPoolClientOutputResponse: Equatable {
    /// <p>The user pool client that was just created.</p>
    public let userPoolClient: UserPoolClientType?

    public init (
        userPoolClient: UserPoolClientType? = nil
    )
    {
        self.userPoolClient = userPoolClient
    }
}

struct CreateUserPoolClientOutputResponseBody: Equatable {
    public let userPoolClient: UserPoolClientType?
}

extension CreateUserPoolClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolClient = "UserPoolClient"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolClientDecoded = try containerValues.decodeIfPresent(UserPoolClientType.self, forKey: .userPoolClient)
        userPoolClient = userPoolClientDecoded
    }
}

public struct CreateUserPoolDomainInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserPoolDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<CreateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolDomainOutputError>
}

extension CreateUserPoolDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolDomainInput(customDomainConfig: \(String(describing: customDomainConfig)), domain: \(String(describing: domain)), userPoolId: \(String(describing: userPoolId)))"}
}

extension CreateUserPoolDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customDomainConfig = "CustomDomainConfig"
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainConfig = customDomainConfig {
            try encodeContainer.encode(customDomainConfig, forKey: .customDomainConfig)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct CreateUserPoolDomainInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserPoolDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<CreateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolDomainOutputError>
}

public struct CreateUserPoolDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserPoolDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<CreateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolDomainOutputError>
}

public struct CreateUserPoolDomainInput: Equatable {
    /// <p>The configuration for a custom domain that hosts the sign-up and sign-in webpages for
    ///             your application.</p>
    ///         <p>Provide this parameter only if you want to use a custom domain for your user pool.
    ///             Otherwise, you can exclude this parameter and use the Amazon Cognito hosted domain
    ///             instead.</p>
    ///         <p>For more information about the hosted domain and custom domains, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-assign-domain.html">Configuring a User Pool Domain</a>.</p>
    public let customDomainConfig: CustomDomainConfigType?
    /// <p>The domain string.</p>
    public let domain: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        customDomainConfig: CustomDomainConfigType? = nil,
        domain: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.customDomainConfig = customDomainConfig
        self.domain = domain
        self.userPoolId = userPoolId
    }
}

struct CreateUserPoolDomainInputBody: Equatable {
    public let domain: String?
    public let userPoolId: String?
    public let customDomainConfig: CustomDomainConfigType?
}

extension CreateUserPoolDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDomainConfig = "CustomDomainConfig"
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let customDomainConfigDecoded = try containerValues.decodeIfPresent(CustomDomainConfigType.self, forKey: .customDomainConfig)
        customDomainConfig = customDomainConfigDecoded
    }
}

extension CreateUserPoolDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserPoolDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserPoolDomainOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserPoolDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolDomainOutputResponse(cloudFrontDomain: \(String(describing: cloudFrontDomain)))"}
}

extension CreateUserPoolDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserPoolDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudFrontDomain = output.cloudFrontDomain
        } else {
            self.cloudFrontDomain = nil
        }
    }
}

public struct CreateUserPoolDomainOutputResponse: Equatable {
    /// <p>The Amazon CloudFront endpoint that you use as the target of the alias that you set up
    ///             with your Domain Name Service (DNS) provider.</p>
    public let cloudFrontDomain: String?

    public init (
        cloudFrontDomain: String? = nil
    )
    {
        self.cloudFrontDomain = cloudFrontDomain
    }
}

struct CreateUserPoolDomainOutputResponseBody: Equatable {
    public let cloudFrontDomain: String?
}

extension CreateUserPoolDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontDomain = "CloudFrontDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudFrontDomain)
        cloudFrontDomain = cloudFrontDomainDecoded
    }
}

public struct CreateUserPoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolInput>
    public typealias MOutput = OperationOutput<CreateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolOutputError>
}

extension CreateUserPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolInput(accountRecoverySetting: \(String(describing: accountRecoverySetting)), adminCreateUserConfig: \(String(describing: adminCreateUserConfig)), aliasAttributes: \(String(describing: aliasAttributes)), autoVerifiedAttributes: \(String(describing: autoVerifiedAttributes)), deviceConfiguration: \(String(describing: deviceConfiguration)), emailConfiguration: \(String(describing: emailConfiguration)), emailVerificationMessage: \(String(describing: emailVerificationMessage)), emailVerificationSubject: \(String(describing: emailVerificationSubject)), lambdaConfig: \(String(describing: lambdaConfig)), mfaConfiguration: \(String(describing: mfaConfiguration)), policies: \(String(describing: policies)), poolName: \(String(describing: poolName)), schema: \(String(describing: schema)), smsAuthenticationMessage: \(String(describing: smsAuthenticationMessage)), smsConfiguration: \(String(describing: smsConfiguration)), smsVerificationMessage: \(String(describing: smsVerificationMessage)), userPoolAddOns: \(String(describing: userPoolAddOns)), userPoolTags: \(String(describing: userPoolTags)), usernameAttributes: \(String(describing: usernameAttributes)), usernameConfiguration: \(String(describing: usernameConfiguration)), verificationMessageTemplate: \(String(describing: verificationMessageTemplate)))"}
}

extension CreateUserPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountRecoverySetting = "AccountRecoverySetting"
        case adminCreateUserConfig = "AdminCreateUserConfig"
        case aliasAttributes = "AliasAttributes"
        case autoVerifiedAttributes = "AutoVerifiedAttributes"
        case deviceConfiguration = "DeviceConfiguration"
        case emailConfiguration = "EmailConfiguration"
        case emailVerificationMessage = "EmailVerificationMessage"
        case emailVerificationSubject = "EmailVerificationSubject"
        case lambdaConfig = "LambdaConfig"
        case mfaConfiguration = "MfaConfiguration"
        case policies = "Policies"
        case poolName = "PoolName"
        case schema = "Schema"
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
        case smsVerificationMessage = "SmsVerificationMessage"
        case userPoolAddOns = "UserPoolAddOns"
        case userPoolTags = "UserPoolTags"
        case usernameAttributes = "UsernameAttributes"
        case usernameConfiguration = "UsernameConfiguration"
        case verificationMessageTemplate = "VerificationMessageTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountRecoverySetting = accountRecoverySetting {
            try encodeContainer.encode(accountRecoverySetting, forKey: .accountRecoverySetting)
        }
        if let adminCreateUserConfig = adminCreateUserConfig {
            try encodeContainer.encode(adminCreateUserConfig, forKey: .adminCreateUserConfig)
        }
        if let aliasAttributes = aliasAttributes {
            var aliasAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasAttributes)
            for aliasattributeslisttype0 in aliasAttributes {
                try aliasAttributesContainer.encode(aliasattributeslisttype0.rawValue)
            }
        }
        if let autoVerifiedAttributes = autoVerifiedAttributes {
            var autoVerifiedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoVerifiedAttributes)
            for verifiedattributeslisttype0 in autoVerifiedAttributes {
                try autoVerifiedAttributesContainer.encode(verifiedattributeslisttype0.rawValue)
            }
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let emailConfiguration = emailConfiguration {
            try encodeContainer.encode(emailConfiguration, forKey: .emailConfiguration)
        }
        if let emailVerificationMessage = emailVerificationMessage {
            try encodeContainer.encode(emailVerificationMessage, forKey: .emailVerificationMessage)
        }
        if let emailVerificationSubject = emailVerificationSubject {
            try encodeContainer.encode(emailVerificationSubject, forKey: .emailVerificationSubject)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let mfaConfiguration = mfaConfiguration {
            try encodeContainer.encode(mfaConfiguration.rawValue, forKey: .mfaConfiguration)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let poolName = poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for schemaattributeslisttype0 in schema {
                try schemaContainer.encode(schemaattributeslisttype0)
            }
        }
        if let smsAuthenticationMessage = smsAuthenticationMessage {
            try encodeContainer.encode(smsAuthenticationMessage, forKey: .smsAuthenticationMessage)
        }
        if let smsConfiguration = smsConfiguration {
            try encodeContainer.encode(smsConfiguration, forKey: .smsConfiguration)
        }
        if let smsVerificationMessage = smsVerificationMessage {
            try encodeContainer.encode(smsVerificationMessage, forKey: .smsVerificationMessage)
        }
        if let userPoolAddOns = userPoolAddOns {
            try encodeContainer.encode(userPoolAddOns, forKey: .userPoolAddOns)
        }
        if let userPoolTags = userPoolTags {
            var userPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userPoolTags)
            for (dictKey0, userpooltagstype0) in userPoolTags {
                try userPoolTagsContainer.encode(userpooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let usernameAttributes = usernameAttributes {
            var usernameAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernameAttributes)
            for usernameattributeslisttype0 in usernameAttributes {
                try usernameAttributesContainer.encode(usernameattributeslisttype0.rawValue)
            }
        }
        if let usernameConfiguration = usernameConfiguration {
            try encodeContainer.encode(usernameConfiguration, forKey: .usernameConfiguration)
        }
        if let verificationMessageTemplate = verificationMessageTemplate {
            try encodeContainer.encode(verificationMessageTemplate, forKey: .verificationMessageTemplate)
        }
    }
}

public struct CreateUserPoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolInput>
    public typealias MOutput = OperationOutput<CreateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolOutputError>
}

public struct CreateUserPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserPoolInput>
    public typealias MOutput = OperationOutput<CreateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserPoolOutputError>
}

/// <p>Represents the request to create a user pool.</p>
public struct CreateUserPoolInput: Equatable {
    /// <p>Use this setting to define which verified available method a user can use to recover
    ///             their password when they call <code>ForgotPassword</code>. It allows you to define a
    ///             preferred method when a user has more than one method available. With this setting, SMS
    ///             does not qualify for a valid password recovery mechanism if the user also has SMS MFA
    ///             enabled. In the absence of this setting, Cognito uses the legacy behavior to determine
    ///             the recovery method where SMS is preferred over email.</p>
    public let accountRecoverySetting: AccountRecoverySettingType?
    /// <p>The configuration for <code>AdminCreateUser</code> requests.</p>
    public let adminCreateUserConfig: AdminCreateUserConfigType?
    /// <p>Attributes supported as an alias for this user pool. Possible values: <b>phone_number</b>, <b>email</b>, or
    ///                 <b>preferred_username</b>.</p>
    public let aliasAttributes: [AliasAttributeType]?
    /// <p>The attributes to be auto-verified. Possible values: <b>email</b>, <b>phone_number</b>.</p>
    public let autoVerifiedAttributes: [VerifiedAttributeType]?
    /// <p>The device configuration.</p>
    public let deviceConfiguration: DeviceConfigurationType?
    /// <p>The email configuration.</p>
    public let emailConfiguration: EmailConfigurationType?
    /// <p>A string representing the email verification message. EmailVerificationMessage is
    ///             allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount">EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailVerificationMessage: String?
    /// <p>A string representing the email verification subject. EmailVerificationSubject is
    ///             allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount">EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailVerificationSubject: String?
    /// <p>The Lambda trigger configuration information for the new user pool.</p>
    ///         <note>
    ///             <p>In a push model, event sources (such as Amazon S3 and custom applications) need
    ///                 permission to invoke a function. So you will need to make an extra call to add
    ///                 permission for these event sources to invoke your Lambda function.</p>
    ///             <p></p>
    ///             <p>For more information on using the Lambda API to add permission, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/API_AddPermission.html">
    ///                     AddPermission </a>. </p>
    ///             <p>For adding permission using the AWS CLI, see <a href="https://docs.aws.amazon.com/cli/latest/reference/lambda/add-permission.html"> add-permission
    ///                 </a>.</p>
    ///         </note>
    public let lambdaConfig: LambdaConfigType?
    /// <p>Specifies MFA configuration details.</p>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>The policies associated with the new user pool.</p>
    public let policies: UserPoolPolicyType?
    /// <p>A string used to name the user pool.</p>
    public let poolName: String?
    /// <p>An array of schema attributes for the new user pool. These attributes can be standard
    ///             or custom attributes.</p>
    public let schema: [SchemaAttributeType]?
    /// <p>A string representing the SMS authentication message.</p>
    public let smsAuthenticationMessage: String?
    /// <p>The SMS configuration.</p>
    public let smsConfiguration: SmsConfigurationType?
    /// <p>A string representing the SMS verification message.</p>
    public let smsVerificationMessage: String?
    /// <p>Used to enable advanced security risk detection. Set the key
    ///                 <code>AdvancedSecurityMode</code> to the value "AUDIT".</p>
    public let userPoolAddOns: UserPoolAddOnsType?
    /// <p>The tag keys and values to assign to the user pool. A tag is a label that you can use
    ///             to categorize and manage user pools in different ways, such as by purpose, owner,
    ///             environment, or other criteria.</p>
    public let userPoolTags: [String:String]?
    /// <p>Specifies whether email addresses or phone numbers can be specified as usernames when
    ///             a user signs up.</p>
    public let usernameAttributes: [UsernameAttributeType]?
    /// <p>You can choose to set case sensitivity on the username input for the selected sign-in
    ///             option. For example, when this is set to <code>False</code>, users will be able to sign
    ///             in using either "username" or "Username". This configuration is immutable once it has
    ///             been set. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UsernameConfigurationType.html">UsernameConfigurationType</a>.</p>
    public let usernameConfiguration: UsernameConfigurationType?
    /// <p>The template for the verification message that the user sees when the app requests
    ///             permission to access the user's information.</p>
    public let verificationMessageTemplate: VerificationMessageTemplateType?

    public init (
        accountRecoverySetting: AccountRecoverySettingType? = nil,
        adminCreateUserConfig: AdminCreateUserConfigType? = nil,
        aliasAttributes: [AliasAttributeType]? = nil,
        autoVerifiedAttributes: [VerifiedAttributeType]? = nil,
        deviceConfiguration: DeviceConfigurationType? = nil,
        emailConfiguration: EmailConfigurationType? = nil,
        emailVerificationMessage: String? = nil,
        emailVerificationSubject: String? = nil,
        lambdaConfig: LambdaConfigType? = nil,
        mfaConfiguration: UserPoolMfaType? = nil,
        policies: UserPoolPolicyType? = nil,
        poolName: String? = nil,
        schema: [SchemaAttributeType]? = nil,
        smsAuthenticationMessage: String? = nil,
        smsConfiguration: SmsConfigurationType? = nil,
        smsVerificationMessage: String? = nil,
        userPoolAddOns: UserPoolAddOnsType? = nil,
        userPoolTags: [String:String]? = nil,
        usernameAttributes: [UsernameAttributeType]? = nil,
        usernameConfiguration: UsernameConfigurationType? = nil,
        verificationMessageTemplate: VerificationMessageTemplateType? = nil
    )
    {
        self.accountRecoverySetting = accountRecoverySetting
        self.adminCreateUserConfig = adminCreateUserConfig
        self.aliasAttributes = aliasAttributes
        self.autoVerifiedAttributes = autoVerifiedAttributes
        self.deviceConfiguration = deviceConfiguration
        self.emailConfiguration = emailConfiguration
        self.emailVerificationMessage = emailVerificationMessage
        self.emailVerificationSubject = emailVerificationSubject
        self.lambdaConfig = lambdaConfig
        self.mfaConfiguration = mfaConfiguration
        self.policies = policies
        self.poolName = poolName
        self.schema = schema
        self.smsAuthenticationMessage = smsAuthenticationMessage
        self.smsConfiguration = smsConfiguration
        self.smsVerificationMessage = smsVerificationMessage
        self.userPoolAddOns = userPoolAddOns
        self.userPoolTags = userPoolTags
        self.usernameAttributes = usernameAttributes
        self.usernameConfiguration = usernameConfiguration
        self.verificationMessageTemplate = verificationMessageTemplate
    }
}

struct CreateUserPoolInputBody: Equatable {
    public let poolName: String?
    public let policies: UserPoolPolicyType?
    public let lambdaConfig: LambdaConfigType?
    public let autoVerifiedAttributes: [VerifiedAttributeType]?
    public let aliasAttributes: [AliasAttributeType]?
    public let usernameAttributes: [UsernameAttributeType]?
    public let smsVerificationMessage: String?
    public let emailVerificationMessage: String?
    public let emailVerificationSubject: String?
    public let verificationMessageTemplate: VerificationMessageTemplateType?
    public let smsAuthenticationMessage: String?
    public let mfaConfiguration: UserPoolMfaType?
    public let deviceConfiguration: DeviceConfigurationType?
    public let emailConfiguration: EmailConfigurationType?
    public let smsConfiguration: SmsConfigurationType?
    public let userPoolTags: [String:String]?
    public let adminCreateUserConfig: AdminCreateUserConfigType?
    public let schema: [SchemaAttributeType]?
    public let userPoolAddOns: UserPoolAddOnsType?
    public let usernameConfiguration: UsernameConfigurationType?
    public let accountRecoverySetting: AccountRecoverySettingType?
}

extension CreateUserPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountRecoverySetting = "AccountRecoverySetting"
        case adminCreateUserConfig = "AdminCreateUserConfig"
        case aliasAttributes = "AliasAttributes"
        case autoVerifiedAttributes = "AutoVerifiedAttributes"
        case deviceConfiguration = "DeviceConfiguration"
        case emailConfiguration = "EmailConfiguration"
        case emailVerificationMessage = "EmailVerificationMessage"
        case emailVerificationSubject = "EmailVerificationSubject"
        case lambdaConfig = "LambdaConfig"
        case mfaConfiguration = "MfaConfiguration"
        case policies = "Policies"
        case poolName = "PoolName"
        case schema = "Schema"
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
        case smsVerificationMessage = "SmsVerificationMessage"
        case userPoolAddOns = "UserPoolAddOns"
        case userPoolTags = "UserPoolTags"
        case usernameAttributes = "UsernameAttributes"
        case usernameConfiguration = "UsernameConfiguration"
        case verificationMessageTemplate = "VerificationMessageTemplate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(UserPoolPolicyType.self, forKey: .policies)
        policies = policiesDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaConfigType.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let autoVerifiedAttributesContainer = try containerValues.decodeIfPresent([VerifiedAttributeType?].self, forKey: .autoVerifiedAttributes)
        var autoVerifiedAttributesDecoded0:[VerifiedAttributeType]? = nil
        if let autoVerifiedAttributesContainer = autoVerifiedAttributesContainer {
            autoVerifiedAttributesDecoded0 = [VerifiedAttributeType]()
            for string0 in autoVerifiedAttributesContainer {
                if let string0 = string0 {
                    autoVerifiedAttributesDecoded0?.append(string0)
                }
            }
        }
        autoVerifiedAttributes = autoVerifiedAttributesDecoded0
        let aliasAttributesContainer = try containerValues.decodeIfPresent([AliasAttributeType?].self, forKey: .aliasAttributes)
        var aliasAttributesDecoded0:[AliasAttributeType]? = nil
        if let aliasAttributesContainer = aliasAttributesContainer {
            aliasAttributesDecoded0 = [AliasAttributeType]()
            for string0 in aliasAttributesContainer {
                if let string0 = string0 {
                    aliasAttributesDecoded0?.append(string0)
                }
            }
        }
        aliasAttributes = aliasAttributesDecoded0
        let usernameAttributesContainer = try containerValues.decodeIfPresent([UsernameAttributeType?].self, forKey: .usernameAttributes)
        var usernameAttributesDecoded0:[UsernameAttributeType]? = nil
        if let usernameAttributesContainer = usernameAttributesContainer {
            usernameAttributesDecoded0 = [UsernameAttributeType]()
            for string0 in usernameAttributesContainer {
                if let string0 = string0 {
                    usernameAttributesDecoded0?.append(string0)
                }
            }
        }
        usernameAttributes = usernameAttributesDecoded0
        let smsVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsVerificationMessage)
        smsVerificationMessage = smsVerificationMessageDecoded
        let emailVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationMessage)
        emailVerificationMessage = emailVerificationMessageDecoded
        let emailVerificationSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationSubject)
        emailVerificationSubject = emailVerificationSubjectDecoded
        let verificationMessageTemplateDecoded = try containerValues.decodeIfPresent(VerificationMessageTemplateType.self, forKey: .verificationMessageTemplate)
        verificationMessageTemplate = verificationMessageTemplateDecoded
        let smsAuthenticationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsAuthenticationMessage)
        smsAuthenticationMessage = smsAuthenticationMessageDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceConfigurationType.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let emailConfigurationDecoded = try containerValues.decodeIfPresent(EmailConfigurationType.self, forKey: .emailConfiguration)
        emailConfiguration = emailConfigurationDecoded
        let smsConfigurationDecoded = try containerValues.decodeIfPresent(SmsConfigurationType.self, forKey: .smsConfiguration)
        smsConfiguration = smsConfigurationDecoded
        let userPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userPoolTags)
        var userPoolTagsDecoded0: [String:String]? = nil
        if let userPoolTagsContainer = userPoolTagsContainer {
            userPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in userPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    userPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        userPoolTags = userPoolTagsDecoded0
        let adminCreateUserConfigDecoded = try containerValues.decodeIfPresent(AdminCreateUserConfigType.self, forKey: .adminCreateUserConfig)
        adminCreateUserConfig = adminCreateUserConfigDecoded
        let schemaContainer = try containerValues.decodeIfPresent([SchemaAttributeType?].self, forKey: .schema)
        var schemaDecoded0:[SchemaAttributeType]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [SchemaAttributeType]()
            for structure0 in schemaContainer {
                if let structure0 = structure0 {
                    schemaDecoded0?.append(structure0)
                }
            }
        }
        schema = schemaDecoded0
        let userPoolAddOnsDecoded = try containerValues.decodeIfPresent(UserPoolAddOnsType.self, forKey: .userPoolAddOns)
        userPoolAddOns = userPoolAddOnsDecoded
        let usernameConfigurationDecoded = try containerValues.decodeIfPresent(UsernameConfigurationType.self, forKey: .usernameConfiguration)
        usernameConfiguration = usernameConfigurationDecoded
        let accountRecoverySettingDecoded = try containerValues.decodeIfPresent(AccountRecoverySettingType.self, forKey: .accountRecoverySetting)
        accountRecoverySetting = accountRecoverySettingDecoded
    }
}

extension CreateUserPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolTaggingException" : self = .userPoolTaggingException(try UserPoolTaggingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case userPoolTaggingException(UserPoolTaggingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserPoolOutputResponse(userPool: \(String(describing: userPool)))"}
}

extension CreateUserPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserPoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userPool = output.userPool
        } else {
            self.userPool = nil
        }
    }
}

/// <p>Represents the response from the server for the request to create a user pool.</p>
public struct CreateUserPoolOutputResponse: Equatable {
    /// <p>A container for the user pool details.</p>
    public let userPool: UserPoolType?

    public init (
        userPool: UserPoolType? = nil
    )
    {
        self.userPool = userPool
    }
}

struct CreateUserPoolOutputResponseBody: Equatable {
    public let userPool: UserPoolType?
}

extension CreateUserPoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPool = "UserPool"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolDecoded = try containerValues.decodeIfPresent(UserPoolType.self, forKey: .userPool)
        userPool = userPoolDecoded
    }
}

extension CustomDomainConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension CustomDomainConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDomainConfigType(certificateArn: \(String(describing: certificateArn)))"}
}

/// <p>The configuration for a custom domain that hosts the sign-up and sign-in webpages for
///             your application.</p>
public struct CustomDomainConfigType: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an AWS Certificate Manager SSL certificate. You use
    ///             this certificate for the subdomain of your custom domain.</p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

extension CustomEmailLambdaVersionConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaArn = "LambdaArn"
        case lambdaVersion = "LambdaVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let lambdaVersion = lambdaVersion {
            try encodeContainer.encode(lambdaVersion.rawValue, forKey: .lambdaVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaVersionDecoded = try containerValues.decodeIfPresent(CustomEmailSenderLambdaVersionType.self, forKey: .lambdaVersion)
        lambdaVersion = lambdaVersionDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension CustomEmailLambdaVersionConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomEmailLambdaVersionConfigType(lambdaArn: \(String(describing: lambdaArn)), lambdaVersion: \(String(describing: lambdaVersion)))"}
}

/// <p>A custom email sender Lambda configuration type.</p>
public struct CustomEmailLambdaVersionConfigType: Equatable {
    /// <p>The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to
    ///             send email notifications to users.</p>
    public let lambdaArn: String?
    /// <p>The Lambda version represents the signature of the "request" attribute in the "event"
    ///             information Amazon Cognito passes to your custom email Lambda function. The only
    ///             supported value is <code>V1_0</code>.</p>
    public let lambdaVersion: CustomEmailSenderLambdaVersionType?

    public init (
        lambdaArn: String? = nil,
        lambdaVersion: CustomEmailSenderLambdaVersionType? = nil
    )
    {
        self.lambdaArn = lambdaArn
        self.lambdaVersion = lambdaVersion
    }
}

public enum CustomEmailSenderLambdaVersionType {
    case v10
    case sdkUnknown(String)
}

extension CustomEmailSenderLambdaVersionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomEmailSenderLambdaVersionType] {
        return [
            .v10,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v10: return "V1_0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomEmailSenderLambdaVersionType(rawValue: rawValue) ?? CustomEmailSenderLambdaVersionType.sdkUnknown(rawValue)
    }
}

extension CustomSMSLambdaVersionConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaArn = "LambdaArn"
        case lambdaVersion = "LambdaVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let lambdaVersion = lambdaVersion {
            try encodeContainer.encode(lambdaVersion.rawValue, forKey: .lambdaVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaVersionDecoded = try containerValues.decodeIfPresent(CustomSMSSenderLambdaVersionType.self, forKey: .lambdaVersion)
        lambdaVersion = lambdaVersionDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension CustomSMSLambdaVersionConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomSMSLambdaVersionConfigType(lambdaArn: \(String(describing: lambdaArn)), lambdaVersion: \(String(describing: lambdaVersion)))"}
}

/// <p>A custom SMS sender Lambda configuration type.</p>
public struct CustomSMSLambdaVersionConfigType: Equatable {
    /// <p>The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to
    ///             send SMS notifications to users.</p>
    public let lambdaArn: String?
    /// <p>The Lambda version represents the signature of the "request" attribute in the "event"
    ///             information Amazon Cognito passes to your custom SMS Lambda function. The only supported
    ///             value is <code>V1_0</code>.</p>
    public let lambdaVersion: CustomSMSSenderLambdaVersionType?

    public init (
        lambdaArn: String? = nil,
        lambdaVersion: CustomSMSSenderLambdaVersionType? = nil
    )
    {
        self.lambdaArn = lambdaArn
        self.lambdaVersion = lambdaVersion
    }
}

public enum CustomSMSSenderLambdaVersionType {
    case v10
    case sdkUnknown(String)
}

extension CustomSMSSenderLambdaVersionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomSMSSenderLambdaVersionType] {
        return [
            .v10,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .v10: return "V1_0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomSMSSenderLambdaVersionType(rawValue: rawValue) ?? CustomSMSSenderLambdaVersionType.sdkUnknown(rawValue)
    }
}

public enum DefaultEmailOptionType {
    case confirmWithCode
    case confirmWithLink
    case sdkUnknown(String)
}

extension DefaultEmailOptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DefaultEmailOptionType] {
        return [
            .confirmWithCode,
            .confirmWithLink,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confirmWithCode: return "CONFIRM_WITH_CODE"
        case .confirmWithLink: return "CONFIRM_WITH_LINK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DefaultEmailOptionType(rawValue: rawValue) ?? DefaultEmailOptionType.sdkUnknown(rawValue)
    }
}

public struct DeleteGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(groupName: \(String(describing: groupName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        groupName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.groupName = groupName
        self.userPoolId = userPoolId
    }
}

struct DeleteGroupInputBody: Equatable {
    public let groupName: String?
    public let userPoolId: String?
}

extension DeleteGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Equatable {
}

extension DeleteGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteIdentityProviderInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityProviderInput>
    public typealias MOutput = OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityProviderOutputError>
}

extension DeleteIdentityProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityProviderInput(providerName: \(String(describing: providerName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteIdentityProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteIdentityProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityProviderInput>
    public typealias MOutput = OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityProviderInput>
    public typealias MOutput = OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInput: Equatable {
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        providerName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.providerName = providerName
        self.userPoolId = userPoolId
    }
}

struct DeleteIdentityProviderInputBody: Equatable {
    public let userPoolId: String?
    public let providerName: String?
}

extension DeleteIdentityProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension DeleteIdentityProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIdentityProviderException" : self = .unsupportedIdentityProviderException(try UnsupportedIdentityProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityProviderOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedIdentityProviderException(UnsupportedIdentityProviderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityProviderOutputResponse()"}
}

extension DeleteIdentityProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityProviderOutputResponse: Equatable {

    public init() {}
}

struct DeleteIdentityProviderOutputResponseBody: Equatable {
}

extension DeleteIdentityProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteResourceServerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourceServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceServerInput>
    public typealias MOutput = OperationOutput<DeleteResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceServerOutputError>
}

extension DeleteResourceServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceServerInput(identifier: \(String(describing: identifier)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteResourceServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteResourceServerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceServerInput>
    public typealias MOutput = OperationOutput<DeleteResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceServerOutputError>
}

public struct DeleteResourceServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceServerInput>
    public typealias MOutput = OperationOutput<DeleteResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceServerOutputError>
}

public struct DeleteResourceServerInput: Equatable {
    /// <p>The identifier for the resource server.</p>
    public let identifier: String?
    /// <p>The user pool ID for the user pool that hosts the resource server.</p>
    public let userPoolId: String?

    public init (
        identifier: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.identifier = identifier
        self.userPoolId = userPoolId
    }
}

struct DeleteResourceServerInputBody: Equatable {
    public let userPoolId: String?
    public let identifier: String?
}

extension DeleteResourceServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteResourceServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceServerOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceServerOutputResponse()"}
}

extension DeleteResourceServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceServerOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceServerOutputResponseBody: Equatable {
}

extension DeleteResourceServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<DeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserAttributesOutputError>
}

extension DeleteUserAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserAttributesInput(accessToken: \(String(describing: accessToken)), userAttributeNames: \(String(describing: userAttributeNames)))"}
}

extension DeleteUserAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case userAttributeNames = "UserAttributeNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let userAttributeNames = userAttributeNames {
            var userAttributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributeNames)
            for attributenamelisttype0 in userAttributeNames {
                try userAttributeNamesContainer.encode(attributenamelisttype0)
            }
        }
    }
}

public struct DeleteUserAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<DeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserAttributesOutputError>
}

public struct DeleteUserAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserAttributesInput>
    public typealias MOutput = OperationOutput<DeleteUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserAttributesOutputError>
}

/// <p>Represents the request to delete user attributes.</p>
public struct DeleteUserAttributesInput: Equatable {
    /// <p>The access token used in the request to delete user attributes.</p>
    public let accessToken: String?
    /// <p>An array of strings representing the user attribute names you wish to delete.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributeNames: [String]?

    public init (
        accessToken: String? = nil,
        userAttributeNames: [String]? = nil
    )
    {
        self.accessToken = accessToken
        self.userAttributeNames = userAttributeNames
    }
}

struct DeleteUserAttributesInputBody: Equatable {
    public let userAttributeNames: [String]?
    public let accessToken: String?
}

extension DeleteUserAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case userAttributeNames = "UserAttributeNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAttributeNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userAttributeNames)
        var userAttributeNamesDecoded0:[String]? = nil
        if let userAttributeNamesContainer = userAttributeNamesContainer {
            userAttributeNamesDecoded0 = [String]()
            for string0 in userAttributeNamesContainer {
                if let string0 = string0 {
                    userAttributeNamesDecoded0?.append(string0)
                }
            }
        }
        userAttributeNames = userAttributeNamesDecoded0
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension DeleteUserAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserAttributesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserAttributesOutputResponse()"}
}

extension DeleteUserAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server to delete user attributes.</p>
public struct DeleteUserAttributesOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserAttributesOutputResponseBody: Equatable {
}

extension DeleteUserAttributesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(accessToken: \(String(describing: accessToken)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

/// <p>Represents the request to delete a user.</p>
public struct DeleteUserInput: Equatable {
    /// <p>The access token from a request to delete a user.</p>
    public let accessToken: String?

    public init (
        accessToken: String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct DeleteUserInputBody: Equatable {
    public let accessToken: String?
}

extension DeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserPoolClientInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserPoolClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolClientInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolClientOutputError>
}

extension DeleteUserPoolClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolClientInput(clientId: \(String(describing: clientId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteUserPoolClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteUserPoolClientInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserPoolClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolClientInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolClientOutputError>
}

public struct DeleteUserPoolClientInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserPoolClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolClientInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolClientOutputError>
}

/// <p>Represents the request to delete a user pool client.</p>
public struct DeleteUserPoolClientInput: Equatable {
    /// <p>The app client ID of the app associated with the user pool.</p>
    public let clientId: String?
    /// <p>The user pool ID for the user pool where you want to delete the client.</p>
    public let userPoolId: String?

    public init (
        clientId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.clientId = clientId
        self.userPoolId = userPoolId
    }
}

struct DeleteUserPoolClientInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
}

extension DeleteUserPoolClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension DeleteUserPoolClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserPoolClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserPoolClientOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPoolClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolClientOutputResponse()"}
}

extension DeleteUserPoolClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPoolClientOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserPoolClientOutputResponseBody: Equatable {
}

extension DeleteUserPoolClientOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserPoolDomainInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserPoolDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolDomainOutputError>
}

extension DeleteUserPoolDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolDomainInput(domain: \(String(describing: domain)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteUserPoolDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteUserPoolDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserPoolDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolDomainOutputError>
}

public struct DeleteUserPoolDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserPoolDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolDomainOutputError>
}

public struct DeleteUserPoolDomainInput: Equatable {
    /// <p>The domain string.</p>
    public let domain: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        domain: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.domain = domain
        self.userPoolId = userPoolId
    }
}

struct DeleteUserPoolDomainInputBody: Equatable {
    public let domain: String?
    public let userPoolId: String?
}

extension DeleteUserPoolDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension DeleteUserPoolDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserPoolDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserPoolDomainOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPoolDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolDomainOutputResponse()"}
}

extension DeleteUserPoolDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPoolDomainOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserPoolDomainOutputResponseBody: Equatable {
}

extension DeleteUserPoolDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserPoolInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolOutputError>
}

extension DeleteUserPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolInput(userPoolId: \(String(describing: userPoolId)))"}
}

extension DeleteUserPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DeleteUserPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolOutputError>
}

public struct DeleteUserPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserPoolInput>
    public typealias MOutput = OperationOutput<DeleteUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserPoolOutputError>
}

/// <p>Represents the request to delete a user pool.</p>
public struct DeleteUserPoolInput: Equatable {
    /// <p>The user pool ID for the user pool you want to delete.</p>
    public let userPoolId: String?

    public init (
        userPoolId: String? = nil
    )
    {
        self.userPoolId = userPoolId
    }
}

struct DeleteUserPoolInputBody: Equatable {
    public let userPoolId: String?
}

extension DeleteUserPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension DeleteUserPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserImportInProgressException" : self = .userImportInProgressException(try UserImportInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userImportInProgressException(UserImportInProgressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserPoolOutputResponse()"}
}

extension DeleteUserPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserPoolOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserPoolOutputResponseBody: Equatable {
}

extension DeleteUserPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DeliveryMediumType {
    case email
    case sms
    case sdkUnknown(String)
}

extension DeliveryMediumType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliveryMediumType] {
        return [
            .email,
            .sms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .sms: return "SMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliveryMediumType(rawValue: rawValue) ?? DeliveryMediumType.sdkUnknown(rawValue)
    }
}

public struct DescribeIdentityProviderInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderOutputError>
}

extension DescribeIdentityProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityProviderInput(providerName: \(String(describing: providerName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeIdentityProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeIdentityProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderOutputError>
}

public struct DescribeIdentityProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderOutputError>
}

public struct DescribeIdentityProviderInput: Equatable {
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        providerName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.providerName = providerName
        self.userPoolId = userPoolId
    }
}

struct DescribeIdentityProviderInputBody: Equatable {
    public let userPoolId: String?
    public let providerName: String?
}

extension DescribeIdentityProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension DescribeIdentityProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityProviderOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityProviderOutputResponse(identityProvider: \(String(describing: identityProvider)))"}
}

extension DescribeIdentityProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct DescribeIdentityProviderOutputResponse: Equatable {
    /// <p>The identity provider that was deleted.</p>
    public let identityProvider: IdentityProviderType?

    public init (
        identityProvider: IdentityProviderType? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct DescribeIdentityProviderOutputResponseBody: Equatable {
    public let identityProvider: IdentityProviderType?
}

extension DescribeIdentityProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityProvider = "IdentityProvider"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

public struct DescribeResourceServerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResourceServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceServerInput>
    public typealias MOutput = OperationOutput<DescribeResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceServerOutputError>
}

extension DescribeResourceServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceServerInput(identifier: \(String(describing: identifier)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeResourceServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeResourceServerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourceServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceServerInput>
    public typealias MOutput = OperationOutput<DescribeResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceServerOutputError>
}

public struct DescribeResourceServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourceServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceServerInput>
    public typealias MOutput = OperationOutput<DescribeResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceServerOutputError>
}

public struct DescribeResourceServerInput: Equatable {
    /// <p>The identifier for the resource server</p>
    public let identifier: String?
    /// <p>The user pool ID for the user pool that hosts the resource server.</p>
    public let userPoolId: String?

    public init (
        identifier: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.identifier = identifier
        self.userPoolId = userPoolId
    }
}

struct DescribeResourceServerInputBody: Equatable {
    public let userPoolId: String?
    public let identifier: String?
}

extension DescribeResourceServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DescribeResourceServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceServerOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceServerOutputResponse(resourceServer: \(String(describing: resourceServer)))"}
}

extension DescribeResourceServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourceServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceServer = output.resourceServer
        } else {
            self.resourceServer = nil
        }
    }
}

public struct DescribeResourceServerOutputResponse: Equatable {
    /// <p>The resource server.</p>
    public let resourceServer: ResourceServerType?

    public init (
        resourceServer: ResourceServerType? = nil
    )
    {
        self.resourceServer = resourceServer
    }
}

struct DescribeResourceServerOutputResponseBody: Equatable {
    public let resourceServer: ResourceServerType?
}

extension DescribeResourceServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceServer = "ResourceServer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceServerDecoded = try containerValues.decodeIfPresent(ResourceServerType.self, forKey: .resourceServer)
        resourceServer = resourceServerDecoded
    }
}

public struct DescribeRiskConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRiskConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRiskConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRiskConfigurationOutputError>
}

extension DescribeRiskConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRiskConfigurationInput(clientId: \(String(describing: clientId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeRiskConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeRiskConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRiskConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRiskConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRiskConfigurationOutputError>
}

public struct DescribeRiskConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRiskConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRiskConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRiskConfigurationOutputError>
}

public struct DescribeRiskConfigurationInput: Equatable {
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        clientId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.clientId = clientId
        self.userPoolId = userPoolId
    }
}

struct DescribeRiskConfigurationInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
}

extension DescribeRiskConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension DescribeRiskConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRiskConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolAddOnNotEnabledException" : self = .userPoolAddOnNotEnabledException(try UserPoolAddOnNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRiskConfigurationOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userPoolAddOnNotEnabledException(UserPoolAddOnNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRiskConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRiskConfigurationOutputResponse(riskConfiguration: \(String(describing: riskConfiguration)))"}
}

extension DescribeRiskConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRiskConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.riskConfiguration = output.riskConfiguration
        } else {
            self.riskConfiguration = nil
        }
    }
}

public struct DescribeRiskConfigurationOutputResponse: Equatable {
    /// <p>The risk configuration.</p>
    public let riskConfiguration: RiskConfigurationType?

    public init (
        riskConfiguration: RiskConfigurationType? = nil
    )
    {
        self.riskConfiguration = riskConfiguration
    }
}

struct DescribeRiskConfigurationOutputResponseBody: Equatable {
    public let riskConfiguration: RiskConfigurationType?
}

extension DescribeRiskConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case riskConfiguration = "RiskConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskConfigurationDecoded = try containerValues.decodeIfPresent(RiskConfigurationType.self, forKey: .riskConfiguration)
        riskConfiguration = riskConfigurationDecoded
    }
}

public struct DescribeUserImportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserImportJobInput>
    public typealias MOutput = OperationOutput<DescribeUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserImportJobOutputError>
}

extension DescribeUserImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserImportJobInput(jobId: \(String(describing: jobId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeUserImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeUserImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserImportJobInput>
    public typealias MOutput = OperationOutput<DescribeUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserImportJobOutputError>
}

public struct DescribeUserImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserImportJobInput>
    public typealias MOutput = OperationOutput<DescribeUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserImportJobOutputError>
}

/// <p>Represents the request to describe the user import job.</p>
public struct DescribeUserImportJobInput: Equatable {
    /// <p>The job ID for the user import job.</p>
    public let jobId: String?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        jobId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.jobId = jobId
        self.userPoolId = userPoolId
    }
}

struct DescribeUserImportJobInputBody: Equatable {
    public let userPoolId: String?
    public let jobId: String?
}

extension DescribeUserImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeUserImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserImportJobOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserImportJobOutputResponse(userImportJob: \(String(describing: userImportJob)))"}
}

extension DescribeUserImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userImportJob = output.userImportJob
        } else {
            self.userImportJob = nil
        }
    }
}

/// <p>Represents the response from the server to the request to describe the user import
///             job.</p>
public struct DescribeUserImportJobOutputResponse: Equatable {
    /// <p>The job object that represents the user import job.</p>
    public let userImportJob: UserImportJobType?

    public init (
        userImportJob: UserImportJobType? = nil
    )
    {
        self.userImportJob = userImportJob
    }
}

struct DescribeUserImportJobOutputResponseBody: Equatable {
    public let userImportJob: UserImportJobType?
}

extension DescribeUserImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userImportJob = "UserImportJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userImportJobDecoded = try containerValues.decodeIfPresent(UserImportJobType.self, forKey: .userImportJob)
        userImportJob = userImportJobDecoded
    }
}

public struct DescribeUserPoolClientInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserPoolClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolClientInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolClientOutputError>
}

extension DescribeUserPoolClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolClientInput(clientId: \(String(describing: clientId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeUserPoolClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeUserPoolClientInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserPoolClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolClientInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolClientOutputError>
}

public struct DescribeUserPoolClientInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserPoolClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolClientInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolClientOutputError>
}

/// <p>Represents the request to describe a user pool client.</p>
public struct DescribeUserPoolClientInput: Equatable {
    /// <p>The app client ID of the app associated with the user pool.</p>
    public let clientId: String?
    /// <p>The user pool ID for the user pool you want to describe.</p>
    public let userPoolId: String?

    public init (
        clientId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.clientId = clientId
        self.userPoolId = userPoolId
    }
}

struct DescribeUserPoolClientInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
}

extension DescribeUserPoolClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension DescribeUserPoolClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserPoolClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserPoolClientOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserPoolClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolClientOutputResponse(userPoolClient: \(String(describing: userPoolClient)))"}
}

extension DescribeUserPoolClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserPoolClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userPoolClient = output.userPoolClient
        } else {
            self.userPoolClient = nil
        }
    }
}

/// <p>Represents the response from the server from a request to describe the user pool
///             client.</p>
public struct DescribeUserPoolClientOutputResponse: Equatable {
    /// <p>The user pool client from a server response to describe the user pool client.</p>
    public let userPoolClient: UserPoolClientType?

    public init (
        userPoolClient: UserPoolClientType? = nil
    )
    {
        self.userPoolClient = userPoolClient
    }
}

struct DescribeUserPoolClientOutputResponseBody: Equatable {
    public let userPoolClient: UserPoolClientType?
}

extension DescribeUserPoolClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolClient = "UserPoolClient"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolClientDecoded = try containerValues.decodeIfPresent(UserPoolClientType.self, forKey: .userPoolClient)
        userPoolClient = userPoolClientDecoded
    }
}

public struct DescribeUserPoolDomainInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserPoolDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolDomainOutputError>
}

extension DescribeUserPoolDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolDomainInput(domain: \(String(describing: domain)))"}
}

extension DescribeUserPoolDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }
}

public struct DescribeUserPoolDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserPoolDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolDomainOutputError>
}

public struct DescribeUserPoolDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserPoolDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolDomainInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolDomainOutputError>
}

public struct DescribeUserPoolDomainInput: Equatable {
    /// <p>The domain string.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeUserPoolDomainInputBody: Equatable {
    public let domain: String?
}

extension DescribeUserPoolDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribeUserPoolDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserPoolDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserPoolDomainOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserPoolDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolDomainOutputResponse(domainDescription: \(String(describing: domainDescription)))"}
}

extension DescribeUserPoolDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserPoolDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainDescription = output.domainDescription
        } else {
            self.domainDescription = nil
        }
    }
}

public struct DescribeUserPoolDomainOutputResponse: Equatable {
    /// <p>A domain description object containing information about the domain.</p>
    public let domainDescription: DomainDescriptionType?

    public init (
        domainDescription: DomainDescriptionType? = nil
    )
    {
        self.domainDescription = domainDescription
    }
}

struct DescribeUserPoolDomainOutputResponseBody: Equatable {
    public let domainDescription: DomainDescriptionType?
}

extension DescribeUserPoolDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainDescription = "DomainDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDescriptionDecoded = try containerValues.decodeIfPresent(DomainDescriptionType.self, forKey: .domainDescription)
        domainDescription = domainDescriptionDecoded
    }
}

public struct DescribeUserPoolInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolOutputError>
}

extension DescribeUserPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolInput(userPoolId: \(String(describing: userPoolId)))"}
}

extension DescribeUserPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct DescribeUserPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolOutputError>
}

public struct DescribeUserPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserPoolInput>
    public typealias MOutput = OperationOutput<DescribeUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserPoolOutputError>
}

/// <p>Represents the request to describe the user pool.</p>
public struct DescribeUserPoolInput: Equatable {
    /// <p>The user pool ID for the user pool you want to describe.</p>
    public let userPoolId: String?

    public init (
        userPoolId: String? = nil
    )
    {
        self.userPoolId = userPoolId
    }
}

struct DescribeUserPoolInputBody: Equatable {
    public let userPoolId: String?
}

extension DescribeUserPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension DescribeUserPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolTaggingException" : self = .userPoolTaggingException(try UserPoolTaggingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userPoolTaggingException(UserPoolTaggingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserPoolOutputResponse(userPool: \(String(describing: userPool)))"}
}

extension DescribeUserPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserPoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userPool = output.userPool
        } else {
            self.userPool = nil
        }
    }
}

/// <p>Represents the response to describe the user pool.</p>
public struct DescribeUserPoolOutputResponse: Equatable {
    /// <p>The container of metadata returned by the server to describe the pool.</p>
    public let userPool: UserPoolType?

    public init (
        userPool: UserPoolType? = nil
    )
    {
        self.userPool = userPool
    }
}

struct DescribeUserPoolOutputResponseBody: Equatable {
    public let userPool: UserPoolType?
}

extension DescribeUserPoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPool = "UserPool"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolDecoded = try containerValues.decodeIfPresent(UserPoolType.self, forKey: .userPool)
        userPool = userPoolDecoded
    }
}

extension DeviceConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case challengeRequiredOnNewDevice = "ChallengeRequiredOnNewDevice"
        case deviceOnlyRememberedOnUserPrompt = "DeviceOnlyRememberedOnUserPrompt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if challengeRequiredOnNewDevice != false {
            try encodeContainer.encode(challengeRequiredOnNewDevice, forKey: .challengeRequiredOnNewDevice)
        }
        if deviceOnlyRememberedOnUserPrompt != false {
            try encodeContainer.encode(deviceOnlyRememberedOnUserPrompt, forKey: .deviceOnlyRememberedOnUserPrompt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeRequiredOnNewDeviceDecoded = try containerValues.decode(Bool.self, forKey: .challengeRequiredOnNewDevice)
        challengeRequiredOnNewDevice = challengeRequiredOnNewDeviceDecoded
        let deviceOnlyRememberedOnUserPromptDecoded = try containerValues.decode(Bool.self, forKey: .deviceOnlyRememberedOnUserPrompt)
        deviceOnlyRememberedOnUserPrompt = deviceOnlyRememberedOnUserPromptDecoded
    }
}

extension DeviceConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceConfigurationType(challengeRequiredOnNewDevice: \(String(describing: challengeRequiredOnNewDevice)), deviceOnlyRememberedOnUserPrompt: \(String(describing: deviceOnlyRememberedOnUserPrompt)))"}
}

/// <p>The configuration for the user pool's device tracking.</p>
public struct DeviceConfigurationType: Equatable {
    /// <p>Indicates whether a challenge is required on a new device. Only applicable to a new
    ///             device.</p>
    public let challengeRequiredOnNewDevice: Bool
    /// <p>If true, a device is only remembered on user prompt.</p>
    public let deviceOnlyRememberedOnUserPrompt: Bool

    public init (
        challengeRequiredOnNewDevice: Bool = false,
        deviceOnlyRememberedOnUserPrompt: Bool = false
    )
    {
        self.challengeRequiredOnNewDevice = challengeRequiredOnNewDevice
        self.deviceOnlyRememberedOnUserPrompt = deviceOnlyRememberedOnUserPrompt
    }
}

public enum DeviceRememberedStatusType {
    case notRemembered
    case remembered
    case sdkUnknown(String)
}

extension DeviceRememberedStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceRememberedStatusType] {
        return [
            .notRemembered,
            .remembered,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notRemembered: return "not_remembered"
        case .remembered: return "remembered"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceRememberedStatusType(rawValue: rawValue) ?? DeviceRememberedStatusType.sdkUnknown(rawValue)
    }
}

extension DeviceSecretVerifierConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case passwordVerifier = "PasswordVerifier"
        case salt = "Salt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passwordVerifier = passwordVerifier {
            try encodeContainer.encode(passwordVerifier, forKey: .passwordVerifier)
        }
        if let salt = salt {
            try encodeContainer.encode(salt, forKey: .salt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passwordVerifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .passwordVerifier)
        passwordVerifier = passwordVerifierDecoded
        let saltDecoded = try containerValues.decodeIfPresent(String.self, forKey: .salt)
        salt = saltDecoded
    }
}

extension DeviceSecretVerifierConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceSecretVerifierConfigType(passwordVerifier: \(String(describing: passwordVerifier)), salt: \(String(describing: salt)))"}
}

/// <p>The device verifier against which it will be authenticated.</p>
public struct DeviceSecretVerifierConfigType: Equatable {
    /// <p>The password verifier.</p>
    public let passwordVerifier: String?
    /// <p>The salt.</p>
    public let salt: String?

    public init (
        passwordVerifier: String? = nil,
        salt: String? = nil
    )
    {
        self.passwordVerifier = passwordVerifier
        self.salt = salt
    }
}

extension DeviceType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceAttributes = "DeviceAttributes"
        case deviceCreateDate = "DeviceCreateDate"
        case deviceKey = "DeviceKey"
        case deviceLastAuthenticatedDate = "DeviceLastAuthenticatedDate"
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceAttributes = deviceAttributes {
            var deviceAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceAttributes)
            for attributelisttype0 in deviceAttributes {
                try deviceAttributesContainer.encode(attributelisttype0)
            }
        }
        if let deviceCreateDate = deviceCreateDate {
            try encodeContainer.encode(deviceCreateDate.timeIntervalSince1970, forKey: .deviceCreateDate)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let deviceLastAuthenticatedDate = deviceLastAuthenticatedDate {
            try encodeContainer.encode(deviceLastAuthenticatedDate.timeIntervalSince1970, forKey: .deviceLastAuthenticatedDate)
        }
        if let deviceLastModifiedDate = deviceLastModifiedDate {
            try encodeContainer.encode(deviceLastModifiedDate.timeIntervalSince1970, forKey: .deviceLastModifiedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let deviceAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .deviceAttributes)
        var deviceAttributesDecoded0:[AttributeType]? = nil
        if let deviceAttributesContainer = deviceAttributesContainer {
            deviceAttributesDecoded0 = [AttributeType]()
            for structure0 in deviceAttributesContainer {
                if let structure0 = structure0 {
                    deviceAttributesDecoded0?.append(structure0)
                }
            }
        }
        deviceAttributes = deviceAttributesDecoded0
        let deviceCreateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deviceCreateDate)
        deviceCreateDate = deviceCreateDateDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
        let deviceLastAuthenticatedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deviceLastAuthenticatedDate)
        deviceLastAuthenticatedDate = deviceLastAuthenticatedDateDecoded
    }
}

extension DeviceType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceType(deviceAttributes: \(String(describing: deviceAttributes)), deviceCreateDate: \(String(describing: deviceCreateDate)), deviceKey: \(String(describing: deviceKey)), deviceLastAuthenticatedDate: \(String(describing: deviceLastAuthenticatedDate)), deviceLastModifiedDate: \(String(describing: deviceLastModifiedDate)))"}
}

/// <p>The device type.</p>
public struct DeviceType: Equatable {
    /// <p>The device attributes.</p>
    public let deviceAttributes: [AttributeType]?
    /// <p>The creation date of the device.</p>
    public let deviceCreateDate: Date?
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The date in which the device was last authenticated.</p>
    public let deviceLastAuthenticatedDate: Date?
    /// <p>The last modified date of the device.</p>
    public let deviceLastModifiedDate: Date?

    public init (
        deviceAttributes: [AttributeType]? = nil,
        deviceCreateDate: Date? = nil,
        deviceKey: String? = nil,
        deviceLastAuthenticatedDate: Date? = nil,
        deviceLastModifiedDate: Date? = nil
    )
    {
        self.deviceAttributes = deviceAttributes
        self.deviceCreateDate = deviceCreateDate
        self.deviceKey = deviceKey
        self.deviceLastAuthenticatedDate = deviceLastAuthenticatedDate
        self.deviceLastModifiedDate = deviceLastModifiedDate
    }
}

extension DomainDescriptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSAccountId = "AWSAccountId"
        case cloudFrontDistribution = "CloudFrontDistribution"
        case customDomainConfig = "CustomDomainConfig"
        case domain = "Domain"
        case s3Bucket = "S3Bucket"
        case status = "Status"
        case userPoolId = "UserPoolId"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSAccountId = aWSAccountId {
            try encodeContainer.encode(aWSAccountId, forKey: .aWSAccountId)
        }
        if let cloudFrontDistribution = cloudFrontDistribution {
            try encodeContainer.encode(cloudFrontDistribution, forKey: .cloudFrontDistribution)
        }
        if let customDomainConfig = customDomainConfig {
            try encodeContainer.encode(customDomainConfig, forKey: .customDomainConfig)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let aWSAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aWSAccountId)
        aWSAccountId = aWSAccountIdDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let cloudFrontDistributionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudFrontDistribution)
        cloudFrontDistribution = cloudFrontDistributionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DomainStatusType.self, forKey: .status)
        status = statusDecoded
        let customDomainConfigDecoded = try containerValues.decodeIfPresent(CustomDomainConfigType.self, forKey: .customDomainConfig)
        customDomainConfig = customDomainConfigDecoded
    }
}

extension DomainDescriptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDescriptionType(aWSAccountId: \(String(describing: aWSAccountId)), cloudFrontDistribution: \(String(describing: cloudFrontDistribution)), customDomainConfig: \(String(describing: customDomainConfig)), domain: \(String(describing: domain)), s3Bucket: \(String(describing: s3Bucket)), status: \(String(describing: status)), userPoolId: \(String(describing: userPoolId)), version: \(String(describing: version)))"}
}

/// <p>A container for information about a domain.</p>
public struct DomainDescriptionType: Equatable {
    /// <p>The AWS account ID for the user pool owner.</p>
    public let aWSAccountId: String?
    /// <p>The ARN of the CloudFront distribution.</p>
    public let cloudFrontDistribution: String?
    /// <p>The configuration for a custom domain that hosts the sign-up and sign-in webpages for
    ///             your application.</p>
    public let customDomainConfig: CustomDomainConfigType?
    /// <p>The domain string.</p>
    public let domain: String?
    /// <p>The S3 bucket where the static files for this domain are stored.</p>
    public let s3Bucket: String?
    /// <p>The domain status.</p>
    public let status: DomainStatusType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The app version.</p>
    public let version: String?

    public init (
        aWSAccountId: String? = nil,
        cloudFrontDistribution: String? = nil,
        customDomainConfig: CustomDomainConfigType? = nil,
        domain: String? = nil,
        s3Bucket: String? = nil,
        status: DomainStatusType? = nil,
        userPoolId: String? = nil,
        version: String? = nil
    )
    {
        self.aWSAccountId = aWSAccountId
        self.cloudFrontDistribution = cloudFrontDistribution
        self.customDomainConfig = customDomainConfig
        self.domain = domain
        self.s3Bucket = s3Bucket
        self.status = status
        self.userPoolId = userPoolId
        self.version = version
    }
}

public enum DomainStatusType {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension DomainStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainStatusType] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainStatusType(rawValue: rawValue) ?? DomainStatusType.sdkUnknown(rawValue)
    }
}

extension DuplicateProviderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateProviderException(message: \(String(describing: message)))"}
}

extension DuplicateProviderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateProviderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provider is already supported by the user
///             pool.</p>
public struct DuplicateProviderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateProviderExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateProviderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EmailConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSet = "ConfigurationSet"
        case emailSendingAccount = "EmailSendingAccount"
        case from = "From"
        case replyToEmailAddress = "ReplyToEmailAddress"
        case sourceArn = "SourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSet = configurationSet {
            try encodeContainer.encode(configurationSet, forKey: .configurationSet)
        }
        if let emailSendingAccount = emailSendingAccount {
            try encodeContainer.encode(emailSendingAccount.rawValue, forKey: .emailSendingAccount)
        }
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let replyToEmailAddress = replyToEmailAddress {
            try encodeContainer.encode(replyToEmailAddress, forKey: .replyToEmailAddress)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let replyToEmailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replyToEmailAddress)
        replyToEmailAddress = replyToEmailAddressDecoded
        let emailSendingAccountDecoded = try containerValues.decodeIfPresent(EmailSendingAccountType.self, forKey: .emailSendingAccount)
        emailSendingAccount = emailSendingAccountDecoded
        let fromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .from)
        from = fromDecoded
        let configurationSetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSet)
        configurationSet = configurationSetDecoded
    }
}

extension EmailConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailConfigurationType(configurationSet: \(String(describing: configurationSet)), emailSendingAccount: \(String(describing: emailSendingAccount)), from: \(String(describing: from)), replyToEmailAddress: \(String(describing: replyToEmailAddress)), sourceArn: \(String(describing: sourceArn)))"}
}

/// <p>The email configuration type. </p>
///         <note>
///             <p>Amazon Cognito has specific regions for use with Amazon SES. For more information
///                 on the supported regions, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-email.html">Email Settings for Amazon Cognito User Pools</a>.</p>
///         </note>
public struct EmailConfigurationType: Equatable {
    /// <p>The set of configuration rules that can be applied to emails sent using Amazon SES. A
    ///             configuration set is applied to an email by including a reference to the configuration
    ///             set in the headers of the email. Once applied, all of the rules in that configuration
    ///             set are applied to the email. Configuration sets can be used to apply the following
    ///             types of rules to emails: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Event publishing  Amazon SES can track the number of send, delivery, open,
    ///                     click, bounce, and complaint events for each email sent. Use event publishing to
    ///                     send information about these events to other AWS services such as SNS and
    ///                     CloudWatch.</p>
    ///             </li>
    ///             <li>
    ///                 <p>IP pool management  When leasing dedicated IP addresses with Amazon SES, you
    ///                     can create groups of IP addresses, called dedicated IP pools. You can then
    ///                     associate the dedicated IP pools with configuration sets.</p>
    ///             </li>
    ///          </ul>
    public let configurationSet: String?
    /// <p>Specifies whether Amazon Cognito emails your users by using its built-in email
    ///             functionality or your Amazon SES email configuration. Specify one of the following
    ///             values:</p>
    ///         <dl>
    ///             <dt>COGNITO_DEFAULT</dt>
    ///             <dd>
    ///                     <p>When Amazon Cognito emails your users, it uses its built-in email
    ///                         functionality. When you use the default option, Amazon Cognito allows only a
    ///                         limited number of emails each day for your user pool. For typical production
    ///                         environments, the default email limit is below the required delivery volume.
    ///                         To achieve a higher delivery volume, specify DEVELOPER to use your Amazon
    ///                         SES email configuration.</p>
    ///
    ///                     <p>To look up the email delivery limit for the default option, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/limits.html">Limits in Amazon Cognito</a> in the <i>Amazon Cognito
    ///                             Developer Guide</i>.</p>
    ///                     <p>The default FROM address is no-reply@verificationemail.com. To customize
    ///                         the FROM address, provide the ARN of an Amazon SES verified email address
    ///                         for the <code>SourceArn</code> parameter.</p>
    ///                     <p> If EmailSendingAccount is COGNITO_DEFAULT, the following parameters
    ///                         aren't allowed:</p>
    ///
    ///                     <ul>
    ///                   <li>
    ///                             <p>EmailVerificationMessage</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>EmailVerificationSubject</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>InviteMessageTemplate.EmailMessage</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>InviteMessageTemplate.EmailSubject</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>VerificationMessageTemplate.EmailMessage</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>VerificationMessageTemplate.EmailMessageByLink</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>VerificationMessageTemplate.EmailSubject,</p>
    ///                         </li>
    ///                   <li>
    ///                             <p>VerificationMessageTemplate.EmailSubjectByLink</p>
    ///                         </li>
    ///                </ul>
    ///
    ///
    ///                     <note>
    ///                         <p>DEVELOPER EmailSendingAccount is required.</p>
    ///                     </note>
    ///                 </dd>
    ///             <dt>DEVELOPER</dt>
    ///             <dd>
    ///                     <p>When Amazon Cognito emails your users, it uses your Amazon SES
    ///                         configuration. Amazon Cognito calls Amazon SES on your behalf to send email
    ///                         from your verified email address. When you use this option, the email
    ///                         delivery limits are the same limits that apply to your Amazon SES verified
    ///                         email address in your AWS account.</p>
    ///                     <p>If you use this option, you must provide the ARN of an Amazon SES verified
    ///                         email address for the <code>SourceArn</code> parameter.</p>
    ///                     <p>Before Amazon Cognito can email your users, it requires additional
    ///                         permissions to call Amazon SES on your behalf. When you update your user
    ///                         pool with this option, Amazon Cognito creates a <i>service-linked
    ///                             role</i>, which is a type of IAM role, in your AWS account. This
    ///                         role contains the permissions that allow Amazon Cognito to access Amazon SES
    ///                         and send email messages with your address. For more information about the
    ///                         service-linked role that Amazon Cognito creates, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/using-service-linked-roles.html">Using Service-Linked Roles for Amazon
    ///                             Cognito</a> in the <i>Amazon Cognito Developer
    ///                             Guide</i>.</p>
    ///                 </dd>
    ///          </dl>
    public let emailSendingAccount: EmailSendingAccountType?
    /// <p>Identifies either the senders email address or the senders name with their email
    ///             address. For example, <code>testuser@example.com</code> or <code>Test User
    ///                 <testuser@example.com></code>. This address will appear before the body of the
    ///             email.</p>
    public let from: String?
    /// <p>The destination to which the receiver of the email should reply to.</p>
    public let replyToEmailAddress: String?
    /// <p>The Amazon Resource Name (ARN) of a verified email address in Amazon SES. This email
    ///             address is used in one of the following ways, depending on the value that you specify
    ///             for the <code>EmailSendingAccount</code> parameter:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>If you specify <code>COGNITO_DEFAULT</code>, Amazon Cognito uses this address
    ///                     as the custom FROM address when it emails your users by using its built-in email
    ///                     account.</p>
    ///             </li>
    ///             <li>
    ///                 <p>If you specify <code>DEVELOPER</code>, Amazon Cognito emails your users with
    ///                     this address by calling Amazon SES on your behalf.</p>
    ///             </li>
    ///          </ul>
    public let sourceArn: String?

    public init (
        configurationSet: String? = nil,
        emailSendingAccount: EmailSendingAccountType? = nil,
        from: String? = nil,
        replyToEmailAddress: String? = nil,
        sourceArn: String? = nil
    )
    {
        self.configurationSet = configurationSet
        self.emailSendingAccount = emailSendingAccount
        self.from = from
        self.replyToEmailAddress = replyToEmailAddress
        self.sourceArn = sourceArn
    }
}

public enum EmailSendingAccountType {
    case cognitoDefault
    case developer
    case sdkUnknown(String)
}

extension EmailSendingAccountType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EmailSendingAccountType] {
        return [
            .cognitoDefault,
            .developer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cognitoDefault: return "COGNITO_DEFAULT"
        case .developer: return "DEVELOPER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EmailSendingAccountType(rawValue: rawValue) ?? EmailSendingAccountType.sdkUnknown(rawValue)
    }
}

extension EnableSoftwareTokenMFAException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableSoftwareTokenMFAException(message: \(String(describing: message)))"}
}

extension EnableSoftwareTokenMFAException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EnableSoftwareTokenMFAExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when there is a code mismatch and the service fails to
///             configure the software token TOTP multi-factor authentication (MFA).</p>
public struct EnableSoftwareTokenMFAException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EnableSoftwareTokenMFAExceptionBody: Equatable {
    public let message: String?
}

extension EnableSoftwareTokenMFAExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventContextDataType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case city = "City"
        case country = "Country"
        case deviceName = "DeviceName"
        case ipAddress = "IpAddress"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
    }
}

extension EventContextDataType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventContextDataType(city: \(String(describing: city)), country: \(String(describing: country)), deviceName: \(String(describing: deviceName)), ipAddress: \(String(describing: ipAddress)), timezone: \(String(describing: timezone)))"}
}

/// <p>Specifies the user context data captured at the time of an event request.</p>
public struct EventContextDataType: Equatable {
    /// <p>The user's city.</p>
    public let city: String?
    /// <p>The user's country.</p>
    public let country: String?
    /// <p>The user's device name.</p>
    public let deviceName: String?
    /// <p>The user's IP address.</p>
    public let ipAddress: String?
    /// <p>The user's time zone.</p>
    public let timezone: String?

    public init (
        city: String? = nil,
        country: String? = nil,
        deviceName: String? = nil,
        ipAddress: String? = nil,
        timezone: String? = nil
    )
    {
        self.city = city
        self.country = country
        self.deviceName = deviceName
        self.ipAddress = ipAddress
        self.timezone = timezone
    }
}

extension EventFeedbackType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case feedbackDate = "FeedbackDate"
        case feedbackValue = "FeedbackValue"
        case provider = "Provider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feedbackDate = feedbackDate {
            try encodeContainer.encode(feedbackDate.timeIntervalSince1970, forKey: .feedbackDate)
        }
        if let feedbackValue = feedbackValue {
            try encodeContainer.encode(feedbackValue.rawValue, forKey: .feedbackValue)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let feedbackValueDecoded = try containerValues.decodeIfPresent(FeedbackValueType.self, forKey: .feedbackValue)
        feedbackValue = feedbackValueDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let feedbackDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .feedbackDate)
        feedbackDate = feedbackDateDecoded
    }
}

extension EventFeedbackType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventFeedbackType(feedbackDate: \(String(describing: feedbackDate)), feedbackValue: \(String(describing: feedbackValue)), provider: \(String(describing: provider)))"}
}

/// <p>Specifies the event feedback type.</p>
public struct EventFeedbackType: Equatable {
    /// <p>The event feedback date.</p>
    public let feedbackDate: Date?
    /// <p>The event feedback value.</p>
    public let feedbackValue: FeedbackValueType?
    /// <p>The provider.</p>
    public let provider: String?

    public init (
        feedbackDate: Date? = nil,
        feedbackValue: FeedbackValueType? = nil,
        provider: String? = nil
    )
    {
        self.feedbackDate = feedbackDate
        self.feedbackValue = feedbackValue
        self.provider = provider
    }
}

public enum EventFilterType {
    case passwordChange
    case signIn
    case signUp
    case sdkUnknown(String)
}

extension EventFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventFilterType] {
        return [
            .passwordChange,
            .signIn,
            .signUp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .passwordChange: return "PASSWORD_CHANGE"
        case .signIn: return "SIGN_IN"
        case .signUp: return "SIGN_UP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventFilterType(rawValue: rawValue) ?? EventFilterType.sdkUnknown(rawValue)
    }
}

public enum EventResponseType {
    case failure
    case success
    case sdkUnknown(String)
}

extension EventResponseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventResponseType] {
        return [
            .failure,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failure: return "Failure"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventResponseType(rawValue: rawValue) ?? EventResponseType.sdkUnknown(rawValue)
    }
}

extension EventRiskType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compromisedCredentialsDetected = "CompromisedCredentialsDetected"
        case riskDecision = "RiskDecision"
        case riskLevel = "RiskLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compromisedCredentialsDetected = compromisedCredentialsDetected {
            try encodeContainer.encode(compromisedCredentialsDetected, forKey: .compromisedCredentialsDetected)
        }
        if let riskDecision = riskDecision {
            try encodeContainer.encode(riskDecision.rawValue, forKey: .riskDecision)
        }
        if let riskLevel = riskLevel {
            try encodeContainer.encode(riskLevel.rawValue, forKey: .riskLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskDecisionDecoded = try containerValues.decodeIfPresent(RiskDecisionType.self, forKey: .riskDecision)
        riskDecision = riskDecisionDecoded
        let riskLevelDecoded = try containerValues.decodeIfPresent(RiskLevelType.self, forKey: .riskLevel)
        riskLevel = riskLevelDecoded
        let compromisedCredentialsDetectedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compromisedCredentialsDetected)
        compromisedCredentialsDetected = compromisedCredentialsDetectedDecoded
    }
}

extension EventRiskType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventRiskType(compromisedCredentialsDetected: \(String(describing: compromisedCredentialsDetected)), riskDecision: \(String(describing: riskDecision)), riskLevel: \(String(describing: riskLevel)))"}
}

/// <p>The event risk type.</p>
public struct EventRiskType: Equatable {
    /// <p>Indicates whether compromised credentials were detected during an authentication
    ///             event.</p>
    public let compromisedCredentialsDetected: Bool?
    /// <p>The risk decision.</p>
    public let riskDecision: RiskDecisionType?
    /// <p>The risk level.</p>
    public let riskLevel: RiskLevelType?

    public init (
        compromisedCredentialsDetected: Bool? = nil,
        riskDecision: RiskDecisionType? = nil,
        riskLevel: RiskLevelType? = nil
    )
    {
        self.compromisedCredentialsDetected = compromisedCredentialsDetected
        self.riskDecision = riskDecision
        self.riskLevel = riskLevel
    }
}

public enum EventType {
    case forgotpassword
    case signin
    case signup
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .forgotpassword,
            .signin,
            .signup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forgotpassword: return "ForgotPassword"
        case .signin: return "SignIn"
        case .signup: return "SignUp"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension ExpiredCodeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredCodeException(message: \(String(describing: message)))"}
}

extension ExpiredCodeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExpiredCodeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown if a code has expired.</p>
public struct ExpiredCodeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the expired code exception is thrown.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredCodeExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredCodeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ExplicitAuthFlowsType {
    case adminNoSrpAuth
    case allowAdminUserPasswordAuth
    case allowCustomAuth
    case allowRefreshTokenAuth
    case allowUserPasswordAuth
    case allowUserSrpAuth
    case customAuthFlowOnly
    case userPasswordAuth
    case sdkUnknown(String)
}

extension ExplicitAuthFlowsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExplicitAuthFlowsType] {
        return [
            .adminNoSrpAuth,
            .allowAdminUserPasswordAuth,
            .allowCustomAuth,
            .allowRefreshTokenAuth,
            .allowUserPasswordAuth,
            .allowUserSrpAuth,
            .customAuthFlowOnly,
            .userPasswordAuth,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminNoSrpAuth: return "ADMIN_NO_SRP_AUTH"
        case .allowAdminUserPasswordAuth: return "ALLOW_ADMIN_USER_PASSWORD_AUTH"
        case .allowCustomAuth: return "ALLOW_CUSTOM_AUTH"
        case .allowRefreshTokenAuth: return "ALLOW_REFRESH_TOKEN_AUTH"
        case .allowUserPasswordAuth: return "ALLOW_USER_PASSWORD_AUTH"
        case .allowUserSrpAuth: return "ALLOW_USER_SRP_AUTH"
        case .customAuthFlowOnly: return "CUSTOM_AUTH_FLOW_ONLY"
        case .userPasswordAuth: return "USER_PASSWORD_AUTH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExplicitAuthFlowsType(rawValue: rawValue) ?? ExplicitAuthFlowsType.sdkUnknown(rawValue)
    }
}

public enum FeedbackValueType {
    case invalid
    case valid
    case sdkUnknown(String)
}

extension FeedbackValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeedbackValueType] {
        return [
            .invalid,
            .valid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalid: return "Invalid"
        case .valid: return "Valid"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeedbackValueType(rawValue: rawValue) ?? FeedbackValueType.sdkUnknown(rawValue)
    }
}

public struct ForgetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "ForgetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetDeviceInput>
    public typealias MOutput = OperationOutput<ForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetDeviceOutputError>
}

extension ForgetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgetDeviceInput(accessToken: \(String(describing: accessToken)), deviceKey: \(String(describing: deviceKey)))"}
}

extension ForgetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
    }
}

public struct ForgetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "ForgetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetDeviceInput>
    public typealias MOutput = OperationOutput<ForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetDeviceOutputError>
}

public struct ForgetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "ForgetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgetDeviceInput>
    public typealias MOutput = OperationOutput<ForgetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgetDeviceOutputError>
}

/// <p>Represents the request to forget the device.</p>
public struct ForgetDeviceInput: Equatable {
    /// <p>The access token for the forgotten device request.</p>
    public let accessToken: String?
    /// <p>The device key.</p>
    public let deviceKey: String?

    public init (
        accessToken: String? = nil,
        deviceKey: String? = nil
    )
    {
        self.accessToken = accessToken
        self.deviceKey = deviceKey
    }
}

struct ForgetDeviceInputBody: Equatable {
    public let accessToken: String?
    public let deviceKey: String?
}

extension ForgetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
    }
}

extension ForgetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ForgetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ForgetDeviceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ForgetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgetDeviceOutputResponse()"}
}

extension ForgetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ForgetDeviceOutputResponse: Equatable {

    public init() {}
}

struct ForgetDeviceOutputResponseBody: Equatable {
}

extension ForgetDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ForgotPasswordInputBodyMiddleware: Middleware {
    public let id: String = "ForgotPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgotPasswordInput>
    public typealias MOutput = OperationOutput<ForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgotPasswordOutputError>
}

extension ForgotPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgotPasswordInput(analyticsMetadata: \(String(describing: analyticsMetadata)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), secretHash: \(String(describing: secretHash)), userContextData: \(String(describing: userContextData)), username: \(String(describing: username)))"}
}

extension ForgotPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let secretHash = secretHash {
            try encodeContainer.encode(secretHash, forKey: .secretHash)
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ForgotPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ForgotPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgotPasswordInput>
    public typealias MOutput = OperationOutput<ForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgotPasswordOutputError>
}

public struct ForgotPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ForgotPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ForgotPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ForgotPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ForgotPasswordInput>
    public typealias MOutput = OperationOutput<ForgotPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ForgotPasswordOutputError>
}

/// <p>Represents the request to reset a user's password.</p>
public struct ForgotPasswordInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>ForgotPassword</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the ForgotPassword API action, Amazon Cognito invokes any functions that
    ///             are assigned to the following triggers: <i>pre sign-up</i>,
    ///                 <i>custom message</i>, and <i>user migration</i>. When
    ///             Amazon Cognito invokes any of these functions, it passes a JSON payload, which the
    ///             function receives as input. This payload contains a <code>clientMetadata</code>
    ///             attribute, which provides the data that you assigned to the ClientMetadata parameter in
    ///             your ForgotPassword request. In your function code in AWS Lambda, you can process the
    ///                 <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>A keyed-hash message authentication code (HMAC) calculated using the secret key of a
    ///             user pool client and username plus the client ID in the message.</p>
    public let secretHash: String?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?
    /// <p>The user name of the user for whom you want to enter a code to reset a forgotten
    ///             password.</p>
    public let username: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        secretHash: String? = nil,
        userContextData: UserContextDataType? = nil,
        username: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.secretHash = secretHash
        self.userContextData = userContextData
        self.username = username
    }
}

struct ForgotPasswordInputBody: Equatable {
    public let clientId: String?
    public let secretHash: String?
    public let userContextData: UserContextDataType?
    public let username: String?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let clientMetadata: [String:String]?
}

extension ForgotPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let secretHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretHash)
        secretHash = secretHashDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension ForgotPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ForgotPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ForgotPasswordOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ForgotPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForgotPasswordOutputResponse(codeDeliveryDetails: \(String(describing: codeDeliveryDetails)))"}
}

extension ForgotPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForgotPasswordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeDeliveryDetails = output.codeDeliveryDetails
        } else {
            self.codeDeliveryDetails = nil
        }
    }
}

/// <p>Respresents the response from the server regarding the request to reset a
///             password.</p>
public struct ForgotPasswordOutputResponse: Equatable {
    /// <p>The code delivery details returned by the server in response to the request to reset a
    ///             password.</p>
    public let codeDeliveryDetails: CodeDeliveryDetailsType?

    public init (
        codeDeliveryDetails: CodeDeliveryDetailsType? = nil
    )
    {
        self.codeDeliveryDetails = codeDeliveryDetails
    }
}

struct ForgotPasswordOutputResponseBody: Equatable {
    public let codeDeliveryDetails: CodeDeliveryDetailsType?
}

extension ForgotPasswordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeDeliveryDetails = "CodeDeliveryDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDeliveryDetailsDecoded = try containerValues.decodeIfPresent(CodeDeliveryDetailsType.self, forKey: .codeDeliveryDetails)
        codeDeliveryDetails = codeDeliveryDetailsDecoded
    }
}

public struct GetCSVHeaderInputBodyMiddleware: Middleware {
    public let id: String = "GetCSVHeaderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCSVHeaderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCSVHeaderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCSVHeaderInput>
    public typealias MOutput = OperationOutput<GetCSVHeaderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCSVHeaderOutputError>
}

extension GetCSVHeaderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCSVHeaderInput(userPoolId: \(String(describing: userPoolId)))"}
}

extension GetCSVHeaderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetCSVHeaderInputHeadersMiddleware: Middleware {
    public let id: String = "GetCSVHeaderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCSVHeaderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCSVHeaderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCSVHeaderInput>
    public typealias MOutput = OperationOutput<GetCSVHeaderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCSVHeaderOutputError>
}

public struct GetCSVHeaderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCSVHeaderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCSVHeaderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCSVHeaderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCSVHeaderInput>
    public typealias MOutput = OperationOutput<GetCSVHeaderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCSVHeaderOutputError>
}

/// <p>Represents the request to get the header information for the .csv file for the user
///             import job.</p>
public struct GetCSVHeaderInput: Equatable {
    /// <p>The user pool ID for the user pool that the users are to be imported into.</p>
    public let userPoolId: String?

    public init (
        userPoolId: String? = nil
    )
    {
        self.userPoolId = userPoolId
    }
}

struct GetCSVHeaderInputBody: Equatable {
    public let userPoolId: String?
}

extension GetCSVHeaderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension GetCSVHeaderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCSVHeaderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCSVHeaderOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCSVHeaderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCSVHeaderOutputResponse(cSVHeader: \(String(describing: cSVHeader)), userPoolId: \(String(describing: userPoolId)))"}
}

extension GetCSVHeaderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCSVHeaderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cSVHeader = output.cSVHeader
            self.userPoolId = output.userPoolId
        } else {
            self.cSVHeader = nil
            self.userPoolId = nil
        }
    }
}

/// <p>Represents the response from the server to the request to get the header information
///             for the .csv file for the user import job.</p>
public struct GetCSVHeaderOutputResponse: Equatable {
    /// <p>The header information for the .csv file for the user import job.</p>
    public let cSVHeader: [String]?
    /// <p>The user pool ID for the user pool that the users are to be imported into.</p>
    public let userPoolId: String?

    public init (
        cSVHeader: [String]? = nil,
        userPoolId: String? = nil
    )
    {
        self.cSVHeader = cSVHeader
        self.userPoolId = userPoolId
    }
}

struct GetCSVHeaderOutputResponseBody: Equatable {
    public let userPoolId: String?
    public let cSVHeader: [String]?
}

extension GetCSVHeaderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cSVHeader = "CSVHeader"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let cSVHeaderContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cSVHeader)
        var cSVHeaderDecoded0:[String]? = nil
        if let cSVHeaderContainer = cSVHeaderContainer {
            cSVHeaderDecoded0 = [String]()
            for string0 in cSVHeaderContainer {
                if let string0 = string0 {
                    cSVHeaderDecoded0?.append(string0)
                }
            }
        }
        cSVHeader = cSVHeaderDecoded0
    }
}

public struct GetDeviceInputBodyMiddleware: Middleware {
    public let id: String = "GetDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

extension GetDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceInput(accessToken: \(String(describing: accessToken)), deviceKey: \(String(describing: deviceKey)))"}
}

extension GetDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
    }
}

public struct GetDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

public struct GetDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceInput>
    public typealias MOutput = OperationOutput<GetDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceOutputError>
}

/// <p>Represents the request to get the device.</p>
public struct GetDeviceInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The device key.</p>
    public let deviceKey: String?

    public init (
        accessToken: String? = nil,
        deviceKey: String? = nil
    )
    {
        self.accessToken = accessToken
        self.deviceKey = deviceKey
    }
}

struct GetDeviceInputBody: Equatable {
    public let deviceKey: String?
    public let accessToken: String?
}

extension GetDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension GetDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension GetDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

/// <p>Gets the device response.</p>
public struct GetDeviceOutputResponse: Equatable {
    /// <p>The device.</p>
    public let device: DeviceType?

    public init (
        device: DeviceType? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Equatable {
    public let device: DeviceType?
}

extension GetDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(DeviceType.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct GetGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

extension GetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupInput(groupName: \(String(describing: groupName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension GetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInput: Equatable {
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        groupName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.groupName = groupName
        self.userPoolId = userPoolId
    }
}

struct GetGroupInputBody: Equatable {
    public let groupName: String?
    public let userPoolId: String?
}

extension GetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension GetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupOutputResponse(group: \(String(describing: group)))"}
}

extension GetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct GetGroupOutputResponse: Equatable {
    /// <p>The group object for the group.</p>
    public let group: GroupType?

    public init (
        group: GroupType? = nil
    )
    {
        self.group = group
    }
}

struct GetGroupOutputResponseBody: Equatable {
    public let group: GroupType?
}

extension GetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(GroupType.self, forKey: .group)
        group = groupDecoded
    }
}

public struct GetIdentityProviderByIdentifierInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityProviderByIdentifierInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityProviderByIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityProviderByIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityProviderByIdentifierInput>
    public typealias MOutput = OperationOutput<GetIdentityProviderByIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityProviderByIdentifierOutputError>
}

extension GetIdentityProviderByIdentifierInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityProviderByIdentifierInput(idpIdentifier: \(String(describing: idpIdentifier)), userPoolId: \(String(describing: userPoolId)))"}
}

extension GetIdentityProviderByIdentifierInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idpIdentifier = "IdpIdentifier"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idpIdentifier = idpIdentifier {
            try encodeContainer.encode(idpIdentifier, forKey: .idpIdentifier)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetIdentityProviderByIdentifierInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityProviderByIdentifierInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityProviderByIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityProviderByIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityProviderByIdentifierInput>
    public typealias MOutput = OperationOutput<GetIdentityProviderByIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityProviderByIdentifierOutputError>
}

public struct GetIdentityProviderByIdentifierInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityProviderByIdentifierInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityProviderByIdentifierInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityProviderByIdentifierOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityProviderByIdentifierInput>
    public typealias MOutput = OperationOutput<GetIdentityProviderByIdentifierOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityProviderByIdentifierOutputError>
}

public struct GetIdentityProviderByIdentifierInput: Equatable {
    /// <p>The identity provider ID.</p>
    public let idpIdentifier: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        idpIdentifier: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.idpIdentifier = idpIdentifier
        self.userPoolId = userPoolId
    }
}

struct GetIdentityProviderByIdentifierInputBody: Equatable {
    public let userPoolId: String?
    public let idpIdentifier: String?
}

extension GetIdentityProviderByIdentifierInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case idpIdentifier = "IdpIdentifier"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let idpIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .idpIdentifier)
        idpIdentifier = idpIdentifierDecoded
    }
}

extension GetIdentityProviderByIdentifierOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityProviderByIdentifierOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityProviderByIdentifierOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityProviderByIdentifierOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityProviderByIdentifierOutputResponse(identityProvider: \(String(describing: identityProvider)))"}
}

extension GetIdentityProviderByIdentifierOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityProviderByIdentifierOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct GetIdentityProviderByIdentifierOutputResponse: Equatable {
    /// <p>The identity provider object.</p>
    public let identityProvider: IdentityProviderType?

    public init (
        identityProvider: IdentityProviderType? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct GetIdentityProviderByIdentifierOutputResponseBody: Equatable {
    public let identityProvider: IdentityProviderType?
}

extension GetIdentityProviderByIdentifierOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityProvider = "IdentityProvider"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

public struct GetSigningCertificateInputBodyMiddleware: Middleware {
    public let id: String = "GetSigningCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningCertificateInput>
    public typealias MOutput = OperationOutput<GetSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningCertificateOutputError>
}

extension GetSigningCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningCertificateInput(userPoolId: \(String(describing: userPoolId)))"}
}

extension GetSigningCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetSigningCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetSigningCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningCertificateInput>
    public typealias MOutput = OperationOutput<GetSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningCertificateOutputError>
}

public struct GetSigningCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSigningCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSigningCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSigningCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSigningCertificateInput>
    public typealias MOutput = OperationOutput<GetSigningCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSigningCertificateOutputError>
}

/// <p>Request to get a signing certificate from Cognito.</p>
public struct GetSigningCertificateInput: Equatable {
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        userPoolId: String? = nil
    )
    {
        self.userPoolId = userPoolId
    }
}

struct GetSigningCertificateInputBody: Equatable {
    public let userPoolId: String?
}

extension GetSigningCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension GetSigningCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSigningCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSigningCertificateOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSigningCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSigningCertificateOutputResponse(certificate: \(String(describing: certificate)))"}
}

extension GetSigningCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSigningCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

/// <p>Response from Cognito for a signing certificate request.</p>
public struct GetSigningCertificateOutputResponse: Equatable {
    /// <p>The signing certificate.</p>
    public let certificate: String?

    public init (
        certificate: String? = nil
    )
    {
        self.certificate = certificate
    }
}

struct GetSigningCertificateOutputResponseBody: Equatable {
    public let certificate: String?
}

extension GetSigningCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct GetUICustomizationInputBodyMiddleware: Middleware {
    public let id: String = "GetUICustomizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUICustomizationInput>
    public typealias MOutput = OperationOutput<GetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUICustomizationOutputError>
}

extension GetUICustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUICustomizationInput(clientId: \(String(describing: clientId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension GetUICustomizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetUICustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "GetUICustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUICustomizationInput>
    public typealias MOutput = OperationOutput<GetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUICustomizationOutputError>
}

public struct GetUICustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUICustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUICustomizationInput>
    public typealias MOutput = OperationOutput<GetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUICustomizationOutputError>
}

public struct GetUICustomizationInput: Equatable {
    /// <p>The client ID for the client app.</p>
    public let clientId: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        clientId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.clientId = clientId
        self.userPoolId = userPoolId
    }
}

struct GetUICustomizationInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
}

extension GetUICustomizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension GetUICustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUICustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUICustomizationOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUICustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUICustomizationOutputResponse(uICustomization: \(String(describing: uICustomization)))"}
}

extension GetUICustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUICustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.uICustomization = output.uICustomization
        } else {
            self.uICustomization = nil
        }
    }
}

public struct GetUICustomizationOutputResponse: Equatable {
    /// <p>The UI customization information.</p>
    public let uICustomization: UICustomizationType?

    public init (
        uICustomization: UICustomizationType? = nil
    )
    {
        self.uICustomization = uICustomization
    }
}

struct GetUICustomizationOutputResponseBody: Equatable {
    public let uICustomization: UICustomizationType?
}

extension GetUICustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uICustomization = "UICustomization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uICustomizationDecoded = try containerValues.decodeIfPresent(UICustomizationType.self, forKey: .uICustomization)
        uICustomization = uICustomizationDecoded
    }
}

public struct GetUserAttributeVerificationCodeInputBodyMiddleware: Middleware {
    public let id: String = "GetUserAttributeVerificationCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserAttributeVerificationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserAttributeVerificationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserAttributeVerificationCodeInput>
    public typealias MOutput = OperationOutput<GetUserAttributeVerificationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserAttributeVerificationCodeOutputError>
}

extension GetUserAttributeVerificationCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserAttributeVerificationCodeInput(accessToken: \(String(describing: accessToken)), attributeName: \(String(describing: attributeName)), clientMetadata: \(String(describing: clientMetadata)))"}
}

extension GetUserAttributeVerificationCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case attributeName = "AttributeName"
        case clientMetadata = "ClientMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetUserAttributeVerificationCodeInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserAttributeVerificationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserAttributeVerificationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserAttributeVerificationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserAttributeVerificationCodeInput>
    public typealias MOutput = OperationOutput<GetUserAttributeVerificationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserAttributeVerificationCodeOutputError>
}

public struct GetUserAttributeVerificationCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserAttributeVerificationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserAttributeVerificationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserAttributeVerificationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserAttributeVerificationCodeInput>
    public typealias MOutput = OperationOutput<GetUserAttributeVerificationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserAttributeVerificationCodeOutputError>
}

/// <p>Represents the request to get user attribute verification.</p>
public struct GetUserAttributeVerificationCodeInput: Equatable {
    /// <p>The access token returned by the server response to get the user attribute
    ///             verification code.</p>
    public let accessToken: String?
    /// <p>The attribute name returned by the server response to get the user attribute
    ///             verification code.</p>
    public let attributeName: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the GetUserAttributeVerificationCode API action, Amazon Cognito invokes the
    ///             function that is assigned to the <i>custom message</i> trigger. When
    ///             Amazon Cognito invokes this function, it passes a JSON payload, which the function
    ///             receives as input. This payload contains a <code>clientMetadata</code> attribute, which
    ///             provides the data that you assigned to the ClientMetadata parameter in your
    ///             GetUserAttributeVerificationCode request. In your function code in AWS Lambda, you can
    ///             process the <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?

    public init (
        accessToken: String? = nil,
        attributeName: String? = nil,
        clientMetadata: [String:String]? = nil
    )
    {
        self.accessToken = accessToken
        self.attributeName = attributeName
        self.clientMetadata = clientMetadata
    }
}

struct GetUserAttributeVerificationCodeInputBody: Equatable {
    public let accessToken: String?
    public let attributeName: String?
    public let clientMetadata: [String:String]?
}

extension GetUserAttributeVerificationCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case attributeName = "AttributeName"
        case clientMetadata = "ClientMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension GetUserAttributeVerificationCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserAttributeVerificationCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserAttributeVerificationCodeOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserAttributeVerificationCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserAttributeVerificationCodeOutputResponse(codeDeliveryDetails: \(String(describing: codeDeliveryDetails)))"}
}

extension GetUserAttributeVerificationCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserAttributeVerificationCodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeDeliveryDetails = output.codeDeliveryDetails
        } else {
            self.codeDeliveryDetails = nil
        }
    }
}

/// <p>The verification code response returned by the server response to get the user
///             attribute verification code.</p>
public struct GetUserAttributeVerificationCodeOutputResponse: Equatable {
    /// <p>The code delivery details returned by the server in response to the request to get the
    ///             user attribute verification code.</p>
    public let codeDeliveryDetails: CodeDeliveryDetailsType?

    public init (
        codeDeliveryDetails: CodeDeliveryDetailsType? = nil
    )
    {
        self.codeDeliveryDetails = codeDeliveryDetails
    }
}

struct GetUserAttributeVerificationCodeOutputResponseBody: Equatable {
    public let codeDeliveryDetails: CodeDeliveryDetailsType?
}

extension GetUserAttributeVerificationCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeDeliveryDetails = "CodeDeliveryDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDeliveryDetailsDecoded = try containerValues.decodeIfPresent(CodeDeliveryDetailsType.self, forKey: .codeDeliveryDetails)
        codeDeliveryDetails = codeDeliveryDetailsDecoded
    }
}

public struct GetUserInputBodyMiddleware: Middleware {
    public let id: String = "GetUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

extension GetUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserInput(accessToken: \(String(describing: accessToken)))"}
}

extension GetUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
    }
}

public struct GetUserInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

public struct GetUserInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserInput>
    public typealias MOutput = OperationOutput<GetUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserOutputError>
}

/// <p>Represents the request to get information about the user.</p>
public struct GetUserInput: Equatable {
    /// <p>The access token returned by the server response to get information about the
    ///             user.</p>
    public let accessToken: String?

    public init (
        accessToken: String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct GetUserInputBody: Equatable {
    public let accessToken: String?
}

extension GetUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension GetUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserOutputResponse(mFAOptions: \(String(describing: mFAOptions)), preferredMfaSetting: \(String(describing: preferredMfaSetting)), userAttributes: \(String(describing: userAttributes)), userMFASettingList: \(String(describing: userMFASettingList)), username: \(String(describing: username)))"}
}

extension GetUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mFAOptions = output.mFAOptions
            self.preferredMfaSetting = output.preferredMfaSetting
            self.userAttributes = output.userAttributes
            self.userMFASettingList = output.userMFASettingList
            self.username = output.username
        } else {
            self.mFAOptions = nil
            self.preferredMfaSetting = nil
            self.userAttributes = nil
            self.userMFASettingList = nil
            self.username = nil
        }
    }
}

/// <p>Represents the response from the server from the request to get information about the
///             user.</p>
public struct GetUserOutputResponse: Equatable {
    /// <p>
    ///             <i>This response parameter is no longer supported.</i> It provides
    ///             information only about SMS MFA configurations. It doesn't provide information about TOTP
    ///             software token MFA configurations. To look up information about either type of MFA
    ///             configuration, use UserMFASettingList instead.</p>
    public let mFAOptions: [MFAOptionType]?
    /// <p>The user's preferred MFA setting.</p>
    public let preferredMfaSetting: String?
    /// <p>An array of name-value pairs representing user attributes.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributes: [AttributeType]?
    /// <p>The MFA options that are enabled for the user. The possible values in this list are
    ///                 <code>SMS_MFA</code> and <code>SOFTWARE_TOKEN_MFA</code>.</p>
    public let userMFASettingList: [String]?
    /// <p>The user name of the user you wish to retrieve from the get user request.</p>
    public let username: String?

    public init (
        mFAOptions: [MFAOptionType]? = nil,
        preferredMfaSetting: String? = nil,
        userAttributes: [AttributeType]? = nil,
        userMFASettingList: [String]? = nil,
        username: String? = nil
    )
    {
        self.mFAOptions = mFAOptions
        self.preferredMfaSetting = preferredMfaSetting
        self.userAttributes = userAttributes
        self.userMFASettingList = userMFASettingList
        self.username = username
    }
}

struct GetUserOutputResponseBody: Equatable {
    public let username: String?
    public let userAttributes: [AttributeType]?
    public let mFAOptions: [MFAOptionType]?
    public let preferredMfaSetting: String?
    public let userMFASettingList: [String]?
}

extension GetUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mFAOptions = "MFAOptions"
        case preferredMfaSetting = "PreferredMfaSetting"
        case userAttributes = "UserAttributes"
        case userMFASettingList = "UserMFASettingList"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let mFAOptionsContainer = try containerValues.decodeIfPresent([MFAOptionType?].self, forKey: .mFAOptions)
        var mFAOptionsDecoded0:[MFAOptionType]? = nil
        if let mFAOptionsContainer = mFAOptionsContainer {
            mFAOptionsDecoded0 = [MFAOptionType]()
            for structure0 in mFAOptionsContainer {
                if let structure0 = structure0 {
                    mFAOptionsDecoded0?.append(structure0)
                }
            }
        }
        mFAOptions = mFAOptionsDecoded0
        let preferredMfaSettingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMfaSetting)
        preferredMfaSetting = preferredMfaSettingDecoded
        let userMFASettingListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userMFASettingList)
        var userMFASettingListDecoded0:[String]? = nil
        if let userMFASettingListContainer = userMFASettingListContainer {
            userMFASettingListDecoded0 = [String]()
            for string0 in userMFASettingListContainer {
                if let string0 = string0 {
                    userMFASettingListDecoded0?.append(string0)
                }
            }
        }
        userMFASettingList = userMFASettingListDecoded0
    }
}

public struct GetUserPoolMfaConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetUserPoolMfaConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<GetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPoolMfaConfigOutputError>
}

extension GetUserPoolMfaConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserPoolMfaConfigInput(userPoolId: \(String(describing: userPoolId)))"}
}

extension GetUserPoolMfaConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct GetUserPoolMfaConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserPoolMfaConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<GetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPoolMfaConfigOutputError>
}

public struct GetUserPoolMfaConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserPoolMfaConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<GetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserPoolMfaConfigOutputError>
}

public struct GetUserPoolMfaConfigInput: Equatable {
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        userPoolId: String? = nil
    )
    {
        self.userPoolId = userPoolId
    }
}

struct GetUserPoolMfaConfigInputBody: Equatable {
    public let userPoolId: String?
}

extension GetUserPoolMfaConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
    }
}

extension GetUserPoolMfaConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserPoolMfaConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserPoolMfaConfigOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserPoolMfaConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserPoolMfaConfigOutputResponse(mfaConfiguration: \(String(describing: mfaConfiguration)), smsMfaConfiguration: \(String(describing: smsMfaConfiguration)), softwareTokenMfaConfiguration: \(String(describing: softwareTokenMfaConfiguration)))"}
}

extension GetUserPoolMfaConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUserPoolMfaConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mfaConfiguration = output.mfaConfiguration
            self.smsMfaConfiguration = output.smsMfaConfiguration
            self.softwareTokenMfaConfiguration = output.softwareTokenMfaConfiguration
        } else {
            self.mfaConfiguration = nil
            self.smsMfaConfiguration = nil
            self.softwareTokenMfaConfiguration = nil
        }
    }
}

public struct GetUserPoolMfaConfigOutputResponse: Equatable {
    /// <p>The multi-factor (MFA) configuration. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>OFF</code> MFA will not be used for any users.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ON</code> MFA is required for all users to sign in.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>OPTIONAL</code> MFA will be required only for individual users who have
    ///                     an MFA factor enabled.</p>
    ///             </li>
    ///          </ul>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>The SMS text message multi-factor (MFA) configuration.</p>
    public let smsMfaConfiguration: SmsMfaConfigType?
    /// <p>The software token multi-factor (MFA) configuration.</p>
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?

    public init (
        mfaConfiguration: UserPoolMfaType? = nil,
        smsMfaConfiguration: SmsMfaConfigType? = nil,
        softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType? = nil
    )
    {
        self.mfaConfiguration = mfaConfiguration
        self.smsMfaConfiguration = smsMfaConfiguration
        self.softwareTokenMfaConfiguration = softwareTokenMfaConfiguration
    }
}

struct GetUserPoolMfaConfigOutputResponseBody: Equatable {
    public let smsMfaConfiguration: SmsMfaConfigType?
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?
    public let mfaConfiguration: UserPoolMfaType?
}

extension GetUserPoolMfaConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mfaConfiguration = "MfaConfiguration"
        case smsMfaConfiguration = "SmsMfaConfiguration"
        case softwareTokenMfaConfiguration = "SoftwareTokenMfaConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMfaConfigurationDecoded = try containerValues.decodeIfPresent(SmsMfaConfigType.self, forKey: .smsMfaConfiguration)
        smsMfaConfiguration = smsMfaConfigurationDecoded
        let softwareTokenMfaConfigurationDecoded = try containerValues.decodeIfPresent(SoftwareTokenMfaConfigType.self, forKey: .softwareTokenMfaConfiguration)
        softwareTokenMfaConfiguration = softwareTokenMfaConfigurationDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
    }
}

public struct GlobalSignOutInputBodyMiddleware: Middleware {
    public let id: String = "GlobalSignOutInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<GlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GlobalSignOutInput>
    public typealias MOutput = OperationOutput<GlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GlobalSignOutOutputError>
}

extension GlobalSignOutInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalSignOutInput(accessToken: \(String(describing: accessToken)))"}
}

extension GlobalSignOutInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
    }
}

public struct GlobalSignOutInputHeadersMiddleware: Middleware {
    public let id: String = "GlobalSignOutInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<GlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GlobalSignOutInput>
    public typealias MOutput = OperationOutput<GlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GlobalSignOutOutputError>
}

public struct GlobalSignOutInputQueryItemMiddleware: Middleware {
    public let id: String = "GlobalSignOutInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GlobalSignOutInput>,
                  next: H) -> Swift.Result<OperationOutput<GlobalSignOutOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GlobalSignOutInput>
    public typealias MOutput = OperationOutput<GlobalSignOutOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GlobalSignOutOutputError>
}

/// <p>Represents the request to sign out all devices.</p>
public struct GlobalSignOutInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?

    public init (
        accessToken: String? = nil
    )
    {
        self.accessToken = accessToken
    }
}

struct GlobalSignOutInputBody: Equatable {
    public let accessToken: String?
}

extension GlobalSignOutInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension GlobalSignOutOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GlobalSignOutOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GlobalSignOutOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GlobalSignOutOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalSignOutOutputResponse()"}
}

extension GlobalSignOutOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response to the request to sign out all devices.</p>
public struct GlobalSignOutOutputResponse: Equatable {

    public init() {}
}

struct GlobalSignOutOutputResponseBody: Equatable {
}

extension GlobalSignOutOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GroupExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupExistsException(message: \(String(describing: message)))"}
}

extension GroupExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GroupExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters a group that already exists in
///             the user pool.</p>
public struct GroupExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GroupExistsExceptionBody: Equatable {
    public let message: String?
}

extension GroupExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GroupType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case groupName = "GroupName"
        case lastModifiedDate = "LastModifiedDate"
        case precedence = "Precedence"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let precedence = precedence {
            try encodeContainer.encode(precedence, forKey: .precedence)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let precedenceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .precedence)
        precedence = precedenceDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GroupType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupType(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), groupName: \(String(describing: groupName)), lastModifiedDate: \(String(describing: lastModifiedDate)), precedence: \(String(describing: precedence)), roleArn: \(String(describing: roleArn)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>The group type.</p>
public struct GroupType: Equatable {
    /// <p>The date the group was created.</p>
    public let creationDate: Date?
    /// <p>A string containing the description of the group.</p>
    public let description: String?
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The date the group was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>A nonnegative integer value that specifies the precedence of this group relative to
    ///             the other groups that a user can belong to in the user pool. If a user belongs to two or
    ///             more groups, it is the group with the highest precedence whose role ARN will be used in
    ///             the <code>cognito:roles</code> and <code>cognito:preferred_role</code> claims in the
    ///             user's tokens. Groups with higher <code>Precedence</code> values take precedence over
    ///             groups with lower <code>Precedence</code> values or with null <code>Precedence</code>
    ///             values.</p>
    ///         <p>Two groups can have the same <code>Precedence</code> value. If this happens, neither
    ///             group takes precedence over the other. If two groups with the same
    ///                 <code>Precedence</code> have the same role ARN, that role is used in the
    ///                 <code>cognito:preferred_role</code> claim in tokens for users in each group. If the
    ///             two groups have different role ARNs, the <code>cognito:preferred_role</code> claim is
    ///             not set in users' tokens.</p>
    ///         <p>The default <code>Precedence</code> value is null.</p>
    public let precedence: Int?
    /// <p>The role ARN for the group.</p>
    public let roleArn: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        groupName: String? = nil,
        lastModifiedDate: Date? = nil,
        precedence: Int? = nil,
        roleArn: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.groupName = groupName
        self.lastModifiedDate = lastModifiedDate
        self.precedence = precedence
        self.roleArn = roleArn
        self.userPoolId = userPoolId
    }
}

extension HttpHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerName
        case headerValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerName = headerName {
            try encodeContainer.encode(headerName, forKey: .headerName)
        }
        if let headerValue = headerValue {
            try encodeContainer.encode(headerValue, forKey: .headerValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension HttpHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpHeader(headerName: \(String(describing: headerName)), headerValue: \(String(describing: headerValue)))"}
}

/// <p>The HTTP header.</p>
public struct HttpHeader: Equatable {
    /// <p>The header name</p>
    public let headerName: String?
    /// <p>The header value.</p>
    public let headerValue: String?

    public init (
        headerName: String? = nil,
        headerValue: String? = nil
    )
    {
        self.headerName = headerName
        self.headerValue = headerValue
    }
}

extension IdentityProviderType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeMapping = "AttributeMapping"
        case creationDate = "CreationDate"
        case idpIdentifiers = "IdpIdentifiers"
        case lastModifiedDate = "LastModifiedDate"
        case providerDetails = "ProviderDetails"
        case providerName = "ProviderName"
        case providerType = "ProviderType"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMapping = attributeMapping {
            var attributeMappingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributeMapping)
            for (dictKey0, attributemappingtype0) in attributeMapping {
                try attributeMappingContainer.encode(attributemappingtype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let idpIdentifiers = idpIdentifiers {
            var idpIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idpIdentifiers)
            for idpidentifierslisttype0 in idpIdentifiers {
                try idpIdentifiersContainer.encode(idpidentifierslisttype0)
            }
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let providerDetails = providerDetails {
            var providerDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .providerDetails)
            for (dictKey0, providerdetailstype0) in providerDetails {
                try providerDetailsContainer.encode(providerdetailstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderTypeType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let providerDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .providerDetails)
        var providerDetailsDecoded0: [String:String]? = nil
        if let providerDetailsContainer = providerDetailsContainer {
            providerDetailsDecoded0 = [String:String]()
            for (key0, stringtype0) in providerDetailsContainer {
                if let stringtype0 = stringtype0 {
                    providerDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        providerDetails = providerDetailsDecoded0
        let attributeMappingContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributeMapping)
        var attributeMappingDecoded0: [String:String]? = nil
        if let attributeMappingContainer = attributeMappingContainer {
            attributeMappingDecoded0 = [String:String]()
            for (key0, stringtype0) in attributeMappingContainer {
                if let stringtype0 = stringtype0 {
                    attributeMappingDecoded0?[key0] = stringtype0
                }
            }
        }
        attributeMapping = attributeMappingDecoded0
        let idpIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .idpIdentifiers)
        var idpIdentifiersDecoded0:[String]? = nil
        if let idpIdentifiersContainer = idpIdentifiersContainer {
            idpIdentifiersDecoded0 = [String]()
            for string0 in idpIdentifiersContainer {
                if let string0 = string0 {
                    idpIdentifiersDecoded0?.append(string0)
                }
            }
        }
        idpIdentifiers = idpIdentifiersDecoded0
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension IdentityProviderType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityProviderType(attributeMapping: \(String(describing: attributeMapping)), creationDate: \(String(describing: creationDate)), idpIdentifiers: \(String(describing: idpIdentifiers)), lastModifiedDate: \(String(describing: lastModifiedDate)), providerDetails: \(String(describing: providerDetails)), providerName: \(String(describing: providerName)), providerType: \(String(describing: providerType)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>A container for information about an identity provider.</p>
public struct IdentityProviderType: Equatable {
    /// <p>A mapping of identity provider attributes to standard and custom user pool
    ///             attributes.</p>
    public let attributeMapping: [String:String]?
    /// <p>The date the identity provider was created.</p>
    public let creationDate: Date?
    /// <p>A list of identity provider identifiers.</p>
    public let idpIdentifiers: [String]?
    /// <p>The date the identity provider was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The identity provider details. The following list describes the provider detail keys
    ///             for each identity provider type.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For Google and Login with Amazon:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For Facebook:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>api_version</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For Sign in with Apple:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>team_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>key_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>private_key</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For OIDC providers:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>client_id</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>client_secret</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>attributes_request_method</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>oidc_issuer</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_url <i>if not available from discovery URL specified
    ///                                 by oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>token_url <i>if not available from discovery URL specified by
    ///                                 oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>attributes_url <i>if not available from discovery URL specified
    ///                                 by oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>jwks_uri <i>if not available from discovery URL specified by
    ///                                 oidc_issuer key</i>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p>authorize_scopes</p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                 <p>For SAML providers:</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>MetadataFile OR MetadataURL</p>
    ///                     </li>
    ///                   <li>
    ///                         <p>IDPSignOut <i>optional</i>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let providerDetails: [String:String]?
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The identity provider type.</p>
    public let providerType: IdentityProviderTypeType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        attributeMapping: [String:String]? = nil,
        creationDate: Date? = nil,
        idpIdentifiers: [String]? = nil,
        lastModifiedDate: Date? = nil,
        providerDetails: [String:String]? = nil,
        providerName: String? = nil,
        providerType: IdentityProviderTypeType? = nil,
        userPoolId: String? = nil
    )
    {
        self.attributeMapping = attributeMapping
        self.creationDate = creationDate
        self.idpIdentifiers = idpIdentifiers
        self.lastModifiedDate = lastModifiedDate
        self.providerDetails = providerDetails
        self.providerName = providerName
        self.providerType = providerType
        self.userPoolId = userPoolId
    }
}

public enum IdentityProviderTypeType {
    case facebook
    case google
    case loginwithamazon
    case oidc
    case saml
    case signinwithapple
    case sdkUnknown(String)
}

extension IdentityProviderTypeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityProviderTypeType] {
        return [
            .facebook,
            .google,
            .loginwithamazon,
            .oidc,
            .saml,
            .signinwithapple,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .facebook: return "Facebook"
        case .google: return "Google"
        case .loginwithamazon: return "LoginWithAmazon"
        case .oidc: return "OIDC"
        case .saml: return "SAML"
        case .signinwithapple: return "SignInWithApple"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityProviderTypeType(rawValue: rawValue) ?? IdentityProviderTypeType.sdkUnknown(rawValue)
    }
}

public struct InitiateAuthInputBodyMiddleware: Middleware {
    public let id: String = "InitiateAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateAuthInput>
    public typealias MOutput = OperationOutput<InitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateAuthOutputError>
}

extension InitiateAuthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateAuthInput(analyticsMetadata: \(String(describing: analyticsMetadata)), authFlow: \(String(describing: authFlow)), authParameters: \(String(describing: authParameters)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), userContextData: \(String(describing: userContextData)))"}
}

extension InitiateAuthInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case authFlow = "AuthFlow"
        case authParameters = "AuthParameters"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case userContextData = "UserContextData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let authFlow = authFlow {
            try encodeContainer.encode(authFlow.rawValue, forKey: .authFlow)
        }
        if let authParameters = authParameters {
            var authParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .authParameters)
            for (dictKey0, authparameterstype0) in authParameters {
                try authParametersContainer.encode(authparameterstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
    }
}

public struct InitiateAuthInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateAuthInput>
    public typealias MOutput = OperationOutput<InitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateAuthOutputError>
}

public struct InitiateAuthInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateAuthInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateAuthInput>
    public typealias MOutput = OperationOutput<InitiateAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateAuthOutputError>
}

/// <p>Initiates the authentication request.</p>
public struct InitiateAuthInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>InitiateAuth</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The authentication flow for this call to execute. The API action will depend on this
    ///             value. For example: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>REFRESH_TOKEN_AUTH</code> will take in a valid refresh token and return
    ///                     new tokens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_SRP_AUTH</code> will take in <code>USERNAME</code> and
    ///                         <code>SRP_A</code> and return the SRP variables to be used for next
    ///                     challenge execution.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_PASSWORD_AUTH</code> will take in <code>USERNAME</code> and
    ///                         <code>PASSWORD</code> and return the next challenge or tokens.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_SRP_AUTH</code>: Authentication flow for the Secure Remote Password
    ///                     (SRP) protocol.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>REFRESH_TOKEN_AUTH</code>/<code>REFRESH_TOKEN</code>: Authentication
    ///                     flow for refreshing the access token and ID token by supplying a valid refresh
    ///                     token.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CUSTOM_AUTH</code>: Custom authentication flow.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>USER_PASSWORD_AUTH</code>: Non-SRP authentication flow; USERNAME and
    ///                     PASSWORD are passed directly. If a user migration Lambda trigger is set, this
    ///                     flow will invoke the user migration Lambda if the USERNAME is not found in the
    ///                     user pool. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ADMIN_USER_PASSWORD_AUTH</code>: Admin-based user password
    ///                     authentication. This replaces the <code>ADMIN_NO_SRP_AUTH</code> authentication
    ///                     flow. In this flow, Cognito receives the password in the request instead of
    ///                     using the SRP process to verify passwords.</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <code>ADMIN_NO_SRP_AUTH</code> is not a valid value.</p>
    public let authFlow: AuthFlowType?
    /// <p>The authentication parameters. These are inputs corresponding to the
    ///                 <code>AuthFlow</code> that you are invoking. The required values depend on the value
    ///             of <code>AuthFlow</code>:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For <code>USER_SRP_AUTH</code>: <code>USERNAME</code> (required),
    ///                         <code>SRP_A</code> (required), <code>SECRET_HASH</code> (required if the app
    ///                     client is configured with a client secret), <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For <code>REFRESH_TOKEN_AUTH/REFRESH_TOKEN</code>: <code>REFRESH_TOKEN</code>
    ///                     (required), <code>SECRET_HASH</code> (required if the app client is configured
    ///                     with a client secret), <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>For <code>CUSTOM_AUTH</code>: <code>USERNAME</code> (required),
    ///                         <code>SECRET_HASH</code> (if app client is configured with client secret),
    ///                         <code>DEVICE_KEY</code>. To start the authentication flow with password
    ///                     verification, include <code>ChallengeName: SRP_A</code> and <code>SRP_A: (The
    ///                         SRP_A Value)</code>.</p>
    ///             </li>
    ///          </ul>
    public let authParameters: [String:String]?
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for certain custom
    ///             workflows that this action triggers.</p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the InitiateAuth API action, Amazon Cognito invokes the AWS Lambda
    ///             functions that are specified for various triggers. The ClientMetadata value is passed as
    ///             input to the functions for only the following triggers:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Pre signup</p>
    ///             </li>
    ///             <li>
    ///                 <p>Pre authentication</p>
    ///             </li>
    ///             <li>
    ///                 <p>User migration</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>When Amazon Cognito invokes the functions for these triggers, it passes a JSON
    ///             payload, which the function receives as input. This payload contains a
    ///                 <code>validationData</code> attribute, which provides the data that you assigned to
    ///             the ClientMetadata parameter in your InitiateAuth request. In your function code in AWS
    ///             Lambda, you can process the <code>validationData</code> value to enhance your workflow
    ///             for your specific needs.</p>
    ///
    ///         <p>When you use the InitiateAuth API action, Amazon Cognito also invokes the functions
    ///             for the following triggers, but it does not provide the ClientMetadata value as
    ///             input:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                 <p>Post authentication</p>
    ///             </li>
    ///             <li>
    ///                 <p>Custom message</p>
    ///             </li>
    ///             <li>
    ///                 <p>Pre token generation</p>
    ///             </li>
    ///             <li>
    ///                 <p>Create auth challenge</p>
    ///             </li>
    ///             <li>
    ///                 <p>Define auth challenge</p>
    ///             </li>
    ///             <li>
    ///                 <p>Verify auth challenge</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        authFlow: AuthFlowType? = nil,
        authParameters: [String:String]? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        userContextData: UserContextDataType? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.authFlow = authFlow
        self.authParameters = authParameters
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.userContextData = userContextData
    }
}

struct InitiateAuthInputBody: Equatable {
    public let authFlow: AuthFlowType?
    public let authParameters: [String:String]?
    public let clientMetadata: [String:String]?
    public let clientId: String?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let userContextData: UserContextDataType?
}

extension InitiateAuthInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case authFlow = "AuthFlow"
        case authParameters = "AuthParameters"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case userContextData = "UserContextData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authFlowDecoded = try containerValues.decodeIfPresent(AuthFlowType.self, forKey: .authFlow)
        authFlow = authFlowDecoded
        let authParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .authParameters)
        var authParametersDecoded0: [String:String]? = nil
        if let authParametersContainer = authParametersContainer {
            authParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in authParametersContainer {
                if let stringtype0 = stringtype0 {
                    authParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        authParameters = authParametersDecoded0
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
    }
}

extension InitiateAuthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateAuthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateAuthOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateAuthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateAuthOutputResponse(authenticationResult: \(String(describing: authenticationResult)), challengeName: \(String(describing: challengeName)), challengeParameters: \(String(describing: challengeParameters)), session: \(String(describing: session)))"}
}

extension InitiateAuthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InitiateAuthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationResult = output.authenticationResult
            self.challengeName = output.challengeName
            self.challengeParameters = output.challengeParameters
            self.session = output.session
        } else {
            self.authenticationResult = nil
            self.challengeName = nil
            self.challengeParameters = nil
            self.session = nil
        }
    }
}

/// <p>Initiates the authentication response.</p>
public struct InitiateAuthOutputResponse: Equatable {
    /// <p>The result of the authentication response. This is only returned if the caller does
    ///             not need to pass another challenge. If the caller does need to pass another challenge
    ///             before it gets tokens, <code>ChallengeName</code>, <code>ChallengeParameters</code>, and
    ///                 <code>Session</code> are returned.</p>
    public let authenticationResult: AuthenticationResultType?
    /// <p>The name of the challenge which you are responding to with this call. This is returned
    ///             to you in the <code>AdminInitiateAuth</code> response if you need to pass another
    ///             challenge.</p>
    ///         <p>Valid values include the following. Note that all of these challenges require
    ///                 <code>USERNAME</code> and <code>SECRET_HASH</code> (if applicable) in the
    ///             parameters.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SMS_MFA</code>: Next challenge is to supply an
    ///                     <code>SMS_MFA_CODE</code>, delivered via SMS.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PASSWORD_VERIFIER</code>: Next challenge is to supply
    ///                         <code>PASSWORD_CLAIM_SIGNATURE</code>,
    ///                         <code>PASSWORD_CLAIM_SECRET_BLOCK</code>, and <code>TIMESTAMP</code> after
    ///                     the client-side SRP calculations.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CUSTOM_CHALLENGE</code>: This is returned if your custom authentication
    ///                     flow determines that the user should pass another challenge before tokens are
    ///                     issued.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_SRP_AUTH</code>: If device tracking was enabled on your user pool
    ///                     and the previous challenges were passed, this challenge is returned so that
    ///                     Amazon Cognito can start tracking this device.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_PASSWORD_VERIFIER</code>: Similar to
    ///                         <code>PASSWORD_VERIFIER</code>, but for devices only.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NEW_PASSWORD_REQUIRED</code>: For users who are required to change their
    ///                     passwords after successful first login. This challenge should be passed with
    ///                         <code>NEW_PASSWORD</code> and any other required attributes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_SETUP</code>: For users who are required to setup an MFA factor
    ///                     before they can sign-in. The MFA types enabled for the user pool will be listed
    ///                     in the challenge parameters <code>MFA_CAN_SETUP</code> value. </p>
    ///                 <p> To setup software token MFA, use the session returned here from
    ///                         <code>InitiateAuth</code> as an input to
    ///                     <code>AssociateSoftwareToken</code>, and use the session returned by
    ///                         <code>VerifySoftwareToken</code> as an input to
    ///                         <code>RespondToAuthChallenge</code> with challenge name
    ///                         <code>MFA_SETUP</code> to complete sign-in. To setup SMS MFA, users will
    ///                     need help from an administrator to add a phone number to their account and then
    ///                     call <code>InitiateAuth</code> again to restart sign-in.</p>
    ///             </li>
    ///          </ul>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge parameters. These are returned to you in the <code>InitiateAuth</code>
    ///             response if you need to pass another challenge. The responses in this parameter should
    ///             be used to compute inputs to the next call (<code>RespondToAuthChallenge</code>). </p>
    ///         <p>All challenges require <code>USERNAME</code> and <code>SECRET_HASH</code> (if
    ///             applicable).</p>
    public let challengeParameters: [String:String]?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If the caller needs to go through another challenge, they return a session with
    ///             other challenge parameters. This session should be passed as it is to the next
    ///                 <code>RespondToAuthChallenge</code> API call.</p>
    public let session: String?

    public init (
        authenticationResult: AuthenticationResultType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeParameters: [String:String]? = nil,
        session: String? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.challengeName = challengeName
        self.challengeParameters = challengeParameters
        self.session = session
    }
}

struct InitiateAuthOutputResponseBody: Equatable {
    public let challengeName: ChallengeNameType?
    public let session: String?
    public let challengeParameters: [String:String]?
    public let authenticationResult: AuthenticationResultType?
}

extension InitiateAuthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationResult = "AuthenticationResult"
        case challengeName = "ChallengeName"
        case challengeParameters = "ChallengeParameters"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let challengeParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeParameters)
        var challengeParametersDecoded0: [String:String]? = nil
        if let challengeParametersContainer = challengeParametersContainer {
            challengeParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeParametersContainer {
                if let stringtype0 = stringtype0 {
                    challengeParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeParameters = challengeParametersDecoded0
        let authenticationResultDecoded = try containerValues.decodeIfPresent(AuthenticationResultType.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters an internal error.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message returned when Amazon Cognito throws an internal error exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEmailRoleAccessPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEmailRoleAccessPolicyException(message: \(String(describing: message)))"}
}

extension InvalidEmailRoleAccessPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEmailRoleAccessPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when Amazon Cognito is not allowed to use your email
///             identity. HTTP status code: 400.</p>
public struct InvalidEmailRoleAccessPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when you have an unverified email address or the identity policy
    ///             is not set on an email address that Amazon Cognito can access.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEmailRoleAccessPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEmailRoleAccessPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaResponseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLambdaResponseException(message: \(String(describing: message)))"}
}

extension InvalidLambdaResponseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLambdaResponseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid AWS
///             Lambda response.</p>
public struct InvalidLambdaResponseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service throws an invalid AWS Lambda
    ///             response exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaResponseExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLambdaResponseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOAuthFlowException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOAuthFlowException(message: \(String(describing: message)))"}
}

extension InvalidOAuthFlowException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOAuthFlowExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified OAuth flow is invalid.</p>
public struct InvalidOAuthFlowException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOAuthFlowExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOAuthFlowExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid
///             parameter.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service throws an invalid parameter
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPasswordException(message: \(String(describing: message)))"}
}

extension InvalidPasswordException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid
///             password.</p>
public struct InvalidPasswordException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service throws an invalid user password
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPasswordExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSmsRoleAccessPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSmsRoleAccessPolicyException(message: \(String(describing: message)))"}
}

extension InvalidSmsRoleAccessPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSmsRoleAccessPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is returned when the role provided for SMS configuration does not have
///             permission to publish using Amazon SNS.</p>
public struct InvalidSmsRoleAccessPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message retuned when the invalid SMS role access policy exception is
    ///             thrown.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSmsRoleAccessPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSmsRoleAccessPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSmsRoleTrustRelationshipException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSmsRoleTrustRelationshipException(message: \(String(describing: message)))"}
}

extension InvalidSmsRoleTrustRelationshipException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSmsRoleTrustRelationshipExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the trust relationship is invalid for the role provided
///             for SMS configuration. This can happen if you do not trust <b>cognito-idp.amazonaws.com</b> or the external ID provided in the role does
///             not match what is provided in the SMS configuration for the user pool.</p>
public struct InvalidSmsRoleTrustRelationshipException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the role trust relationship for the SMS message is
    ///             invalid.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSmsRoleTrustRelationshipExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSmsRoleTrustRelationshipExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserPoolConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUserPoolConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidUserPoolConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidUserPoolConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the user pool configuration is invalid.</p>
public struct InvalidUserPoolConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the user pool configuration is invalid.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUserPoolConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidUserPoolConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createAuthChallenge = "CreateAuthChallenge"
        case customEmailSender = "CustomEmailSender"
        case customMessage = "CustomMessage"
        case customSMSSender = "CustomSMSSender"
        case defineAuthChallenge = "DefineAuthChallenge"
        case kMSKeyID = "KMSKeyID"
        case postAuthentication = "PostAuthentication"
        case postConfirmation = "PostConfirmation"
        case preAuthentication = "PreAuthentication"
        case preSignUp = "PreSignUp"
        case preTokenGeneration = "PreTokenGeneration"
        case userMigration = "UserMigration"
        case verifyAuthChallengeResponse = "VerifyAuthChallengeResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createAuthChallenge = createAuthChallenge {
            try encodeContainer.encode(createAuthChallenge, forKey: .createAuthChallenge)
        }
        if let customEmailSender = customEmailSender {
            try encodeContainer.encode(customEmailSender, forKey: .customEmailSender)
        }
        if let customMessage = customMessage {
            try encodeContainer.encode(customMessage, forKey: .customMessage)
        }
        if let customSMSSender = customSMSSender {
            try encodeContainer.encode(customSMSSender, forKey: .customSMSSender)
        }
        if let defineAuthChallenge = defineAuthChallenge {
            try encodeContainer.encode(defineAuthChallenge, forKey: .defineAuthChallenge)
        }
        if let kMSKeyID = kMSKeyID {
            try encodeContainer.encode(kMSKeyID, forKey: .kMSKeyID)
        }
        if let postAuthentication = postAuthentication {
            try encodeContainer.encode(postAuthentication, forKey: .postAuthentication)
        }
        if let postConfirmation = postConfirmation {
            try encodeContainer.encode(postConfirmation, forKey: .postConfirmation)
        }
        if let preAuthentication = preAuthentication {
            try encodeContainer.encode(preAuthentication, forKey: .preAuthentication)
        }
        if let preSignUp = preSignUp {
            try encodeContainer.encode(preSignUp, forKey: .preSignUp)
        }
        if let preTokenGeneration = preTokenGeneration {
            try encodeContainer.encode(preTokenGeneration, forKey: .preTokenGeneration)
        }
        if let userMigration = userMigration {
            try encodeContainer.encode(userMigration, forKey: .userMigration)
        }
        if let verifyAuthChallengeResponse = verifyAuthChallengeResponse {
            try encodeContainer.encode(verifyAuthChallengeResponse, forKey: .verifyAuthChallengeResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignUpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preSignUp)
        preSignUp = preSignUpDecoded
        let customMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customMessage)
        customMessage = customMessageDecoded
        let postConfirmationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postConfirmation)
        postConfirmation = postConfirmationDecoded
        let preAuthenticationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preAuthentication)
        preAuthentication = preAuthenticationDecoded
        let postAuthenticationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postAuthentication)
        postAuthentication = postAuthenticationDecoded
        let defineAuthChallengeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defineAuthChallenge)
        defineAuthChallenge = defineAuthChallengeDecoded
        let createAuthChallengeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createAuthChallenge)
        createAuthChallenge = createAuthChallengeDecoded
        let verifyAuthChallengeResponseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verifyAuthChallengeResponse)
        verifyAuthChallengeResponse = verifyAuthChallengeResponseDecoded
        let preTokenGenerationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preTokenGeneration)
        preTokenGeneration = preTokenGenerationDecoded
        let userMigrationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userMigration)
        userMigration = userMigrationDecoded
        let customSMSSenderDecoded = try containerValues.decodeIfPresent(CustomSMSLambdaVersionConfigType.self, forKey: .customSMSSender)
        customSMSSender = customSMSSenderDecoded
        let customEmailSenderDecoded = try containerValues.decodeIfPresent(CustomEmailLambdaVersionConfigType.self, forKey: .customEmailSender)
        customEmailSender = customEmailSenderDecoded
        let kMSKeyIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyID)
        kMSKeyID = kMSKeyIDDecoded
    }
}

extension LambdaConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaConfigType(createAuthChallenge: \(String(describing: createAuthChallenge)), customEmailSender: \(String(describing: customEmailSender)), customMessage: \(String(describing: customMessage)), customSMSSender: \(String(describing: customSMSSender)), defineAuthChallenge: \(String(describing: defineAuthChallenge)), kMSKeyID: \(String(describing: kMSKeyID)), postAuthentication: \(String(describing: postAuthentication)), postConfirmation: \(String(describing: postConfirmation)), preAuthentication: \(String(describing: preAuthentication)), preSignUp: \(String(describing: preSignUp)), preTokenGeneration: \(String(describing: preTokenGeneration)), userMigration: \(String(describing: userMigration)), verifyAuthChallengeResponse: \(String(describing: verifyAuthChallengeResponse)))"}
}

/// <p>Specifies the configuration for AWS Lambda triggers.</p>
public struct LambdaConfigType: Equatable {
    /// <p>Creates an authentication challenge.</p>
    public let createAuthChallenge: String?
    /// <p>A custom email sender AWS Lambda trigger.</p>
    public let customEmailSender: CustomEmailLambdaVersionConfigType?
    /// <p>A custom Message AWS Lambda trigger.</p>
    public let customMessage: String?
    /// <p>A custom SMS sender AWS Lambda trigger.</p>
    public let customSMSSender: CustomSMSLambdaVersionConfigType?
    /// <p>Defines the authentication challenge.</p>
    public let defineAuthChallenge: String?
    /// <p>The Amazon Resource Name of Key Management Service <a href="/kms/latest/developerguide/concepts.html#master_keys">Customer master
    ///                 keys</a> . Amazon Cognito uses the key to encrypt codes and temporary passwords
    ///             sent to <code>CustomEmailSender</code> and <code>CustomSMSSender</code>.</p>
    public let kMSKeyID: String?
    /// <p>A post-authentication AWS Lambda trigger.</p>
    public let postAuthentication: String?
    /// <p>A post-confirmation AWS Lambda trigger.</p>
    public let postConfirmation: String?
    /// <p>A pre-authentication AWS Lambda trigger.</p>
    public let preAuthentication: String?
    /// <p>A pre-registration AWS Lambda trigger.</p>
    public let preSignUp: String?
    /// <p>A Lambda trigger that is invoked before token generation.</p>
    public let preTokenGeneration: String?
    /// <p>The user migration Lambda config type.</p>
    public let userMigration: String?
    /// <p>Verifies the authentication challenge response.</p>
    public let verifyAuthChallengeResponse: String?

    public init (
        createAuthChallenge: String? = nil,
        customEmailSender: CustomEmailLambdaVersionConfigType? = nil,
        customMessage: String? = nil,
        customSMSSender: CustomSMSLambdaVersionConfigType? = nil,
        defineAuthChallenge: String? = nil,
        kMSKeyID: String? = nil,
        postAuthentication: String? = nil,
        postConfirmation: String? = nil,
        preAuthentication: String? = nil,
        preSignUp: String? = nil,
        preTokenGeneration: String? = nil,
        userMigration: String? = nil,
        verifyAuthChallengeResponse: String? = nil
    )
    {
        self.createAuthChallenge = createAuthChallenge
        self.customEmailSender = customEmailSender
        self.customMessage = customMessage
        self.customSMSSender = customSMSSender
        self.defineAuthChallenge = defineAuthChallenge
        self.kMSKeyID = kMSKeyID
        self.postAuthentication = postAuthentication
        self.postConfirmation = postConfirmation
        self.preAuthentication = preAuthentication
        self.preSignUp = preSignUp
        self.preTokenGeneration = preTokenGeneration
        self.userMigration = userMigration
        self.verifyAuthChallengeResponse = verifyAuthChallengeResponse
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user exceeds the limit for a requested AWS
///             resource.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when Amazon Cognito throws a limit exceeded exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDevicesInputBodyMiddleware: Middleware {
    public let id: String = "ListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

extension ListDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesInput(accessToken: \(String(describing: accessToken)), limit: \(String(describing: limit)), paginationToken: \(String(describing: paginationToken)))"}
}

extension ListDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case limit = "Limit"
        case paginationToken = "PaginationToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
    }
}

public struct ListDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

/// <p>Represents the request to list the devices.</p>
public struct ListDevicesInput: Equatable {
    /// <p>The access tokens for the request to list devices.</p>
    public let accessToken: String?
    /// <p>The limit of the device request.</p>
    public let limit: Int?
    /// <p>The pagination token for the list request.</p>
    public let paginationToken: String?

    public init (
        accessToken: String? = nil,
        limit: Int? = nil,
        paginationToken: String? = nil
    )
    {
        self.accessToken = accessToken
        self.limit = limit
        self.paginationToken = paginationToken
    }
}

struct ListDevicesInputBody: Equatable {
    public let accessToken: String?
    public let limit: Int?
    public let paginationToken: String?
}

extension ListDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case limit = "Limit"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension ListDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesOutputResponse(devices: \(String(describing: devices)), paginationToken: \(String(describing: paginationToken)))"}
}

extension ListDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.paginationToken = output.paginationToken
        } else {
            self.devices = nil
            self.paginationToken = nil
        }
    }
}

/// <p>Represents the response to list devices.</p>
public struct ListDevicesOutputResponse: Equatable {
    /// <p>The devices returned in the list devices response.</p>
    public let devices: [DeviceType]?
    /// <p>The pagination token for the list device response.</p>
    public let paginationToken: String?

    public init (
        devices: [DeviceType]? = nil,
        paginationToken: String? = nil
    )
    {
        self.devices = devices
        self.paginationToken = paginationToken
    }
}

struct ListDevicesOutputResponseBody: Equatable {
    public let devices: [DeviceType]?
    public let paginationToken: String?
}

extension ListDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
        case paginationToken = "PaginationToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceType?].self, forKey: .devices)
        var devicesDecoded0:[DeviceType]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceType]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

public struct ListGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// <p>The limit of the request to list groups.</p>
    public let limit: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.userPoolId = userPoolId
    }
}

struct ListGroupsInputBody: Equatable {
    public let userPoolId: String?
    public let limit: Int?
    public let nextToken: String?
}

extension ListGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Equatable {
    /// <p>The group objects for the groups.</p>
    public let groups: [GroupType]?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        groups: [GroupType]? = nil,
        nextToken: String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groups: [GroupType]?
    public let nextToken: String?
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupType?].self, forKey: .groups)
        var groupsDecoded0:[GroupType]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupType]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIdentityProvidersInputBodyMiddleware: Middleware {
    public let id: String = "ListIdentityProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityProvidersInput>
    public typealias MOutput = OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityProvidersOutputError>
}

extension ListIdentityProvidersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityProvidersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListIdentityProvidersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListIdentityProvidersInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentityProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityProvidersInput>
    public typealias MOutput = OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentityProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityProvidersInput>
    public typealias MOutput = OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInput: Equatable {
    /// <p>The maximum number of identity providers to return.</p>
    public let maxResults: Int?
    /// <p>A pagination token.</p>
    public let nextToken: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userPoolId = userPoolId
    }
}

struct ListIdentityProvidersInputBody: Equatable {
    public let userPoolId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListIdentityProvidersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityProvidersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityProvidersOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityProvidersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityProvidersOutputResponse(nextToken: \(String(describing: nextToken)), providers: \(String(describing: providers)))"}
}

extension ListIdentityProvidersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentityProvidersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.providers = output.providers
        } else {
            self.nextToken = nil
            self.providers = nil
        }
    }
}

public struct ListIdentityProvidersOutputResponse: Equatable {
    /// <p>A pagination token.</p>
    public let nextToken: String?
    /// <p>A list of identity provider objects.</p>
    public let providers: [ProviderDescription]?

    public init (
        nextToken: String? = nil,
        providers: [ProviderDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.providers = providers
    }
}

struct ListIdentityProvidersOutputResponseBody: Equatable {
    public let providers: [ProviderDescription]?
    public let nextToken: String?
}

extension ListIdentityProvidersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case providers = "Providers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providersContainer = try containerValues.decodeIfPresent([ProviderDescription?].self, forKey: .providers)
        var providersDecoded0:[ProviderDescription]? = nil
        if let providersContainer = providersContainer {
            providersDecoded0 = [ProviderDescription]()
            for structure0 in providersContainer {
                if let structure0 = structure0 {
                    providersDecoded0?.append(structure0)
                }
            }
        }
        providers = providersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceServersInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceServersInput>
    public typealias MOutput = OperationOutput<ListResourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceServersOutputError>
}

extension ListResourceServersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceServersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListResourceServersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListResourceServersInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceServersInput>
    public typealias MOutput = OperationOutput<ListResourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceServersOutputError>
}

public struct ListResourceServersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceServersInput>
    public typealias MOutput = OperationOutput<ListResourceServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceServersOutputError>
}

public struct ListResourceServersInput: Equatable {
    /// <p>The maximum number of resource servers to return.</p>
    public let maxResults: Int
    /// <p>A pagination token.</p>
    public let nextToken: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userPoolId = userPoolId
    }
}

struct ListResourceServersInputBody: Equatable {
    public let userPoolId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListResourceServersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceServersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceServersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceServersOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceServersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceServersOutputResponse(nextToken: \(String(describing: nextToken)), resourceServers: \(String(describing: resourceServers)))"}
}

extension ListResourceServersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceServersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceServers = output.resourceServers
        } else {
            self.nextToken = nil
            self.resourceServers = nil
        }
    }
}

public struct ListResourceServersOutputResponse: Equatable {
    /// <p>A pagination token.</p>
    public let nextToken: String?
    /// <p>The resource servers.</p>
    public let resourceServers: [ResourceServerType]?

    public init (
        nextToken: String? = nil,
        resourceServers: [ResourceServerType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceServers = resourceServers
    }
}

struct ListResourceServersOutputResponseBody: Equatable {
    public let resourceServers: [ResourceServerType]?
    public let nextToken: String?
}

extension ListResourceServersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceServers = "ResourceServers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceServersContainer = try containerValues.decodeIfPresent([ResourceServerType?].self, forKey: .resourceServers)
        var resourceServersDecoded0:[ResourceServerType]? = nil
        if let resourceServersContainer = resourceServersContainer {
            resourceServersDecoded0 = [ResourceServerType]()
            for structure0 in resourceServersContainer {
                if let structure0 = structure0 {
                    resourceServersDecoded0?.append(structure0)
                }
            }
        }
        resourceServers = resourceServersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user pool that the tags are assigned to.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags that are assigned to the user pool.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListUserImportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListUserImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserImportJobsInput>
    public typealias MOutput = OperationOutput<ListUserImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserImportJobsOutputError>
}

extension ListUserImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserImportJobsInput(maxResults: \(String(describing: maxResults)), paginationToken: \(String(describing: paginationToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListUserImportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListUserImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserImportJobsInput>
    public typealias MOutput = OperationOutput<ListUserImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserImportJobsOutputError>
}

public struct ListUserImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserImportJobsInput>
    public typealias MOutput = OperationOutput<ListUserImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserImportJobsOutputError>
}

/// <p>Represents the request to list the user import jobs.</p>
public struct ListUserImportJobsInput: Equatable {
    /// <p>The maximum number of import jobs you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to
    ///                 <code>ListUserImportJobs</code>, which can be used to return the next set of import
    ///             jobs in the list.</p>
    public let paginationToken: String?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        maxResults: Int = 0,
        paginationToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.paginationToken = paginationToken
        self.userPoolId = userPoolId
    }
}

struct ListUserImportJobsInputBody: Equatable {
    public let userPoolId: String?
    public let maxResults: Int
    public let paginationToken: String?
}

extension ListUserImportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension ListUserImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserImportJobsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserImportJobsOutputResponse(paginationToken: \(String(describing: paginationToken)), userImportJobs: \(String(describing: userImportJobs)))"}
}

extension ListUserImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.userImportJobs = output.userImportJobs
        } else {
            self.paginationToken = nil
            self.userImportJobs = nil
        }
    }
}

/// <p>Represents the response from the server to the request to list the user import
///             jobs.</p>
public struct ListUserImportJobsOutputResponse: Equatable {
    /// <p>An identifier that can be used to return the next set of user import jobs in the
    ///             list.</p>
    public let paginationToken: String?
    /// <p>The user import jobs.</p>
    public let userImportJobs: [UserImportJobType]?

    public init (
        paginationToken: String? = nil,
        userImportJobs: [UserImportJobType]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.userImportJobs = userImportJobs
    }
}

struct ListUserImportJobsOutputResponseBody: Equatable {
    public let userImportJobs: [UserImportJobType]?
    public let paginationToken: String?
}

extension ListUserImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case userImportJobs = "UserImportJobs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userImportJobsContainer = try containerValues.decodeIfPresent([UserImportJobType?].self, forKey: .userImportJobs)
        var userImportJobsDecoded0:[UserImportJobType]? = nil
        if let userImportJobsContainer = userImportJobsContainer {
            userImportJobsDecoded0 = [UserImportJobType]()
            for structure0 in userImportJobsContainer {
                if let structure0 = structure0 {
                    userImportJobsDecoded0?.append(structure0)
                }
            }
        }
        userImportJobs = userImportJobsDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

public struct ListUserPoolClientsInputBodyMiddleware: Middleware {
    public let id: String = "ListUserPoolClientsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolClientsInput>
    public typealias MOutput = OperationOutput<ListUserPoolClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolClientsOutputError>
}

extension ListUserPoolClientsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoolClientsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListUserPoolClientsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListUserPoolClientsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserPoolClientsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolClientsInput>
    public typealias MOutput = OperationOutput<ListUserPoolClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolClientsOutputError>
}

public struct ListUserPoolClientsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserPoolClientsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolClientsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolClientsInput>
    public typealias MOutput = OperationOutput<ListUserPoolClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolClientsOutputError>
}

/// <p>Represents the request to list the user pool clients.</p>
public struct ListUserPoolClientsInput: Equatable {
    /// <p>The maximum number of results you want the request to return when listing the user
    ///             pool clients.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pool ID for the user pool where you want to list user pool clients.</p>
    public let userPoolId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userPoolId = userPoolId
    }
}

struct ListUserPoolClientsInputBody: Equatable {
    public let userPoolId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListUserPoolClientsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserPoolClientsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserPoolClientsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserPoolClientsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserPoolClientsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoolClientsOutputResponse(nextToken: \(String(describing: nextToken)), userPoolClients: \(String(describing: userPoolClients)))"}
}

extension ListUserPoolClientsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserPoolClientsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userPoolClients = output.userPoolClients
        } else {
            self.nextToken = nil
            self.userPoolClients = nil
        }
    }
}

/// <p>Represents the response from the server that lists user pool clients.</p>
public struct ListUserPoolClientsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pool clients in the response that lists user pool clients.</p>
    public let userPoolClients: [UserPoolClientDescription]?

    public init (
        nextToken: String? = nil,
        userPoolClients: [UserPoolClientDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.userPoolClients = userPoolClients
    }
}

struct ListUserPoolClientsOutputResponseBody: Equatable {
    public let userPoolClients: [UserPoolClientDescription]?
    public let nextToken: String?
}

extension ListUserPoolClientsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userPoolClients = "UserPoolClients"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolClientsContainer = try containerValues.decodeIfPresent([UserPoolClientDescription?].self, forKey: .userPoolClients)
        var userPoolClientsDecoded0:[UserPoolClientDescription]? = nil
        if let userPoolClientsContainer = userPoolClientsContainer {
            userPoolClientsDecoded0 = [UserPoolClientDescription]()
            for structure0 in userPoolClientsContainer {
                if let structure0 = structure0 {
                    userPoolClientsDecoded0?.append(structure0)
                }
            }
        }
        userPoolClients = userPoolClientsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUserPoolsInputBodyMiddleware: Middleware {
    public let id: String = "ListUserPoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolsInput>
    public typealias MOutput = OperationOutput<ListUserPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolsOutputError>
}

extension ListUserPoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoolsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUserPoolsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUserPoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListUserPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolsInput>
    public typealias MOutput = OperationOutput<ListUserPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolsOutputError>
}

public struct ListUserPoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUserPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUserPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUserPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUserPoolsInput>
    public typealias MOutput = OperationOutput<ListUserPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUserPoolsOutputError>
}

/// <p>Represents the request to list user pools.</p>
public struct ListUserPoolsInput: Equatable {
    /// <p>The maximum number of results you want the request to return when listing the user
    ///             pools.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserPoolsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListUserPoolsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUserPoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserPoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserPoolsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserPoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUserPoolsOutputResponse(nextToken: \(String(describing: nextToken)), userPools: \(String(describing: userPools)))"}
}

extension ListUserPoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUserPoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.userPools = output.userPools
        } else {
            self.nextToken = nil
            self.userPools = nil
        }
    }
}

/// <p>Represents the response to list user pools.</p>
public struct ListUserPoolsOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pools from the response to list users.</p>
    public let userPools: [UserPoolDescriptionType]?

    public init (
        nextToken: String? = nil,
        userPools: [UserPoolDescriptionType]? = nil
    )
    {
        self.nextToken = nextToken
        self.userPools = userPools
    }
}

struct ListUserPoolsOutputResponseBody: Equatable {
    public let userPools: [UserPoolDescriptionType]?
    public let nextToken: String?
}

extension ListUserPoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case userPools = "UserPools"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolsContainer = try containerValues.decodeIfPresent([UserPoolDescriptionType?].self, forKey: .userPools)
        var userPoolsDecoded0:[UserPoolDescriptionType]? = nil
        if let userPoolsContainer = userPoolsContainer {
            userPoolsDecoded0 = [UserPoolDescriptionType]()
            for structure0 in userPoolsContainer {
                if let structure0 = structure0 {
                    userPoolsDecoded0?.append(structure0)
                }
            }
        }
        userPools = userPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUsersInGroupInputBodyMiddleware: Middleware {
    public let id: String = "ListUsersInGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersInGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInGroupInput>
    public typealias MOutput = OperationOutput<ListUsersInGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersInGroupOutputError>
}

extension ListUsersInGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInGroupInput(groupName: \(String(describing: groupName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListUsersInGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListUsersInGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersInGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInGroupInput>
    public typealias MOutput = OperationOutput<ListUsersInGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersInGroupOutputError>
}

public struct ListUsersInGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersInGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInGroupInput>
    public typealias MOutput = OperationOutput<ListUsersInGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersInGroupOutputError>
}

public struct ListUsersInGroupInput: Equatable {
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The limit of the request to list users.</p>
    public let limit: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        groupName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.groupName = groupName
        self.limit = limit
        self.nextToken = nextToken
        self.userPoolId = userPoolId
    }
}

struct ListUsersInGroupInputBody: Equatable {
    public let userPoolId: String?
    public let groupName: String?
    public let limit: Int?
    public let nextToken: String?
}

extension ListUsersInGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupName = "GroupName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersInGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersInGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersInGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersInGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInGroupOutputResponse(nextToken: \(String(describing: nextToken)), users: \(String(describing: users)))"}
}

extension ListUsersInGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersInGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersInGroupOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The users returned in the request to list users.</p>
    public let users: [UserType]?

    public init (
        nextToken: String? = nil,
        users: [UserType]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersInGroupOutputResponseBody: Equatable {
    public let users: [UserType]?
    public let nextToken: String?
}

extension ListUsersInGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([UserType?].self, forKey: .users)
        var usersDecoded0:[UserType]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserType]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUsersInputBodyMiddleware: Middleware {
    public let id: String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(attributesToGet: \(String(describing: attributesToGet)), filter: \(String(describing: filter)), limit: \(String(describing: limit)), paginationToken: \(String(describing: paginationToken)), userPoolId: \(String(describing: userPoolId)))"}
}

extension ListUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributesToGet = "AttributesToGet"
        case filter = "Filter"
        case limit = "Limit"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesToGet = attributesToGet {
            var attributesToGetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToGet)
            for searchedattributenameslisttype0 in attributesToGet {
                try attributesToGetContainer.encode(searchedattributenameslisttype0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let paginationToken = paginationToken {
            try encodeContainer.encode(paginationToken, forKey: .paginationToken)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

/// <p>Represents the request to list users.</p>
public struct ListUsersInput: Equatable {
    /// <p>An array of strings, where each string is the name of a user attribute to be returned
    ///             for each user in the search results. If the array is null, all attributes are
    ///             returned.</p>
    public let attributesToGet: [String]?
    /// <p>A filter string of the form "<i>AttributeName</i>
    ///             <i>Filter-Type</i> "<i>AttributeValue</i>"". Quotation marks
    ///             within the filter string must be escaped using the backslash (\) character. For example,
    ///                 "<code>family_name</code> = \"Reddy\"".</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <i>AttributeName</i>: The name of the attribute to search for.
    ///                     You can only search for one attribute at a time.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>Filter-Type</i>: For an exact match, use =, for example,
    ///                         "<code>given_name</code> = \"Jon\"". For a prefix ("starts with") match, use
    ///                     ^=, for example, "<code>given_name</code> ^= \"Jon\"". </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <i>AttributeValue</i>: The attribute value that must be matched
    ///                     for each user.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If the filter string is empty, <code>ListUsers</code> returns all users in the user
    ///             pool.</p>
    ///         <p>You can only search for the following standard attributes:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>username</code> (case-sensitive)</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>email</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>phone_number</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>name</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>given_name</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>family_name</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>preferred_username</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>cognito:user_status</code> (called <b>Status</b> in the Console) (case-insensitive)</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>status (called <b>Enabled</b> in the Console)
    ///                         (case-sensitive)</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>sub</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <p>Custom attributes are not searchable.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/how-to-manage-user-accounts.html#cognito-user-pools-searching-for-users-using-listusers-api">Searching for Users Using the ListUsers API</a> and <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/how-to-manage-user-accounts.html#cognito-user-pools-searching-for-users-listusers-api-examples">Examples of Using the ListUsers API</a> in the <i>Amazon Cognito
    ///                 Developer Guide</i>.</p>
    public let filter: String?
    /// <p>Maximum number of users to be returned.</p>
    public let limit: Int?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let paginationToken: String?
    /// <p>The user pool ID for the user pool on which the search should be performed.</p>
    public let userPoolId: String?

    public init (
        attributesToGet: [String]? = nil,
        filter: String? = nil,
        limit: Int? = nil,
        paginationToken: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.attributesToGet = attributesToGet
        self.filter = filter
        self.limit = limit
        self.paginationToken = paginationToken
        self.userPoolId = userPoolId
    }
}

struct ListUsersInputBody: Equatable {
    public let userPoolId: String?
    public let attributesToGet: [String]?
    public let limit: Int?
    public let paginationToken: String?
    public let filter: String?
}

extension ListUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesToGet = "AttributesToGet"
        case filter = "Filter"
        case limit = "Limit"
        case paginationToken = "PaginationToken"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let attributesToGetContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributesToGet)
        var attributesToGetDecoded0:[String]? = nil
        if let attributesToGetContainer = attributesToGetContainer {
            attributesToGetDecoded0 = [String]()
            for string0 in attributesToGetContainer {
                if let string0 = string0 {
                    attributesToGetDecoded0?.append(string0)
                }
            }
        }
        attributesToGet = attributesToGetDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(paginationToken: \(String(describing: paginationToken)), users: \(String(describing: users)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.paginationToken = output.paginationToken
            self.users = output.users
        } else {
            self.paginationToken = nil
            self.users = nil
        }
    }
}

/// <p>The response from the request to list users.</p>
public struct ListUsersOutputResponse: Equatable {
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///             used to return the next set of items in the list.</p>
    public let paginationToken: String?
    /// <p>The users returned in the request to list users.</p>
    public let users: [UserType]?

    public init (
        paginationToken: String? = nil,
        users: [UserType]? = nil
    )
    {
        self.paginationToken = paginationToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let users: [UserType]?
    public let paginationToken: String?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case paginationToken = "PaginationToken"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([UserType?].self, forKey: .users)
        var usersDecoded0:[UserType]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserType]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
    }
}

extension MFAMethodNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MFAMethodNotFoundException(message: \(String(describing: message)))"}
}

extension MFAMethodNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MFAMethodNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when Amazon Cognito cannot find a multi-factor authentication
///             (MFA) method.</p>
public struct MFAMethodNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when Amazon Cognito throws an MFA method not found
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MFAMethodNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension MFAMethodNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MFAOptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case deliveryMedium = "DeliveryMedium"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let deliveryMedium = deliveryMedium {
            try encodeContainer.encode(deliveryMedium.rawValue, forKey: .deliveryMedium)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMediumDecoded = try containerValues.decodeIfPresent(DeliveryMediumType.self, forKey: .deliveryMedium)
        deliveryMedium = deliveryMediumDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
    }
}

extension MFAOptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MFAOptionType(attributeName: \(String(describing: attributeName)), deliveryMedium: \(String(describing: deliveryMedium)))"}
}

/// <p>
///             <i>This data type is no longer supported.</i> You can use it only for
///             SMS MFA configurations. You can't use it for TOTP software token MFA
///             configurations.</p>
public struct MFAOptionType: Equatable {
    /// <p>The attribute name of the MFA option type. The only valid value is
    ///                 <code>phone_number</code>.</p>
    public let attributeName: String?
    /// <p>The delivery medium to send the MFA code. You can use this parameter to set only the
    ///                 <code>SMS</code> delivery medium value.</p>
    public let deliveryMedium: DeliveryMediumType?

    public init (
        attributeName: String? = nil,
        deliveryMedium: DeliveryMediumType? = nil
    )
    {
        self.attributeName = attributeName
        self.deliveryMedium = deliveryMedium
    }
}

public enum MessageActionType {
    case resend
    case suppress
    case sdkUnknown(String)
}

extension MessageActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageActionType] {
        return [
            .resend,
            .suppress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resend: return "RESEND"
        case .suppress: return "SUPPRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageActionType(rawValue: rawValue) ?? MessageActionType.sdkUnknown(rawValue)
    }
}

extension MessageTemplateType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailMessage = "EmailMessage"
        case emailSubject = "EmailSubject"
        case sMSMessage = "SMSMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailSubject = emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
        if let sMSMessage = sMSMessage {
            try encodeContainer.encode(sMSMessage, forKey: .sMSMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sMSMessage)
        sMSMessage = sMSMessageDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
    }
}

extension MessageTemplateType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageTemplateType(emailMessage: \(String(describing: emailMessage)), emailSubject: \(String(describing: emailSubject)), sMSMessage: \(String(describing: sMSMessage)))"}
}

/// <p>The message template structure.</p>
public struct MessageTemplateType: Equatable {
    /// <p>The message template for email messages. EmailMessage is allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount">EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailMessage: String?
    /// <p>The subject line for email messages. EmailSubject is allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount">EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailSubject: String?
    /// <p>The message template for SMS messages.</p>
    public let sMSMessage: String?

    public init (
        emailMessage: String? = nil,
        emailSubject: String? = nil,
        sMSMessage: String? = nil
    )
    {
        self.emailMessage = emailMessage
        self.emailSubject = emailSubject
        self.sMSMessage = sMSMessage
    }
}

extension NewDeviceMetadataType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceGroupKey = "DeviceGroupKey"
        case deviceKey = "DeviceKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceGroupKey = deviceGroupKey {
            try encodeContainer.encode(deviceGroupKey, forKey: .deviceGroupKey)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let deviceGroupKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceGroupKey)
        deviceGroupKey = deviceGroupKeyDecoded
    }
}

extension NewDeviceMetadataType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NewDeviceMetadataType(deviceGroupKey: \(String(describing: deviceGroupKey)), deviceKey: \(String(describing: deviceKey)))"}
}

/// <p>The new device metadata type.</p>
public struct NewDeviceMetadataType: Equatable {
    /// <p>The device group key.</p>
    public let deviceGroupKey: String?
    /// <p>The device key.</p>
    public let deviceKey: String?

    public init (
        deviceGroupKey: String? = nil,
        deviceKey: String? = nil
    )
    {
        self.deviceGroupKey = deviceGroupKey
        self.deviceKey = deviceKey
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user is not authorized.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns a not authorized
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotifyConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockEmail = "BlockEmail"
        case from = "From"
        case mfaEmail = "MfaEmail"
        case noActionEmail = "NoActionEmail"
        case replyTo = "ReplyTo"
        case sourceArn = "SourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockEmail = blockEmail {
            try encodeContainer.encode(blockEmail, forKey: .blockEmail)
        }
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let mfaEmail = mfaEmail {
            try encodeContainer.encode(mfaEmail, forKey: .mfaEmail)
        }
        if let noActionEmail = noActionEmail {
            try encodeContainer.encode(noActionEmail, forKey: .noActionEmail)
        }
        if let replyTo = replyTo {
            try encodeContainer.encode(replyTo, forKey: .replyTo)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(String.self, forKey: .from)
        from = fromDecoded
        let replyToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replyTo)
        replyTo = replyToDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let blockEmailDecoded = try containerValues.decodeIfPresent(NotifyEmailType.self, forKey: .blockEmail)
        blockEmail = blockEmailDecoded
        let noActionEmailDecoded = try containerValues.decodeIfPresent(NotifyEmailType.self, forKey: .noActionEmail)
        noActionEmail = noActionEmailDecoded
        let mfaEmailDecoded = try containerValues.decodeIfPresent(NotifyEmailType.self, forKey: .mfaEmail)
        mfaEmail = mfaEmailDecoded
    }
}

extension NotifyConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyConfigurationType(blockEmail: \(String(describing: blockEmail)), from: \(String(describing: from)), mfaEmail: \(String(describing: mfaEmail)), noActionEmail: \(String(describing: noActionEmail)), replyTo: \(String(describing: replyTo)), sourceArn: \(String(describing: sourceArn)))"}
}

/// <p>The notify configuration type.</p>
public struct NotifyConfigurationType: Equatable {
    /// <p>Email template used when a detected risk event is blocked.</p>
    public let blockEmail: NotifyEmailType?
    /// <p>The email address that is sending the email. It must be either individually verified
    ///             with Amazon SES, or from a domain that has been verified with Amazon SES.</p>
    public let from: String?
    /// <p>The MFA email template used when MFA is challenged as part of a detected risk.</p>
    public let mfaEmail: NotifyEmailType?
    /// <p>The email template used when a detected risk event is allowed.</p>
    public let noActionEmail: NotifyEmailType?
    /// <p>The destination to which the receiver of an email should reply to.</p>
    public let replyTo: String?
    /// <p>The Amazon Resource Name (ARN) of the identity that is associated with the sending
    ///             authorization policy. It permits Amazon Cognito to send for the email address specified
    ///             in the <code>From</code> parameter.</p>
    public let sourceArn: String?

    public init (
        blockEmail: NotifyEmailType? = nil,
        from: String? = nil,
        mfaEmail: NotifyEmailType? = nil,
        noActionEmail: NotifyEmailType? = nil,
        replyTo: String? = nil,
        sourceArn: String? = nil
    )
    {
        self.blockEmail = blockEmail
        self.from = from
        self.mfaEmail = mfaEmail
        self.noActionEmail = noActionEmail
        self.replyTo = replyTo
        self.sourceArn = sourceArn
    }
}

extension NotifyEmailType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case htmlBody = "HtmlBody"
        case subject = "Subject"
        case textBody = "TextBody"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let htmlBody = htmlBody {
            try encodeContainer.encode(htmlBody, forKey: .htmlBody)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let textBody = textBody {
            try encodeContainer.encode(textBody, forKey: .textBody)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let htmlBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .htmlBody)
        htmlBody = htmlBodyDecoded
        let textBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textBody)
        textBody = textBodyDecoded
    }
}

extension NotifyEmailType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyEmailType(htmlBody: \(String(describing: htmlBody)), subject: \(String(describing: subject)), textBody: \(String(describing: textBody)))"}
}

/// <p>The notify email type.</p>
public struct NotifyEmailType: Equatable {
    /// <p>The HTML body.</p>
    public let htmlBody: String?
    /// <p>The subject.</p>
    public let subject: String?
    /// <p>The text body.</p>
    public let textBody: String?

    public init (
        htmlBody: String? = nil,
        subject: String? = nil,
        textBody: String? = nil
    )
    {
        self.htmlBody = htmlBody
        self.subject = subject
        self.textBody = textBody
    }
}

extension NumberAttributeConstraintsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxValue)
        maxValue = maxValueDecoded
    }
}

extension NumberAttributeConstraintsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberAttributeConstraintsType(maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)))"}
}

/// <p>The minimum and maximum value of an attribute that is of the number data type.</p>
public struct NumberAttributeConstraintsType: Equatable {
    /// <p>The maximum value of an attribute that is of the number data type.</p>
    public let maxValue: String?
    /// <p>The minimum value of an attribute that is of the number data type.</p>
    public let minValue: String?

    public init (
        maxValue: String? = nil,
        minValue: String? = nil
    )
    {
        self.maxValue = maxValue
        self.minValue = minValue
    }
}

public enum OAuthFlowType {
    case clientCredentials
    case code
    case implicit
    case sdkUnknown(String)
}

extension OAuthFlowType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OAuthFlowType] {
        return [
            .clientCredentials,
            .code,
            .implicit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .clientCredentials: return "client_credentials"
        case .code: return "code"
        case .implicit: return "implicit"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OAuthFlowType(rawValue: rawValue) ?? OAuthFlowType.sdkUnknown(rawValue)
    }
}

extension PasswordPolicyType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case minimumLength = "MinimumLength"
        case requireLowercase = "RequireLowercase"
        case requireNumbers = "RequireNumbers"
        case requireSymbols = "RequireSymbols"
        case requireUppercase = "RequireUppercase"
        case temporaryPasswordValidityDays = "TemporaryPasswordValidityDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if minimumLength != 0 {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
        if requireLowercase != false {
            try encodeContainer.encode(requireLowercase, forKey: .requireLowercase)
        }
        if requireNumbers != false {
            try encodeContainer.encode(requireNumbers, forKey: .requireNumbers)
        }
        if requireSymbols != false {
            try encodeContainer.encode(requireSymbols, forKey: .requireSymbols)
        }
        if requireUppercase != false {
            try encodeContainer.encode(requireUppercase, forKey: .requireUppercase)
        }
        if temporaryPasswordValidityDays != 0 {
            try encodeContainer.encode(temporaryPasswordValidityDays, forKey: .temporaryPasswordValidityDays)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumLengthDecoded = try containerValues.decode(Int.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
        let requireUppercaseDecoded = try containerValues.decode(Bool.self, forKey: .requireUppercase)
        requireUppercase = requireUppercaseDecoded
        let requireLowercaseDecoded = try containerValues.decode(Bool.self, forKey: .requireLowercase)
        requireLowercase = requireLowercaseDecoded
        let requireNumbersDecoded = try containerValues.decode(Bool.self, forKey: .requireNumbers)
        requireNumbers = requireNumbersDecoded
        let requireSymbolsDecoded = try containerValues.decode(Bool.self, forKey: .requireSymbols)
        requireSymbols = requireSymbolsDecoded
        let temporaryPasswordValidityDaysDecoded = try containerValues.decode(Int.self, forKey: .temporaryPasswordValidityDays)
        temporaryPasswordValidityDays = temporaryPasswordValidityDaysDecoded
    }
}

extension PasswordPolicyType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PasswordPolicyType(minimumLength: \(String(describing: minimumLength)), requireLowercase: \(String(describing: requireLowercase)), requireNumbers: \(String(describing: requireNumbers)), requireSymbols: \(String(describing: requireSymbols)), requireUppercase: \(String(describing: requireUppercase)), temporaryPasswordValidityDays: \(String(describing: temporaryPasswordValidityDays)))"}
}

/// <p>The password policy type.</p>
public struct PasswordPolicyType: Equatable {
    /// <p>The minimum length of the password policy that you have set. Cannot be less than
    ///             6.</p>
    public let minimumLength: Int
    /// <p>In the password policy that you have set, refers to whether you have required users to
    ///             use at least one lowercase letter in their password.</p>
    public let requireLowercase: Bool
    /// <p>In the password policy that you have set, refers to whether you have required users to
    ///             use at least one number in their password.</p>
    public let requireNumbers: Bool
    /// <p>In the password policy that you have set, refers to whether you have required users to
    ///             use at least one symbol in their password.</p>
    public let requireSymbols: Bool
    /// <p>In the password policy that you have set, refers to whether you have required users to
    ///             use at least one uppercase letter in their password.</p>
    public let requireUppercase: Bool
    /// <p>In the password policy you have set, refers to the number of days a temporary password
    ///             is valid. If the user does not sign-in during this time, their password will need to be
    ///             reset by an administrator.</p>
    ///         <note>
    ///             <p>When you set <code>TemporaryPasswordValidityDays</code> for a user pool, you will
    ///                 no longer be able to set the deprecated <code>UnusedAccountValidityDays</code> value
    ///                 for that user pool.</p>
    ///         </note>
    public let temporaryPasswordValidityDays: Int

    public init (
        minimumLength: Int = 0,
        requireLowercase: Bool = false,
        requireNumbers: Bool = false,
        requireSymbols: Bool = false,
        requireUppercase: Bool = false,
        temporaryPasswordValidityDays: Int = 0
    )
    {
        self.minimumLength = minimumLength
        self.requireLowercase = requireLowercase
        self.requireNumbers = requireNumbers
        self.requireSymbols = requireSymbols
        self.requireUppercase = requireUppercase
        self.temporaryPasswordValidityDays = temporaryPasswordValidityDays
    }
}

extension PasswordResetRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PasswordResetRequiredException(message: \(String(describing: message)))"}
}

extension PasswordResetRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PasswordResetRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a password reset is required.</p>
public struct PasswordResetRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when a password reset is required.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PasswordResetRequiredExceptionBody: Equatable {
    public let message: String?
}

extension PasswordResetRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionNotMetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionNotMetException(message: \(String(describing: message)))"}
}

extension PreconditionNotMetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a precondition is not met.</p>
public struct PreconditionNotMetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when a precondition is not met.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionNotMetExceptionBody: Equatable {
    public let message: String?
}

extension PreconditionNotMetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PreventUserExistenceErrorTypes {
    case enabled
    case legacy
    case sdkUnknown(String)
}

extension PreventUserExistenceErrorTypes : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PreventUserExistenceErrorTypes] {
        return [
            .enabled,
            .legacy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enabled: return "ENABLED"
        case .legacy: return "LEGACY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PreventUserExistenceErrorTypes(rawValue: rawValue) ?? PreventUserExistenceErrorTypes.sdkUnknown(rawValue)
    }
}

extension ProviderDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case providerName = "ProviderName"
        case providerType = "ProviderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderTypeType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension ProviderDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProviderDescription(creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), providerName: \(String(describing: providerName)), providerType: \(String(describing: providerType)))"}
}

/// <p>A container for identity provider details.</p>
public struct ProviderDescription: Equatable {
    /// <p>The date the provider was added to the user pool.</p>
    public let creationDate: Date?
    /// <p>The date the provider was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The identity provider type.</p>
    public let providerType: IdentityProviderTypeType?

    public init (
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        providerName: String? = nil,
        providerType: IdentityProviderTypeType? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.providerName = providerName
        self.providerType = providerType
    }
}

extension ProviderUserIdentifierType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case providerAttributeName = "ProviderAttributeName"
        case providerAttributeValue = "ProviderAttributeValue"
        case providerName = "ProviderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let providerAttributeName = providerAttributeName {
            try encodeContainer.encode(providerAttributeName, forKey: .providerAttributeName)
        }
        if let providerAttributeValue = providerAttributeValue {
            try encodeContainer.encode(providerAttributeValue, forKey: .providerAttributeValue)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerAttributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerAttributeName)
        providerAttributeName = providerAttributeNameDecoded
        let providerAttributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerAttributeValue)
        providerAttributeValue = providerAttributeValueDecoded
    }
}

extension ProviderUserIdentifierType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProviderUserIdentifierType(providerAttributeName: \(String(describing: providerAttributeName)), providerAttributeValue: \(String(describing: providerAttributeValue)), providerName: \(String(describing: providerName)))"}
}

/// <p>A container for information about an identity provider for a user pool.</p>
public struct ProviderUserIdentifierType: Equatable {
    /// <p>The name of the provider attribute to link to, for example,
    ///             <code>NameID</code>.</p>
    public let providerAttributeName: String?
    /// <p>The value of the provider attribute to link to, for example,
    ///                 <code>xxxxx_account</code>.</p>
    public let providerAttributeValue: String?
    /// <p>The name of the provider, for example, Facebook, Google, or Login with Amazon.</p>
    public let providerName: String?

    public init (
        providerAttributeName: String? = nil,
        providerAttributeValue: String? = nil,
        providerName: String? = nil
    )
    {
        self.providerAttributeName = providerAttributeName
        self.providerAttributeValue = providerAttributeValue
        self.providerName = providerName
    }
}

public enum RecoveryOptionNameType {
    case adminOnly
    case verifiedEmail
    case verifiedPhoneNumber
    case sdkUnknown(String)
}

extension RecoveryOptionNameType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecoveryOptionNameType] {
        return [
            .adminOnly,
            .verifiedEmail,
            .verifiedPhoneNumber,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adminOnly: return "admin_only"
        case .verifiedEmail: return "verified_email"
        case .verifiedPhoneNumber: return "verified_phone_number"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecoveryOptionNameType(rawValue: rawValue) ?? RecoveryOptionNameType.sdkUnknown(rawValue)
    }
}

extension RecoveryOptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let nameDecoded = try containerValues.decodeIfPresent(RecoveryOptionNameType.self, forKey: .name)
        name = nameDecoded
    }
}

extension RecoveryOptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecoveryOptionType(name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

/// <p>A map containing a priority as a key, and recovery method name as a value.</p>
public struct RecoveryOptionType: Equatable {
    /// <p>Specifies the recovery method for a user.</p>
    public let name: RecoveryOptionNameType?
    /// <p>A positive integer specifying priority of a method with 1 being the highest
    ///             priority.</p>
    public let priority: Int

    public init (
        name: RecoveryOptionNameType? = nil,
        priority: Int = 0
    )
    {
        self.name = name
        self.priority = priority
    }
}

public struct ResendConfirmationCodeInputBodyMiddleware: Middleware {
    public let id: String = "ResendConfirmationCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendConfirmationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendConfirmationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendConfirmationCodeInput>
    public typealias MOutput = OperationOutput<ResendConfirmationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendConfirmationCodeOutputError>
}

extension ResendConfirmationCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResendConfirmationCodeInput(analyticsMetadata: \(String(describing: analyticsMetadata)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), secretHash: \(String(describing: secretHash)), userContextData: \(String(describing: userContextData)), username: \(String(describing: username)))"}
}

extension ResendConfirmationCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let secretHash = secretHash {
            try encodeContainer.encode(secretHash, forKey: .secretHash)
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct ResendConfirmationCodeInputHeadersMiddleware: Middleware {
    public let id: String = "ResendConfirmationCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendConfirmationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendConfirmationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendConfirmationCodeInput>
    public typealias MOutput = OperationOutput<ResendConfirmationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendConfirmationCodeOutputError>
}

public struct ResendConfirmationCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "ResendConfirmationCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResendConfirmationCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<ResendConfirmationCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResendConfirmationCodeInput>
    public typealias MOutput = OperationOutput<ResendConfirmationCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResendConfirmationCodeOutputError>
}

/// <p>Represents the request to resend the confirmation code.</p>
public struct ResendConfirmationCodeInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>ResendConfirmationCode</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the ResendConfirmationCode API action, Amazon Cognito invokes the function
    ///             that is assigned to the <i>custom message</i> trigger. When Amazon Cognito
    ///             invokes this function, it passes a JSON payload, which the function receives as input.
    ///             This payload contains a <code>clientMetadata</code> attribute, which provides the data
    ///             that you assigned to the ClientMetadata parameter in your ResendConfirmationCode
    ///             request. In your function code in AWS Lambda, you can process the
    ///                 <code>clientMetadata</code> value to enhance your workflow for your specific
    ///             needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>A keyed-hash message authentication code (HMAC) calculated using the secret key of a
    ///             user pool client and username plus the client ID in the message.</p>
    public let secretHash: String?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?
    /// <p>The user name of the user to whom you wish to resend a confirmation code.</p>
    public let username: String?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        secretHash: String? = nil,
        userContextData: UserContextDataType? = nil,
        username: String? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.secretHash = secretHash
        self.userContextData = userContextData
        self.username = username
    }
}

struct ResendConfirmationCodeInputBody: Equatable {
    public let clientId: String?
    public let secretHash: String?
    public let userContextData: UserContextDataType?
    public let username: String?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let clientMetadata: [String:String]?
}

extension ResendConfirmationCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case secretHash = "SecretHash"
        case userContextData = "UserContextData"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let secretHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretHash)
        secretHash = secretHashDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension ResendConfirmationCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResendConfirmationCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResendConfirmationCodeOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResendConfirmationCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResendConfirmationCodeOutputResponse(codeDeliveryDetails: \(String(describing: codeDeliveryDetails)))"}
}

extension ResendConfirmationCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResendConfirmationCodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeDeliveryDetails = output.codeDeliveryDetails
        } else {
            self.codeDeliveryDetails = nil
        }
    }
}

/// <p>The response from the server when the Amazon Cognito Your User Pools service makes the
///             request to resend a confirmation code.</p>
public struct ResendConfirmationCodeOutputResponse: Equatable {
    /// <p>The code delivery details returned by the server in response to the request to resend
    ///             the confirmation code.</p>
    public let codeDeliveryDetails: CodeDeliveryDetailsType?

    public init (
        codeDeliveryDetails: CodeDeliveryDetailsType? = nil
    )
    {
        self.codeDeliveryDetails = codeDeliveryDetails
    }
}

struct ResendConfirmationCodeOutputResponseBody: Equatable {
    public let codeDeliveryDetails: CodeDeliveryDetailsType?
}

extension ResendConfirmationCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeDeliveryDetails = "CodeDeliveryDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDeliveryDetailsDecoded = try containerValues.decodeIfPresent(CodeDeliveryDetailsType.self, forKey: .codeDeliveryDetails)
        codeDeliveryDetails = codeDeliveryDetailsDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service cannot find the requested
///             resource.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns a resource not found
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceServerScopeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scopeDescription = "ScopeDescription"
        case scopeName = "ScopeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scopeDescription = scopeDescription {
            try encodeContainer.encode(scopeDescription, forKey: .scopeDescription)
        }
        if let scopeName = scopeName {
            try encodeContainer.encode(scopeName, forKey: .scopeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scopeName)
        scopeName = scopeNameDecoded
        let scopeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scopeDescription)
        scopeDescription = scopeDescriptionDecoded
    }
}

extension ResourceServerScopeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceServerScopeType(scopeDescription: \(String(describing: scopeDescription)), scopeName: \(String(describing: scopeName)))"}
}

/// <p>A resource server scope.</p>
public struct ResourceServerScopeType: Equatable {
    /// <p>A description of the scope.</p>
    public let scopeDescription: String?
    /// <p>The name of the scope.</p>
    public let scopeName: String?

    public init (
        scopeDescription: String? = nil,
        scopeName: String? = nil
    )
    {
        self.scopeDescription = scopeDescription
        self.scopeName = scopeName
    }
}

extension ResourceServerType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case name = "Name"
        case scopes = "Scopes"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for resourceserverscopelisttype0 in scopes {
                try scopesContainer.encode(resourceserverscopelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopesContainer = try containerValues.decodeIfPresent([ResourceServerScopeType?].self, forKey: .scopes)
        var scopesDecoded0:[ResourceServerScopeType]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [ResourceServerScopeType]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension ResourceServerType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceServerType(identifier: \(String(describing: identifier)), name: \(String(describing: name)), scopes: \(String(describing: scopes)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>A container for information about a resource server for a user pool.</p>
public struct ResourceServerType: Equatable {
    /// <p>The identifier for the resource server.</p>
    public let identifier: String?
    /// <p>The name of the resource server.</p>
    public let name: String?
    /// <p>A list of scopes that are defined for the resource server.</p>
    public let scopes: [ResourceServerScopeType]?
    /// <p>The user pool ID for the user pool that hosts the resource server.</p>
    public let userPoolId: String?

    public init (
        identifier: String? = nil,
        name: String? = nil,
        scopes: [ResourceServerScopeType]? = nil,
        userPoolId: String? = nil
    )
    {
        self.identifier = identifier
        self.name = name
        self.scopes = scopes
        self.userPoolId = userPoolId
    }
}

public struct RespondToAuthChallengeInputBodyMiddleware: Middleware {
    public let id: String = "RespondToAuthChallengeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<RespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<RespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RespondToAuthChallengeOutputError>
}

extension RespondToAuthChallengeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RespondToAuthChallengeInput(analyticsMetadata: \(String(describing: analyticsMetadata)), challengeName: \(String(describing: challengeName)), challengeResponses: \(String(describing: challengeResponses)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), session: \(String(describing: session)), userContextData: \(String(describing: userContextData)))"}
}

extension RespondToAuthChallengeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case challengeName = "ChallengeName"
        case challengeResponses = "ChallengeResponses"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case session = "Session"
        case userContextData = "UserContextData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let challengeName = challengeName {
            try encodeContainer.encode(challengeName.rawValue, forKey: .challengeName)
        }
        if let challengeResponses = challengeResponses {
            var challengeResponsesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .challengeResponses)
            for (dictKey0, challengeresponsestype0) in challengeResponses {
                try challengeResponsesContainer.encode(challengeresponsestype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let session = session {
            try encodeContainer.encode(session, forKey: .session)
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
    }
}

public struct RespondToAuthChallengeInputHeadersMiddleware: Middleware {
    public let id: String = "RespondToAuthChallengeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<RespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<RespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RespondToAuthChallengeOutputError>
}

public struct RespondToAuthChallengeInputQueryItemMiddleware: Middleware {
    public let id: String = "RespondToAuthChallengeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RespondToAuthChallengeInput>,
                  next: H) -> Swift.Result<OperationOutput<RespondToAuthChallengeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RespondToAuthChallengeInput>
    public typealias MOutput = OperationOutput<RespondToAuthChallengeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RespondToAuthChallengeOutputError>
}

/// <p>The request to respond to an authentication challenge.</p>
public struct RespondToAuthChallengeInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for
    ///                 <code>RespondToAuthChallenge</code> calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The challenge name. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_InitiateAuth.html">InitiateAuth</a>.</p>
    ///         <p>
    ///             <code>ADMIN_NO_SRP_AUTH</code> is not a valid value.</p>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge responses. These are inputs corresponding to the value of
    ///                 <code>ChallengeName</code>, for example:</p>
    ///         <note>
    ///             <p>
    ///                <code>SECRET_HASH</code> (if app client is configured with client secret) applies
    ///                 to all inputs below (including <code>SOFTWARE_TOKEN_MFA</code>).</p>
    ///         </note>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>SMS_MFA</code>: <code>SMS_MFA_CODE</code>, <code>USERNAME</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>PASSWORD_VERIFIER</code>: <code>PASSWORD_CLAIM_SIGNATURE</code>,
    ///                         <code>PASSWORD_CLAIM_SECRET_BLOCK</code>, <code>TIMESTAMP</code>,
    ///                         <code>USERNAME</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>NEW_PASSWORD_REQUIRED</code>: <code>NEW_PASSWORD</code>, any other
    ///                     required attributes, <code>USERNAME</code>. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>SOFTWARE_TOKEN_MFA</code>: <code>USERNAME</code> and
    ///                         <code>SOFTWARE_TOKEN_MFA_CODE</code> are required attributes.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_SRP_AUTH</code> requires <code>USERNAME</code>,
    ///                         <code>DEVICE_KEY</code>, <code>SRP_A</code> (and
    ///                     <code>SECRET_HASH</code>).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DEVICE_PASSWORD_VERIFIER</code> requires everything that
    ///                         <code>PASSWORD_VERIFIER</code> requires plus <code>DEVICE_KEY</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>MFA_SETUP</code> requires <code>USERNAME</code>, plus you need to use
    ///                     the session value returned by <code>VerifySoftwareToken</code> in the
    ///                         <code>Session</code> parameter.</p>
    ///             </li>
    ///          </ul>
    public let challengeResponses: [String:String]?
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the RespondToAuthChallenge API action, Amazon Cognito invokes any functions
    ///             that are assigned to the following triggers: <i>post authentication</i>,
    ///                 <i>pre token generation</i>, <i>define auth
    ///                 challenge</i>, <i>create auth challenge</i>, and
    ///                 <i>verify auth challenge</i>. When Amazon Cognito invokes any of these
    ///             functions, it passes a JSON payload, which the function receives as input. This payload
    ///             contains a <code>clientMetadata</code> attribute, which provides the data that you
    ///             assigned to the ClientMetadata parameter in your RespondToAuthChallenge request. In your
    ///             function code in AWS Lambda, you can process the <code>clientMetadata</code> value to
    ///             enhance your workflow for your specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If <code>InitiateAuth</code> or <code>RespondToAuthChallenge</code> API call
    ///             determines that the caller needs to go through another challenge, they return a session
    ///             with other challenge parameters. This session should be passed as it is to the next
    ///                 <code>RespondToAuthChallenge</code> API call.</p>
    public let session: String?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeResponses: [String:String]? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        session: String? = nil,
        userContextData: UserContextDataType? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.challengeName = challengeName
        self.challengeResponses = challengeResponses
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.session = session
        self.userContextData = userContextData
    }
}

struct RespondToAuthChallengeInputBody: Equatable {
    public let clientId: String?
    public let challengeName: ChallengeNameType?
    public let session: String?
    public let challengeResponses: [String:String]?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let userContextData: UserContextDataType?
    public let clientMetadata: [String:String]?
}

extension RespondToAuthChallengeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case challengeName = "ChallengeName"
        case challengeResponses = "ChallengeResponses"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case session = "Session"
        case userContextData = "UserContextData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let challengeResponsesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeResponses)
        var challengeResponsesDecoded0: [String:String]? = nil
        if let challengeResponsesContainer = challengeResponsesContainer {
            challengeResponsesDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeResponsesContainer {
                if let stringtype0 = stringtype0 {
                    challengeResponsesDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeResponses = challengeResponsesDecoded0
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension RespondToAuthChallengeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RespondToAuthChallengeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MFAMethodNotFoundException" : self = .mFAMethodNotFoundException(try MFAMethodNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SoftwareTokenMFANotFoundException" : self = .softwareTokenMFANotFoundException(try SoftwareTokenMFANotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RespondToAuthChallengeOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case mFAMethodNotFoundException(MFAMethodNotFoundException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case softwareTokenMFANotFoundException(SoftwareTokenMFANotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RespondToAuthChallengeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RespondToAuthChallengeOutputResponse(authenticationResult: \(String(describing: authenticationResult)), challengeName: \(String(describing: challengeName)), challengeParameters: \(String(describing: challengeParameters)), session: \(String(describing: session)))"}
}

extension RespondToAuthChallengeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RespondToAuthChallengeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationResult = output.authenticationResult
            self.challengeName = output.challengeName
            self.challengeParameters = output.challengeParameters
            self.session = output.session
        } else {
            self.authenticationResult = nil
            self.challengeName = nil
            self.challengeParameters = nil
            self.session = nil
        }
    }
}

/// <p>The response to respond to the authentication challenge.</p>
public struct RespondToAuthChallengeOutputResponse: Equatable {
    /// <p>The result returned by the server in response to the request to respond to the
    ///             authentication challenge.</p>
    public let authenticationResult: AuthenticationResultType?
    /// <p>The challenge name. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_InitiateAuth.html">InitiateAuth</a>.</p>
    public let challengeName: ChallengeNameType?
    /// <p>The challenge parameters. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_InitiateAuth.html">InitiateAuth</a>.</p>
    public let challengeParameters: [String:String]?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service. If the caller needs to go through another challenge, they return a session with
    ///             other challenge parameters. This session should be passed as it is to the next
    ///                 <code>RespondToAuthChallenge</code> API call.</p>
    public let session: String?

    public init (
        authenticationResult: AuthenticationResultType? = nil,
        challengeName: ChallengeNameType? = nil,
        challengeParameters: [String:String]? = nil,
        session: String? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.challengeName = challengeName
        self.challengeParameters = challengeParameters
        self.session = session
    }
}

struct RespondToAuthChallengeOutputResponseBody: Equatable {
    public let challengeName: ChallengeNameType?
    public let session: String?
    public let challengeParameters: [String:String]?
    public let authenticationResult: AuthenticationResultType?
}

extension RespondToAuthChallengeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationResult = "AuthenticationResult"
        case challengeName = "ChallengeName"
        case challengeParameters = "ChallengeParameters"
        case session = "Session"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let challengeNameDecoded = try containerValues.decodeIfPresent(ChallengeNameType.self, forKey: .challengeName)
        challengeName = challengeNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let challengeParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .challengeParameters)
        var challengeParametersDecoded0: [String:String]? = nil
        if let challengeParametersContainer = challengeParametersContainer {
            challengeParametersDecoded0 = [String:String]()
            for (key0, stringtype0) in challengeParametersContainer {
                if let stringtype0 = stringtype0 {
                    challengeParametersDecoded0?[key0] = stringtype0
                }
            }
        }
        challengeParameters = challengeParametersDecoded0
        let authenticationResultDecoded = try containerValues.decodeIfPresent(AuthenticationResultType.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
    }
}

extension RiskConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountTakeoverRiskConfiguration = "AccountTakeoverRiskConfiguration"
        case clientId = "ClientId"
        case compromisedCredentialsRiskConfiguration = "CompromisedCredentialsRiskConfiguration"
        case lastModifiedDate = "LastModifiedDate"
        case riskExceptionConfiguration = "RiskExceptionConfiguration"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountTakeoverRiskConfiguration = accountTakeoverRiskConfiguration {
            try encodeContainer.encode(accountTakeoverRiskConfiguration, forKey: .accountTakeoverRiskConfiguration)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfiguration {
            try encodeContainer.encode(compromisedCredentialsRiskConfiguration, forKey: .compromisedCredentialsRiskConfiguration)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let riskExceptionConfiguration = riskExceptionConfiguration {
            try encodeContainer.encode(riskExceptionConfiguration, forKey: .riskExceptionConfiguration)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let compromisedCredentialsRiskConfigurationDecoded = try containerValues.decodeIfPresent(CompromisedCredentialsRiskConfigurationType.self, forKey: .compromisedCredentialsRiskConfiguration)
        compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfigurationDecoded
        let accountTakeoverRiskConfigurationDecoded = try containerValues.decodeIfPresent(AccountTakeoverRiskConfigurationType.self, forKey: .accountTakeoverRiskConfiguration)
        accountTakeoverRiskConfiguration = accountTakeoverRiskConfigurationDecoded
        let riskExceptionConfigurationDecoded = try containerValues.decodeIfPresent(RiskExceptionConfigurationType.self, forKey: .riskExceptionConfiguration)
        riskExceptionConfiguration = riskExceptionConfigurationDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension RiskConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RiskConfigurationType(accountTakeoverRiskConfiguration: \(String(describing: accountTakeoverRiskConfiguration)), clientId: \(String(describing: clientId)), compromisedCredentialsRiskConfiguration: \(String(describing: compromisedCredentialsRiskConfiguration)), lastModifiedDate: \(String(describing: lastModifiedDate)), riskExceptionConfiguration: \(String(describing: riskExceptionConfiguration)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>The risk configuration type.</p>
public struct RiskConfigurationType: Equatable {
    /// <p>The account takeover risk configuration object including the
    ///                 <code>NotifyConfiguration</code> object and <code>Actions</code> to take in the case
    ///             of an account takeover.</p>
    public let accountTakeoverRiskConfiguration: AccountTakeoverRiskConfigurationType?
    /// <p>The app client ID.</p>
    public let clientId: String?
    /// <p>The compromised credentials risk configuration object including the
    ///                 <code>EventFilter</code> and the <code>EventAction</code>
    ///          </p>
    public let compromisedCredentialsRiskConfiguration: CompromisedCredentialsRiskConfigurationType?
    /// <p>The last modified date.</p>
    public let lastModifiedDate: Date?
    /// <p>The configuration to override the risk decision.</p>
    public let riskExceptionConfiguration: RiskExceptionConfigurationType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        accountTakeoverRiskConfiguration: AccountTakeoverRiskConfigurationType? = nil,
        clientId: String? = nil,
        compromisedCredentialsRiskConfiguration: CompromisedCredentialsRiskConfigurationType? = nil,
        lastModifiedDate: Date? = nil,
        riskExceptionConfiguration: RiskExceptionConfigurationType? = nil,
        userPoolId: String? = nil
    )
    {
        self.accountTakeoverRiskConfiguration = accountTakeoverRiskConfiguration
        self.clientId = clientId
        self.compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfiguration
        self.lastModifiedDate = lastModifiedDate
        self.riskExceptionConfiguration = riskExceptionConfiguration
        self.userPoolId = userPoolId
    }
}

public enum RiskDecisionType {
    case accounttakeover
    case block
    case norisk
    case sdkUnknown(String)
}

extension RiskDecisionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RiskDecisionType] {
        return [
            .accounttakeover,
            .block,
            .norisk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accounttakeover: return "AccountTakeover"
        case .block: return "Block"
        case .norisk: return "NoRisk"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RiskDecisionType(rawValue: rawValue) ?? RiskDecisionType.sdkUnknown(rawValue)
    }
}

extension RiskExceptionConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockedIPRangeList = "BlockedIPRangeList"
        case skippedIPRangeList = "SkippedIPRangeList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedIPRangeList = blockedIPRangeList {
            var blockedIPRangeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedIPRangeList)
            for blockediprangelisttype0 in blockedIPRangeList {
                try blockedIPRangeListContainer.encode(blockediprangelisttype0)
            }
        }
        if let skippedIPRangeList = skippedIPRangeList {
            var skippedIPRangeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skippedIPRangeList)
            for skippediprangelisttype0 in skippedIPRangeList {
                try skippedIPRangeListContainer.encode(skippediprangelisttype0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedIPRangeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .blockedIPRangeList)
        var blockedIPRangeListDecoded0:[String]? = nil
        if let blockedIPRangeListContainer = blockedIPRangeListContainer {
            blockedIPRangeListDecoded0 = [String]()
            for string0 in blockedIPRangeListContainer {
                if let string0 = string0 {
                    blockedIPRangeListDecoded0?.append(string0)
                }
            }
        }
        blockedIPRangeList = blockedIPRangeListDecoded0
        let skippedIPRangeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .skippedIPRangeList)
        var skippedIPRangeListDecoded0:[String]? = nil
        if let skippedIPRangeListContainer = skippedIPRangeListContainer {
            skippedIPRangeListDecoded0 = [String]()
            for string0 in skippedIPRangeListContainer {
                if let string0 = string0 {
                    skippedIPRangeListDecoded0?.append(string0)
                }
            }
        }
        skippedIPRangeList = skippedIPRangeListDecoded0
    }
}

extension RiskExceptionConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RiskExceptionConfigurationType(blockedIPRangeList: \(String(describing: blockedIPRangeList)), skippedIPRangeList: \(String(describing: skippedIPRangeList)))"}
}

/// <p>The type of the configuration to override the risk decision.</p>
public struct RiskExceptionConfigurationType: Equatable {
    /// <p>Overrides the risk decision to always block the pre-authentication requests. The IP
    ///             range is in CIDR notation: a compact representation of an IP address and its associated
    ///             routing prefix.</p>
    public let blockedIPRangeList: [String]?
    /// <p>Risk detection is not performed on the IP addresses in the range list. The IP range is
    ///             in CIDR notation.</p>
    public let skippedIPRangeList: [String]?

    public init (
        blockedIPRangeList: [String]? = nil,
        skippedIPRangeList: [String]? = nil
    )
    {
        self.blockedIPRangeList = blockedIPRangeList
        self.skippedIPRangeList = skippedIPRangeList
    }
}

public enum RiskLevelType {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension RiskLevelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RiskLevelType] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "High"
        case .low: return "Low"
        case .medium: return "Medium"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RiskLevelType(rawValue: rawValue) ?? RiskLevelType.sdkUnknown(rawValue)
    }
}

extension SMSMfaSettingsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case preferredMfa = "PreferredMfa"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if preferredMfa != false {
            try encodeContainer.encode(preferredMfa, forKey: .preferredMfa)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let preferredMfaDecoded = try containerValues.decode(Bool.self, forKey: .preferredMfa)
        preferredMfa = preferredMfaDecoded
    }
}

extension SMSMfaSettingsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSMfaSettingsType(enabled: \(String(describing: enabled)), preferredMfa: \(String(describing: preferredMfa)))"}
}

/// <p>The type used for enabling SMS MFA at the user level. Phone numbers don't need to be
///             verified to be used for SMS MFA. If an MFA type is enabled for a user, the user will be
///             prompted for MFA during all sign in attempts, unless device tracking is turned on and
///             the device has been trusted. If you would like MFA to be applied selectively based on
///             the assessed risk level of sign in attempts, disable MFA for users and turn on Adaptive
///             Authentication for the user pool.</p>
public struct SMSMfaSettingsType: Equatable {
    /// <p>Specifies whether SMS text message MFA is enabled. If an MFA type is enabled for a
    ///             user, the user will be prompted for MFA during all sign in attempts, unless device
    ///             tracking is turned on and the device has been trusted.</p>
    public let enabled: Bool
    /// <p>Specifies whether SMS is the preferred MFA method.</p>
    public let preferredMfa: Bool

    public init (
        enabled: Bool = false,
        preferredMfa: Bool = false
    )
    {
        self.enabled = enabled
        self.preferredMfa = preferredMfa
    }
}

extension SchemaAttributeType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeDataType = "AttributeDataType"
        case developerOnlyAttribute = "DeveloperOnlyAttribute"
        case mutable = "Mutable"
        case name = "Name"
        case numberAttributeConstraints = "NumberAttributeConstraints"
        case `required` = "Required"
        case stringAttributeConstraints = "StringAttributeConstraints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDataType = attributeDataType {
            try encodeContainer.encode(attributeDataType.rawValue, forKey: .attributeDataType)
        }
        if developerOnlyAttribute != false {
            try encodeContainer.encode(developerOnlyAttribute, forKey: .developerOnlyAttribute)
        }
        if mutable != false {
            try encodeContainer.encode(mutable, forKey: .mutable)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberAttributeConstraints = numberAttributeConstraints {
            try encodeContainer.encode(numberAttributeConstraints, forKey: .numberAttributeConstraints)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let stringAttributeConstraints = stringAttributeConstraints {
            try encodeContainer.encode(stringAttributeConstraints, forKey: .stringAttributeConstraints)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let attributeDataTypeDecoded = try containerValues.decodeIfPresent(AttributeDataType.self, forKey: .attributeDataType)
        attributeDataType = attributeDataTypeDecoded
        let developerOnlyAttributeDecoded = try containerValues.decode(Bool.self, forKey: .developerOnlyAttribute)
        developerOnlyAttribute = developerOnlyAttributeDecoded
        let mutableDecoded = try containerValues.decode(Bool.self, forKey: .mutable)
        mutable = mutableDecoded
        let requiredDecoded = try containerValues.decode(Bool.self, forKey: .required)
        `required` = requiredDecoded
        let numberAttributeConstraintsDecoded = try containerValues.decodeIfPresent(NumberAttributeConstraintsType.self, forKey: .numberAttributeConstraints)
        numberAttributeConstraints = numberAttributeConstraintsDecoded
        let stringAttributeConstraintsDecoded = try containerValues.decodeIfPresent(StringAttributeConstraintsType.self, forKey: .stringAttributeConstraints)
        stringAttributeConstraints = stringAttributeConstraintsDecoded
    }
}

extension SchemaAttributeType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaAttributeType(attributeDataType: \(String(describing: attributeDataType)), developerOnlyAttribute: \(String(describing: developerOnlyAttribute)), mutable: \(String(describing: mutable)), name: \(String(describing: name)), numberAttributeConstraints: \(String(describing: numberAttributeConstraints)), required: \(String(describing: `required`)), stringAttributeConstraints: \(String(describing: stringAttributeConstraints)))"}
}

/// <p>Contains information about the schema attribute.</p>
public struct SchemaAttributeType: Equatable {
    /// <p>Specifies whether a user pool attribute is required. If the attribute is required and
    ///             the user does not provide a value, registration or sign-in will fail.</p>
    public let `required`: Bool
    /// <p>The attribute data type.</p>
    public let attributeDataType: AttributeDataType?
    /// <note>
    ///             <p>We recommend that you use <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UserPoolClientType.html#CognitoUserPools-Type-UserPoolClientType-WriteAttributes">WriteAttributes</a> in the user pool client to control how attributes can
    ///                 be mutated for new use cases instead of using
    ///                 <code>DeveloperOnlyAttribute</code>.</p>
    ///         </note>
    ///         <p>Specifies whether the attribute type is developer only. This attribute can only be
    ///             modified by an administrator. Users will not be able to modify this attribute using
    ///             their access token. For example, <code>DeveloperOnlyAttribute</code> can be modified
    ///             using AdminUpdateUserAttributes but cannot be updated using UpdateUserAttributes.</p>
    public let developerOnlyAttribute: Bool
    /// <p>Specifies whether the value of the attribute can be changed.</p>
    ///         <p>For any user pool attribute that's mapped to an identity provider attribute, you must
    ///             set this parameter to <code>true</code>. Amazon Cognito updates mapped attributes when
    ///             users sign in to your application through an identity provider. If an attribute is
    ///             immutable, Amazon Cognito throws an error when it attempts to update the attribute. For
    ///             more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-specifying-attribute-mapping.html">Specifying Identity Provider Attribute Mappings for Your User
    ///                 Pool</a>.</p>
    public let mutable: Bool
    /// <p>A schema attribute of the name type.</p>
    public let name: String?
    /// <p>Specifies the constraints for an attribute of the number type.</p>
    public let numberAttributeConstraints: NumberAttributeConstraintsType?
    /// <p>Specifies the constraints for an attribute of the string type.</p>
    public let stringAttributeConstraints: StringAttributeConstraintsType?

    public init (
        `required`: Bool = false,
        attributeDataType: AttributeDataType? = nil,
        developerOnlyAttribute: Bool = false,
        mutable: Bool = false,
        name: String? = nil,
        numberAttributeConstraints: NumberAttributeConstraintsType? = nil,
        stringAttributeConstraints: StringAttributeConstraintsType? = nil
    )
    {
        self.`required` = `required`
        self.attributeDataType = attributeDataType
        self.developerOnlyAttribute = developerOnlyAttribute
        self.mutable = mutable
        self.name = name
        self.numberAttributeConstraints = numberAttributeConstraints
        self.stringAttributeConstraints = stringAttributeConstraints
    }
}

extension ScopeDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScopeDoesNotExistException(message: \(String(describing: message)))"}
}

extension ScopeDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ScopeDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified scope does not exist.</p>
public struct ScopeDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ScopeDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ScopeDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetRiskConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "SetRiskConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRiskConfigurationInput>
    public typealias MOutput = OperationOutput<SetRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRiskConfigurationOutputError>
}

extension SetRiskConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRiskConfigurationInput(accountTakeoverRiskConfiguration: \(String(describing: accountTakeoverRiskConfiguration)), clientId: \(String(describing: clientId)), compromisedCredentialsRiskConfiguration: \(String(describing: compromisedCredentialsRiskConfiguration)), riskExceptionConfiguration: \(String(describing: riskExceptionConfiguration)), userPoolId: \(String(describing: userPoolId)))"}
}

extension SetRiskConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountTakeoverRiskConfiguration = "AccountTakeoverRiskConfiguration"
        case clientId = "ClientId"
        case compromisedCredentialsRiskConfiguration = "CompromisedCredentialsRiskConfiguration"
        case riskExceptionConfiguration = "RiskExceptionConfiguration"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountTakeoverRiskConfiguration = accountTakeoverRiskConfiguration {
            try encodeContainer.encode(accountTakeoverRiskConfiguration, forKey: .accountTakeoverRiskConfiguration)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfiguration {
            try encodeContainer.encode(compromisedCredentialsRiskConfiguration, forKey: .compromisedCredentialsRiskConfiguration)
        }
        if let riskExceptionConfiguration = riskExceptionConfiguration {
            try encodeContainer.encode(riskExceptionConfiguration, forKey: .riskExceptionConfiguration)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct SetRiskConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "SetRiskConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRiskConfigurationInput>
    public typealias MOutput = OperationOutput<SetRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRiskConfigurationOutputError>
}

public struct SetRiskConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "SetRiskConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRiskConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRiskConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRiskConfigurationInput>
    public typealias MOutput = OperationOutput<SetRiskConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRiskConfigurationOutputError>
}

public struct SetRiskConfigurationInput: Equatable {
    /// <p>The account takeover risk configuration.</p>
    public let accountTakeoverRiskConfiguration: AccountTakeoverRiskConfigurationType?
    /// <p>The app client ID. If <code>ClientId</code> is null, then the risk configuration is
    ///             mapped to <code>userPoolId</code>. When the client ID is null, the same risk
    ///             configuration is applied to all the clients in the userPool.</p>
    ///         <p>Otherwise, <code>ClientId</code> is mapped to the client. When the client ID is not
    ///             null, the user pool configuration is overridden and the risk configuration for the
    ///             client is used instead.</p>
    public let clientId: String?
    /// <p>The compromised credentials risk configuration.</p>
    public let compromisedCredentialsRiskConfiguration: CompromisedCredentialsRiskConfigurationType?
    /// <p>The configuration to override the risk decision.</p>
    public let riskExceptionConfiguration: RiskExceptionConfigurationType?
    /// <p>The user pool ID. </p>
    public let userPoolId: String?

    public init (
        accountTakeoverRiskConfiguration: AccountTakeoverRiskConfigurationType? = nil,
        clientId: String? = nil,
        compromisedCredentialsRiskConfiguration: CompromisedCredentialsRiskConfigurationType? = nil,
        riskExceptionConfiguration: RiskExceptionConfigurationType? = nil,
        userPoolId: String? = nil
    )
    {
        self.accountTakeoverRiskConfiguration = accountTakeoverRiskConfiguration
        self.clientId = clientId
        self.compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfiguration
        self.riskExceptionConfiguration = riskExceptionConfiguration
        self.userPoolId = userPoolId
    }
}

struct SetRiskConfigurationInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
    public let compromisedCredentialsRiskConfiguration: CompromisedCredentialsRiskConfigurationType?
    public let accountTakeoverRiskConfiguration: AccountTakeoverRiskConfigurationType?
    public let riskExceptionConfiguration: RiskExceptionConfigurationType?
}

extension SetRiskConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountTakeoverRiskConfiguration = "AccountTakeoverRiskConfiguration"
        case clientId = "ClientId"
        case compromisedCredentialsRiskConfiguration = "CompromisedCredentialsRiskConfiguration"
        case riskExceptionConfiguration = "RiskExceptionConfiguration"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let compromisedCredentialsRiskConfigurationDecoded = try containerValues.decodeIfPresent(CompromisedCredentialsRiskConfigurationType.self, forKey: .compromisedCredentialsRiskConfiguration)
        compromisedCredentialsRiskConfiguration = compromisedCredentialsRiskConfigurationDecoded
        let accountTakeoverRiskConfigurationDecoded = try containerValues.decodeIfPresent(AccountTakeoverRiskConfigurationType.self, forKey: .accountTakeoverRiskConfiguration)
        accountTakeoverRiskConfiguration = accountTakeoverRiskConfigurationDecoded
        let riskExceptionConfigurationDecoded = try containerValues.decodeIfPresent(RiskExceptionConfigurationType.self, forKey: .riskExceptionConfiguration)
        riskExceptionConfiguration = riskExceptionConfigurationDecoded
    }
}

extension SetRiskConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRiskConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolAddOnNotEnabledException" : self = .userPoolAddOnNotEnabledException(try UserPoolAddOnNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRiskConfigurationOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userPoolAddOnNotEnabledException(UserPoolAddOnNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRiskConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRiskConfigurationOutputResponse(riskConfiguration: \(String(describing: riskConfiguration)))"}
}

extension SetRiskConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetRiskConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.riskConfiguration = output.riskConfiguration
        } else {
            self.riskConfiguration = nil
        }
    }
}

public struct SetRiskConfigurationOutputResponse: Equatable {
    /// <p>The risk configuration.</p>
    public let riskConfiguration: RiskConfigurationType?

    public init (
        riskConfiguration: RiskConfigurationType? = nil
    )
    {
        self.riskConfiguration = riskConfiguration
    }
}

struct SetRiskConfigurationOutputResponseBody: Equatable {
    public let riskConfiguration: RiskConfigurationType?
}

extension SetRiskConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case riskConfiguration = "RiskConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskConfigurationDecoded = try containerValues.decodeIfPresent(RiskConfigurationType.self, forKey: .riskConfiguration)
        riskConfiguration = riskConfigurationDecoded
    }
}

public struct SetUICustomizationInputBodyMiddleware: Middleware {
    public let id: String = "SetUICustomizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUICustomizationInput>
    public typealias MOutput = OperationOutput<SetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUICustomizationOutputError>
}

extension SetUICustomizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUICustomizationInput(cSS: \(String(describing: cSS)), clientId: \(String(describing: clientId)), imageFile: \(String(describing: imageFile)), userPoolId: \(String(describing: userPoolId)))"}
}

extension SetUICustomizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSS = "CSS"
        case clientId = "ClientId"
        case imageFile = "ImageFile"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cSS = cSS {
            try encodeContainer.encode(cSS, forKey: .cSS)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let imageFile = imageFile {
            try encodeContainer.encode(imageFile.base64EncodedString(), forKey: .imageFile)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct SetUICustomizationInputHeadersMiddleware: Middleware {
    public let id: String = "SetUICustomizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUICustomizationInput>
    public typealias MOutput = OperationOutput<SetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUICustomizationOutputError>
}

public struct SetUICustomizationInputQueryItemMiddleware: Middleware {
    public let id: String = "SetUICustomizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUICustomizationInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUICustomizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUICustomizationInput>
    public typealias MOutput = OperationOutput<SetUICustomizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUICustomizationOutputError>
}

public struct SetUICustomizationInput: Equatable {
    /// <p>The CSS values in the UI customization.</p>
    public let cSS: String?
    /// <p>The client ID for the client app.</p>
    public let clientId: String?
    /// <p>The uploaded logo image for the UI customization.</p>
    public let imageFile: Data?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        cSS: String? = nil,
        clientId: String? = nil,
        imageFile: Data? = nil,
        userPoolId: String? = nil
    )
    {
        self.cSS = cSS
        self.clientId = clientId
        self.imageFile = imageFile
        self.userPoolId = userPoolId
    }
}

struct SetUICustomizationInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
    public let cSS: String?
    public let imageFile: Data?
}

extension SetUICustomizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cSS = "CSS"
        case clientId = "ClientId"
        case imageFile = "ImageFile"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let cSSDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cSS)
        cSS = cSSDecoded
        let imageFileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .imageFile)
        imageFile = imageFileDecoded
    }
}

extension SetUICustomizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetUICustomizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetUICustomizationOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetUICustomizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUICustomizationOutputResponse(uICustomization: \(String(describing: uICustomization)))"}
}

extension SetUICustomizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetUICustomizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.uICustomization = output.uICustomization
        } else {
            self.uICustomization = nil
        }
    }
}

public struct SetUICustomizationOutputResponse: Equatable {
    /// <p>The UI customization information.</p>
    public let uICustomization: UICustomizationType?

    public init (
        uICustomization: UICustomizationType? = nil
    )
    {
        self.uICustomization = uICustomization
    }
}

struct SetUICustomizationOutputResponseBody: Equatable {
    public let uICustomization: UICustomizationType?
}

extension SetUICustomizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case uICustomization = "UICustomization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uICustomizationDecoded = try containerValues.decodeIfPresent(UICustomizationType.self, forKey: .uICustomization)
        uICustomization = uICustomizationDecoded
    }
}

public struct SetUserMFAPreferenceInputBodyMiddleware: Middleware {
    public let id: String = "SetUserMFAPreferenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<SetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserMFAPreferenceOutputError>
}

extension SetUserMFAPreferenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserMFAPreferenceInput(accessToken: \(String(describing: accessToken)), sMSMfaSettings: \(String(describing: sMSMfaSettings)), softwareTokenMfaSettings: \(String(describing: softwareTokenMfaSettings)))"}
}

extension SetUserMFAPreferenceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case sMSMfaSettings = "SMSMfaSettings"
        case softwareTokenMfaSettings = "SoftwareTokenMfaSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let sMSMfaSettings = sMSMfaSettings {
            try encodeContainer.encode(sMSMfaSettings, forKey: .sMSMfaSettings)
        }
        if let softwareTokenMfaSettings = softwareTokenMfaSettings {
            try encodeContainer.encode(softwareTokenMfaSettings, forKey: .softwareTokenMfaSettings)
        }
    }
}

public struct SetUserMFAPreferenceInputHeadersMiddleware: Middleware {
    public let id: String = "SetUserMFAPreferenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<SetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserMFAPreferenceOutputError>
}

public struct SetUserMFAPreferenceInputQueryItemMiddleware: Middleware {
    public let id: String = "SetUserMFAPreferenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserMFAPreferenceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserMFAPreferenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserMFAPreferenceInput>
    public typealias MOutput = OperationOutput<SetUserMFAPreferenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserMFAPreferenceOutputError>
}

public struct SetUserMFAPreferenceInput: Equatable {
    /// <p>The access token for the user.</p>
    public let accessToken: String?
    /// <p>The SMS text message multi-factor authentication (MFA) settings.</p>
    public let sMSMfaSettings: SMSMfaSettingsType?
    /// <p>The time-based one-time password software token MFA settings.</p>
    public let softwareTokenMfaSettings: SoftwareTokenMfaSettingsType?

    public init (
        accessToken: String? = nil,
        sMSMfaSettings: SMSMfaSettingsType? = nil,
        softwareTokenMfaSettings: SoftwareTokenMfaSettingsType? = nil
    )
    {
        self.accessToken = accessToken
        self.sMSMfaSettings = sMSMfaSettings
        self.softwareTokenMfaSettings = softwareTokenMfaSettings
    }
}

struct SetUserMFAPreferenceInputBody: Equatable {
    public let sMSMfaSettings: SMSMfaSettingsType?
    public let softwareTokenMfaSettings: SoftwareTokenMfaSettingsType?
    public let accessToken: String?
}

extension SetUserMFAPreferenceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case sMSMfaSettings = "SMSMfaSettings"
        case softwareTokenMfaSettings = "SoftwareTokenMfaSettings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSMfaSettingsDecoded = try containerValues.decodeIfPresent(SMSMfaSettingsType.self, forKey: .sMSMfaSettings)
        sMSMfaSettings = sMSMfaSettingsDecoded
        let softwareTokenMfaSettingsDecoded = try containerValues.decodeIfPresent(SoftwareTokenMfaSettingsType.self, forKey: .softwareTokenMfaSettings)
        softwareTokenMfaSettings = softwareTokenMfaSettingsDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension SetUserMFAPreferenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetUserMFAPreferenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetUserMFAPreferenceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetUserMFAPreferenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserMFAPreferenceOutputResponse()"}
}

extension SetUserMFAPreferenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetUserMFAPreferenceOutputResponse: Equatable {

    public init() {}
}

struct SetUserMFAPreferenceOutputResponseBody: Equatable {
}

extension SetUserMFAPreferenceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetUserPoolMfaConfigInputBodyMiddleware: Middleware {
    public let id: String = "SetUserPoolMfaConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<SetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserPoolMfaConfigOutputError>
}

extension SetUserPoolMfaConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserPoolMfaConfigInput(mfaConfiguration: \(String(describing: mfaConfiguration)), smsMfaConfiguration: \(String(describing: smsMfaConfiguration)), softwareTokenMfaConfiguration: \(String(describing: softwareTokenMfaConfiguration)), userPoolId: \(String(describing: userPoolId)))"}
}

extension SetUserPoolMfaConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mfaConfiguration = "MfaConfiguration"
        case smsMfaConfiguration = "SmsMfaConfiguration"
        case softwareTokenMfaConfiguration = "SoftwareTokenMfaConfiguration"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaConfiguration = mfaConfiguration {
            try encodeContainer.encode(mfaConfiguration.rawValue, forKey: .mfaConfiguration)
        }
        if let smsMfaConfiguration = smsMfaConfiguration {
            try encodeContainer.encode(smsMfaConfiguration, forKey: .smsMfaConfiguration)
        }
        if let softwareTokenMfaConfiguration = softwareTokenMfaConfiguration {
            try encodeContainer.encode(softwareTokenMfaConfiguration, forKey: .softwareTokenMfaConfiguration)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct SetUserPoolMfaConfigInputHeadersMiddleware: Middleware {
    public let id: String = "SetUserPoolMfaConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<SetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserPoolMfaConfigOutputError>
}

public struct SetUserPoolMfaConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "SetUserPoolMfaConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserPoolMfaConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserPoolMfaConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserPoolMfaConfigInput>
    public typealias MOutput = OperationOutput<SetUserPoolMfaConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserPoolMfaConfigOutputError>
}

public struct SetUserPoolMfaConfigInput: Equatable {
    /// <p>The MFA configuration. Users who don't have an MFA factor set up won't be able to
    ///             sign-in if you set the MfaConfiguration value to ON. See <a href="cognito/latest/developerguide/user-pool-settings-mfa.html">Adding Multi-Factor
    ///                 Authentication (MFA) to a User Pool</a> to learn more. Valid values
    ///             include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>OFF</code> MFA will not be used for any users.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ON</code> MFA is required for all users to sign in.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>OPTIONAL</code> MFA will be required only for individual users who have
    ///                     an MFA factor enabled.</p>
    ///             </li>
    ///          </ul>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>The SMS text message MFA configuration.</p>
    public let smsMfaConfiguration: SmsMfaConfigType?
    /// <p>The software token MFA configuration.</p>
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        mfaConfiguration: UserPoolMfaType? = nil,
        smsMfaConfiguration: SmsMfaConfigType? = nil,
        softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType? = nil,
        userPoolId: String? = nil
    )
    {
        self.mfaConfiguration = mfaConfiguration
        self.smsMfaConfiguration = smsMfaConfiguration
        self.softwareTokenMfaConfiguration = softwareTokenMfaConfiguration
        self.userPoolId = userPoolId
    }
}

struct SetUserPoolMfaConfigInputBody: Equatable {
    public let userPoolId: String?
    public let smsMfaConfiguration: SmsMfaConfigType?
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?
    public let mfaConfiguration: UserPoolMfaType?
}

extension SetUserPoolMfaConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mfaConfiguration = "MfaConfiguration"
        case smsMfaConfiguration = "SmsMfaConfiguration"
        case softwareTokenMfaConfiguration = "SoftwareTokenMfaConfiguration"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let smsMfaConfigurationDecoded = try containerValues.decodeIfPresent(SmsMfaConfigType.self, forKey: .smsMfaConfiguration)
        smsMfaConfiguration = smsMfaConfigurationDecoded
        let softwareTokenMfaConfigurationDecoded = try containerValues.decodeIfPresent(SoftwareTokenMfaConfigType.self, forKey: .softwareTokenMfaConfiguration)
        softwareTokenMfaConfiguration = softwareTokenMfaConfigurationDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
    }
}

extension SetUserPoolMfaConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetUserPoolMfaConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetUserPoolMfaConfigOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetUserPoolMfaConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserPoolMfaConfigOutputResponse(mfaConfiguration: \(String(describing: mfaConfiguration)), smsMfaConfiguration: \(String(describing: smsMfaConfiguration)), softwareTokenMfaConfiguration: \(String(describing: softwareTokenMfaConfiguration)))"}
}

extension SetUserPoolMfaConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetUserPoolMfaConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mfaConfiguration = output.mfaConfiguration
            self.smsMfaConfiguration = output.smsMfaConfiguration
            self.softwareTokenMfaConfiguration = output.softwareTokenMfaConfiguration
        } else {
            self.mfaConfiguration = nil
            self.smsMfaConfiguration = nil
            self.softwareTokenMfaConfiguration = nil
        }
    }
}

public struct SetUserPoolMfaConfigOutputResponse: Equatable {
    /// <p>The MFA configuration. Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>OFF</code> MFA will not be used for any users.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ON</code> MFA is required for all users to sign in.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>OPTIONAL</code> MFA will be required only for individual users who have
    ///                     an MFA factor enabled.</p>
    ///             </li>
    ///          </ul>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>The SMS text message MFA configuration.</p>
    public let smsMfaConfiguration: SmsMfaConfigType?
    /// <p>The software token MFA configuration.</p>
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?

    public init (
        mfaConfiguration: UserPoolMfaType? = nil,
        smsMfaConfiguration: SmsMfaConfigType? = nil,
        softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType? = nil
    )
    {
        self.mfaConfiguration = mfaConfiguration
        self.smsMfaConfiguration = smsMfaConfiguration
        self.softwareTokenMfaConfiguration = softwareTokenMfaConfiguration
    }
}

struct SetUserPoolMfaConfigOutputResponseBody: Equatable {
    public let smsMfaConfiguration: SmsMfaConfigType?
    public let softwareTokenMfaConfiguration: SoftwareTokenMfaConfigType?
    public let mfaConfiguration: UserPoolMfaType?
}

extension SetUserPoolMfaConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mfaConfiguration = "MfaConfiguration"
        case smsMfaConfiguration = "SmsMfaConfiguration"
        case softwareTokenMfaConfiguration = "SoftwareTokenMfaConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMfaConfigurationDecoded = try containerValues.decodeIfPresent(SmsMfaConfigType.self, forKey: .smsMfaConfiguration)
        smsMfaConfiguration = smsMfaConfigurationDecoded
        let softwareTokenMfaConfigurationDecoded = try containerValues.decodeIfPresent(SoftwareTokenMfaConfigType.self, forKey: .softwareTokenMfaConfiguration)
        softwareTokenMfaConfiguration = softwareTokenMfaConfigurationDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
    }
}

public struct SetUserSettingsInputBodyMiddleware: Middleware {
    public let id: String = "SetUserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserSettingsInput>
    public typealias MOutput = OperationOutput<SetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserSettingsOutputError>
}

extension SetUserSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserSettingsInput(accessToken: \(String(describing: accessToken)), mFAOptions: \(String(describing: mFAOptions)))"}
}

extension SetUserSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case mFAOptions = "MFAOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let mFAOptions = mFAOptions {
            var mFAOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mFAOptions)
            for mfaoptionlisttype0 in mFAOptions {
                try mFAOptionsContainer.encode(mfaoptionlisttype0)
            }
        }
    }
}

public struct SetUserSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "SetUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserSettingsInput>
    public typealias MOutput = OperationOutput<SetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserSettingsOutputError>
}

public struct SetUserSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetUserSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetUserSettingsInput>
    public typealias MOutput = OperationOutput<SetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetUserSettingsOutputError>
}

/// <p>Represents the request to set user settings.</p>
public struct SetUserSettingsInput: Equatable {
    /// <p>The access token for the set user settings request.</p>
    public let accessToken: String?
    /// <p>You can use this parameter only to set an SMS configuration that uses SMS for
    ///             delivery.</p>
    public let mFAOptions: [MFAOptionType]?

    public init (
        accessToken: String? = nil,
        mFAOptions: [MFAOptionType]? = nil
    )
    {
        self.accessToken = accessToken
        self.mFAOptions = mFAOptions
    }
}

struct SetUserSettingsInputBody: Equatable {
    public let accessToken: String?
    public let mFAOptions: [MFAOptionType]?
}

extension SetUserSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case mFAOptions = "MFAOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let mFAOptionsContainer = try containerValues.decodeIfPresent([MFAOptionType?].self, forKey: .mFAOptions)
        var mFAOptionsDecoded0:[MFAOptionType]? = nil
        if let mFAOptionsContainer = mFAOptionsContainer {
            mFAOptionsDecoded0 = [MFAOptionType]()
            for structure0 in mFAOptionsContainer {
                if let structure0 = structure0 {
                    mFAOptionsDecoded0?.append(structure0)
                }
            }
        }
        mFAOptions = mFAOptionsDecoded0
    }
}

extension SetUserSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetUserSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetUserSettingsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetUserSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetUserSettingsOutputResponse()"}
}

extension SetUserSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response from the server for a set user settings request.</p>
public struct SetUserSettingsOutputResponse: Equatable {

    public init() {}
}

struct SetUserSettingsOutputResponseBody: Equatable {
}

extension SetUserSettingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SignUpInputBodyMiddleware: Middleware {
    public let id: String = "SignUpInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<SignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignUpInput>
    public typealias MOutput = OperationOutput<SignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignUpOutputError>
}

extension SignUpInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignUpInput(analyticsMetadata: \(String(describing: analyticsMetadata)), clientId: \(String(describing: clientId)), clientMetadata: \(String(describing: clientMetadata)), password: \(String(describing: password)), secretHash: \(String(describing: secretHash)), userAttributes: \(String(describing: userAttributes)), userContextData: \(String(describing: userContextData)), username: \(String(describing: username)), validationData: \(String(describing: validationData)))"}
}

extension SignUpInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case password = "Password"
        case secretHash = "SecretHash"
        case userAttributes = "UserAttributes"
        case userContextData = "UserContextData"
        case username = "Username"
        case validationData = "ValidationData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyticsMetadata = analyticsMetadata {
            try encodeContainer.encode(analyticsMetadata, forKey: .analyticsMetadata)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let secretHash = secretHash {
            try encodeContainer.encode(secretHash, forKey: .secretHash)
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelisttype0 in userAttributes {
                try userAttributesContainer.encode(attributelisttype0)
            }
        }
        if let userContextData = userContextData {
            try encodeContainer.encode(userContextData, forKey: .userContextData)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let validationData = validationData {
            var validationDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationData)
            for attributelisttype0 in validationData {
                try validationDataContainer.encode(attributelisttype0)
            }
        }
    }
}

public struct SignUpInputHeadersMiddleware: Middleware {
    public let id: String = "SignUpInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<SignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignUpInput>
    public typealias MOutput = OperationOutput<SignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignUpOutputError>
}

public struct SignUpInputQueryItemMiddleware: Middleware {
    public let id: String = "SignUpInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignUpInput>,
                  next: H) -> Swift.Result<OperationOutput<SignUpOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignUpInput>
    public typealias MOutput = OperationOutput<SignUpOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignUpOutputError>
}

/// <p>Represents the request to register a user.</p>
public struct SignUpInput: Equatable {
    /// <p>The Amazon Pinpoint analytics metadata for collecting metrics for <code>SignUp</code>
    ///             calls.</p>
    public let analyticsMetadata: AnalyticsMetadataType?
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the SignUp API action, Amazon Cognito invokes any functions that are
    ///             assigned to the following triggers: <i>pre sign-up</i>, <i>custom
    ///                 message</i>, and <i>post confirmation</i>. When Amazon Cognito
    ///             invokes any of these functions, it passes a JSON payload, which the function receives as
    ///             input. This payload contains a <code>clientMetadata</code> attribute, which provides the
    ///             data that you assigned to the ClientMetadata parameter in your SignUp request. In your
    ///             function code in AWS Lambda, you can process the <code>clientMetadata</code> value to
    ///             enhance your workflow for your specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>The password of the user you wish to register.</p>
    public let password: String?
    /// <p>A keyed-hash message authentication code (HMAC) calculated using the secret key of a
    ///             user pool client and username plus the client ID in the message.</p>
    public let secretHash: String?
    /// <p>An array of name-value pairs representing user attributes.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributes: [AttributeType]?
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let userContextData: UserContextDataType?
    /// <p>The user name of the user you wish to register.</p>
    public let username: String?
    /// <p>The validation data in the request to register a user.</p>
    public let validationData: [AttributeType]?

    public init (
        analyticsMetadata: AnalyticsMetadataType? = nil,
        clientId: String? = nil,
        clientMetadata: [String:String]? = nil,
        password: String? = nil,
        secretHash: String? = nil,
        userAttributes: [AttributeType]? = nil,
        userContextData: UserContextDataType? = nil,
        username: String? = nil,
        validationData: [AttributeType]? = nil
    )
    {
        self.analyticsMetadata = analyticsMetadata
        self.clientId = clientId
        self.clientMetadata = clientMetadata
        self.password = password
        self.secretHash = secretHash
        self.userAttributes = userAttributes
        self.userContextData = userContextData
        self.username = username
        self.validationData = validationData
    }
}

struct SignUpInputBody: Equatable {
    public let clientId: String?
    public let secretHash: String?
    public let username: String?
    public let password: String?
    public let userAttributes: [AttributeType]?
    public let validationData: [AttributeType]?
    public let analyticsMetadata: AnalyticsMetadataType?
    public let userContextData: UserContextDataType?
    public let clientMetadata: [String:String]?
}

extension SignUpInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyticsMetadata = "AnalyticsMetadata"
        case clientId = "ClientId"
        case clientMetadata = "ClientMetadata"
        case password = "Password"
        case secretHash = "SecretHash"
        case userAttributes = "UserAttributes"
        case userContextData = "UserContextData"
        case username = "Username"
        case validationData = "ValidationData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let secretHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretHash)
        secretHash = secretHashDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let validationDataContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .validationData)
        var validationDataDecoded0:[AttributeType]? = nil
        if let validationDataContainer = validationDataContainer {
            validationDataDecoded0 = [AttributeType]()
            for structure0 in validationDataContainer {
                if let structure0 = structure0 {
                    validationDataDecoded0?.append(structure0)
                }
            }
        }
        validationData = validationDataDecoded0
        let analyticsMetadataDecoded = try containerValues.decodeIfPresent(AnalyticsMetadataType.self, forKey: .analyticsMetadata)
        analyticsMetadata = analyticsMetadataDecoded
        let userContextDataDecoded = try containerValues.decodeIfPresent(UserContextDataType.self, forKey: .userContextData)
        userContextData = userContextDataDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension SignUpOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignUpOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UsernameExistsException" : self = .usernameExistsException(try UsernameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SignUpOutputError: Equatable {
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case usernameExistsException(UsernameExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignUpOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignUpOutputResponse(codeDeliveryDetails: \(String(describing: codeDeliveryDetails)), userConfirmed: \(String(describing: userConfirmed)), userSub: \(String(describing: userSub)))"}
}

extension SignUpOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SignUpOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeDeliveryDetails = output.codeDeliveryDetails
            self.userConfirmed = output.userConfirmed
            self.userSub = output.userSub
        } else {
            self.codeDeliveryDetails = nil
            self.userConfirmed = false
            self.userSub = nil
        }
    }
}

/// <p>The response from the server for a registration request.</p>
public struct SignUpOutputResponse: Equatable {
    /// <p>The code delivery details returned by the server response to the user registration
    ///             request.</p>
    public let codeDeliveryDetails: CodeDeliveryDetailsType?
    /// <p>A response from the server indicating that a user registration has been
    ///             confirmed.</p>
    public let userConfirmed: Bool
    /// <p>The UUID of the authenticated user. This is not the same as
    ///             <code>username</code>.</p>
    public let userSub: String?

    public init (
        codeDeliveryDetails: CodeDeliveryDetailsType? = nil,
        userConfirmed: Bool = false,
        userSub: String? = nil
    )
    {
        self.codeDeliveryDetails = codeDeliveryDetails
        self.userConfirmed = userConfirmed
        self.userSub = userSub
    }
}

struct SignUpOutputResponseBody: Equatable {
    public let userConfirmed: Bool
    public let codeDeliveryDetails: CodeDeliveryDetailsType?
    public let userSub: String?
}

extension SignUpOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeDeliveryDetails = "CodeDeliveryDetails"
        case userConfirmed = "UserConfirmed"
        case userSub = "UserSub"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userConfirmedDecoded = try containerValues.decode(Bool.self, forKey: .userConfirmed)
        userConfirmed = userConfirmedDecoded
        let codeDeliveryDetailsDecoded = try containerValues.decodeIfPresent(CodeDeliveryDetailsType.self, forKey: .codeDeliveryDetails)
        codeDeliveryDetails = codeDeliveryDetailsDecoded
        let userSubDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userSub)
        userSub = userSubDecoded
    }
}

extension SmsConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case snsCallerArn = "SnsCallerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let snsCallerArn = snsCallerArn {
            try encodeContainer.encode(snsCallerArn, forKey: .snsCallerArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsCallerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsCallerArn)
        snsCallerArn = snsCallerArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension SmsConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SmsConfigurationType(externalId: \(String(describing: externalId)), snsCallerArn: \(String(describing: snsCallerArn)))"}
}

/// <p>The SMS configuration type that includes the settings the Cognito User Pool needs to
///             call for the Amazon SNS service to send an SMS message from your AWS account. The
///             Cognito User Pool makes the request to the Amazon SNS Service by using an AWS IAM role
///             that you provide for your AWS account.</p>
public struct SmsConfigurationType: Equatable {
    /// <p>The external ID is a value that we recommend you use to add security to your IAM role
    ///             which is used to call Amazon SNS to send SMS messages for your user pool. If you provide
    ///             an <code>ExternalId</code>, the Cognito User Pool will include it when attempting to
    ///             assume your IAM role, so that you can set your roles trust policy to require the
    ///                 <code>ExternalID</code>. If you use the Cognito Management Console to create a role
    ///             for SMS MFA, Cognito will create a role with the required permissions and a trust policy
    ///             that demonstrates use of the <code>ExternalId</code>.</p>
    ///         <p>For more information about the <code>ExternalId</code> of a role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to use an
    ///                 external ID when granting access to your AWS resources to a third
    ///             party</a>
    ///          </p>
    public let externalId: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) caller.
    ///             This is the ARN of the IAM role in your AWS account which Cognito will use to send SMS
    ///             messages. SMS messages are subject to a <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-email-phone-verification.html">spending limit</a>. </p>
    public let snsCallerArn: String?

    public init (
        externalId: String? = nil,
        snsCallerArn: String? = nil
    )
    {
        self.externalId = externalId
        self.snsCallerArn = snsCallerArn
    }
}

extension SmsMfaConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let smsAuthenticationMessage = smsAuthenticationMessage {
            try encodeContainer.encode(smsAuthenticationMessage, forKey: .smsAuthenticationMessage)
        }
        if let smsConfiguration = smsConfiguration {
            try encodeContainer.encode(smsConfiguration, forKey: .smsConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsAuthenticationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsAuthenticationMessage)
        smsAuthenticationMessage = smsAuthenticationMessageDecoded
        let smsConfigurationDecoded = try containerValues.decodeIfPresent(SmsConfigurationType.self, forKey: .smsConfiguration)
        smsConfiguration = smsConfigurationDecoded
    }
}

extension SmsMfaConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SmsMfaConfigType(smsAuthenticationMessage: \(String(describing: smsAuthenticationMessage)), smsConfiguration: \(String(describing: smsConfiguration)))"}
}

/// <p>The SMS text message multi-factor authentication (MFA) configuration type.</p>
public struct SmsMfaConfigType: Equatable {
    /// <p>The SMS authentication message that will be sent to users with the code they need to
    ///             sign in. The message must contain the {####} placeholder, which will be replaced with
    ///             the code. If the message is not included, and default message will be used.</p>
    public let smsAuthenticationMessage: String?
    /// <p>The SMS configuration.</p>
    public let smsConfiguration: SmsConfigurationType?

    public init (
        smsAuthenticationMessage: String? = nil,
        smsConfiguration: SmsConfigurationType? = nil
    )
    {
        self.smsAuthenticationMessage = smsAuthenticationMessage
        self.smsConfiguration = smsConfiguration
    }
}

extension SoftwareTokenMFANotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SoftwareTokenMFANotFoundException(message: \(String(describing: message)))"}
}

extension SoftwareTokenMFANotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SoftwareTokenMFANotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the software token TOTP multi-factor authentication
///             (MFA) is not enabled for the user pool.</p>
public struct SoftwareTokenMFANotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SoftwareTokenMFANotFoundExceptionBody: Equatable {
    public let message: String?
}

extension SoftwareTokenMFANotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SoftwareTokenMfaConfigType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension SoftwareTokenMfaConfigType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SoftwareTokenMfaConfigType(enabled: \(String(describing: enabled)))"}
}

/// <p>The type used for enabling software token MFA at the user pool level.</p>
public struct SoftwareTokenMfaConfigType: Equatable {
    /// <p>Specifies whether software token MFA is enabled.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension SoftwareTokenMfaSettingsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case preferredMfa = "PreferredMfa"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if preferredMfa != false {
            try encodeContainer.encode(preferredMfa, forKey: .preferredMfa)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let preferredMfaDecoded = try containerValues.decode(Bool.self, forKey: .preferredMfa)
        preferredMfa = preferredMfaDecoded
    }
}

extension SoftwareTokenMfaSettingsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SoftwareTokenMfaSettingsType(enabled: \(String(describing: enabled)), preferredMfa: \(String(describing: preferredMfa)))"}
}

/// <p>The type used for enabling software token MFA at the user level. If an MFA type is
///             enabled for a user, the user will be prompted for MFA during all sign in attempts,
///             unless device tracking is turned on and the device has been trusted. If you would like
///             MFA to be applied selectively based on the assessed risk level of sign in attempts,
///             disable MFA for users and turn on Adaptive Authentication for the user pool.</p>
public struct SoftwareTokenMfaSettingsType: Equatable {
    /// <p>Specifies whether software token MFA is enabled. If an MFA type is enabled for a user,
    ///             the user will be prompted for MFA during all sign in attempts, unless device tracking is
    ///             turned on and the device has been trusted.</p>
    public let enabled: Bool
    /// <p>Specifies whether software token MFA is the preferred MFA method.</p>
    public let preferredMfa: Bool

    public init (
        enabled: Bool = false,
        preferredMfa: Bool = false
    )
    {
        self.enabled = enabled
        self.preferredMfa = preferredMfa
    }
}

public struct StartUserImportJobInputBodyMiddleware: Middleware {
    public let id: String = "StartUserImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartUserImportJobInput>
    public typealias MOutput = OperationOutput<StartUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartUserImportJobOutputError>
}

extension StartUserImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartUserImportJobInput(jobId: \(String(describing: jobId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension StartUserImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct StartUserImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartUserImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartUserImportJobInput>
    public typealias MOutput = OperationOutput<StartUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartUserImportJobOutputError>
}

public struct StartUserImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartUserImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartUserImportJobInput>
    public typealias MOutput = OperationOutput<StartUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartUserImportJobOutputError>
}

/// <p>Represents the request to start the user import job.</p>
public struct StartUserImportJobInput: Equatable {
    /// <p>The job ID for the user import job.</p>
    public let jobId: String?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        jobId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.jobId = jobId
        self.userPoolId = userPoolId
    }
}

struct StartUserImportJobInputBody: Equatable {
    public let userPoolId: String?
    public let jobId: String?
}

extension StartUserImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartUserImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartUserImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartUserImportJobOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartUserImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartUserImportJobOutputResponse(userImportJob: \(String(describing: userImportJob)))"}
}

extension StartUserImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartUserImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userImportJob = output.userImportJob
        } else {
            self.userImportJob = nil
        }
    }
}

/// <p>Represents the response from the server to the request to start the user import
///             job.</p>
public struct StartUserImportJobOutputResponse: Equatable {
    /// <p>The job object that represents the user import job.</p>
    public let userImportJob: UserImportJobType?

    public init (
        userImportJob: UserImportJobType? = nil
    )
    {
        self.userImportJob = userImportJob
    }
}

struct StartUserImportJobOutputResponseBody: Equatable {
    public let userImportJob: UserImportJobType?
}

extension StartUserImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userImportJob = "UserImportJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userImportJobDecoded = try containerValues.decodeIfPresent(UserImportJobType.self, forKey: .userImportJob)
        userImportJob = userImportJobDecoded
    }
}

public enum StatusType {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension StatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusType] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusType(rawValue: rawValue) ?? StatusType.sdkUnknown(rawValue)
    }
}

public struct StopUserImportJobInputBodyMiddleware: Middleware {
    public let id: String = "StopUserImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopUserImportJobInput>
    public typealias MOutput = OperationOutput<StopUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopUserImportJobOutputError>
}

extension StopUserImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopUserImportJobInput(jobId: \(String(describing: jobId)), userPoolId: \(String(describing: userPoolId)))"}
}

extension StopUserImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct StopUserImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopUserImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopUserImportJobInput>
    public typealias MOutput = OperationOutput<StopUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopUserImportJobOutputError>
}

public struct StopUserImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopUserImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopUserImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopUserImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopUserImportJobInput>
    public typealias MOutput = OperationOutput<StopUserImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopUserImportJobOutputError>
}

/// <p>Represents the request to stop the user import job.</p>
public struct StopUserImportJobInput: Equatable {
    /// <p>The job ID for the user import job.</p>
    public let jobId: String?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        jobId: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.jobId = jobId
        self.userPoolId = userPoolId
    }
}

struct StopUserImportJobInputBody: Equatable {
    public let userPoolId: String?
    public let jobId: String?
}

extension StopUserImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopUserImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopUserImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionNotMetException" : self = .preconditionNotMetException(try PreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopUserImportJobOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case preconditionNotMetException(PreconditionNotMetException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopUserImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopUserImportJobOutputResponse(userImportJob: \(String(describing: userImportJob)))"}
}

extension StopUserImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopUserImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userImportJob = output.userImportJob
        } else {
            self.userImportJob = nil
        }
    }
}

/// <p>Represents the response from the server to the request to stop the user import
///             job.</p>
public struct StopUserImportJobOutputResponse: Equatable {
    /// <p>The job object that represents the user import job.</p>
    public let userImportJob: UserImportJobType?

    public init (
        userImportJob: UserImportJobType? = nil
    )
    {
        self.userImportJob = userImportJob
    }
}

struct StopUserImportJobOutputResponseBody: Equatable {
    public let userImportJob: UserImportJobType?
}

extension StopUserImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userImportJob = "UserImportJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userImportJobDecoded = try containerValues.decodeIfPresent(UserImportJobType.self, forKey: .userImportJob)
        userImportJob = userImportJobDecoded
    }
}

extension StringAttributeConstraintsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxLength = "MaxLength"
        case minLength = "MinLength"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLength = maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let minLength = minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minLengthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minLength)
        minLength = minLengthDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
    }
}

extension StringAttributeConstraintsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StringAttributeConstraintsType(maxLength: \(String(describing: maxLength)), minLength: \(String(describing: minLength)))"}
}

/// <p>The constraints associated with a string attribute.</p>
public struct StringAttributeConstraintsType: Equatable {
    /// <p>The maximum length.</p>
    public let maxLength: String?
    /// <p>The minimum length.</p>
    public let minLength: String?

    public init (
        maxLength: String? = nil,
        minLength: String? = nil
    )
    {
        self.maxLength = maxLength
        self.minLength = minLength
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, userpooltagstype0) in tags {
                try tagsContainer.encode(userpooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user pool to assign the tags to.</p>
    public let resourceArn: String?
    /// <p>The tags to assign to the user pool.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TimeUnitsType {
    case days
    case hours
    case minutes
    case seconds
    case sdkUnknown(String)
}

extension TimeUnitsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeUnitsType] {
        return [
            .days,
            .hours,
            .minutes,
            .seconds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .days: return "days"
        case .hours: return "hours"
        case .minutes: return "minutes"
        case .seconds: return "seconds"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeUnitsType(rawValue: rawValue) ?? TimeUnitsType.sdkUnknown(rawValue)
    }
}

extension TokenValidityUnitsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case idToken = "IdToken"
        case refreshToken = "RefreshToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken.rawValue, forKey: .accessToken)
        }
        if let idToken = idToken {
            try encodeContainer.encode(idToken.rawValue, forKey: .idToken)
        }
        if let refreshToken = refreshToken {
            try encodeContainer.encode(refreshToken.rawValue, forKey: .refreshToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(TimeUnitsType.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let idTokenDecoded = try containerValues.decodeIfPresent(TimeUnitsType.self, forKey: .idToken)
        idToken = idTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(TimeUnitsType.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
    }
}

extension TokenValidityUnitsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TokenValidityUnitsType(accessToken: \(String(describing: accessToken)), idToken: \(String(describing: idToken)), refreshToken: \(String(describing: refreshToken)))"}
}

/// <p>The data type for TokenValidityUnits that specifics the time measurements for token
///             validity.</p>
public struct TokenValidityUnitsType: Equatable {
    /// <p> A time unit in seconds, minutes, hours or days for the value in
    ///             AccessTokenValidity, defaults to hours.</p>
    public let accessToken: TimeUnitsType?
    /// <p>A time unit in seconds, minutes, hours or days for the value in
    ///             IdTokenValidity, defaults to hours.</p>
    public let idToken: TimeUnitsType?
    /// <p>A time unit in seconds, minutes, hours or days for the value in
    ///             RefreshTokenValidity, defaults to days.</p>
    public let refreshToken: TimeUnitsType?

    public init (
        accessToken: TimeUnitsType? = nil,
        idToken: TimeUnitsType? = nil,
        refreshToken: TimeUnitsType? = nil
    )
    {
        self.accessToken = accessToken
        self.idToken = idToken
        self.refreshToken = refreshToken
    }
}

extension TooManyFailedAttemptsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFailedAttemptsException(message: \(String(describing: message)))"}
}

extension TooManyFailedAttemptsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyFailedAttemptsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the user has made too many failed attempts for a given
///             action (e.g., sign in).</p>
public struct TooManyFailedAttemptsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns a too many failed
    ///             attempts exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFailedAttemptsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyFailedAttemptsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the user has made too many requests for a given
///             operation.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns a too many requests
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UICustomizationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cSS = "CSS"
        case cSSVersion = "CSSVersion"
        case clientId = "ClientId"
        case creationDate = "CreationDate"
        case imageUrl = "ImageUrl"
        case lastModifiedDate = "LastModifiedDate"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cSS = cSS {
            try encodeContainer.encode(cSS, forKey: .cSS)
        }
        if let cSSVersion = cSSVersion {
            try encodeContainer.encode(cSSVersion, forKey: .cSSVersion)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let cSSDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cSS)
        cSS = cSSDecoded
        let cSSVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cSSVersion)
        cSSVersion = cSSVersionDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension UICustomizationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UICustomizationType(cSS: \(String(describing: cSS)), cSSVersion: \(String(describing: cSSVersion)), clientId: \(String(describing: clientId)), creationDate: \(String(describing: creationDate)), imageUrl: \(String(describing: imageUrl)), lastModifiedDate: \(String(describing: lastModifiedDate)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>A container for the UI customization information for a user pool's built-in app
///             UI.</p>
public struct UICustomizationType: Equatable {
    /// <p>The CSS values in the UI customization.</p>
    public let cSS: String?
    /// <p>The CSS version number.</p>
    public let cSSVersion: String?
    /// <p>The client ID for the client app.</p>
    public let clientId: String?
    /// <p>The creation date for the UI customization.</p>
    public let creationDate: Date?
    /// <p>The logo image for the UI customization.</p>
    public let imageUrl: String?
    /// <p>The last-modified date for the UI customization.</p>
    public let lastModifiedDate: Date?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        cSS: String? = nil,
        cSSVersion: String? = nil,
        clientId: String? = nil,
        creationDate: Date? = nil,
        imageUrl: String? = nil,
        lastModifiedDate: Date? = nil,
        userPoolId: String? = nil
    )
    {
        self.cSS = cSS
        self.cSSVersion = cSSVersion
        self.clientId = clientId
        self.creationDate = creationDate
        self.imageUrl = imageUrl
        self.lastModifiedDate = lastModifiedDate
        self.userPoolId = userPoolId
    }
}

extension UnexpectedLambdaException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnexpectedLambdaException(message: \(String(describing: message)))"}
}

extension UnexpectedLambdaException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnexpectedLambdaExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an unexpected
///             exception with the AWS Lambda service.</p>
public struct UnexpectedLambdaException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns an unexpected AWS Lambda
    ///             exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnexpectedLambdaExceptionBody: Equatable {
    public let message: String?
}

extension UnexpectedLambdaExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedIdentityProviderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedIdentityProviderException(message: \(String(describing: message)))"}
}

extension UnsupportedIdentityProviderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedIdentityProviderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified identifier is not supported.</p>
public struct UnsupportedIdentityProviderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedIdentityProviderExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedIdentityProviderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedUserStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedUserStateException(message: \(String(describing: message)))"}
}

extension UnsupportedUserStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedUserStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because the user is in an unsupported state.</p>
public struct UnsupportedUserStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the user is in an unsupported state.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedUserStateExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedUserStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for userpooltagslisttype0 in tagKeys {
                try tagKeysContainer.encode(userpooltagslisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user pool that the tags are assigned to.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to remove from the user pool.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAuthEventFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuthEventFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthEventFeedbackOutputError>
}

extension UpdateAuthEventFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthEventFeedbackInput(eventId: \(String(describing: eventId)), feedbackToken: \(String(describing: feedbackToken)), feedbackValue: \(String(describing: feedbackValue)), userPoolId: \(String(describing: userPoolId)), username: \(String(describing: username)))"}
}

extension UpdateAuthEventFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId = "EventId"
        case feedbackToken = "FeedbackToken"
        case feedbackValue = "FeedbackValue"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let feedbackToken = feedbackToken {
            try encodeContainer.encode(feedbackToken, forKey: .feedbackToken)
        }
        if let feedbackValue = feedbackValue {
            try encodeContainer.encode(feedbackValue.rawValue, forKey: .feedbackValue)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct UpdateAuthEventFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuthEventFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthEventFeedbackOutputError>
}

public struct UpdateAuthEventFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuthEventFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuthEventFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuthEventFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuthEventFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateAuthEventFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuthEventFeedbackOutputError>
}

public struct UpdateAuthEventFeedbackInput: Equatable {
    /// <p>The event ID.</p>
    public let eventId: String?
    /// <p>The feedback token.</p>
    public let feedbackToken: String?
    /// <p>The authentication event feedback value.</p>
    public let feedbackValue: FeedbackValueType?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?
    /// <p>The user pool username.</p>
    public let username: String?

    public init (
        eventId: String? = nil,
        feedbackToken: String? = nil,
        feedbackValue: FeedbackValueType? = nil,
        userPoolId: String? = nil,
        username: String? = nil
    )
    {
        self.eventId = eventId
        self.feedbackToken = feedbackToken
        self.feedbackValue = feedbackValue
        self.userPoolId = userPoolId
        self.username = username
    }
}

struct UpdateAuthEventFeedbackInputBody: Equatable {
    public let userPoolId: String?
    public let username: String?
    public let eventId: String?
    public let feedbackToken: String?
    public let feedbackValue: FeedbackValueType?
}

extension UpdateAuthEventFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventId = "EventId"
        case feedbackToken = "FeedbackToken"
        case feedbackValue = "FeedbackValue"
        case userPoolId = "UserPoolId"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let feedbackTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackToken)
        feedbackToken = feedbackTokenDecoded
        let feedbackValueDecoded = try containerValues.decodeIfPresent(FeedbackValueType.self, forKey: .feedbackValue)
        feedbackValue = feedbackValueDecoded
    }
}

extension UpdateAuthEventFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthEventFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolAddOnNotEnabledException" : self = .userPoolAddOnNotEnabledException(try UserPoolAddOnNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthEventFeedbackOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotFoundException(UserNotFoundException)
    case userPoolAddOnNotEnabledException(UserPoolAddOnNotEnabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthEventFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuthEventFeedbackOutputResponse()"}
}

extension UpdateAuthEventFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAuthEventFeedbackOutputResponse: Equatable {

    public init() {}
}

struct UpdateAuthEventFeedbackOutputResponseBody: Equatable {
}

extension UpdateAuthEventFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDeviceStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeviceStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<UpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceStatusOutputError>
}

extension UpdateDeviceStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceStatusInput(accessToken: \(String(describing: accessToken)), deviceKey: \(String(describing: deviceKey)), deviceRememberedStatus: \(String(describing: deviceRememberedStatus)))"}
}

extension UpdateDeviceStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
        case deviceRememberedStatus = "DeviceRememberedStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let deviceKey = deviceKey {
            try encodeContainer.encode(deviceKey, forKey: .deviceKey)
        }
        if let deviceRememberedStatus = deviceRememberedStatus {
            try encodeContainer.encode(deviceRememberedStatus.rawValue, forKey: .deviceRememberedStatus)
        }
    }
}

public struct UpdateDeviceStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeviceStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<UpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceStatusOutputError>
}

public struct UpdateDeviceStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeviceStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceStatusInput>
    public typealias MOutput = OperationOutput<UpdateDeviceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceStatusOutputError>
}

/// <p>Represents the request to update the device status.</p>
public struct UpdateDeviceStatusInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The device key.</p>
    public let deviceKey: String?
    /// <p>The status of whether a device is remembered.</p>
    public let deviceRememberedStatus: DeviceRememberedStatusType?

    public init (
        accessToken: String? = nil,
        deviceKey: String? = nil,
        deviceRememberedStatus: DeviceRememberedStatusType? = nil
    )
    {
        self.accessToken = accessToken
        self.deviceKey = deviceKey
        self.deviceRememberedStatus = deviceRememberedStatus
    }
}

struct UpdateDeviceStatusInputBody: Equatable {
    public let accessToken: String?
    public let deviceKey: String?
    public let deviceRememberedStatus: DeviceRememberedStatusType?
}

extension UpdateDeviceStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case deviceKey = "DeviceKey"
        case deviceRememberedStatus = "DeviceRememberedStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let deviceKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceKey)
        deviceKey = deviceKeyDecoded
        let deviceRememberedStatusDecoded = try containerValues.decodeIfPresent(DeviceRememberedStatusType.self, forKey: .deviceRememberedStatus)
        deviceRememberedStatus = deviceRememberedStatusDecoded
    }
}

extension UpdateDeviceStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceStatusOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceStatusOutputResponse()"}
}

extension UpdateDeviceStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response to the request to update the device status.</p>
public struct UpdateDeviceStatusOutputResponse: Equatable {

    public init() {}
}

struct UpdateDeviceStatusOutputResponseBody: Equatable {
}

extension UpdateDeviceStatusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(description: \(String(describing: description)), groupName: \(String(describing: groupName)), precedence: \(String(describing: precedence)), roleArn: \(String(describing: roleArn)), userPoolId: \(String(describing: userPoolId)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
        case precedence = "Precedence"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let precedence = precedence {
            try encodeContainer.encode(precedence, forKey: .precedence)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// <p>A string containing the new description of the group.</p>
    public let description: String?
    /// <p>The name of the group.</p>
    public let groupName: String?
    /// <p>The new precedence value for the group. For more information about this parameter, see
    ///                 <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_CreateGroup.html">CreateGroup</a>.</p>
    public let precedence: Int?
    /// <p>The new role ARN for the group. This is used for setting the
    ///                 <code>cognito:roles</code> and <code>cognito:preferred_role</code> claims in the
    ///             token.</p>
    public let roleArn: String?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        description: String? = nil,
        groupName: String? = nil,
        precedence: Int? = nil,
        roleArn: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.description = description
        self.groupName = groupName
        self.precedence = precedence
        self.roleArn = roleArn
        self.userPoolId = userPoolId
    }
}

struct UpdateGroupInputBody: Equatable {
    public let groupName: String?
    public let userPoolId: String?
    public let description: String?
    public let roleArn: String?
    public let precedence: Int?
}

extension UpdateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case groupName = "GroupName"
        case precedence = "Precedence"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let precedenceDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .precedence)
        precedence = precedenceDecoded
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct UpdateGroupOutputResponse: Equatable {
    /// <p>The group object for the group.</p>
    public let group: GroupType?

    public init (
        group: GroupType? = nil
    )
    {
        self.group = group
    }
}

struct UpdateGroupOutputResponseBody: Equatable {
    public let group: GroupType?
}

extension UpdateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(GroupType.self, forKey: .group)
        group = groupDecoded
    }
}

public struct UpdateIdentityProviderInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderOutputError>
}

extension UpdateIdentityProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityProviderInput(attributeMapping: \(String(describing: attributeMapping)), idpIdentifiers: \(String(describing: idpIdentifiers)), providerDetails: \(String(describing: providerDetails)), providerName: \(String(describing: providerName)), userPoolId: \(String(describing: userPoolId)))"}
}

extension UpdateIdentityProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeMapping = "AttributeMapping"
        case idpIdentifiers = "IdpIdentifiers"
        case providerDetails = "ProviderDetails"
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeMapping = attributeMapping {
            var attributeMappingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributeMapping)
            for (dictKey0, attributemappingtype0) in attributeMapping {
                try attributeMappingContainer.encode(attributemappingtype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let idpIdentifiers = idpIdentifiers {
            var idpIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idpIdentifiers)
            for idpidentifierslisttype0 in idpIdentifiers {
                try idpIdentifiersContainer.encode(idpidentifierslisttype0)
            }
        }
        if let providerDetails = providerDetails {
            var providerDetailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .providerDetails)
            for (dictKey0, providerdetailstype0) in providerDetails {
                try providerDetailsContainer.encode(providerdetailstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct UpdateIdentityProviderInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInput: Equatable {
    /// <p>The identity provider attribute mapping to be changed.</p>
    public let attributeMapping: [String:String]?
    /// <p>A list of identity provider identifiers.</p>
    public let idpIdentifiers: [String]?
    /// <p>The identity provider details to be updated, such as <code>MetadataURL</code> and
    ///                 <code>MetadataFile</code>.</p>
    public let providerDetails: [String:String]?
    /// <p>The identity provider name.</p>
    public let providerName: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        attributeMapping: [String:String]? = nil,
        idpIdentifiers: [String]? = nil,
        providerDetails: [String:String]? = nil,
        providerName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.attributeMapping = attributeMapping
        self.idpIdentifiers = idpIdentifiers
        self.providerDetails = providerDetails
        self.providerName = providerName
        self.userPoolId = userPoolId
    }
}

struct UpdateIdentityProviderInputBody: Equatable {
    public let userPoolId: String?
    public let providerName: String?
    public let providerDetails: [String:String]?
    public let attributeMapping: [String:String]?
    public let idpIdentifiers: [String]?
}

extension UpdateIdentityProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeMapping = "AttributeMapping"
        case idpIdentifiers = "IdpIdentifiers"
        case providerDetails = "ProviderDetails"
        case providerName = "ProviderName"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let providerDetailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .providerDetails)
        var providerDetailsDecoded0: [String:String]? = nil
        if let providerDetailsContainer = providerDetailsContainer {
            providerDetailsDecoded0 = [String:String]()
            for (key0, stringtype0) in providerDetailsContainer {
                if let stringtype0 = stringtype0 {
                    providerDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        providerDetails = providerDetailsDecoded0
        let attributeMappingContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributeMapping)
        var attributeMappingDecoded0: [String:String]? = nil
        if let attributeMappingContainer = attributeMappingContainer {
            attributeMappingDecoded0 = [String:String]()
            for (key0, stringtype0) in attributeMappingContainer {
                if let stringtype0 = stringtype0 {
                    attributeMappingDecoded0?[key0] = stringtype0
                }
            }
        }
        attributeMapping = attributeMappingDecoded0
        let idpIdentifiersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .idpIdentifiers)
        var idpIdentifiersDecoded0:[String]? = nil
        if let idpIdentifiersContainer = idpIdentifiersContainer {
            idpIdentifiersDecoded0 = [String]()
            for string0 in idpIdentifiersContainer {
                if let string0 = string0 {
                    idpIdentifiersDecoded0?.append(string0)
                }
            }
        }
        idpIdentifiers = idpIdentifiersDecoded0
    }
}

extension UpdateIdentityProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedIdentityProviderException" : self = .unsupportedIdentityProviderException(try UnsupportedIdentityProviderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityProviderOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedIdentityProviderException(UnsupportedIdentityProviderException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityProviderOutputResponse(identityProvider: \(String(describing: identityProvider)))"}
}

extension UpdateIdentityProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct UpdateIdentityProviderOutputResponse: Equatable {
    /// <p>The identity provider object.</p>
    public let identityProvider: IdentityProviderType?

    public init (
        identityProvider: IdentityProviderType? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct UpdateIdentityProviderOutputResponseBody: Equatable {
    public let identityProvider: IdentityProviderType?
}

extension UpdateIdentityProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityProvider = "IdentityProvider"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

public struct UpdateResourceServerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceServerInput>
    public typealias MOutput = OperationOutput<UpdateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceServerOutputError>
}

extension UpdateResourceServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceServerInput(identifier: \(String(describing: identifier)), name: \(String(describing: name)), scopes: \(String(describing: scopes)), userPoolId: \(String(describing: userPoolId)))"}
}

extension UpdateResourceServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case name = "Name"
        case scopes = "Scopes"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for resourceserverscopelisttype0 in scopes {
                try scopesContainer.encode(resourceserverscopelisttype0)
            }
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct UpdateResourceServerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceServerInput>
    public typealias MOutput = OperationOutput<UpdateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceServerOutputError>
}

public struct UpdateResourceServerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceServerInput>
    public typealias MOutput = OperationOutput<UpdateResourceServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceServerOutputError>
}

public struct UpdateResourceServerInput: Equatable {
    /// <p>The identifier for the resource server.</p>
    public let identifier: String?
    /// <p>The name of the resource server.</p>
    public let name: String?
    /// <p>The scope values to be set for the resource server.</p>
    public let scopes: [ResourceServerScopeType]?
    /// <p>The user pool ID for the user pool.</p>
    public let userPoolId: String?

    public init (
        identifier: String? = nil,
        name: String? = nil,
        scopes: [ResourceServerScopeType]? = nil,
        userPoolId: String? = nil
    )
    {
        self.identifier = identifier
        self.name = name
        self.scopes = scopes
        self.userPoolId = userPoolId
    }
}

struct UpdateResourceServerInputBody: Equatable {
    public let userPoolId: String?
    public let identifier: String?
    public let name: String?
    public let scopes: [ResourceServerScopeType]?
}

extension UpdateResourceServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case name = "Name"
        case scopes = "Scopes"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopesContainer = try containerValues.decodeIfPresent([ResourceServerScopeType?].self, forKey: .scopes)
        var scopesDecoded0:[ResourceServerScopeType]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [ResourceServerScopeType]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension UpdateResourceServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceServerOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceServerOutputResponse(resourceServer: \(String(describing: resourceServer)))"}
}

extension UpdateResourceServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResourceServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceServer = output.resourceServer
        } else {
            self.resourceServer = nil
        }
    }
}

public struct UpdateResourceServerOutputResponse: Equatable {
    /// <p>The resource server.</p>
    public let resourceServer: ResourceServerType?

    public init (
        resourceServer: ResourceServerType? = nil
    )
    {
        self.resourceServer = resourceServer
    }
}

struct UpdateResourceServerOutputResponseBody: Equatable {
    public let resourceServer: ResourceServerType?
}

extension UpdateResourceServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceServer = "ResourceServer"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceServerDecoded = try containerValues.decodeIfPresent(ResourceServerType.self, forKey: .resourceServer)
        resourceServer = resourceServerDecoded
    }
}

public struct UpdateUserAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<UpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserAttributesOutputError>
}

extension UpdateUserAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserAttributesInput(accessToken: \(String(describing: accessToken)), clientMetadata: \(String(describing: clientMetadata)), userAttributes: \(String(describing: userAttributes)))"}
}

extension UpdateUserAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case clientMetadata = "ClientMetadata"
        case userAttributes = "UserAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientMetadata = clientMetadata {
            var clientMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .clientMetadata)
            for (dictKey0, clientmetadatatype0) in clientMetadata {
                try clientMetadataContainer.encode(clientmetadatatype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelisttype0 in userAttributes {
                try userAttributesContainer.encode(attributelisttype0)
            }
        }
    }
}

public struct UpdateUserAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<UpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserAttributesOutputError>
}

public struct UpdateUserAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserAttributesInput>
    public typealias MOutput = OperationOutput<UpdateUserAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserAttributesOutputError>
}

/// <p>Represents the request to update user attributes.</p>
public struct UpdateUserAttributesInput: Equatable {
    /// <p>The access token for the request to update user attributes.</p>
    public let accessToken: String?
    /// <p>A map of custom key-value pairs that you can provide as input for any custom workflows
    ///             that this action triggers. </p>
    ///         <p>You create custom workflows by assigning AWS Lambda functions to user pool triggers.
    ///             When you use the UpdateUserAttributes API action, Amazon Cognito invokes the function
    ///             that is assigned to the <i>custom message</i> trigger. When Amazon Cognito
    ///             invokes this function, it passes a JSON payload, which the function receives as input.
    ///             This payload contains a <code>clientMetadata</code> attribute, which provides the data
    ///             that you assigned to the ClientMetadata parameter in your UpdateUserAttributes request.
    ///             In your function code in AWS Lambda, you can process the <code>clientMetadata</code>
    ///             value to enhance your workflow for your specific needs.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html">Customizing User Pool Workflows with Lambda Triggers</a> in the
    ///                 <i>Amazon Cognito Developer Guide</i>.</p>
    ///         <note>
    ///             <p>Take the following limitations into consideration when you use the ClientMetadata
    ///                 parameter:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>Amazon Cognito does not store the ClientMetadata value. This data is
    ///                         available only to AWS Lambda triggers that are assigned to a user pool to
    ///                         support custom workflows. If your user pool configuration does not include
    ///                         triggers, the ClientMetadata parameter serves no purpose.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not validate the ClientMetadata value.</p>
    ///                 </li>
    ///                <li>
    ///                     <p>Amazon Cognito does not encrypt the the ClientMetadata value, so don't use
    ///                         it to provide sensitive information.</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    public let clientMetadata: [String:String]?
    /// <p>An array of name-value pairs representing user attributes.</p>
    ///         <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
    ///             attribute name.</p>
    public let userAttributes: [AttributeType]?

    public init (
        accessToken: String? = nil,
        clientMetadata: [String:String]? = nil,
        userAttributes: [AttributeType]? = nil
    )
    {
        self.accessToken = accessToken
        self.clientMetadata = clientMetadata
        self.userAttributes = userAttributes
    }
}

struct UpdateUserAttributesInputBody: Equatable {
    public let userAttributes: [AttributeType]?
    public let accessToken: String?
    public let clientMetadata: [String:String]?
}

extension UpdateUserAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case clientMetadata = "ClientMetadata"
        case userAttributes = "UserAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAttributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[AttributeType]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [AttributeType]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let clientMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .clientMetadata)
        var clientMetadataDecoded0: [String:String]? = nil
        if let clientMetadataContainer = clientMetadataContainer {
            clientMetadataDecoded0 = [String:String]()
            for (key0, stringtype0) in clientMetadataContainer {
                if let stringtype0 = stringtype0 {
                    clientMetadataDecoded0?[key0] = stringtype0
                }
            }
        }
        clientMetadata = clientMetadataDecoded0
    }
}

extension UpdateUserAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AliasExistsException" : self = .aliasExistsException(try AliasExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeDeliveryFailureException" : self = .codeDeliveryFailureException(try CodeDeliveryFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaResponseException" : self = .invalidLambdaResponseException(try InvalidLambdaResponseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnexpectedLambdaException" : self = .unexpectedLambdaException(try UnexpectedLambdaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserLambdaValidationException" : self = .userLambdaValidationException(try UserLambdaValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserAttributesOutputError: Equatable {
    case aliasExistsException(AliasExistsException)
    case codeDeliveryFailureException(CodeDeliveryFailureException)
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidLambdaResponseException(InvalidLambdaResponseException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unexpectedLambdaException(UnexpectedLambdaException)
    case userLambdaValidationException(UserLambdaValidationException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserAttributesOutputResponse(codeDeliveryDetailsList: \(String(describing: codeDeliveryDetailsList)))"}
}

extension UpdateUserAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeDeliveryDetailsList = output.codeDeliveryDetailsList
        } else {
            self.codeDeliveryDetailsList = nil
        }
    }
}

/// <p>Represents the response from the server for the request to update user
///             attributes.</p>
public struct UpdateUserAttributesOutputResponse: Equatable {
    /// <p>The code delivery details list from the server for the request to update user
    ///             attributes.</p>
    public let codeDeliveryDetailsList: [CodeDeliveryDetailsType]?

    public init (
        codeDeliveryDetailsList: [CodeDeliveryDetailsType]? = nil
    )
    {
        self.codeDeliveryDetailsList = codeDeliveryDetailsList
    }
}

struct UpdateUserAttributesOutputResponseBody: Equatable {
    public let codeDeliveryDetailsList: [CodeDeliveryDetailsType]?
}

extension UpdateUserAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeDeliveryDetailsList = "CodeDeliveryDetailsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDeliveryDetailsListContainer = try containerValues.decodeIfPresent([CodeDeliveryDetailsType?].self, forKey: .codeDeliveryDetailsList)
        var codeDeliveryDetailsListDecoded0:[CodeDeliveryDetailsType]? = nil
        if let codeDeliveryDetailsListContainer = codeDeliveryDetailsListContainer {
            codeDeliveryDetailsListDecoded0 = [CodeDeliveryDetailsType]()
            for structure0 in codeDeliveryDetailsListContainer {
                if let structure0 = structure0 {
                    codeDeliveryDetailsListDecoded0?.append(structure0)
                }
            }
        }
        codeDeliveryDetailsList = codeDeliveryDetailsListDecoded0
    }
}

public struct UpdateUserPoolClientInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserPoolClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolClientInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolClientOutputError>
}

extension UpdateUserPoolClientInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolClientInput(accessTokenValidity: \(String(describing: accessTokenValidity)), allowedOAuthFlows: \(String(describing: allowedOAuthFlows)), allowedOAuthFlowsUserPoolClient: \(String(describing: allowedOAuthFlowsUserPoolClient)), allowedOAuthScopes: \(String(describing: allowedOAuthScopes)), analyticsConfiguration: \(String(describing: analyticsConfiguration)), callbackURLs: \(String(describing: callbackURLs)), clientId: \(String(describing: clientId)), clientName: \(String(describing: clientName)), defaultRedirectURI: \(String(describing: defaultRedirectURI)), explicitAuthFlows: \(String(describing: explicitAuthFlows)), idTokenValidity: \(String(describing: idTokenValidity)), logoutURLs: \(String(describing: logoutURLs)), preventUserExistenceErrors: \(String(describing: preventUserExistenceErrors)), readAttributes: \(String(describing: readAttributes)), refreshTokenValidity: \(String(describing: refreshTokenValidity)), supportedIdentityProviders: \(String(describing: supportedIdentityProviders)), tokenValidityUnits: \(String(describing: tokenValidityUnits)), userPoolId: \(String(describing: userPoolId)), writeAttributes: \(String(describing: writeAttributes)))"}
}

extension UpdateUserPoolClientInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessTokenValidity = "AccessTokenValidity"
        case allowedOAuthFlows = "AllowedOAuthFlows"
        case allowedOAuthFlowsUserPoolClient = "AllowedOAuthFlowsUserPoolClient"
        case allowedOAuthScopes = "AllowedOAuthScopes"
        case analyticsConfiguration = "AnalyticsConfiguration"
        case callbackURLs = "CallbackURLs"
        case clientId = "ClientId"
        case clientName = "ClientName"
        case defaultRedirectURI = "DefaultRedirectURI"
        case explicitAuthFlows = "ExplicitAuthFlows"
        case idTokenValidity = "IdTokenValidity"
        case logoutURLs = "LogoutURLs"
        case preventUserExistenceErrors = "PreventUserExistenceErrors"
        case readAttributes = "ReadAttributes"
        case refreshTokenValidity = "RefreshTokenValidity"
        case supportedIdentityProviders = "SupportedIdentityProviders"
        case tokenValidityUnits = "TokenValidityUnits"
        case userPoolId = "UserPoolId"
        case writeAttributes = "WriteAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTokenValidity = accessTokenValidity {
            try encodeContainer.encode(accessTokenValidity, forKey: .accessTokenValidity)
        }
        if let allowedOAuthFlows = allowedOAuthFlows {
            var allowedOAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthFlows)
            for oauthflowstype0 in allowedOAuthFlows {
                try allowedOAuthFlowsContainer.encode(oauthflowstype0.rawValue)
            }
        }
        if allowedOAuthFlowsUserPoolClient != false {
            try encodeContainer.encode(allowedOAuthFlowsUserPoolClient, forKey: .allowedOAuthFlowsUserPoolClient)
        }
        if let allowedOAuthScopes = allowedOAuthScopes {
            var allowedOAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthScopes)
            for scopelisttype0 in allowedOAuthScopes {
                try allowedOAuthScopesContainer.encode(scopelisttype0)
            }
        }
        if let analyticsConfiguration = analyticsConfiguration {
            try encodeContainer.encode(analyticsConfiguration, forKey: .analyticsConfiguration)
        }
        if let callbackURLs = callbackURLs {
            var callbackURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callbackURLs)
            for callbackurlslisttype0 in callbackURLs {
                try callbackURLsContainer.encode(callbackurlslisttype0)
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let defaultRedirectURI = defaultRedirectURI {
            try encodeContainer.encode(defaultRedirectURI, forKey: .defaultRedirectURI)
        }
        if let explicitAuthFlows = explicitAuthFlows {
            var explicitAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .explicitAuthFlows)
            for explicitauthflowslisttype0 in explicitAuthFlows {
                try explicitAuthFlowsContainer.encode(explicitauthflowslisttype0.rawValue)
            }
        }
        if let idTokenValidity = idTokenValidity {
            try encodeContainer.encode(idTokenValidity, forKey: .idTokenValidity)
        }
        if let logoutURLs = logoutURLs {
            var logoutURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logoutURLs)
            for logouturlslisttype0 in logoutURLs {
                try logoutURLsContainer.encode(logouturlslisttype0)
            }
        }
        if let preventUserExistenceErrors = preventUserExistenceErrors {
            try encodeContainer.encode(preventUserExistenceErrors.rawValue, forKey: .preventUserExistenceErrors)
        }
        if let readAttributes = readAttributes {
            var readAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readAttributes)
            for clientpermissionlisttype0 in readAttributes {
                try readAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
        if refreshTokenValidity != 0 {
            try encodeContainer.encode(refreshTokenValidity, forKey: .refreshTokenValidity)
        }
        if let supportedIdentityProviders = supportedIdentityProviders {
            var supportedIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedIdentityProviders)
            for supportedidentityproviderslisttype0 in supportedIdentityProviders {
                try supportedIdentityProvidersContainer.encode(supportedidentityproviderslisttype0)
            }
        }
        if let tokenValidityUnits = tokenValidityUnits {
            try encodeContainer.encode(tokenValidityUnits, forKey: .tokenValidityUnits)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let writeAttributes = writeAttributes {
            var writeAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .writeAttributes)
            for clientpermissionlisttype0 in writeAttributes {
                try writeAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
    }
}

public struct UpdateUserPoolClientInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserPoolClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolClientInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolClientOutputError>
}

public struct UpdateUserPoolClientInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserPoolClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolClientInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolClientInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolClientOutputError>
}

/// <p>Represents the request to update the user pool client.</p>
public struct UpdateUserPoolClientInput: Equatable {
    /// <p>The time limit, after which the access token is no longer valid and cannot be
    ///             used.</p>
    public let accessTokenValidity: Int?
    /// <p>The allowed OAuth flows.</p>
    ///         <p>Set to <code>code</code> to initiate a code grant flow, which provides an
    ///             authorization code as the response. This code can be exchanged for access tokens with
    ///             the token endpoint.</p>
    ///         <p>Set to <code>implicit</code> to specify that the client should get the access token
    ///             (and, optionally, ID token, based on scopes) directly.</p>
    ///         <p>Set to <code>client_credentials</code> to specify that the client should get the
    ///             access token (and, optionally, ID token, based on scopes) from the token endpoint using
    ///             a combination of client and client_secret.</p>
    public let allowedOAuthFlows: [OAuthFlowType]?
    /// <p>Set to true if the client is allowed to follow the OAuth protocol when interacting
    ///             with Cognito user pools.</p>
    public let allowedOAuthFlowsUserPoolClient: Bool
    /// <p>The allowed OAuth scopes. Possible values provided by OAuth are: <code>phone</code>,
    ///                 <code>email</code>, <code>openid</code>, and <code>profile</code>. Possible values
    ///             provided by AWS are: <code>aws.cognito.signin.user.admin</code>. Custom scopes created
    ///             in Resource Servers are also supported.</p>
    public let allowedOAuthScopes: [String]?
    /// <p>The Amazon Pinpoint analytics configuration for collecting metrics for this user
    ///             pool.</p>
    ///         <note>
    ///             <p>In regions where Pinpoint is not available, Cognito User Pools only supports
    ///                 sending events to Amazon Pinpoint projects in us-east-1. In regions where Pinpoint
    ///                 is available, Cognito User Pools will support sending events to Amazon Pinpoint
    ///                 projects within that same region. </p>
    ///         </note>
    public let analyticsConfiguration: AnalyticsConfigurationType?
    /// <p>A list of allowed redirect (callback) URLs for the identity providers.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let callbackURLs: [String]?
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>The client name from the update user pool client request.</p>
    public let clientName: String?
    /// <p>The default redirect URI. Must be in the <code>CallbackURLs</code> list.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let defaultRedirectURI: String?
    /// <p>The authentication flows that are supported by the user pool clients. Flow names
    ///             without the <code>ALLOW_</code> prefix are deprecated in favor of new names with the
    ///                 <code>ALLOW_</code> prefix. Note that values with <code>ALLOW_</code> prefix cannot
    ///             be used along with values without <code>ALLOW_</code> prefix.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_ADMIN_USER_PASSWORD_AUTH</code>: Enable admin based user password
    ///                     authentication flow <code>ADMIN_USER_PASSWORD_AUTH</code>. This setting replaces
    ///                     the <code>ADMIN_NO_SRP_AUTH</code> setting. With this authentication flow,
    ///                     Cognito receives the password in the request instead of using the SRP (Secure
    ///                     Remote Password protocol) protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_CUSTOM_AUTH</code>: Enable Lambda trigger based
    ///                     authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_PASSWORD_AUTH</code>: Enable user password-based
    ///                     authentication. In this flow, Cognito receives the password in the request
    ///                     instead of using the SRP protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_SRP_AUTH</code>: Enable SRP based authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_REFRESH_TOKEN_AUTH</code>: Enable authflow to refresh
    ///                     tokens.</p>
    ///             </li>
    ///          </ul>
    public let explicitAuthFlows: [ExplicitAuthFlowsType]?
    /// <p>The time limit, after which the ID token is no longer valid and cannot be used.</p>
    public let idTokenValidity: Int?
    /// <p>A list of allowed logout URLs for the identity providers.</p>
    public let logoutURLs: [String]?
    /// <p>Use this setting to choose which errors and responses are returned by Cognito APIs
    ///             during authentication, account confirmation, and password recovery when the user does
    ///             not exist in the user pool. When set to <code>ENABLED</code> and the user does not
    ///             exist, authentication returns an error indicating either the username or password was
    ///             incorrect, and account confirmation and password recovery return a response indicating a
    ///             code was sent to a simulated destination. When set to <code>LEGACY</code>, those APIs
    ///             will return a <code>UserNotFoundException</code> exception if the user does not exist in
    ///             the user pool.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ENABLED</code> - This prevents user existence-related errors.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LEGACY</code> - This represents the old behavior of Cognito where user
    ///                     existence related errors are not prevented.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <note>
    ///             <p>After February 15th 2020, the value of <code>PreventUserExistenceErrors</code>
    ///                 will default to <code>ENABLED</code> for newly created user pool clients if no value
    ///                 is provided.</p>
    ///         </note>
    public let preventUserExistenceErrors: PreventUserExistenceErrorTypes?
    /// <p>The read-only attributes of the user pool.</p>
    public let readAttributes: [String]?
    /// <p>The time limit, in days, after which the refresh token is no longer valid and cannot
    ///             be used.</p>
    public let refreshTokenValidity: Int
    /// <p>A list of provider names for the identity providers that are supported on this
    ///             client.</p>
    public let supportedIdentityProviders: [String]?
    /// <p>The units in which the validity times are represented in. Default for RefreshToken is
    ///             days, and default for ID and access tokens are hours.</p>
    public let tokenValidityUnits: TokenValidityUnitsType?
    /// <p>The user pool ID for the user pool where you want to update the user pool
    ///             client.</p>
    public let userPoolId: String?
    /// <p>The writeable attributes of the user pool.</p>
    public let writeAttributes: [String]?

    public init (
        accessTokenValidity: Int? = nil,
        allowedOAuthFlows: [OAuthFlowType]? = nil,
        allowedOAuthFlowsUserPoolClient: Bool = false,
        allowedOAuthScopes: [String]? = nil,
        analyticsConfiguration: AnalyticsConfigurationType? = nil,
        callbackURLs: [String]? = nil,
        clientId: String? = nil,
        clientName: String? = nil,
        defaultRedirectURI: String? = nil,
        explicitAuthFlows: [ExplicitAuthFlowsType]? = nil,
        idTokenValidity: Int? = nil,
        logoutURLs: [String]? = nil,
        preventUserExistenceErrors: PreventUserExistenceErrorTypes? = nil,
        readAttributes: [String]? = nil,
        refreshTokenValidity: Int = 0,
        supportedIdentityProviders: [String]? = nil,
        tokenValidityUnits: TokenValidityUnitsType? = nil,
        userPoolId: String? = nil,
        writeAttributes: [String]? = nil
    )
    {
        self.accessTokenValidity = accessTokenValidity
        self.allowedOAuthFlows = allowedOAuthFlows
        self.allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClient
        self.allowedOAuthScopes = allowedOAuthScopes
        self.analyticsConfiguration = analyticsConfiguration
        self.callbackURLs = callbackURLs
        self.clientId = clientId
        self.clientName = clientName
        self.defaultRedirectURI = defaultRedirectURI
        self.explicitAuthFlows = explicitAuthFlows
        self.idTokenValidity = idTokenValidity
        self.logoutURLs = logoutURLs
        self.preventUserExistenceErrors = preventUserExistenceErrors
        self.readAttributes = readAttributes
        self.refreshTokenValidity = refreshTokenValidity
        self.supportedIdentityProviders = supportedIdentityProviders
        self.tokenValidityUnits = tokenValidityUnits
        self.userPoolId = userPoolId
        self.writeAttributes = writeAttributes
    }
}

struct UpdateUserPoolClientInputBody: Equatable {
    public let userPoolId: String?
    public let clientId: String?
    public let clientName: String?
    public let refreshTokenValidity: Int
    public let accessTokenValidity: Int?
    public let idTokenValidity: Int?
    public let tokenValidityUnits: TokenValidityUnitsType?
    public let readAttributes: [String]?
    public let writeAttributes: [String]?
    public let explicitAuthFlows: [ExplicitAuthFlowsType]?
    public let supportedIdentityProviders: [String]?
    public let callbackURLs: [String]?
    public let logoutURLs: [String]?
    public let defaultRedirectURI: String?
    public let allowedOAuthFlows: [OAuthFlowType]?
    public let allowedOAuthScopes: [String]?
    public let allowedOAuthFlowsUserPoolClient: Bool
    public let analyticsConfiguration: AnalyticsConfigurationType?
    public let preventUserExistenceErrors: PreventUserExistenceErrorTypes?
}

extension UpdateUserPoolClientInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessTokenValidity = "AccessTokenValidity"
        case allowedOAuthFlows = "AllowedOAuthFlows"
        case allowedOAuthFlowsUserPoolClient = "AllowedOAuthFlowsUserPoolClient"
        case allowedOAuthScopes = "AllowedOAuthScopes"
        case analyticsConfiguration = "AnalyticsConfiguration"
        case callbackURLs = "CallbackURLs"
        case clientId = "ClientId"
        case clientName = "ClientName"
        case defaultRedirectURI = "DefaultRedirectURI"
        case explicitAuthFlows = "ExplicitAuthFlows"
        case idTokenValidity = "IdTokenValidity"
        case logoutURLs = "LogoutURLs"
        case preventUserExistenceErrors = "PreventUserExistenceErrors"
        case readAttributes = "ReadAttributes"
        case refreshTokenValidity = "RefreshTokenValidity"
        case supportedIdentityProviders = "SupportedIdentityProviders"
        case tokenValidityUnits = "TokenValidityUnits"
        case userPoolId = "UserPoolId"
        case writeAttributes = "WriteAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let refreshTokenValidityDecoded = try containerValues.decode(Int.self, forKey: .refreshTokenValidity)
        refreshTokenValidity = refreshTokenValidityDecoded
        let accessTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .accessTokenValidity)
        accessTokenValidity = accessTokenValidityDecoded
        let idTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idTokenValidity)
        idTokenValidity = idTokenValidityDecoded
        let tokenValidityUnitsDecoded = try containerValues.decodeIfPresent(TokenValidityUnitsType.self, forKey: .tokenValidityUnits)
        tokenValidityUnits = tokenValidityUnitsDecoded
        let readAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readAttributes)
        var readAttributesDecoded0:[String]? = nil
        if let readAttributesContainer = readAttributesContainer {
            readAttributesDecoded0 = [String]()
            for string0 in readAttributesContainer {
                if let string0 = string0 {
                    readAttributesDecoded0?.append(string0)
                }
            }
        }
        readAttributes = readAttributesDecoded0
        let writeAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .writeAttributes)
        var writeAttributesDecoded0:[String]? = nil
        if let writeAttributesContainer = writeAttributesContainer {
            writeAttributesDecoded0 = [String]()
            for string0 in writeAttributesContainer {
                if let string0 = string0 {
                    writeAttributesDecoded0?.append(string0)
                }
            }
        }
        writeAttributes = writeAttributesDecoded0
        let explicitAuthFlowsContainer = try containerValues.decodeIfPresent([ExplicitAuthFlowsType?].self, forKey: .explicitAuthFlows)
        var explicitAuthFlowsDecoded0:[ExplicitAuthFlowsType]? = nil
        if let explicitAuthFlowsContainer = explicitAuthFlowsContainer {
            explicitAuthFlowsDecoded0 = [ExplicitAuthFlowsType]()
            for string0 in explicitAuthFlowsContainer {
                if let string0 = string0 {
                    explicitAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        explicitAuthFlows = explicitAuthFlowsDecoded0
        let supportedIdentityProvidersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedIdentityProviders)
        var supportedIdentityProvidersDecoded0:[String]? = nil
        if let supportedIdentityProvidersContainer = supportedIdentityProvidersContainer {
            supportedIdentityProvidersDecoded0 = [String]()
            for string0 in supportedIdentityProvidersContainer {
                if let string0 = string0 {
                    supportedIdentityProvidersDecoded0?.append(string0)
                }
            }
        }
        supportedIdentityProviders = supportedIdentityProvidersDecoded0
        let callbackURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .callbackURLs)
        var callbackURLsDecoded0:[String]? = nil
        if let callbackURLsContainer = callbackURLsContainer {
            callbackURLsDecoded0 = [String]()
            for string0 in callbackURLsContainer {
                if let string0 = string0 {
                    callbackURLsDecoded0?.append(string0)
                }
            }
        }
        callbackURLs = callbackURLsDecoded0
        let logoutURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logoutURLs)
        var logoutURLsDecoded0:[String]? = nil
        if let logoutURLsContainer = logoutURLsContainer {
            logoutURLsDecoded0 = [String]()
            for string0 in logoutURLsContainer {
                if let string0 = string0 {
                    logoutURLsDecoded0?.append(string0)
                }
            }
        }
        logoutURLs = logoutURLsDecoded0
        let defaultRedirectURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultRedirectURI)
        defaultRedirectURI = defaultRedirectURIDecoded
        let allowedOAuthFlowsContainer = try containerValues.decodeIfPresent([OAuthFlowType?].self, forKey: .allowedOAuthFlows)
        var allowedOAuthFlowsDecoded0:[OAuthFlowType]? = nil
        if let allowedOAuthFlowsContainer = allowedOAuthFlowsContainer {
            allowedOAuthFlowsDecoded0 = [OAuthFlowType]()
            for string0 in allowedOAuthFlowsContainer {
                if let string0 = string0 {
                    allowedOAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthFlows = allowedOAuthFlowsDecoded0
        let allowedOAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedOAuthScopes)
        var allowedOAuthScopesDecoded0:[String]? = nil
        if let allowedOAuthScopesContainer = allowedOAuthScopesContainer {
            allowedOAuthScopesDecoded0 = [String]()
            for string0 in allowedOAuthScopesContainer {
                if let string0 = string0 {
                    allowedOAuthScopesDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthScopes = allowedOAuthScopesDecoded0
        let allowedOAuthFlowsUserPoolClientDecoded = try containerValues.decode(Bool.self, forKey: .allowedOAuthFlowsUserPoolClient)
        allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClientDecoded
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(AnalyticsConfigurationType.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
        let preventUserExistenceErrorsDecoded = try containerValues.decodeIfPresent(PreventUserExistenceErrorTypes.self, forKey: .preventUserExistenceErrors)
        preventUserExistenceErrors = preventUserExistenceErrorsDecoded
    }
}

extension UpdateUserPoolClientOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserPoolClientOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOAuthFlowException" : self = .invalidOAuthFlowException(try InvalidOAuthFlowException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScopeDoesNotExistException" : self = .scopeDoesNotExistException(try ScopeDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserPoolClientOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidOAuthFlowException(InvalidOAuthFlowException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case scopeDoesNotExistException(ScopeDoesNotExistException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserPoolClientOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolClientOutputResponse(userPoolClient: \(String(describing: userPoolClient)))"}
}

extension UpdateUserPoolClientOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserPoolClientOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userPoolClient = output.userPoolClient
        } else {
            self.userPoolClient = nil
        }
    }
}

/// <p>Represents the response from the server to the request to update the user pool
///             client.</p>
public struct UpdateUserPoolClientOutputResponse: Equatable {
    /// <p>The user pool client value from the response from the server when an update user pool
    ///             client request is made.</p>
    public let userPoolClient: UserPoolClientType?

    public init (
        userPoolClient: UserPoolClientType? = nil
    )
    {
        self.userPoolClient = userPoolClient
    }
}

struct UpdateUserPoolClientOutputResponseBody: Equatable {
    public let userPoolClient: UserPoolClientType?
}

extension UpdateUserPoolClientOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userPoolClient = "UserPoolClient"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolClientDecoded = try containerValues.decodeIfPresent(UserPoolClientType.self, forKey: .userPoolClient)
        userPoolClient = userPoolClientDecoded
    }
}

public struct UpdateUserPoolDomainInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserPoolDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolDomainOutputError>
}

extension UpdateUserPoolDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolDomainInput(customDomainConfig: \(String(describing: customDomainConfig)), domain: \(String(describing: domain)), userPoolId: \(String(describing: userPoolId)))"}
}

extension UpdateUserPoolDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customDomainConfig = "CustomDomainConfig"
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDomainConfig = customDomainConfig {
            try encodeContainer.encode(customDomainConfig, forKey: .customDomainConfig)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }
}

public struct UpdateUserPoolDomainInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserPoolDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolDomainOutputError>
}

public struct UpdateUserPoolDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserPoolDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolDomainInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolDomainOutputError>
}

/// <p>The UpdateUserPoolDomain request input.</p>
public struct UpdateUserPoolDomainInput: Equatable {
    /// <p>The configuration for a custom domain that hosts the sign-up and sign-in pages for
    ///             your application. Use this object to specify an SSL certificate that is managed by
    ///             ACM.</p>
    public let customDomainConfig: CustomDomainConfigType?
    /// <p>The domain name for the custom domain that hosts the sign-up and sign-in pages for
    ///             your application. For example: <code>auth.example.com</code>. </p>
    ///         <p>This string can include only lowercase letters, numbers, and hyphens. Do not use a
    ///             hyphen for the first or last character. Use periods to separate subdomain names.</p>
    public let domain: String?
    /// <p>The ID of the user pool that is associated with the custom domain that you are
    ///             updating the certificate for.</p>
    public let userPoolId: String?

    public init (
        customDomainConfig: CustomDomainConfigType? = nil,
        domain: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.customDomainConfig = customDomainConfig
        self.domain = domain
        self.userPoolId = userPoolId
    }
}

struct UpdateUserPoolDomainInputBody: Equatable {
    public let domain: String?
    public let userPoolId: String?
    public let customDomainConfig: CustomDomainConfigType?
}

extension UpdateUserPoolDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customDomainConfig = "CustomDomainConfig"
        case domain = "Domain"
        case userPoolId = "UserPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let customDomainConfigDecoded = try containerValues.decodeIfPresent(CustomDomainConfigType.self, forKey: .customDomainConfig)
        customDomainConfig = customDomainConfigDecoded
    }
}

extension UpdateUserPoolDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserPoolDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserPoolDomainOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserPoolDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolDomainOutputResponse(cloudFrontDomain: \(String(describing: cloudFrontDomain)))"}
}

extension UpdateUserPoolDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserPoolDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudFrontDomain = output.cloudFrontDomain
        } else {
            self.cloudFrontDomain = nil
        }
    }
}

/// <p>The UpdateUserPoolDomain response output.</p>
public struct UpdateUserPoolDomainOutputResponse: Equatable {
    /// <p>The Amazon CloudFront endpoint that Amazon Cognito set up when you added the custom
    ///             domain to your user pool.</p>
    public let cloudFrontDomain: String?

    public init (
        cloudFrontDomain: String? = nil
    )
    {
        self.cloudFrontDomain = cloudFrontDomain
    }
}

struct UpdateUserPoolDomainOutputResponseBody: Equatable {
    public let cloudFrontDomain: String?
}

extension UpdateUserPoolDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontDomain = "CloudFrontDomain"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudFrontDomain)
        cloudFrontDomain = cloudFrontDomainDecoded
    }
}

public struct UpdateUserPoolInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolOutputError>
}

extension UpdateUserPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolInput(accountRecoverySetting: \(String(describing: accountRecoverySetting)), adminCreateUserConfig: \(String(describing: adminCreateUserConfig)), autoVerifiedAttributes: \(String(describing: autoVerifiedAttributes)), deviceConfiguration: \(String(describing: deviceConfiguration)), emailConfiguration: \(String(describing: emailConfiguration)), emailVerificationMessage: \(String(describing: emailVerificationMessage)), emailVerificationSubject: \(String(describing: emailVerificationSubject)), lambdaConfig: \(String(describing: lambdaConfig)), mfaConfiguration: \(String(describing: mfaConfiguration)), policies: \(String(describing: policies)), smsAuthenticationMessage: \(String(describing: smsAuthenticationMessage)), smsConfiguration: \(String(describing: smsConfiguration)), smsVerificationMessage: \(String(describing: smsVerificationMessage)), userPoolAddOns: \(String(describing: userPoolAddOns)), userPoolId: \(String(describing: userPoolId)), userPoolTags: \(String(describing: userPoolTags)), verificationMessageTemplate: \(String(describing: verificationMessageTemplate)))"}
}

extension UpdateUserPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountRecoverySetting = "AccountRecoverySetting"
        case adminCreateUserConfig = "AdminCreateUserConfig"
        case autoVerifiedAttributes = "AutoVerifiedAttributes"
        case deviceConfiguration = "DeviceConfiguration"
        case emailConfiguration = "EmailConfiguration"
        case emailVerificationMessage = "EmailVerificationMessage"
        case emailVerificationSubject = "EmailVerificationSubject"
        case lambdaConfig = "LambdaConfig"
        case mfaConfiguration = "MfaConfiguration"
        case policies = "Policies"
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
        case smsVerificationMessage = "SmsVerificationMessage"
        case userPoolAddOns = "UserPoolAddOns"
        case userPoolId = "UserPoolId"
        case userPoolTags = "UserPoolTags"
        case verificationMessageTemplate = "VerificationMessageTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountRecoverySetting = accountRecoverySetting {
            try encodeContainer.encode(accountRecoverySetting, forKey: .accountRecoverySetting)
        }
        if let adminCreateUserConfig = adminCreateUserConfig {
            try encodeContainer.encode(adminCreateUserConfig, forKey: .adminCreateUserConfig)
        }
        if let autoVerifiedAttributes = autoVerifiedAttributes {
            var autoVerifiedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoVerifiedAttributes)
            for verifiedattributeslisttype0 in autoVerifiedAttributes {
                try autoVerifiedAttributesContainer.encode(verifiedattributeslisttype0.rawValue)
            }
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let emailConfiguration = emailConfiguration {
            try encodeContainer.encode(emailConfiguration, forKey: .emailConfiguration)
        }
        if let emailVerificationMessage = emailVerificationMessage {
            try encodeContainer.encode(emailVerificationMessage, forKey: .emailVerificationMessage)
        }
        if let emailVerificationSubject = emailVerificationSubject {
            try encodeContainer.encode(emailVerificationSubject, forKey: .emailVerificationSubject)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let mfaConfiguration = mfaConfiguration {
            try encodeContainer.encode(mfaConfiguration.rawValue, forKey: .mfaConfiguration)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let smsAuthenticationMessage = smsAuthenticationMessage {
            try encodeContainer.encode(smsAuthenticationMessage, forKey: .smsAuthenticationMessage)
        }
        if let smsConfiguration = smsConfiguration {
            try encodeContainer.encode(smsConfiguration, forKey: .smsConfiguration)
        }
        if let smsVerificationMessage = smsVerificationMessage {
            try encodeContainer.encode(smsVerificationMessage, forKey: .smsVerificationMessage)
        }
        if let userPoolAddOns = userPoolAddOns {
            try encodeContainer.encode(userPoolAddOns, forKey: .userPoolAddOns)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let userPoolTags = userPoolTags {
            var userPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userPoolTags)
            for (dictKey0, userpooltagstype0) in userPoolTags {
                try userPoolTagsContainer.encode(userpooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let verificationMessageTemplate = verificationMessageTemplate {
            try encodeContainer.encode(verificationMessageTemplate, forKey: .verificationMessageTemplate)
        }
    }
}

public struct UpdateUserPoolInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolOutputError>
}

public struct UpdateUserPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserPoolInput>
    public typealias MOutput = OperationOutput<UpdateUserPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserPoolOutputError>
}

/// <p>Represents the request to update the user pool.</p>
public struct UpdateUserPoolInput: Equatable {
    /// <p>Use this setting to define which verified available method a user can use to recover
    ///             their password when they call <code>ForgotPassword</code>. It allows you to define a
    ///             preferred method when a user has more than one method available. With this setting, SMS
    ///             does not qualify for a valid password recovery mechanism if the user also has SMS MFA
    ///             enabled. In the absence of this setting, Cognito uses the legacy behavior to determine
    ///             the recovery method where SMS is preferred over email.</p>
    public let accountRecoverySetting: AccountRecoverySettingType?
    /// <p>The configuration for <code>AdminCreateUser</code> requests.</p>
    public let adminCreateUserConfig: AdminCreateUserConfigType?
    /// <p>The attributes that are automatically verified when the Amazon Cognito service makes a
    ///             request to update user pools.</p>
    public let autoVerifiedAttributes: [VerifiedAttributeType]?
    /// <p>Device configuration.</p>
    public let deviceConfiguration: DeviceConfigurationType?
    /// <p>Email configuration.</p>
    public let emailConfiguration: EmailConfigurationType?
    /// <p>The contents of the email verification message.</p>
    public let emailVerificationMessage: String?
    /// <p>The subject of the email verification message.</p>
    public let emailVerificationSubject: String?
    /// <p>The AWS Lambda configuration information from the request to update the user
    ///             pool.</p>
    public let lambdaConfig: LambdaConfigType?
    /// <p>Can be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>OFF</code> - MFA tokens are not required and cannot be specified during
    ///                     user registration.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ON</code> - MFA tokens are required for all user registrations. You can
    ///                     only specify ON when you are initially creating a user pool. You can use the
    ///                         <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_SetUserPoolMfaConfig.html">SetUserPoolMfaConfig</a> API operation to turn MFA "ON" for existing
    ///                     user pools. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OPTIONAL</code> - Users have the option when registering to create an MFA
    ///                     token.</p>
    ///             </li>
    ///          </ul>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>A container with the policies you wish to update in a user pool.</p>
    public let policies: UserPoolPolicyType?
    /// <p>The contents of the SMS authentication message.</p>
    public let smsAuthenticationMessage: String?
    /// <p>SMS configuration.</p>
    public let smsConfiguration: SmsConfigurationType?
    /// <p>A container with information about the SMS verification message.</p>
    public let smsVerificationMessage: String?
    /// <p>Used to enable advanced security risk detection. Set the key
    ///                 <code>AdvancedSecurityMode</code> to the value "AUDIT".</p>
    public let userPoolAddOns: UserPoolAddOnsType?
    /// <p>The user pool ID for the user pool you want to update.</p>
    public let userPoolId: String?
    /// <p>The tag keys and values to assign to the user pool. A tag is a label that you can use
    ///             to categorize and manage user pools in different ways, such as by purpose, owner,
    ///             environment, or other criteria.</p>
    public let userPoolTags: [String:String]?
    /// <p>The template for verification messages.</p>
    public let verificationMessageTemplate: VerificationMessageTemplateType?

    public init (
        accountRecoverySetting: AccountRecoverySettingType? = nil,
        adminCreateUserConfig: AdminCreateUserConfigType? = nil,
        autoVerifiedAttributes: [VerifiedAttributeType]? = nil,
        deviceConfiguration: DeviceConfigurationType? = nil,
        emailConfiguration: EmailConfigurationType? = nil,
        emailVerificationMessage: String? = nil,
        emailVerificationSubject: String? = nil,
        lambdaConfig: LambdaConfigType? = nil,
        mfaConfiguration: UserPoolMfaType? = nil,
        policies: UserPoolPolicyType? = nil,
        smsAuthenticationMessage: String? = nil,
        smsConfiguration: SmsConfigurationType? = nil,
        smsVerificationMessage: String? = nil,
        userPoolAddOns: UserPoolAddOnsType? = nil,
        userPoolId: String? = nil,
        userPoolTags: [String:String]? = nil,
        verificationMessageTemplate: VerificationMessageTemplateType? = nil
    )
    {
        self.accountRecoverySetting = accountRecoverySetting
        self.adminCreateUserConfig = adminCreateUserConfig
        self.autoVerifiedAttributes = autoVerifiedAttributes
        self.deviceConfiguration = deviceConfiguration
        self.emailConfiguration = emailConfiguration
        self.emailVerificationMessage = emailVerificationMessage
        self.emailVerificationSubject = emailVerificationSubject
        self.lambdaConfig = lambdaConfig
        self.mfaConfiguration = mfaConfiguration
        self.policies = policies
        self.smsAuthenticationMessage = smsAuthenticationMessage
        self.smsConfiguration = smsConfiguration
        self.smsVerificationMessage = smsVerificationMessage
        self.userPoolAddOns = userPoolAddOns
        self.userPoolId = userPoolId
        self.userPoolTags = userPoolTags
        self.verificationMessageTemplate = verificationMessageTemplate
    }
}

struct UpdateUserPoolInputBody: Equatable {
    public let userPoolId: String?
    public let policies: UserPoolPolicyType?
    public let lambdaConfig: LambdaConfigType?
    public let autoVerifiedAttributes: [VerifiedAttributeType]?
    public let smsVerificationMessage: String?
    public let emailVerificationMessage: String?
    public let emailVerificationSubject: String?
    public let verificationMessageTemplate: VerificationMessageTemplateType?
    public let smsAuthenticationMessage: String?
    public let mfaConfiguration: UserPoolMfaType?
    public let deviceConfiguration: DeviceConfigurationType?
    public let emailConfiguration: EmailConfigurationType?
    public let smsConfiguration: SmsConfigurationType?
    public let userPoolTags: [String:String]?
    public let adminCreateUserConfig: AdminCreateUserConfigType?
    public let userPoolAddOns: UserPoolAddOnsType?
    public let accountRecoverySetting: AccountRecoverySettingType?
}

extension UpdateUserPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountRecoverySetting = "AccountRecoverySetting"
        case adminCreateUserConfig = "AdminCreateUserConfig"
        case autoVerifiedAttributes = "AutoVerifiedAttributes"
        case deviceConfiguration = "DeviceConfiguration"
        case emailConfiguration = "EmailConfiguration"
        case emailVerificationMessage = "EmailVerificationMessage"
        case emailVerificationSubject = "EmailVerificationSubject"
        case lambdaConfig = "LambdaConfig"
        case mfaConfiguration = "MfaConfiguration"
        case policies = "Policies"
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
        case smsVerificationMessage = "SmsVerificationMessage"
        case userPoolAddOns = "UserPoolAddOns"
        case userPoolId = "UserPoolId"
        case userPoolTags = "UserPoolTags"
        case verificationMessageTemplate = "VerificationMessageTemplate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(UserPoolPolicyType.self, forKey: .policies)
        policies = policiesDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaConfigType.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let autoVerifiedAttributesContainer = try containerValues.decodeIfPresent([VerifiedAttributeType?].self, forKey: .autoVerifiedAttributes)
        var autoVerifiedAttributesDecoded0:[VerifiedAttributeType]? = nil
        if let autoVerifiedAttributesContainer = autoVerifiedAttributesContainer {
            autoVerifiedAttributesDecoded0 = [VerifiedAttributeType]()
            for string0 in autoVerifiedAttributesContainer {
                if let string0 = string0 {
                    autoVerifiedAttributesDecoded0?.append(string0)
                }
            }
        }
        autoVerifiedAttributes = autoVerifiedAttributesDecoded0
        let smsVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsVerificationMessage)
        smsVerificationMessage = smsVerificationMessageDecoded
        let emailVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationMessage)
        emailVerificationMessage = emailVerificationMessageDecoded
        let emailVerificationSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationSubject)
        emailVerificationSubject = emailVerificationSubjectDecoded
        let verificationMessageTemplateDecoded = try containerValues.decodeIfPresent(VerificationMessageTemplateType.self, forKey: .verificationMessageTemplate)
        verificationMessageTemplate = verificationMessageTemplateDecoded
        let smsAuthenticationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsAuthenticationMessage)
        smsAuthenticationMessage = smsAuthenticationMessageDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceConfigurationType.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let emailConfigurationDecoded = try containerValues.decodeIfPresent(EmailConfigurationType.self, forKey: .emailConfiguration)
        emailConfiguration = emailConfigurationDecoded
        let smsConfigurationDecoded = try containerValues.decodeIfPresent(SmsConfigurationType.self, forKey: .smsConfiguration)
        smsConfiguration = smsConfigurationDecoded
        let userPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userPoolTags)
        var userPoolTagsDecoded0: [String:String]? = nil
        if let userPoolTagsContainer = userPoolTagsContainer {
            userPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in userPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    userPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        userPoolTags = userPoolTagsDecoded0
        let adminCreateUserConfigDecoded = try containerValues.decodeIfPresent(AdminCreateUserConfigType.self, forKey: .adminCreateUserConfig)
        adminCreateUserConfig = adminCreateUserConfigDecoded
        let userPoolAddOnsDecoded = try containerValues.decodeIfPresent(UserPoolAddOnsType.self, forKey: .userPoolAddOns)
        userPoolAddOns = userPoolAddOnsDecoded
        let accountRecoverySettingDecoded = try containerValues.decodeIfPresent(AccountRecoverySettingType.self, forKey: .accountRecoverySetting)
        accountRecoverySetting = accountRecoverySettingDecoded
    }
}

extension UpdateUserPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailRoleAccessPolicyException" : self = .invalidEmailRoleAccessPolicyException(try InvalidEmailRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleAccessPolicyException" : self = .invalidSmsRoleAccessPolicyException(try InvalidSmsRoleAccessPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSmsRoleTrustRelationshipException" : self = .invalidSmsRoleTrustRelationshipException(try InvalidSmsRoleTrustRelationshipException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserImportInProgressException" : self = .userImportInProgressException(try UserImportInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserPoolTaggingException" : self = .userPoolTaggingException(try UserPoolTaggingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserPoolOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidEmailRoleAccessPolicyException(InvalidEmailRoleAccessPolicyException)
    case invalidParameterException(InvalidParameterException)
    case invalidSmsRoleAccessPolicyException(InvalidSmsRoleAccessPolicyException)
    case invalidSmsRoleTrustRelationshipException(InvalidSmsRoleTrustRelationshipException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userImportInProgressException(UserImportInProgressException)
    case userPoolTaggingException(UserPoolTaggingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserPoolOutputResponse()"}
}

extension UpdateUserPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the response from the server when you make a request to update the user
///             pool.</p>
public struct UpdateUserPoolOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserPoolOutputResponseBody: Equatable {
}

extension UpdateUserPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserContextDataType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encodedData = "EncodedData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodedData = encodedData {
            try encodeContainer.encode(encodedData, forKey: .encodedData)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodedDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encodedData)
        encodedData = encodedDataDecoded
    }
}

extension UserContextDataType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserContextDataType(encodedData: \(String(describing: encodedData)))"}
}

/// <p>Contextual data such as the user's device fingerprint, IP address, or location used
///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
///             security.</p>
public struct UserContextDataType: Equatable {
    /// <p>Contextual data such as the user's device fingerprint, IP address, or location used
    ///             for evaluating the risk of an unexpected event by Amazon Cognito advanced
    ///             security.</p>
    public let encodedData: String?

    public init (
        encodedData: String? = nil
    )
    {
        self.encodedData = encodedData
    }
}

extension UserImportInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserImportInProgressException(message: \(String(describing: message)))"}
}

extension UserImportInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserImportInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when you are trying to modify a user pool while a user import
///             job is in progress for that pool.</p>
public struct UserImportInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the user pool has an import job running.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserImportInProgressExceptionBody: Equatable {
    public let message: String?
}

extension UserImportInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum UserImportJobStatusType {
    case created
    case expired
    case failed
    case inprogress
    case pending
    case stopped
    case stopping
    case succeeded
    case sdkUnknown(String)
}

extension UserImportJobStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserImportJobStatusType] {
        return [
            .created,
            .expired,
            .failed,
            .inprogress,
            .pending,
            .stopped,
            .stopping,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "Created"
        case .expired: return "Expired"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .pending: return "Pending"
        case .stopped: return "Stopped"
        case .stopping: return "Stopping"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserImportJobStatusType(rawValue: rawValue) ?? UserImportJobStatusType.sdkUnknown(rawValue)
    }
}

extension UserImportJobType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case completionDate = "CompletionDate"
        case completionMessage = "CompletionMessage"
        case creationDate = "CreationDate"
        case failedUsers = "FailedUsers"
        case importedUsers = "ImportedUsers"
        case jobId = "JobId"
        case jobName = "JobName"
        case preSignedUrl = "PreSignedUrl"
        case skippedUsers = "SkippedUsers"
        case startDate = "StartDate"
        case status = "Status"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let completionMessage = completionMessage {
            try encodeContainer.encode(completionMessage, forKey: .completionMessage)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if failedUsers != 0 {
            try encodeContainer.encode(failedUsers, forKey: .failedUsers)
        }
        if importedUsers != 0 {
            try encodeContainer.encode(importedUsers, forKey: .importedUsers)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let preSignedUrl = preSignedUrl {
            try encodeContainer.encode(preSignedUrl, forKey: .preSignedUrl)
        }
        if skippedUsers != 0 {
            try encodeContainer.encode(skippedUsers, forKey: .skippedUsers)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(UserImportJobStatusType.self, forKey: .status)
        status = statusDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let importedUsersDecoded = try containerValues.decode(Int.self, forKey: .importedUsers)
        importedUsers = importedUsersDecoded
        let skippedUsersDecoded = try containerValues.decode(Int.self, forKey: .skippedUsers)
        skippedUsers = skippedUsersDecoded
        let failedUsersDecoded = try containerValues.decode(Int.self, forKey: .failedUsers)
        failedUsers = failedUsersDecoded
        let completionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionMessage)
        completionMessage = completionMessageDecoded
    }
}

extension UserImportJobType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserImportJobType(cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), completionDate: \(String(describing: completionDate)), completionMessage: \(String(describing: completionMessage)), creationDate: \(String(describing: creationDate)), failedUsers: \(String(describing: failedUsers)), importedUsers: \(String(describing: importedUsers)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), preSignedUrl: \(String(describing: preSignedUrl)), skippedUsers: \(String(describing: skippedUsers)), startDate: \(String(describing: startDate)), status: \(String(describing: status)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>The user import job type.</p>
public struct UserImportJobType: Equatable {
    /// <p>The role ARN for the Amazon CloudWatch Logging role for the user import job. For more
    ///             information, see "Creating the CloudWatch Logs IAM Role" in the Amazon Cognito Developer
    ///             Guide.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>The date when the user import job was completed.</p>
    public let completionDate: Date?
    /// <p>The message returned when the user import job is completed.</p>
    public let completionMessage: String?
    /// <p>The date the user import job was created.</p>
    public let creationDate: Date?
    /// <p>The number of users that could not be imported.</p>
    public let failedUsers: Int
    /// <p>The number of users that were successfully imported.</p>
    public let importedUsers: Int
    /// <p>The job ID for the user import job.</p>
    public let jobId: String?
    /// <p>The job name for the user import job.</p>
    public let jobName: String?
    /// <p>The pre-signed URL to be used to upload the <code>.csv</code> file.</p>
    public let preSignedUrl: String?
    /// <p>The number of users that were skipped.</p>
    public let skippedUsers: Int
    /// <p>The date when the user import job was started.</p>
    public let startDate: Date?
    /// <p>The status of the user import job. One of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Created</code> - The job was created but not started.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Pending</code> - A transition state. You have started the job, but it
    ///                     has not begun importing users yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>InProgress</code> - The job has started, and users are being
    ///                     imported.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Stopping</code> - You have stopped the job, but the job has not stopped
    ///                     importing users yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Stopped</code> - You have stopped the job, and the job has stopped
    ///                     importing users.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Succeeded</code> - The job has completed successfully.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Failed</code> - The job has stopped due to an error.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Expired</code> - You created a job, but did not start the job within
    ///                     24-48 hours. All data associated with the job was deleted, and the job cannot be
    ///                     started.</p>
    ///             </li>
    ///          </ul>
    public let status: UserImportJobStatusType?
    /// <p>The user pool ID for the user pool that the users are being imported into.</p>
    public let userPoolId: String?

    public init (
        cloudWatchLogsRoleArn: String? = nil,
        completionDate: Date? = nil,
        completionMessage: String? = nil,
        creationDate: Date? = nil,
        failedUsers: Int = 0,
        importedUsers: Int = 0,
        jobId: String? = nil,
        jobName: String? = nil,
        preSignedUrl: String? = nil,
        skippedUsers: Int = 0,
        startDate: Date? = nil,
        status: UserImportJobStatusType? = nil,
        userPoolId: String? = nil
    )
    {
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.completionDate = completionDate
        self.completionMessage = completionMessage
        self.creationDate = creationDate
        self.failedUsers = failedUsers
        self.importedUsers = importedUsers
        self.jobId = jobId
        self.jobName = jobName
        self.preSignedUrl = preSignedUrl
        self.skippedUsers = skippedUsers
        self.startDate = startDate
        self.status = status
        self.userPoolId = userPoolId
    }
}

extension UserLambdaValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserLambdaValidationException(message: \(String(describing: message)))"}
}

extension UserLambdaValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserLambdaValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters a user validation
///             exception with the AWS Lambda service.</p>
public struct UserLambdaValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when the Amazon Cognito service returns a user validation
    ///             exception with the AWS Lambda service.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserLambdaValidationExceptionBody: Equatable {
    public let message: String?
}

extension UserLambdaValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserNotConfirmedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserNotConfirmedException(message: \(String(describing: message)))"}
}

extension UserNotConfirmedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserNotConfirmedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user is not confirmed successfully.</p>
public struct UserNotConfirmedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when a user is not confirmed successfully.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserNotConfirmedExceptionBody: Equatable {
    public let message: String?
}

extension UserNotConfirmedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserNotFoundException(message: \(String(describing: message)))"}
}

extension UserNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user is not found.</p>
public struct UserNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when a user is not found.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension UserNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserPoolAddOnNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolAddOnNotEnabledException(message: \(String(describing: message)))"}
}

extension UserPoolAddOnNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserPoolAddOnNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when user pool add-ons are not enabled.</p>
public struct UserPoolAddOnNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserPoolAddOnNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension UserPoolAddOnNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserPoolAddOnsType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advancedSecurityMode = "AdvancedSecurityMode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedSecurityMode = advancedSecurityMode {
            try encodeContainer.encode(advancedSecurityMode.rawValue, forKey: .advancedSecurityMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let advancedSecurityModeDecoded = try containerValues.decodeIfPresent(AdvancedSecurityModeType.self, forKey: .advancedSecurityMode)
        advancedSecurityMode = advancedSecurityModeDecoded
    }
}

extension UserPoolAddOnsType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolAddOnsType(advancedSecurityMode: \(String(describing: advancedSecurityMode)))"}
}

/// <p>The user pool add-ons type.</p>
public struct UserPoolAddOnsType: Equatable {
    /// <p>The advanced security mode.</p>
    public let advancedSecurityMode: AdvancedSecurityModeType?

    public init (
        advancedSecurityMode: AdvancedSecurityModeType? = nil
    )
    {
        self.advancedSecurityMode = advancedSecurityMode
    }
}

extension UserPoolClientDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case clientName = "ClientName"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientName)
        clientName = clientNameDecoded
    }
}

extension UserPoolClientDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolClientDescription(clientId: \(String(describing: clientId)), clientName: \(String(describing: clientName)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>The description of the user pool client.</p>
public struct UserPoolClientDescription: Equatable {
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>The client name from the user pool client description.</p>
    public let clientName: String?
    /// <p>The user pool ID for the user pool where you want to describe the user pool
    ///             client.</p>
    public let userPoolId: String?

    public init (
        clientId: String? = nil,
        clientName: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.clientId = clientId
        self.clientName = clientName
        self.userPoolId = userPoolId
    }
}

extension UserPoolClientType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessTokenValidity = "AccessTokenValidity"
        case allowedOAuthFlows = "AllowedOAuthFlows"
        case allowedOAuthFlowsUserPoolClient = "AllowedOAuthFlowsUserPoolClient"
        case allowedOAuthScopes = "AllowedOAuthScopes"
        case analyticsConfiguration = "AnalyticsConfiguration"
        case callbackURLs = "CallbackURLs"
        case clientId = "ClientId"
        case clientName = "ClientName"
        case clientSecret = "ClientSecret"
        case creationDate = "CreationDate"
        case defaultRedirectURI = "DefaultRedirectURI"
        case explicitAuthFlows = "ExplicitAuthFlows"
        case idTokenValidity = "IdTokenValidity"
        case lastModifiedDate = "LastModifiedDate"
        case logoutURLs = "LogoutURLs"
        case preventUserExistenceErrors = "PreventUserExistenceErrors"
        case readAttributes = "ReadAttributes"
        case refreshTokenValidity = "RefreshTokenValidity"
        case supportedIdentityProviders = "SupportedIdentityProviders"
        case tokenValidityUnits = "TokenValidityUnits"
        case userPoolId = "UserPoolId"
        case writeAttributes = "WriteAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTokenValidity = accessTokenValidity {
            try encodeContainer.encode(accessTokenValidity, forKey: .accessTokenValidity)
        }
        if let allowedOAuthFlows = allowedOAuthFlows {
            var allowedOAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthFlows)
            for oauthflowstype0 in allowedOAuthFlows {
                try allowedOAuthFlowsContainer.encode(oauthflowstype0.rawValue)
            }
        }
        if allowedOAuthFlowsUserPoolClient != false {
            try encodeContainer.encode(allowedOAuthFlowsUserPoolClient, forKey: .allowedOAuthFlowsUserPoolClient)
        }
        if let allowedOAuthScopes = allowedOAuthScopes {
            var allowedOAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedOAuthScopes)
            for scopelisttype0 in allowedOAuthScopes {
                try allowedOAuthScopesContainer.encode(scopelisttype0)
            }
        }
        if let analyticsConfiguration = analyticsConfiguration {
            try encodeContainer.encode(analyticsConfiguration, forKey: .analyticsConfiguration)
        }
        if let callbackURLs = callbackURLs {
            var callbackURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callbackURLs)
            for callbackurlslisttype0 in callbackURLs {
                try callbackURLsContainer.encode(callbackurlslisttype0)
            }
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientName = clientName {
            try encodeContainer.encode(clientName, forKey: .clientName)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let defaultRedirectURI = defaultRedirectURI {
            try encodeContainer.encode(defaultRedirectURI, forKey: .defaultRedirectURI)
        }
        if let explicitAuthFlows = explicitAuthFlows {
            var explicitAuthFlowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .explicitAuthFlows)
            for explicitauthflowslisttype0 in explicitAuthFlows {
                try explicitAuthFlowsContainer.encode(explicitauthflowslisttype0.rawValue)
            }
        }
        if let idTokenValidity = idTokenValidity {
            try encodeContainer.encode(idTokenValidity, forKey: .idTokenValidity)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let logoutURLs = logoutURLs {
            var logoutURLsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logoutURLs)
            for logouturlslisttype0 in logoutURLs {
                try logoutURLsContainer.encode(logouturlslisttype0)
            }
        }
        if let preventUserExistenceErrors = preventUserExistenceErrors {
            try encodeContainer.encode(preventUserExistenceErrors.rawValue, forKey: .preventUserExistenceErrors)
        }
        if let readAttributes = readAttributes {
            var readAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readAttributes)
            for clientpermissionlisttype0 in readAttributes {
                try readAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
        if refreshTokenValidity != 0 {
            try encodeContainer.encode(refreshTokenValidity, forKey: .refreshTokenValidity)
        }
        if let supportedIdentityProviders = supportedIdentityProviders {
            var supportedIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedIdentityProviders)
            for supportedidentityproviderslisttype0 in supportedIdentityProviders {
                try supportedIdentityProvidersContainer.encode(supportedidentityproviderslisttype0)
            }
        }
        if let tokenValidityUnits = tokenValidityUnits {
            try encodeContainer.encode(tokenValidityUnits, forKey: .tokenValidityUnits)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let writeAttributes = writeAttributes {
            var writeAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .writeAttributes)
            for clientpermissionlisttype0 in writeAttributes {
                try writeAttributesContainer.encode(clientpermissionlisttype0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let clientNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientName)
        clientName = clientNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let refreshTokenValidityDecoded = try containerValues.decode(Int.self, forKey: .refreshTokenValidity)
        refreshTokenValidity = refreshTokenValidityDecoded
        let accessTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .accessTokenValidity)
        accessTokenValidity = accessTokenValidityDecoded
        let idTokenValidityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .idTokenValidity)
        idTokenValidity = idTokenValidityDecoded
        let tokenValidityUnitsDecoded = try containerValues.decodeIfPresent(TokenValidityUnitsType.self, forKey: .tokenValidityUnits)
        tokenValidityUnits = tokenValidityUnitsDecoded
        let readAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .readAttributes)
        var readAttributesDecoded0:[String]? = nil
        if let readAttributesContainer = readAttributesContainer {
            readAttributesDecoded0 = [String]()
            for string0 in readAttributesContainer {
                if let string0 = string0 {
                    readAttributesDecoded0?.append(string0)
                }
            }
        }
        readAttributes = readAttributesDecoded0
        let writeAttributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .writeAttributes)
        var writeAttributesDecoded0:[String]? = nil
        if let writeAttributesContainer = writeAttributesContainer {
            writeAttributesDecoded0 = [String]()
            for string0 in writeAttributesContainer {
                if let string0 = string0 {
                    writeAttributesDecoded0?.append(string0)
                }
            }
        }
        writeAttributes = writeAttributesDecoded0
        let explicitAuthFlowsContainer = try containerValues.decodeIfPresent([ExplicitAuthFlowsType?].self, forKey: .explicitAuthFlows)
        var explicitAuthFlowsDecoded0:[ExplicitAuthFlowsType]? = nil
        if let explicitAuthFlowsContainer = explicitAuthFlowsContainer {
            explicitAuthFlowsDecoded0 = [ExplicitAuthFlowsType]()
            for string0 in explicitAuthFlowsContainer {
                if let string0 = string0 {
                    explicitAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        explicitAuthFlows = explicitAuthFlowsDecoded0
        let supportedIdentityProvidersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedIdentityProviders)
        var supportedIdentityProvidersDecoded0:[String]? = nil
        if let supportedIdentityProvidersContainer = supportedIdentityProvidersContainer {
            supportedIdentityProvidersDecoded0 = [String]()
            for string0 in supportedIdentityProvidersContainer {
                if let string0 = string0 {
                    supportedIdentityProvidersDecoded0?.append(string0)
                }
            }
        }
        supportedIdentityProviders = supportedIdentityProvidersDecoded0
        let callbackURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .callbackURLs)
        var callbackURLsDecoded0:[String]? = nil
        if let callbackURLsContainer = callbackURLsContainer {
            callbackURLsDecoded0 = [String]()
            for string0 in callbackURLsContainer {
                if let string0 = string0 {
                    callbackURLsDecoded0?.append(string0)
                }
            }
        }
        callbackURLs = callbackURLsDecoded0
        let logoutURLsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logoutURLs)
        var logoutURLsDecoded0:[String]? = nil
        if let logoutURLsContainer = logoutURLsContainer {
            logoutURLsDecoded0 = [String]()
            for string0 in logoutURLsContainer {
                if let string0 = string0 {
                    logoutURLsDecoded0?.append(string0)
                }
            }
        }
        logoutURLs = logoutURLsDecoded0
        let defaultRedirectURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultRedirectURI)
        defaultRedirectURI = defaultRedirectURIDecoded
        let allowedOAuthFlowsContainer = try containerValues.decodeIfPresent([OAuthFlowType?].self, forKey: .allowedOAuthFlows)
        var allowedOAuthFlowsDecoded0:[OAuthFlowType]? = nil
        if let allowedOAuthFlowsContainer = allowedOAuthFlowsContainer {
            allowedOAuthFlowsDecoded0 = [OAuthFlowType]()
            for string0 in allowedOAuthFlowsContainer {
                if let string0 = string0 {
                    allowedOAuthFlowsDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthFlows = allowedOAuthFlowsDecoded0
        let allowedOAuthScopesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedOAuthScopes)
        var allowedOAuthScopesDecoded0:[String]? = nil
        if let allowedOAuthScopesContainer = allowedOAuthScopesContainer {
            allowedOAuthScopesDecoded0 = [String]()
            for string0 in allowedOAuthScopesContainer {
                if let string0 = string0 {
                    allowedOAuthScopesDecoded0?.append(string0)
                }
            }
        }
        allowedOAuthScopes = allowedOAuthScopesDecoded0
        let allowedOAuthFlowsUserPoolClientDecoded = try containerValues.decode(Bool.self, forKey: .allowedOAuthFlowsUserPoolClient)
        allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClientDecoded
        let analyticsConfigurationDecoded = try containerValues.decodeIfPresent(AnalyticsConfigurationType.self, forKey: .analyticsConfiguration)
        analyticsConfiguration = analyticsConfigurationDecoded
        let preventUserExistenceErrorsDecoded = try containerValues.decodeIfPresent(PreventUserExistenceErrorTypes.self, forKey: .preventUserExistenceErrors)
        preventUserExistenceErrors = preventUserExistenceErrorsDecoded
    }
}

extension UserPoolClientType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolClientType(accessTokenValidity: \(String(describing: accessTokenValidity)), allowedOAuthFlows: \(String(describing: allowedOAuthFlows)), allowedOAuthFlowsUserPoolClient: \(String(describing: allowedOAuthFlowsUserPoolClient)), allowedOAuthScopes: \(String(describing: allowedOAuthScopes)), analyticsConfiguration: \(String(describing: analyticsConfiguration)), callbackURLs: \(String(describing: callbackURLs)), clientId: \(String(describing: clientId)), clientName: \(String(describing: clientName)), clientSecret: \(String(describing: clientSecret)), creationDate: \(String(describing: creationDate)), defaultRedirectURI: \(String(describing: defaultRedirectURI)), explicitAuthFlows: \(String(describing: explicitAuthFlows)), idTokenValidity: \(String(describing: idTokenValidity)), lastModifiedDate: \(String(describing: lastModifiedDate)), logoutURLs: \(String(describing: logoutURLs)), preventUserExistenceErrors: \(String(describing: preventUserExistenceErrors)), readAttributes: \(String(describing: readAttributes)), refreshTokenValidity: \(String(describing: refreshTokenValidity)), supportedIdentityProviders: \(String(describing: supportedIdentityProviders)), tokenValidityUnits: \(String(describing: tokenValidityUnits)), userPoolId: \(String(describing: userPoolId)), writeAttributes: \(String(describing: writeAttributes)))"}
}

/// <p>Contains information about a user pool client.</p>
public struct UserPoolClientType: Equatable {
    /// <p>The time limit, specified by tokenValidityUnits, defaulting to hours, after which the
    ///             access token is no longer valid and cannot be used.</p>
    public let accessTokenValidity: Int?
    /// <p>The allowed OAuth flows.</p>
    ///         <p>Set to <code>code</code> to initiate a code grant flow, which provides an
    ///             authorization code as the response. This code can be exchanged for access tokens with
    ///             the token endpoint.</p>
    ///         <p>Set to <code>implicit</code> to specify that the client should get the access token
    ///             (and, optionally, ID token, based on scopes) directly.</p>
    ///         <p>Set to <code>client_credentials</code> to specify that the client should get the
    ///             access token (and, optionally, ID token, based on scopes) from the token endpoint using
    ///             a combination of client and client_secret.</p>
    public let allowedOAuthFlows: [OAuthFlowType]?
    /// <p>Set to true if the client is allowed to follow the OAuth protocol when interacting
    ///             with Cognito user pools.</p>
    public let allowedOAuthFlowsUserPoolClient: Bool
    /// <p>The allowed OAuth scopes. Possible values provided by OAuth are: <code>phone</code>,
    ///                 <code>email</code>, <code>openid</code>, and <code>profile</code>. Possible values
    ///             provided by AWS are: <code>aws.cognito.signin.user.admin</code>. Custom scopes created
    ///             in Resource Servers are also supported.</p>
    public let allowedOAuthScopes: [String]?
    /// <p>The Amazon Pinpoint analytics configuration for the user pool client.</p>
    ///         <note>
    ///             <p>Cognito User Pools only supports sending events to Amazon Pinpoint projects in the
    ///                 US East (N. Virginia) us-east-1 Region, regardless of the region in which the user
    ///                 pool resides.</p>
    ///         </note>
    public let analyticsConfiguration: AnalyticsConfigurationType?
    /// <p>A list of allowed redirect (callback) URLs for the identity providers.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let callbackURLs: [String]?
    /// <p>The ID of the client associated with the user pool.</p>
    public let clientId: String?
    /// <p>The client name from the user pool request of the client type.</p>
    public let clientName: String?
    /// <p>The client secret from the user pool request of the client type.</p>
    public let clientSecret: String?
    /// <p>The date the user pool client was created.</p>
    public let creationDate: Date?
    /// <p>The default redirect URI. Must be in the <code>CallbackURLs</code> list.</p>
    ///         <p>A redirect URI must:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Be an absolute URI.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Be registered with the authorization server.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Not include a fragment component.</p>
    ///             </li>
    ///          </ul>
    ///         <p>See <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">OAuth 2.0 -
    ///                 Redirection Endpoint</a>.</p>
    ///         <p>Amazon Cognito requires HTTPS over HTTP except for http://localhost for testing
    ///             purposes only.</p>
    ///         <p>App callback URLs such as myapp://example are also supported.</p>
    public let defaultRedirectURI: String?
    /// <p>The authentication flows that are supported by the user pool clients. Flow names
    ///             without the <code>ALLOW_</code> prefix are deprecated in favor of new names with the
    ///                 <code>ALLOW_</code> prefix. Note that values with <code>ALLOW_</code> prefix cannot
    ///             be used along with values without <code>ALLOW_</code> prefix.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_ADMIN_USER_PASSWORD_AUTH</code>: Enable admin based user password
    ///                     authentication flow <code>ADMIN_USER_PASSWORD_AUTH</code>. This setting replaces
    ///                     the <code>ADMIN_NO_SRP_AUTH</code> setting. With this authentication flow,
    ///                     Cognito receives the password in the request instead of using the SRP (Secure
    ///                     Remote Password protocol) protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_CUSTOM_AUTH</code>: Enable Lambda trigger based
    ///                     authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_PASSWORD_AUTH</code>: Enable user password-based
    ///                     authentication. In this flow, Cognito receives the password in the request
    ///                     instead of using the SRP protocol to verify passwords.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_USER_SRP_AUTH</code>: Enable SRP based authentication.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ALLOW_REFRESH_TOKEN_AUTH</code>: Enable authflow to refresh
    ///                     tokens.</p>
    ///             </li>
    ///          </ul>
    public let explicitAuthFlows: [ExplicitAuthFlowsType]?
    /// <p>The time limit, specified by tokenValidityUnits, defaulting to hours, after which the
    ///             refresh token is no longer valid and cannot be used.</p>
    public let idTokenValidity: Int?
    /// <p>The date the user pool client was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>A list of allowed logout URLs for the identity providers.</p>
    public let logoutURLs: [String]?
    /// <p>Use this setting to choose which errors and responses are returned by Cognito APIs
    ///             during authentication, account confirmation, and password recovery when the user does
    ///             not exist in the user pool. When set to <code>ENABLED</code> and the user does not
    ///             exist, authentication returns an error indicating either the username or password was
    ///             incorrect, and account confirmation and password recovery return a response indicating a
    ///             code was sent to a simulated destination. When set to <code>LEGACY</code>, those APIs
    ///             will return a <code>UserNotFoundException</code> exception if the user does not exist in
    ///             the user pool.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ENABLED</code> - This prevents user existence-related errors.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>LEGACY</code> - This represents the old behavior of Cognito where user
    ///                     existence related errors are not prevented.</p>
    ///             </li>
    ///          </ul>
    ///
    ///
    ///         <note>
    ///             <p>After February 15th 2020, the value of <code>PreventUserExistenceErrors</code>
    ///                 will default to <code>ENABLED</code> for newly created user pool clients if no value
    ///                 is provided.</p>
    ///         </note>
    public let preventUserExistenceErrors: PreventUserExistenceErrorTypes?
    /// <p>The Read-only attributes.</p>
    public let readAttributes: [String]?
    /// <p>The time limit, in days, after which the refresh token is no longer valid and cannot
    ///             be used.</p>
    public let refreshTokenValidity: Int
    /// <p>A list of provider names for the identity providers that are supported on this
    ///             client.</p>
    public let supportedIdentityProviders: [String]?
    /// <p>The time units used to specify the token validity times of their respective
    ///             token.</p>
    public let tokenValidityUnits: TokenValidityUnitsType?
    /// <p>The user pool ID for the user pool client.</p>
    public let userPoolId: String?
    /// <p>The writeable attributes.</p>
    public let writeAttributes: [String]?

    public init (
        accessTokenValidity: Int? = nil,
        allowedOAuthFlows: [OAuthFlowType]? = nil,
        allowedOAuthFlowsUserPoolClient: Bool = false,
        allowedOAuthScopes: [String]? = nil,
        analyticsConfiguration: AnalyticsConfigurationType? = nil,
        callbackURLs: [String]? = nil,
        clientId: String? = nil,
        clientName: String? = nil,
        clientSecret: String? = nil,
        creationDate: Date? = nil,
        defaultRedirectURI: String? = nil,
        explicitAuthFlows: [ExplicitAuthFlowsType]? = nil,
        idTokenValidity: Int? = nil,
        lastModifiedDate: Date? = nil,
        logoutURLs: [String]? = nil,
        preventUserExistenceErrors: PreventUserExistenceErrorTypes? = nil,
        readAttributes: [String]? = nil,
        refreshTokenValidity: Int = 0,
        supportedIdentityProviders: [String]? = nil,
        tokenValidityUnits: TokenValidityUnitsType? = nil,
        userPoolId: String? = nil,
        writeAttributes: [String]? = nil
    )
    {
        self.accessTokenValidity = accessTokenValidity
        self.allowedOAuthFlows = allowedOAuthFlows
        self.allowedOAuthFlowsUserPoolClient = allowedOAuthFlowsUserPoolClient
        self.allowedOAuthScopes = allowedOAuthScopes
        self.analyticsConfiguration = analyticsConfiguration
        self.callbackURLs = callbackURLs
        self.clientId = clientId
        self.clientName = clientName
        self.clientSecret = clientSecret
        self.creationDate = creationDate
        self.defaultRedirectURI = defaultRedirectURI
        self.explicitAuthFlows = explicitAuthFlows
        self.idTokenValidity = idTokenValidity
        self.lastModifiedDate = lastModifiedDate
        self.logoutURLs = logoutURLs
        self.preventUserExistenceErrors = preventUserExistenceErrors
        self.readAttributes = readAttributes
        self.refreshTokenValidity = refreshTokenValidity
        self.supportedIdentityProviders = supportedIdentityProviders
        self.tokenValidityUnits = tokenValidityUnits
        self.userPoolId = userPoolId
        self.writeAttributes = writeAttributes
    }
}

extension UserPoolDescriptionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case id = "Id"
        case lambdaConfig = "LambdaConfig"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaConfigType.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension UserPoolDescriptionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolDescriptionType(creationDate: \(String(describing: creationDate)), id: \(String(describing: id)), lambdaConfig: \(String(describing: lambdaConfig)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>A user pool description.</p>
public struct UserPoolDescriptionType: Equatable {
    /// <p>The date the user pool description was created.</p>
    public let creationDate: Date?
    /// <p>The ID in a user pool description.</p>
    public let id: String?
    /// <p>The AWS Lambda configuration information in a user pool description.</p>
    public let lambdaConfig: LambdaConfigType?
    /// <p>The date the user pool description was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The name in a user pool description.</p>
    public let name: String?
    /// <p>The user pool status in a user pool description.</p>
    public let status: StatusType?

    public init (
        creationDate: Date? = nil,
        id: String? = nil,
        lambdaConfig: LambdaConfigType? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        status: StatusType? = nil
    )
    {
        self.creationDate = creationDate
        self.id = id
        self.lambdaConfig = lambdaConfig
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.status = status
    }
}

public enum UserPoolMfaType {
    case off
    case on
    case `optional`
    case sdkUnknown(String)
}

extension UserPoolMfaType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserPoolMfaType] {
        return [
            .off,
            .on,
            .optional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .off: return "OFF"
        case .on: return "ON"
        case .optional: return "OPTIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserPoolMfaType(rawValue: rawValue) ?? UserPoolMfaType.sdkUnknown(rawValue)
    }
}

extension UserPoolPolicyType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case passwordPolicy = "PasswordPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let passwordPolicy = passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(PasswordPolicyType.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

extension UserPoolPolicyType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolPolicyType(passwordPolicy: \(String(describing: passwordPolicy)))"}
}

/// <p>The policy associated with a user pool.</p>
public struct UserPoolPolicyType: Equatable {
    /// <p>The password policy.</p>
    public let passwordPolicy: PasswordPolicyType?

    public init (
        passwordPolicy: PasswordPolicyType? = nil
    )
    {
        self.passwordPolicy = passwordPolicy
    }
}

extension UserPoolTaggingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolTaggingException(message: \(String(describing: message)))"}
}

extension UserPoolTaggingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UserPoolTaggingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a user pool tag cannot be set or updated.</p>
public struct UserPoolTaggingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UserPoolTaggingExceptionBody: Equatable {
    public let message: String?
}

extension UserPoolTaggingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserPoolType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountRecoverySetting = "AccountRecoverySetting"
        case adminCreateUserConfig = "AdminCreateUserConfig"
        case aliasAttributes = "AliasAttributes"
        case arn = "Arn"
        case autoVerifiedAttributes = "AutoVerifiedAttributes"
        case creationDate = "CreationDate"
        case customDomain = "CustomDomain"
        case deviceConfiguration = "DeviceConfiguration"
        case domain = "Domain"
        case emailConfiguration = "EmailConfiguration"
        case emailConfigurationFailure = "EmailConfigurationFailure"
        case emailVerificationMessage = "EmailVerificationMessage"
        case emailVerificationSubject = "EmailVerificationSubject"
        case estimatedNumberOfUsers = "EstimatedNumberOfUsers"
        case id = "Id"
        case lambdaConfig = "LambdaConfig"
        case lastModifiedDate = "LastModifiedDate"
        case mfaConfiguration = "MfaConfiguration"
        case name = "Name"
        case policies = "Policies"
        case schemaAttributes = "SchemaAttributes"
        case smsAuthenticationMessage = "SmsAuthenticationMessage"
        case smsConfiguration = "SmsConfiguration"
        case smsConfigurationFailure = "SmsConfigurationFailure"
        case smsVerificationMessage = "SmsVerificationMessage"
        case status = "Status"
        case userPoolAddOns = "UserPoolAddOns"
        case userPoolTags = "UserPoolTags"
        case usernameAttributes = "UsernameAttributes"
        case usernameConfiguration = "UsernameConfiguration"
        case verificationMessageTemplate = "VerificationMessageTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountRecoverySetting = accountRecoverySetting {
            try encodeContainer.encode(accountRecoverySetting, forKey: .accountRecoverySetting)
        }
        if let adminCreateUserConfig = adminCreateUserConfig {
            try encodeContainer.encode(adminCreateUserConfig, forKey: .adminCreateUserConfig)
        }
        if let aliasAttributes = aliasAttributes {
            var aliasAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliasAttributes)
            for aliasattributeslisttype0 in aliasAttributes {
                try aliasAttributesContainer.encode(aliasattributeslisttype0.rawValue)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoVerifiedAttributes = autoVerifiedAttributes {
            var autoVerifiedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoVerifiedAttributes)
            for verifiedattributeslisttype0 in autoVerifiedAttributes {
                try autoVerifiedAttributesContainer.encode(verifiedattributeslisttype0.rawValue)
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let customDomain = customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let emailConfiguration = emailConfiguration {
            try encodeContainer.encode(emailConfiguration, forKey: .emailConfiguration)
        }
        if let emailConfigurationFailure = emailConfigurationFailure {
            try encodeContainer.encode(emailConfigurationFailure, forKey: .emailConfigurationFailure)
        }
        if let emailVerificationMessage = emailVerificationMessage {
            try encodeContainer.encode(emailVerificationMessage, forKey: .emailVerificationMessage)
        }
        if let emailVerificationSubject = emailVerificationSubject {
            try encodeContainer.encode(emailVerificationSubject, forKey: .emailVerificationSubject)
        }
        if estimatedNumberOfUsers != 0 {
            try encodeContainer.encode(estimatedNumberOfUsers, forKey: .estimatedNumberOfUsers)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let mfaConfiguration = mfaConfiguration {
            try encodeContainer.encode(mfaConfiguration.rawValue, forKey: .mfaConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let schemaAttributes = schemaAttributes {
            var schemaAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaAttributes)
            for schemaattributeslisttype0 in schemaAttributes {
                try schemaAttributesContainer.encode(schemaattributeslisttype0)
            }
        }
        if let smsAuthenticationMessage = smsAuthenticationMessage {
            try encodeContainer.encode(smsAuthenticationMessage, forKey: .smsAuthenticationMessage)
        }
        if let smsConfiguration = smsConfiguration {
            try encodeContainer.encode(smsConfiguration, forKey: .smsConfiguration)
        }
        if let smsConfigurationFailure = smsConfigurationFailure {
            try encodeContainer.encode(smsConfigurationFailure, forKey: .smsConfigurationFailure)
        }
        if let smsVerificationMessage = smsVerificationMessage {
            try encodeContainer.encode(smsVerificationMessage, forKey: .smsVerificationMessage)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userPoolAddOns = userPoolAddOns {
            try encodeContainer.encode(userPoolAddOns, forKey: .userPoolAddOns)
        }
        if let userPoolTags = userPoolTags {
            var userPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userPoolTags)
            for (dictKey0, userpooltagstype0) in userPoolTags {
                try userPoolTagsContainer.encode(userpooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let usernameAttributes = usernameAttributes {
            var usernameAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernameAttributes)
            for usernameattributeslisttype0 in usernameAttributes {
                try usernameAttributesContainer.encode(usernameattributeslisttype0.rawValue)
            }
        }
        if let usernameConfiguration = usernameConfiguration {
            try encodeContainer.encode(usernameConfiguration, forKey: .usernameConfiguration)
        }
        if let verificationMessageTemplate = verificationMessageTemplate {
            try encodeContainer.encode(verificationMessageTemplate, forKey: .verificationMessageTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(UserPoolPolicyType.self, forKey: .policies)
        policies = policiesDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaConfigType.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StatusType.self, forKey: .status)
        status = statusDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let schemaAttributesContainer = try containerValues.decodeIfPresent([SchemaAttributeType?].self, forKey: .schemaAttributes)
        var schemaAttributesDecoded0:[SchemaAttributeType]? = nil
        if let schemaAttributesContainer = schemaAttributesContainer {
            schemaAttributesDecoded0 = [SchemaAttributeType]()
            for structure0 in schemaAttributesContainer {
                if let structure0 = structure0 {
                    schemaAttributesDecoded0?.append(structure0)
                }
            }
        }
        schemaAttributes = schemaAttributesDecoded0
        let autoVerifiedAttributesContainer = try containerValues.decodeIfPresent([VerifiedAttributeType?].self, forKey: .autoVerifiedAttributes)
        var autoVerifiedAttributesDecoded0:[VerifiedAttributeType]? = nil
        if let autoVerifiedAttributesContainer = autoVerifiedAttributesContainer {
            autoVerifiedAttributesDecoded0 = [VerifiedAttributeType]()
            for string0 in autoVerifiedAttributesContainer {
                if let string0 = string0 {
                    autoVerifiedAttributesDecoded0?.append(string0)
                }
            }
        }
        autoVerifiedAttributes = autoVerifiedAttributesDecoded0
        let aliasAttributesContainer = try containerValues.decodeIfPresent([AliasAttributeType?].self, forKey: .aliasAttributes)
        var aliasAttributesDecoded0:[AliasAttributeType]? = nil
        if let aliasAttributesContainer = aliasAttributesContainer {
            aliasAttributesDecoded0 = [AliasAttributeType]()
            for string0 in aliasAttributesContainer {
                if let string0 = string0 {
                    aliasAttributesDecoded0?.append(string0)
                }
            }
        }
        aliasAttributes = aliasAttributesDecoded0
        let usernameAttributesContainer = try containerValues.decodeIfPresent([UsernameAttributeType?].self, forKey: .usernameAttributes)
        var usernameAttributesDecoded0:[UsernameAttributeType]? = nil
        if let usernameAttributesContainer = usernameAttributesContainer {
            usernameAttributesDecoded0 = [UsernameAttributeType]()
            for string0 in usernameAttributesContainer {
                if let string0 = string0 {
                    usernameAttributesDecoded0?.append(string0)
                }
            }
        }
        usernameAttributes = usernameAttributesDecoded0
        let smsVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsVerificationMessage)
        smsVerificationMessage = smsVerificationMessageDecoded
        let emailVerificationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationMessage)
        emailVerificationMessage = emailVerificationMessageDecoded
        let emailVerificationSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailVerificationSubject)
        emailVerificationSubject = emailVerificationSubjectDecoded
        let verificationMessageTemplateDecoded = try containerValues.decodeIfPresent(VerificationMessageTemplateType.self, forKey: .verificationMessageTemplate)
        verificationMessageTemplate = verificationMessageTemplateDecoded
        let smsAuthenticationMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsAuthenticationMessage)
        smsAuthenticationMessage = smsAuthenticationMessageDecoded
        let mfaConfigurationDecoded = try containerValues.decodeIfPresent(UserPoolMfaType.self, forKey: .mfaConfiguration)
        mfaConfiguration = mfaConfigurationDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceConfigurationType.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let estimatedNumberOfUsersDecoded = try containerValues.decode(Int.self, forKey: .estimatedNumberOfUsers)
        estimatedNumberOfUsers = estimatedNumberOfUsersDecoded
        let emailConfigurationDecoded = try containerValues.decodeIfPresent(EmailConfigurationType.self, forKey: .emailConfiguration)
        emailConfiguration = emailConfigurationDecoded
        let smsConfigurationDecoded = try containerValues.decodeIfPresent(SmsConfigurationType.self, forKey: .smsConfiguration)
        smsConfiguration = smsConfigurationDecoded
        let userPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userPoolTags)
        var userPoolTagsDecoded0: [String:String]? = nil
        if let userPoolTagsContainer = userPoolTagsContainer {
            userPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in userPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    userPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        userPoolTags = userPoolTagsDecoded0
        let smsConfigurationFailureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsConfigurationFailure)
        smsConfigurationFailure = smsConfigurationFailureDecoded
        let emailConfigurationFailureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailConfigurationFailure)
        emailConfigurationFailure = emailConfigurationFailureDecoded
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let adminCreateUserConfigDecoded = try containerValues.decodeIfPresent(AdminCreateUserConfigType.self, forKey: .adminCreateUserConfig)
        adminCreateUserConfig = adminCreateUserConfigDecoded
        let userPoolAddOnsDecoded = try containerValues.decodeIfPresent(UserPoolAddOnsType.self, forKey: .userPoolAddOns)
        userPoolAddOns = userPoolAddOnsDecoded
        let usernameConfigurationDecoded = try containerValues.decodeIfPresent(UsernameConfigurationType.self, forKey: .usernameConfiguration)
        usernameConfiguration = usernameConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let accountRecoverySettingDecoded = try containerValues.decodeIfPresent(AccountRecoverySettingType.self, forKey: .accountRecoverySetting)
        accountRecoverySetting = accountRecoverySettingDecoded
    }
}

extension UserPoolType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolType(accountRecoverySetting: \(String(describing: accountRecoverySetting)), adminCreateUserConfig: \(String(describing: adminCreateUserConfig)), aliasAttributes: \(String(describing: aliasAttributes)), arn: \(String(describing: arn)), autoVerifiedAttributes: \(String(describing: autoVerifiedAttributes)), creationDate: \(String(describing: creationDate)), customDomain: \(String(describing: customDomain)), deviceConfiguration: \(String(describing: deviceConfiguration)), domain: \(String(describing: domain)), emailConfiguration: \(String(describing: emailConfiguration)), emailConfigurationFailure: \(String(describing: emailConfigurationFailure)), emailVerificationMessage: \(String(describing: emailVerificationMessage)), emailVerificationSubject: \(String(describing: emailVerificationSubject)), estimatedNumberOfUsers: \(String(describing: estimatedNumberOfUsers)), id: \(String(describing: id)), lambdaConfig: \(String(describing: lambdaConfig)), lastModifiedDate: \(String(describing: lastModifiedDate)), mfaConfiguration: \(String(describing: mfaConfiguration)), name: \(String(describing: name)), policies: \(String(describing: policies)), schemaAttributes: \(String(describing: schemaAttributes)), smsAuthenticationMessage: \(String(describing: smsAuthenticationMessage)), smsConfiguration: \(String(describing: smsConfiguration)), smsConfigurationFailure: \(String(describing: smsConfigurationFailure)), smsVerificationMessage: \(String(describing: smsVerificationMessage)), status: \(String(describing: status)), userPoolAddOns: \(String(describing: userPoolAddOns)), userPoolTags: \(String(describing: userPoolTags)), usernameAttributes: \(String(describing: usernameAttributes)), usernameConfiguration: \(String(describing: usernameConfiguration)), verificationMessageTemplate: \(String(describing: verificationMessageTemplate)))"}
}

/// <p>A container for information about the user pool.</p>
public struct UserPoolType: Equatable {
    /// <p>Use this setting to define which verified available method a user can use to recover
    ///             their password when they call <code>ForgotPassword</code>. It allows you to define a
    ///             preferred method when a user has more than one method available. With this setting, SMS
    ///             does not qualify for a valid password recovery mechanism if the user also has SMS MFA
    ///             enabled. In the absence of this setting, Cognito uses the legacy behavior to determine
    ///             the recovery method where SMS is preferred over email.</p>
    public let accountRecoverySetting: AccountRecoverySettingType?
    /// <p>The configuration for <code>AdminCreateUser</code> requests.</p>
    public let adminCreateUserConfig: AdminCreateUserConfigType?
    /// <p>Specifies the attributes that are aliased in a user pool.</p>
    public let aliasAttributes: [AliasAttributeType]?
    /// <p>The Amazon Resource Name (ARN) for the user pool.</p>
    public let arn: String?
    /// <p>Specifies the attributes that are auto-verified in a user pool.</p>
    public let autoVerifiedAttributes: [VerifiedAttributeType]?
    /// <p>The date the user pool was created.</p>
    public let creationDate: Date?
    /// <p>A custom domain name that you provide to Amazon Cognito. This parameter applies only
    ///             if you use a custom domain to host the sign-up and sign-in pages for your application.
    ///             For example: <code>auth.example.com</code>.</p>
    ///         <p>For more information about adding a custom domain to your user pool, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-add-custom-domain.html">Using Your Own Domain for the Hosted UI</a>.</p>
    public let customDomain: String?
    /// <p>The device configuration.</p>
    public let deviceConfiguration: DeviceConfigurationType?
    /// <p>Holds the domain prefix if the user pool has a domain associated with it.</p>
    public let domain: String?
    /// <p>The email configuration.</p>
    public let emailConfiguration: EmailConfigurationType?
    /// <p>The reason why the email configuration cannot send the messages to your users.</p>
    public let emailConfigurationFailure: String?
    /// <p>The contents of the email verification message.</p>
    public let emailVerificationMessage: String?
    /// <p>The subject of the email verification message.</p>
    public let emailVerificationSubject: String?
    /// <p>A number estimating the size of the user pool.</p>
    public let estimatedNumberOfUsers: Int
    /// <p>The ID of the user pool.</p>
    public let id: String?
    /// <p>The AWS Lambda triggers associated with the user pool.</p>
    public let lambdaConfig: LambdaConfigType?
    /// <p>The date the user pool was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>Can be one of the following values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>OFF</code> - MFA tokens are not required and cannot be specified during
    ///                     user registration.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ON</code> - MFA tokens are required for all user registrations. You can
    ///                     only specify required when you are initially creating a user pool.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>OPTIONAL</code> - Users have the option when registering to create an MFA
    ///                     token.</p>
    ///             </li>
    ///          </ul>
    public let mfaConfiguration: UserPoolMfaType?
    /// <p>The name of the user pool.</p>
    public let name: String?
    /// <p>The policies associated with the user pool.</p>
    public let policies: UserPoolPolicyType?
    /// <p>A container with the schema attributes of a user pool.</p>
    public let schemaAttributes: [SchemaAttributeType]?
    /// <p>The contents of the SMS authentication message.</p>
    public let smsAuthenticationMessage: String?
    /// <p>The SMS configuration.</p>
    public let smsConfiguration: SmsConfigurationType?
    /// <p>The reason why the SMS configuration cannot send the messages to your users.</p>
    public let smsConfigurationFailure: String?
    /// <p>The contents of the SMS verification message.</p>
    public let smsVerificationMessage: String?
    /// <p>The status of a user pool.</p>
    public let status: StatusType?
    /// <p>The user pool add-ons.</p>
    public let userPoolAddOns: UserPoolAddOnsType?
    /// <p>The tags that are assigned to the user pool. A tag is a label that you can apply to
    ///             user pools to categorize and manage them in different ways, such as by purpose, owner,
    ///             environment, or other criteria.</p>
    public let userPoolTags: [String:String]?
    /// <p>Specifies whether email addresses or phone numbers can be specified as usernames when
    ///             a user signs up.</p>
    public let usernameAttributes: [UsernameAttributeType]?
    /// <p>You can choose to enable case sensitivity on the username input for the selected
    ///             sign-in option. For example, when this is set to <code>False</code>, users will be able
    ///             to sign in using either "username" or "Username". This configuration is immutable once
    ///             it has been set. For more information, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UsernameConfigurationType.html">UsernameConfigurationType</a>.</p>
    public let usernameConfiguration: UsernameConfigurationType?
    /// <p>The template for verification messages.</p>
    public let verificationMessageTemplate: VerificationMessageTemplateType?

    public init (
        accountRecoverySetting: AccountRecoverySettingType? = nil,
        adminCreateUserConfig: AdminCreateUserConfigType? = nil,
        aliasAttributes: [AliasAttributeType]? = nil,
        arn: String? = nil,
        autoVerifiedAttributes: [VerifiedAttributeType]? = nil,
        creationDate: Date? = nil,
        customDomain: String? = nil,
        deviceConfiguration: DeviceConfigurationType? = nil,
        domain: String? = nil,
        emailConfiguration: EmailConfigurationType? = nil,
        emailConfigurationFailure: String? = nil,
        emailVerificationMessage: String? = nil,
        emailVerificationSubject: String? = nil,
        estimatedNumberOfUsers: Int = 0,
        id: String? = nil,
        lambdaConfig: LambdaConfigType? = nil,
        lastModifiedDate: Date? = nil,
        mfaConfiguration: UserPoolMfaType? = nil,
        name: String? = nil,
        policies: UserPoolPolicyType? = nil,
        schemaAttributes: [SchemaAttributeType]? = nil,
        smsAuthenticationMessage: String? = nil,
        smsConfiguration: SmsConfigurationType? = nil,
        smsConfigurationFailure: String? = nil,
        smsVerificationMessage: String? = nil,
        status: StatusType? = nil,
        userPoolAddOns: UserPoolAddOnsType? = nil,
        userPoolTags: [String:String]? = nil,
        usernameAttributes: [UsernameAttributeType]? = nil,
        usernameConfiguration: UsernameConfigurationType? = nil,
        verificationMessageTemplate: VerificationMessageTemplateType? = nil
    )
    {
        self.accountRecoverySetting = accountRecoverySetting
        self.adminCreateUserConfig = adminCreateUserConfig
        self.aliasAttributes = aliasAttributes
        self.arn = arn
        self.autoVerifiedAttributes = autoVerifiedAttributes
        self.creationDate = creationDate
        self.customDomain = customDomain
        self.deviceConfiguration = deviceConfiguration
        self.domain = domain
        self.emailConfiguration = emailConfiguration
        self.emailConfigurationFailure = emailConfigurationFailure
        self.emailVerificationMessage = emailVerificationMessage
        self.emailVerificationSubject = emailVerificationSubject
        self.estimatedNumberOfUsers = estimatedNumberOfUsers
        self.id = id
        self.lambdaConfig = lambdaConfig
        self.lastModifiedDate = lastModifiedDate
        self.mfaConfiguration = mfaConfiguration
        self.name = name
        self.policies = policies
        self.schemaAttributes = schemaAttributes
        self.smsAuthenticationMessage = smsAuthenticationMessage
        self.smsConfiguration = smsConfiguration
        self.smsConfigurationFailure = smsConfigurationFailure
        self.smsVerificationMessage = smsVerificationMessage
        self.status = status
        self.userPoolAddOns = userPoolAddOns
        self.userPoolTags = userPoolTags
        self.usernameAttributes = usernameAttributes
        self.usernameConfiguration = usernameConfiguration
        self.verificationMessageTemplate = verificationMessageTemplate
    }
}

public enum UserStatusType {
    case archived
    case compromised
    case confirmed
    case forceChangePassword
    case resetRequired
    case unconfirmed
    case unknown
    case sdkUnknown(String)
}

extension UserStatusType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserStatusType] {
        return [
            .archived,
            .compromised,
            .confirmed,
            .forceChangePassword,
            .resetRequired,
            .unconfirmed,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archived: return "ARCHIVED"
        case .compromised: return "COMPROMISED"
        case .confirmed: return "CONFIRMED"
        case .forceChangePassword: return "FORCE_CHANGE_PASSWORD"
        case .resetRequired: return "RESET_REQUIRED"
        case .unconfirmed: return "UNCONFIRMED"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserStatusType(rawValue: rawValue) ?? UserStatusType.sdkUnknown(rawValue)
    }
}

extension UserType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case enabled = "Enabled"
        case mFAOptions = "MFAOptions"
        case userCreateDate = "UserCreateDate"
        case userLastModifiedDate = "UserLastModifiedDate"
        case userStatus = "UserStatus"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelisttype0 in attributes {
                try attributesContainer.encode(attributelisttype0)
            }
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let mFAOptions = mFAOptions {
            var mFAOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mFAOptions)
            for mfaoptionlisttype0 in mFAOptions {
                try mFAOptionsContainer.encode(mfaoptionlisttype0)
            }
        }
        if let userCreateDate = userCreateDate {
            try encodeContainer.encode(userCreateDate.timeIntervalSince1970, forKey: .userCreateDate)
        }
        if let userLastModifiedDate = userLastModifiedDate {
            try encodeContainer.encode(userLastModifiedDate.timeIntervalSince1970, forKey: .userLastModifiedDate)
        }
        if let userStatus = userStatus {
            try encodeContainer.encode(userStatus.rawValue, forKey: .userStatus)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AttributeType?].self, forKey: .attributes)
        var attributesDecoded0:[AttributeType]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AttributeType]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userCreateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .userCreateDate)
        userCreateDate = userCreateDateDecoded
        let userLastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .userLastModifiedDate)
        userLastModifiedDate = userLastModifiedDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let userStatusDecoded = try containerValues.decodeIfPresent(UserStatusType.self, forKey: .userStatus)
        userStatus = userStatusDecoded
        let mFAOptionsContainer = try containerValues.decodeIfPresent([MFAOptionType?].self, forKey: .mFAOptions)
        var mFAOptionsDecoded0:[MFAOptionType]? = nil
        if let mFAOptionsContainer = mFAOptionsContainer {
            mFAOptionsDecoded0 = [MFAOptionType]()
            for structure0 in mFAOptionsContainer {
                if let structure0 = structure0 {
                    mFAOptionsDecoded0?.append(structure0)
                }
            }
        }
        mFAOptions = mFAOptionsDecoded0
    }
}

extension UserType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserType(attributes: \(String(describing: attributes)), enabled: \(String(describing: enabled)), mFAOptions: \(String(describing: mFAOptions)), userCreateDate: \(String(describing: userCreateDate)), userLastModifiedDate: \(String(describing: userLastModifiedDate)), userStatus: \(String(describing: userStatus)), username: \(String(describing: username)))"}
}

/// <p>The user type.</p>
public struct UserType: Equatable {
    /// <p>A container with information about the user type attributes.</p>
    public let attributes: [AttributeType]?
    /// <p>Specifies whether the user is enabled.</p>
    public let enabled: Bool
    /// <p>The MFA options for the user.</p>
    public let mFAOptions: [MFAOptionType]?
    /// <p>The creation date of the user.</p>
    public let userCreateDate: Date?
    /// <p>The last modified date of the user.</p>
    public let userLastModifiedDate: Date?
    /// <p>The user status. Can be one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>UNCONFIRMED - User has been created but not confirmed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>CONFIRMED - User has been confirmed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARCHIVED - User is no longer active.</p>
    ///             </li>
    ///             <li>
    ///                 <p>COMPROMISED - User is disabled due to a potential security threat.</p>
    ///             </li>
    ///             <li>
    ///                 <p>UNKNOWN - User status is not known.</p>
    ///             </li>
    ///             <li>
    ///                 <p>RESET_REQUIRED - User is confirmed, but the user must request a code and reset
    ///                     his or her password before he or she can sign in.</p>
    ///             </li>
    ///             <li>
    ///                 <p>FORCE_CHANGE_PASSWORD - The user is confirmed and the user can sign in using a
    ///                     temporary password, but on first sign-in, the user must change his or her
    ///                     password to a new value before doing anything else. </p>
    ///             </li>
    ///          </ul>
    public let userStatus: UserStatusType?
    /// <p>The user name of the user you wish to describe.</p>
    public let username: String?

    public init (
        attributes: [AttributeType]? = nil,
        enabled: Bool = false,
        mFAOptions: [MFAOptionType]? = nil,
        userCreateDate: Date? = nil,
        userLastModifiedDate: Date? = nil,
        userStatus: UserStatusType? = nil,
        username: String? = nil
    )
    {
        self.attributes = attributes
        self.enabled = enabled
        self.mFAOptions = mFAOptions
        self.userCreateDate = userCreateDate
        self.userLastModifiedDate = userLastModifiedDate
        self.userStatus = userStatus
        self.username = username
    }
}

public enum UsernameAttributeType {
    case email
    case phoneNumber
    case sdkUnknown(String)
}

extension UsernameAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsernameAttributeType] {
        return [
            .email,
            .phoneNumber,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "email"
        case .phoneNumber: return "phone_number"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsernameAttributeType(rawValue: rawValue) ?? UsernameAttributeType.sdkUnknown(rawValue)
    }
}

extension UsernameConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseSensitive = "CaseSensitive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseSensitive = caseSensitive {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension UsernameConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsernameConfigurationType(caseSensitive: \(String(describing: caseSensitive)))"}
}

/// <p>The username configuration type. </p>
public struct UsernameConfigurationType: Equatable {
    /// <p>Specifies whether username case sensitivity will be applied for all users in the user
    ///             pool through Cognito APIs.</p>
    ///         <p>Valid values include:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>True</code>
    ///                   </b>: Enables case sensitivity
    ///                     for all username input. When this option is set to <code>True</code>, users must
    ///                     sign in using the exact capitalization of their given username. For example,
    ///                     UserName. This is the default value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <b>
    ///                      <code>False</code>
    ///                   </b>: Enables case
    ///                     insensitivity for all username input. For example, when this option is set to
    ///                         <code>False</code>, users will be able to sign in using either "username" or
    ///                     "Username". This option also enables both <code>preferred_username</code> and
    ///                         <code>email</code> alias to be case insensitive, in addition to the
    ///                         <code>username</code> attribute.</p>
    ///             </li>
    ///          </ul>
    public let caseSensitive: Bool?

    public init (
        caseSensitive: Bool? = nil
    )
    {
        self.caseSensitive = caseSensitive
    }
}

extension UsernameExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsernameExistsException(message: \(String(describing: message)))"}
}

extension UsernameExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UsernameExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters a user name that already
///             exists in the user pool.</p>
public struct UsernameExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned when Amazon Cognito throws a user name exists exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UsernameExistsExceptionBody: Equatable {
    public let message: String?
}

extension UsernameExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerificationMessageTemplateType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultEmailOption = "DefaultEmailOption"
        case emailMessage = "EmailMessage"
        case emailMessageByLink = "EmailMessageByLink"
        case emailSubject = "EmailSubject"
        case emailSubjectByLink = "EmailSubjectByLink"
        case smsMessage = "SmsMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultEmailOption = defaultEmailOption {
            try encodeContainer.encode(defaultEmailOption.rawValue, forKey: .defaultEmailOption)
        }
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailMessageByLink = emailMessageByLink {
            try encodeContainer.encode(emailMessageByLink, forKey: .emailMessageByLink)
        }
        if let emailSubject = emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
        if let emailSubjectByLink = emailSubjectByLink {
            try encodeContainer.encode(emailSubjectByLink, forKey: .emailSubjectByLink)
        }
        if let smsMessage = smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
        let emailMessageByLinkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailMessageByLink)
        emailMessageByLink = emailMessageByLinkDecoded
        let emailSubjectByLinkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailSubjectByLink)
        emailSubjectByLink = emailSubjectByLinkDecoded
        let defaultEmailOptionDecoded = try containerValues.decodeIfPresent(DefaultEmailOptionType.self, forKey: .defaultEmailOption)
        defaultEmailOption = defaultEmailOptionDecoded
    }
}

extension VerificationMessageTemplateType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerificationMessageTemplateType(defaultEmailOption: \(String(describing: defaultEmailOption)), emailMessage: \(String(describing: emailMessage)), emailMessageByLink: \(String(describing: emailMessageByLink)), emailSubject: \(String(describing: emailSubject)), emailSubjectByLink: \(String(describing: emailSubjectByLink)), smsMessage: \(String(describing: smsMessage)))"}
}

/// <p>The template for verification messages.</p>
public struct VerificationMessageTemplateType: Equatable {
    /// <p>The default email option.</p>
    public let defaultEmailOption: DefaultEmailOptionType?
    /// <p>The email message template. EmailMessage is allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount"> EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailMessage: String?
    /// <p>The email message template for sending a confirmation link to the user.
    ///             EmailMessageByLink is allowed only if <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount"> EmailSendingAccount</a> is DEVELOPER.</p>
    public let emailMessageByLink: String?
    /// <p>The subject line for the email message template. EmailSubject is allowed only if
    ///                 <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount">EmailSendingAccount</a> is DEVELOPER. </p>
    public let emailSubject: String?
    /// <p>The subject line for the email message template for sending a confirmation link to the
    ///             user. EmailSubjectByLink is allowed only <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_EmailConfigurationType.html#CognitoUserPools-Type-EmailConfigurationType-EmailSendingAccount"> EmailSendingAccount</a> is DEVELOPER.</p>
    public let emailSubjectByLink: String?
    /// <p>The SMS message template.</p>
    public let smsMessage: String?

    public init (
        defaultEmailOption: DefaultEmailOptionType? = nil,
        emailMessage: String? = nil,
        emailMessageByLink: String? = nil,
        emailSubject: String? = nil,
        emailSubjectByLink: String? = nil,
        smsMessage: String? = nil
    )
    {
        self.defaultEmailOption = defaultEmailOption
        self.emailMessage = emailMessage
        self.emailMessageByLink = emailMessageByLink
        self.emailSubject = emailSubject
        self.emailSubjectByLink = emailSubjectByLink
        self.smsMessage = smsMessage
    }
}

public enum VerifiedAttributeType {
    case email
    case phoneNumber
    case sdkUnknown(String)
}

extension VerifiedAttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VerifiedAttributeType] {
        return [
            .email,
            .phoneNumber,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "email"
        case .phoneNumber: return "phone_number"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VerifiedAttributeType(rawValue: rawValue) ?? VerifiedAttributeType.sdkUnknown(rawValue)
    }
}

public struct VerifySoftwareTokenInputBodyMiddleware: Middleware {
    public let id: String = "VerifySoftwareTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySoftwareTokenInput>
    public typealias MOutput = OperationOutput<VerifySoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySoftwareTokenOutputError>
}

extension VerifySoftwareTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifySoftwareTokenInput(accessToken: \(String(describing: accessToken)), friendlyDeviceName: \(String(describing: friendlyDeviceName)), session: \(String(describing: session)), userCode: \(String(describing: userCode)))"}
}

extension VerifySoftwareTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case friendlyDeviceName = "FriendlyDeviceName"
        case session = "Session"
        case userCode = "UserCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let friendlyDeviceName = friendlyDeviceName {
            try encodeContainer.encode(friendlyDeviceName, forKey: .friendlyDeviceName)
        }
        if let session = session {
            try encodeContainer.encode(session, forKey: .session)
        }
        if let userCode = userCode {
            try encodeContainer.encode(userCode, forKey: .userCode)
        }
    }
}

public struct VerifySoftwareTokenInputHeadersMiddleware: Middleware {
    public let id: String = "VerifySoftwareTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySoftwareTokenInput>
    public typealias MOutput = OperationOutput<VerifySoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySoftwareTokenOutputError>
}

public struct VerifySoftwareTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifySoftwareTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifySoftwareTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifySoftwareTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifySoftwareTokenInput>
    public typealias MOutput = OperationOutput<VerifySoftwareTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifySoftwareTokenOutputError>
}

public struct VerifySoftwareTokenInput: Equatable {
    /// <p>The access token.</p>
    public let accessToken: String?
    /// <p>The friendly device name.</p>
    public let friendlyDeviceName: String?
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service.</p>
    public let session: String?
    /// <p>The one time password computed using the secret code returned by <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AssociateSoftwareToken.html">AssociateSoftwareToken"</a>.</p>
    public let userCode: String?

    public init (
        accessToken: String? = nil,
        friendlyDeviceName: String? = nil,
        session: String? = nil,
        userCode: String? = nil
    )
    {
        self.accessToken = accessToken
        self.friendlyDeviceName = friendlyDeviceName
        self.session = session
        self.userCode = userCode
    }
}

struct VerifySoftwareTokenInputBody: Equatable {
    public let accessToken: String?
    public let session: String?
    public let userCode: String?
    public let friendlyDeviceName: String?
}

extension VerifySoftwareTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case friendlyDeviceName = "FriendlyDeviceName"
        case session = "Session"
        case userCode = "UserCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let friendlyDeviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .friendlyDeviceName)
        friendlyDeviceName = friendlyDeviceNameDecoded
    }
}

extension VerifySoftwareTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension VerifySoftwareTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EnableSoftwareTokenMFAException" : self = .enableSoftwareTokenMFAException(try EnableSoftwareTokenMFAException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserPoolConfigurationException" : self = .invalidUserPoolConfigurationException(try InvalidUserPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SoftwareTokenMFANotFoundException" : self = .softwareTokenMFANotFoundException(try SoftwareTokenMFANotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifySoftwareTokenOutputError: Equatable {
    case codeMismatchException(CodeMismatchException)
    case enableSoftwareTokenMFAException(EnableSoftwareTokenMFAException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidUserPoolConfigurationException(InvalidUserPoolConfigurationException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case softwareTokenMFANotFoundException(SoftwareTokenMFANotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifySoftwareTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifySoftwareTokenOutputResponse(session: \(String(describing: session)), status: \(String(describing: status)))"}
}

extension VerifySoftwareTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: VerifySoftwareTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.session = output.session
            self.status = output.status
        } else {
            self.session = nil
            self.status = nil
        }
    }
}

public struct VerifySoftwareTokenOutputResponse: Equatable {
    /// <p>The session which should be passed both ways in challenge-response calls to the
    ///             service.</p>
    public let session: String?
    /// <p>The status of the verify software token.</p>
    public let status: VerifySoftwareTokenResponseType?

    public init (
        session: String? = nil,
        status: VerifySoftwareTokenResponseType? = nil
    )
    {
        self.session = session
        self.status = status
    }
}

struct VerifySoftwareTokenOutputResponseBody: Equatable {
    public let status: VerifySoftwareTokenResponseType?
    public let session: String?
}

extension VerifySoftwareTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case session = "Session"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(VerifySoftwareTokenResponseType.self, forKey: .status)
        status = statusDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .session)
        session = sessionDecoded
    }
}

public enum VerifySoftwareTokenResponseType {
    case error
    case success
    case sdkUnknown(String)
}

extension VerifySoftwareTokenResponseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VerifySoftwareTokenResponseType] {
        return [
            .error,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VerifySoftwareTokenResponseType(rawValue: rawValue) ?? VerifySoftwareTokenResponseType.sdkUnknown(rawValue)
    }
}

public struct VerifyUserAttributeInputBodyMiddleware: Middleware {
    public let id: String = "VerifyUserAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyUserAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyUserAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyUserAttributeInput>
    public typealias MOutput = OperationOutput<VerifyUserAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyUserAttributeOutputError>
}

extension VerifyUserAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyUserAttributeInput(accessToken: \(String(describing: accessToken)), attributeName: \(String(describing: attributeName)), code: \(String(describing: code)))"}
}

extension VerifyUserAttributeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case attributeName = "AttributeName"
        case code = "Code"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
    }
}

public struct VerifyUserAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "VerifyUserAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyUserAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyUserAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyUserAttributeInput>
    public typealias MOutput = OperationOutput<VerifyUserAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyUserAttributeOutputError>
}

public struct VerifyUserAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "VerifyUserAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<VerifyUserAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<VerifyUserAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<VerifyUserAttributeInput>
    public typealias MOutput = OperationOutput<VerifyUserAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<VerifyUserAttributeOutputError>
}

/// <p>Represents the request to verify user attributes.</p>
public struct VerifyUserAttributeInput: Equatable {
    /// <p>Represents the access token of the request to verify user attributes.</p>
    public let accessToken: String?
    /// <p>The attribute name in the request to verify user attributes.</p>
    public let attributeName: String?
    /// <p>The verification code in the request to verify user attributes.</p>
    public let code: String?

    public init (
        accessToken: String? = nil,
        attributeName: String? = nil,
        code: String? = nil
    )
    {
        self.accessToken = accessToken
        self.attributeName = attributeName
        self.code = code
    }
}

struct VerifyUserAttributeInputBody: Equatable {
    public let accessToken: String?
    public let attributeName: String?
    public let code: String?
}

extension VerifyUserAttributeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "AccessToken"
        case attributeName = "AttributeName"
        case code = "Code"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
    }
}

extension VerifyUserAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension VerifyUserAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeMismatchException" : self = .codeMismatchException(try CodeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredCodeException" : self = .expiredCodeException(try ExpiredCodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PasswordResetRequiredException" : self = .passwordResetRequiredException(try PasswordResetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotConfirmedException" : self = .userNotConfirmedException(try UserNotConfirmedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UserNotFoundException" : self = .userNotFoundException(try UserNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum VerifyUserAttributeOutputError: Equatable {
    case codeMismatchException(CodeMismatchException)
    case expiredCodeException(ExpiredCodeException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case passwordResetRequiredException(PasswordResetRequiredException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case userNotConfirmedException(UserNotConfirmedException)
    case userNotFoundException(UserNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension VerifyUserAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VerifyUserAttributeOutputResponse()"}
}

extension VerifyUserAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>A container representing the response from the server from the request to verify user
///             attributes.</p>
public struct VerifyUserAttributeOutputResponse: Equatable {

    public init() {}
}

struct VerifyUserAttributeOutputResponseBody: Equatable {
}

extension VerifyUserAttributeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
