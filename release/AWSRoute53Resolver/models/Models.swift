// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The current account doesn't have the IAM permissions required to perform the specified Resolver operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alert
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .alert,
                .allow,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alert: return "ALERT"
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension AssociateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension AssociateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFirewallRuleGroupInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections. When you create the association, the default setting is DISABLED.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// A name that lets you identify the association, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 101, 200, and so on. You can change the priority setting for a rule group association after you create it. The allowed values for Priority are between 100 and 9900.
    /// This member is required.
    public var priority: Swift.Int?
    /// A list of the tag keys and values that you want to associate with the rule group association.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The unique identifier of the VPC that you want to associate with the rule group.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        creatorRequestId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct AssociateFirewallRuleGroupInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let firewallRuleGroupId: Swift.String?
    let vpcId: Swift.String?
    let priority: Swift.Int?
    let name: Swift.String?
    let mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension AssociateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFirewallRuleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFirewallRuleGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFirewallRuleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct AssociateFirewallRuleGroupOutputResponse: Swift.Equatable {
    /// The association that you just created. The association has an ID that you can use to identify it in other requests, like update and delete.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct AssociateFirewallRuleGroupOutputResponseBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension AssociateFirewallRuleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

extension AssociateResolverEndpointIpAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension AssociateResolverEndpointIpAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverEndpointIpAddressInput: Swift.Equatable {
    /// Either the IPv4 address that you want to add to a Resolver endpoint or a subnet ID. If you specify a subnet ID, Resolver chooses an IP address for you from the available IPs in the specified subnet.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to associate IP addresses with.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct AssociateResolverEndpointIpAddressInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
}

extension AssociateResolverEndpointIpAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension AssociateResolverEndpointIpAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverEndpointIpAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverEndpointIpAddressOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverEndpointIpAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResolverEndpointIpAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct AssociateResolverEndpointIpAddressOutputResponse: Swift.Equatable {
    /// The response to an AssociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct AssociateResolverEndpointIpAddressOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension AssociateResolverEndpointIpAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension AssociateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension AssociateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to associate a VPC with.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of an Amazon VPC that you want this query logging configuration to log queries for. The VPCs and the query logging configuration must be in the same Region.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct AssociateResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
    let resourceId: Swift.String?
}

extension AssociateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverQueryLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverQueryLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverQueryLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct AssociateResolverQueryLogConfigOutputResponse: Swift.Equatable {
    /// A complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct AssociateResolverQueryLogConfigOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension AssociateResolverQueryLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

extension AssociateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }
}

extension AssociateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateResolverRuleInput: Swift.Equatable {
    /// A name for the association that you're creating between a Resolver rule and a VPC.
    public var name: Swift.String?
    /// The ID of the Resolver rule that you want to associate with the VPC. To list the existing Resolver rules, use [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html).
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to associate the Resolver rule with.
    /// This member is required.
    public var vPCId: Swift.String?

    public init (
        name: Swift.String? = nil,
        resolverRuleId: Swift.String? = nil,
        vPCId: Swift.String? = nil
    )
    {
        self.name = name
        self.resolverRuleId = resolverRuleId
        self.vPCId = vPCId
    }
}

struct AssociateResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
    let name: Swift.String?
    let vPCId: Swift.String?
}

extension AssociateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
    }
}

extension AssociateResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct AssociateResolverRuleOutputResponse: Swift.Equatable {
    /// Information about the AssociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct AssociateResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension AssociateResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum AutodefinedReverseFlag: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [AutodefinedReverseFlag] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutodefinedReverseFlag(rawValue: rawValue) ?? AutodefinedReverseFlag.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum BlockOverrideDnsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cname
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockOverrideDnsType] {
            return [
                .cname,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cname: return "CNAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockOverrideDnsType(rawValue: rawValue) ?? BlockOverrideDnsType.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum BlockResponse: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nodata
        case nxdomain
        case `override`
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockResponse] {
            return [
                .nodata,
                .nxdomain,
                .override,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nodata: return "NODATA"
            case .nxdomain: return "NXDOMAIN"
            case .override: return "OVERRIDE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockResponse(rawValue: rawValue) ?? BlockResponse.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallDomainListInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the domain list to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the domain list.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallDomainListInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallDomainListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallDomainListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallDomainListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallDomainListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct CreateFirewallDomainListOutputResponse: Swift.Equatable {
    /// The domain list that you just created.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init (
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct CreateFirewallDomainListOutputResponseBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension CreateFirewallDomainListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

extension CreateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallRuleGroupInput: Swift.Equatable {
    /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// A name that lets you identify the rule group, to manage and use it.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the rule group.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.name = name
        self.tags = tags
    }
}

struct CreateFirewallRuleGroupInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallRuleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallRuleGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallRuleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct CreateFirewallRuleGroupOutputResponse: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init (
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct CreateFirewallRuleGroupOutputResponseBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension CreateFirewallRuleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

extension CreateFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension CreateFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFirewallRuleInput: Swift.Equatable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request and send metrics and logs to Cloud Watch.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    /// This member is required.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request, used with the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    ///
    ///
    /// This setting is required if the rule action setting is BLOCK.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// A unique string that identifies the request and that allows you to retry failed requests without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ID of the domain list that you want to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group where you want to create the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// A name that lets you identify the rule in the rule group.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    /// This member is required.
    public var priority: Swift.Int?

    public init (
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        creatorRequestId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.creatorRequestId = creatorRequestId
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct CreateFirewallRuleInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let blockResponse: Route53ResolverClientTypes.BlockResponse?
    let blockOverrideDomain: Swift.String?
    let blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    let blockOverrideTtl: Swift.Int?
    let name: Swift.String?
}

extension CreateFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateFirewallRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct CreateFirewallRuleOutputResponse: Swift.Equatable {
    /// The firewall rule that you just created.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init (
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct CreateFirewallRuleOutputResponseBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension CreateFirewallRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

extension CreateResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let ipAddresses = ipAddresses {
            var ipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddresses)
            for ipaddressesrequest0 in ipAddresses {
                try ipAddressesContainer.encode(ipaddressesrequest0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverEndpointInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// Specify the applicable value:
    ///
    /// * INBOUND: Resolver forwards DNS queries to the DNS service for a VPC from your network
    ///
    /// * OUTBOUND: Resolver forwards DNS queries from the DNS service for a VPC to your network
    /// This member is required.
    public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
    /// The subnets and IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). The subnet ID uniquely identifies a VPC.
    /// This member is required.
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]?
    /// A friendly name that lets you easily find a configuration in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The ID of one or more security groups that you want to use to control access to this VPC. The security group that you specify must include one or more inbound rules (for inbound Resolver endpoints) or outbound rules (for outbound Resolver endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
        ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.direction = direction
        self.ipAddresses = ipAddresses
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.tags = tags
    }
}

struct CreateResolverEndpointInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let direction: Route53ResolverClientTypes.ResolverEndpointDirection?
    let ipAddresses: [Route53ResolverClientTypes.IpAddressRequest]?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case ipAddresses = "IpAddresses"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.IpAddressRequest?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Route53ResolverClientTypes.IpAddressRequest]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Route53ResolverClientTypes.IpAddressRequest]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct CreateResolverEndpointOutputResponse: Swift.Equatable {
    /// Information about the CreateResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct CreateResolverEndpointOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension CreateResolverEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension CreateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverQueryLogConfigInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// The ARN of the resource that you want Resolver to send query logs. You can send query logs to an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream. Examples of valid values include the following:
    ///
    /// * S3 bucket: arn:aws:s3:::examplebucket You can optionally append a file prefix to the end of the ARN. arn:aws:s3:::examplebucket/development/
    ///
    /// * CloudWatch Logs log group: arn:aws:logs:us-west-1:123456789012:log-group:/mystack-testgroup-12ABC1AB12A1:*
    ///
    /// * Kinesis Data Firehose delivery stream: arn:aws:kinesis:us-east-2:0123456789:stream/my_stream_name
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The name that you want to give the query logging configuration.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the tag keys and values that you want to associate with the query logging configuration.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        creatorRequestId: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.destinationArn = destinationArn
        self.name = name
        self.tags = tags
    }
}

struct CreateResolverQueryLogConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationArn: Swift.String?
    let creatorRequestId: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverQueryLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverQueryLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverQueryLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct CreateResolverQueryLogConfigOutputResponse: Swift.Equatable {
    /// Information about the CreateResolverQueryLogConfig request, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct CreateResolverQueryLogConfigOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension CreateResolverQueryLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

extension CreateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }
}

extension CreateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateResolverRuleInput: Swift.Equatable {
    /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string, for example, a date/time stamp.
    /// This member is required.
    public var creatorRequestId: Swift.String?
    /// DNS queries for this domain name are forwarded to the IP addresses that you specify in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), outbound DNS queries are routed using the Resolver rule that contains the most specific domain name (www.example.com).
    /// This member is required.
    public var domainName: Swift.String?
    /// A friendly name that lets you easily find a rule in the Resolver dashboard in the Route 53 console.
    public var name: Swift.String?
    /// The ID of the outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
    public var resolverEndpointId: Swift.String?
    /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
    /// This member is required.
    public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
    /// A list of the tag keys and values that you want to associate with the endpoint.
    public var tags: [Route53ResolverClientTypes.Tag]?
    /// The IPs that you want Resolver to forward DNS queries to. You can specify only IPv4 addresses. Separate IP addresses with a space. TargetIps is available only when the value of Rule type is FORWARD.
    public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

    public init (
        creatorRequestId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        name: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil,
        ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil,
        targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.domainName = domainName
        self.name = name
        self.resolverEndpointId = resolverEndpointId
        self.ruleType = ruleType
        self.tags = tags
        self.targetIps = targetIps
    }
}

struct CreateResolverRuleInputBody: Swift.Equatable {
    let creatorRequestId: Swift.String?
    let name: Swift.String?
    let ruleType: Route53ResolverClientTypes.RuleTypeOption?
    let domainName: Swift.String?
    let targetIps: [Route53ResolverClientTypes.TargetAddress]?
    let resolverEndpointId: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension CreateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case tags = "Tags"
        case targetIps = "TargetIps"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct CreateResolverRuleOutputResponse: Swift.Equatable {
    /// Information about the CreateResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init (
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct CreateResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension CreateResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

extension DeleteFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

extension DeleteFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallDomainListInput: Swift.Equatable {
    /// The ID of the domain list that you want to delete.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init (
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct DeleteFirewallDomainListInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
}

extension DeleteFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallDomainListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallDomainListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallDomainListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallDomainListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct DeleteFirewallDomainListOutputResponse: Swift.Equatable {
    /// The domain list that you just deleted.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init (
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct DeleteFirewallDomainListOutputResponseBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension DeleteFirewallDomainListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

extension DeleteFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension DeleteFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallRuleGroupInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group that you want to delete.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init (
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
}

extension DeleteFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension DeleteFirewallRuleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallRuleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallRuleGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallRuleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct DeleteFirewallRuleGroupOutputResponse: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init (
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct DeleteFirewallRuleGroupOutputResponseBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension DeleteFirewallRuleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

extension DeleteFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension DeleteFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFirewallRuleInput: Swift.Equatable {
    /// The ID of the domain list that's used in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group that you want to delete the rule from.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init (
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct DeleteFirewallRuleInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
}

extension DeleteFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension DeleteFirewallRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct DeleteFirewallRuleOutputResponse: Swift.Equatable {
    /// The specification for the firewall rule that you just deleted.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init (
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct DeleteFirewallRuleOutputResponseBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension DeleteFirewallRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

extension DeleteResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension DeleteResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverEndpointInput: Swift.Equatable {
    /// The ID of the Resolver endpoint that you want to delete.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DeleteResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
}

extension DeleteResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension DeleteResolverEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DeleteResolverEndpointOutputResponse: Swift.Equatable {
    /// Information about the DeleteResolverEndpoint request, including the status of the request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DeleteResolverEndpointOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension DeleteResolverEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension DeleteResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

extension DeleteResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to delete.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init (
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct DeleteResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
}

extension DeleteResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension DeleteResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverQueryLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverQueryLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverQueryLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct DeleteResolverQueryLogConfigOutputResponse: Swift.Equatable {
    /// Information about the query logging configuration that you deleted, including the status of the request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct DeleteResolverQueryLogConfigOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension DeleteResolverQueryLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

extension DeleteResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension DeleteResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to delete.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init (
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct DeleteResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
}

extension DeleteResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DeleteResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct DeleteResolverRuleOutputResponse: Swift.Equatable {
    /// Information about the DeleteResolverRule request, including the status of the request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init (
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct DeleteResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension DeleteResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

extension DisassociateFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

extension DisassociateFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFirewallRuleGroupInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init (
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct DisassociateFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
}

extension DisassociateFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension DisassociateFirewallRuleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFirewallRuleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFirewallRuleGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFirewallRuleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct DisassociateFirewallRuleGroupOutputResponse: Swift.Equatable {
    /// The firewall rule group association that you just removed.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct DisassociateFirewallRuleGroupOutputResponseBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension DisassociateFirewallRuleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

extension DisassociateResolverEndpointIpAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension DisassociateResolverEndpointIpAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverEndpointIpAddressInput: Swift.Equatable {
    /// The IPv4 address that you want to remove from a Resolver endpoint.
    /// This member is required.
    public var ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
    /// The ID of the Resolver endpoint that you want to disassociate an IP address from.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        ipAddress: Route53ResolverClientTypes.IpAddressUpdate? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.ipAddress = ipAddress
        self.resolverEndpointId = resolverEndpointId
    }
}

struct DisassociateResolverEndpointIpAddressInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let ipAddress: Route53ResolverClientTypes.IpAddressUpdate?
}

extension DisassociateResolverEndpointIpAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressUpdate.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension DisassociateResolverEndpointIpAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverEndpointIpAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverEndpointIpAddressOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverEndpointIpAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResolverEndpointIpAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct DisassociateResolverEndpointIpAddressOutputResponse: Swift.Equatable {
    /// The response to an DisassociateResolverEndpointIpAddress request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct DisassociateResolverEndpointIpAddressOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension DisassociateResolverEndpointIpAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension DisassociateResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DisassociateResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the query logging configuration that you want to disassociate a specified VPC from.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?
    /// The ID of the Amazon VPC that you want to disassociate from a specified query logging configuration.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resolverQueryLogConfigId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
        self.resourceId = resourceId
    }
}

struct DisassociateResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
    let resourceId: Swift.String?
}

extension DisassociateResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverQueryLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverQueryLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverQueryLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct DisassociateResolverQueryLogConfigOutputResponse: Swift.Equatable {
    /// A complex type that contains settings for the association that you deleted between an Amazon VPC and a query logging configuration.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct DisassociateResolverQueryLogConfigOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension DisassociateResolverQueryLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

extension DisassociateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }
}

extension DisassociateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to disassociate from the specified VPC.
    /// This member is required.
    public var resolverRuleId: Swift.String?
    /// The ID of the VPC that you want to disassociate the Resolver rule from.
    /// This member is required.
    public var vPCId: Swift.String?

    public init (
        resolverRuleId: Swift.String? = nil,
        vPCId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
        self.vPCId = vPCId
    }
}

struct DisassociateResolverRuleInputBody: Swift.Equatable {
    let vPCId: Swift.String?
    let resolverRuleId: Swift.String?
}

extension DisassociateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
        case vPCId = "VPCId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension DisassociateResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct DisassociateResolverRuleOutputResponse: Swift.Equatable {
    /// Information about the DisassociateResolverRule request, including the status of the request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct DisassociateResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension DisassociateResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

extension Route53ResolverClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Route53ResolverClientTypes {
    /// For Resolver list operations ([ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html)), and [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverDnssecConfigs.html)), an optional specification to return a subset of objects. To filter objects, such as Resolver endpoints or Resolver rules, you specify Name and Values. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
    public struct Filter: Swift.Equatable {
        /// The name of the parameter that you want to use to filter objects. The valid values for Name depend on the action that you're including the filter in, [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html), [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html). In early versions of Resolver, values for Name were listed as uppercase, with underscore (_) delimiters. For example, CreatorRequestId was originally listed as CREATOR_REQUEST_ID. Uppercase values for Name are still supported. ListResolverEndpoints Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver endpoint.
        ///
        /// * Direction: Whether you want to return inbound or outbound Resolver endpoints. If you specify DIRECTION for Name, specify INBOUND or OUTBOUND for Values.
        ///
        /// * HostVPCId: The ID of the VPC that inbound DNS queries pass through on the way from your network to your VPCs in a region, or the VPC that outbound queries pass through on the way from your VPCs to your network. In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, SubnetId indirectly identifies the VPC. In a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, the VPC ID for a Resolver endpoint is returned in the HostVPCId element.
        ///
        /// * IpAddressCount: The number of IP addresses that you have associated with the Resolver endpoint.
        ///
        /// * Name: The name of the Resolver endpoint.
        ///
        /// * SecurityGroupIds: The IDs of the VPC security groups that you specified when you created the Resolver endpoint.
        ///
        /// * Status: The status of the Resolver endpoint. If you specify Status for Name, specify one of the following status codes for Values: CREATING, OPERATIONAL, UPDATING, AUTO_RECOVERING, ACTION_NEEDED, or DELETING. For more information, see Status in [ResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverEndpoint.html).
        ///
        ///
        /// ListResolverRules Valid values for Name include the following:
        ///
        /// * CreatorRequestId: The value that you specified when you created the Resolver rule.
        ///
        /// * DomainName: The domain name for which Resolver is forwarding DNS queries to your network. In the value that you specify for Values, include a trailing dot (.) after the domain name. For example, if the domain name is example.com, specify the following value. Note the "." after com: example.com.
        ///
        /// * Name: The name of the Resolver rule.
        ///
        /// * ResolverEndpointId: The ID of the Resolver endpoint that the Resolver rule is associated with. You can filter on the Resolver endpoint only for rules that have a value of FORWARD for RuleType.
        ///
        /// * Status: The status of the Resolver rule. If you specify Status for Name, specify one of the following status codes for Values: COMPLETE, DELETING, UPDATING, or FAILED.
        ///
        /// * Type: The type of the Resolver rule. If you specify TYPE for Name, specify FORWARD or SYSTEM for Values.
        ///
        ///
        /// ListResolverRuleAssociations Valid values for Name include the following:
        ///
        /// * Name: The name of the Resolver rule association.
        ///
        /// * ResolverRuleId: The ID of the Resolver rule that is associated with one or more VPCs.
        ///
        /// * Status: The status of the Resolver rule association. If you specify Status for Name, specify one of the following status codes for Values: CREATING, COMPLETE, DELETING, or FAILED.
        ///
        /// * VPCId: The ID of the VPC that the Resolver rule is associated with.
        ///
        ///
        /// ListResolverQueryLogConfigs Valid values for Name include the following:
        ///
        /// * Arn: The ARN for the query logging configuration.
        ///
        /// * AssociationCount: The number of VPCs that are associated with the query logging configuration.
        ///
        /// * CreationTime: The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * CreatorRequestId: A unique string that identifies the request that created the query logging configuration.
        ///
        /// * Destination: The Amazon Web Services service that you want to forward query logs to. Valid values include the following:
        ///
        /// * S3
        ///
        /// * CloudWatchLogs
        ///
        /// * KinesisFirehose
        ///
        ///
        ///
        ///
        /// * DestinationArn: The ARN of the location that Resolver is sending query logs to. This value can be the ARN for an S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        ///
        /// * Id: The ID of the query logging configuration
        ///
        /// * Name: The name of the query logging configuration
        ///
        /// * OwnerId: The Amazon Web Services account ID for the account that created the query logging configuration.
        ///
        /// * ShareStatus: An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Valid values include: NOT_SHARED, SHARED_WITH_ME, or SHARED_BY_ME.
        ///
        /// * Status: The status of the query logging configuration. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfig.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfig-Status).
        ///
        ///
        /// ListResolverQueryLogConfigAssociations Valid values for Name include the following:
        ///
        /// * CreationTime: The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        ///
        /// * Error: If the value of Status is FAILED, specify the cause: DESTINATION_NOT_FOUND or ACCESS_DENIED.
        ///
        /// * Id: The ID of the query logging association.
        ///
        /// * ResolverQueryLogConfigId: The ID of the query logging configuration that a VPC is associated with.
        ///
        /// * ResourceId: The ID of the Amazon VPC that is associated with the query logging configuration.
        ///
        /// * Status: The status of the query logging association. If you specify Status for Name, specify the applicable status code for Values: CREATING, CREATED, DELETING, or FAILED. For more information, see [Status](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ResolverQueryLogConfigAssociation.html#Route53Resolver-Type-route53resolver_ResolverQueryLogConfigAssociation-Status).
        public var name: Swift.String?
        /// When you're using a List operation and you want the operation to return a subset of objects, such as Resolver endpoints or Resolver rules, the value of the parameter that you want to use to filter objects. For example, to list only inbound Resolver endpoints, specify Direction for Name and specify INBOUND for Values.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension Route53ResolverClientTypes.FirewallConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from Amazon Virtual Private Cloud (Amazon VPC).
    public struct FirewallConfig: Swift.Equatable {
        /// Determines how DNS Firewall operates during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
        ///
        /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall returns a failure error when it is unable to properly evaluate a query.
        ///
        /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
        ///
        ///
        /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
        public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
        /// The ID of the firewall configuration.
        public var id: Swift.String?
        /// The Amazon Web Services account ID of the owner of the VPC that this firewall configuration applies to.
        public var ownerId: Swift.String?
        /// The ID of the VPC that this firewall configuration applies to.
        public var resourceId: Swift.String?

        public init (
            firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.firewallFailOpen = firewallFailOpen
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallDomainImportOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainImportOperation] {
            return [
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainImportOperation(rawValue: rawValue) ?? FirewallDomainImportOperation.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallDomainList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainCount = "DomainCount"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainCount = domainCount {
            try encodeContainer.encode(domainCount, forKey: .domainCount)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .domainCount)
        domainCount = domainCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// High-level information about a list of firewall domains for use in a [FirewallRule]. This is returned by [GetFirewallDomainList]. To retrieve the domains that are defined for this domain list, call [ListFirewallDomains].
    public struct FirewallDomainList: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall domain list.
        public var arn: Swift.String?
        /// The date and time that the domain list was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The number of domain names that are specified in the domain list.
        public var domainCount: Swift.Int?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The date and time that the domain list was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
        /// Additional information about the status of the list, if available.
        public var statusMessage: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainCount = domainCount
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes.FirewallDomainListMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall domain list. The action [ListFirewallDomainLists] returns an array of these objects. To retrieve full information for a firewall domain list, call [GetFirewallDomainList] and [ListFirewallDomains].
    public struct FirewallDomainListMetadata: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall domain list metadata.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list.
        public var id: Swift.String?
        /// The owner of the list, used only for lists that are not managed by you. For example, the managed domain list AWSManagedDomainsMalwareDomainList has the managed owner name Route 53 Resolver DNS Firewall.
        public var managedOwnerName: Swift.String?
        /// The name of the domain list.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.name = name
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallDomainListStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case completeImportFailed
        case deleting
        case importing
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainListStatus] {
            return [
                .complete,
                .completeImportFailed,
                .deleting,
                .importing,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .completeImportFailed: return "COMPLETE_IMPORT_FAILED"
            case .deleting: return "DELETING"
            case .importing: return "IMPORTING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainListStatus(rawValue: rawValue) ?? FirewallDomainListStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum FirewallDomainUpdateOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDomainUpdateOperation] {
            return [
                .add,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallDomainUpdateOperation(rawValue: rawValue) ?? FirewallDomainUpdateOperation.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum FirewallFailOpenStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallFailOpenStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallFailOpenStatus(rawValue: rawValue) ?? FirewallFailOpenStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A single firewall rule in a rule group.
    public struct FirewallRule: Swift.Equatable {
        /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
        ///
        /// * ALLOW - Permit the request to go through.
        ///
        /// * ALERT - Permit the request to go through but send an alert to the logs.
        ///
        /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
        public var action: Route53ResolverClientTypes.Action?
        /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
        /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideDomain: Swift.String?
        /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
        public var blockOverrideTtl: Swift.Int?
        /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
        ///
        /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
        ///
        /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
        ///
        /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
        public var blockResponse: Route53ResolverClientTypes.BlockResponse?
        /// The date and time that the rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of executing the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the domain list that's used in the rule.
        public var firewallDomainListId: Swift.String?
        /// The unique identifier of the firewall rule group of the rule.
        public var firewallRuleGroupId: Swift.String?
        /// The date and time that the rule was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule in the rule group. This value must be unique within the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
        public var priority: Swift.Int?

        public init (
            action: Route53ResolverClientTypes.Action? = nil,
            blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallDomainListId = firewallDomainListId
            self.firewallRuleGroupId = firewallRuleGroupId
            self.modificationTime = modificationTime
            self.name = name
            self.priority = priority
        }
    }

}

extension Route53ResolverClientTypes.FirewallRuleGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case ruleCount = "RuleCount"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let ruleCount = ruleCount {
            try encodeContainer.encode(ruleCount, forKey: .ruleCount)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleCount)
        ruleCount = ruleCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// High-level information for a firewall rule group. A firewall rule group is a collection of rules that DNS Firewall uses to filter DNS network traffic for a VPC. To retrieve the rules for the rule group, call [ListFirewallRules].
    public struct FirewallRuleGroup: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// The date and time that the rule group was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The date and time that the rule group was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// The number of rules in the rule group.
        public var ruleCount: Swift.Int?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the domain list.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupStatus?
        /// Additional information about the status of the rule group, if available.
        public var statusMessage: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            ruleCount: Swift.Int? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.ruleCount = ruleCount
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes.FirewallRuleGroupAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case id = "Id"
        case managedOwnerName = "ManagedOwnerName"
        case modificationTime = "ModificationTime"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let managedOwnerName = managedOwnerName {
            try encodeContainer.encode(managedOwnerName, forKey: .managedOwnerName)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let managedOwnerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedOwnerName)
        managedOwnerName = managedOwnerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// An association between a firewall rule group and a VPC, which enables DNS filtering for the VPC.
    public struct FirewallRuleGroupAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the firewall rule group association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The unique identifier of the firewall rule group.
        public var firewallRuleGroupId: Swift.String?
        /// The identifier for the association.
        public var id: Swift.String?
        /// The owner of the association, used only for associations that are not managed by you. If you use Firewall Manager to manage your DNS Firewalls, then this reports Firewall Manager as the managed owner.
        public var managedOwnerName: Swift.String?
        /// The date and time that the association was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
        public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
        /// The name of the association.
        public var name: Swift.String?
        /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from rule group with the lowest numeric priority setting.
        public var priority: Swift.Int?
        /// The current status of the association.
        public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
        /// Additional information about the status of the response, if available.
        public var statusMessage: Swift.String?
        /// The unique identifier of the VPC that is associated with the rule group.
        public var vpcId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            firewallRuleGroupId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedOwnerName: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.firewallRuleGroupId = firewallRuleGroupId
            self.id = id
            self.managedOwnerName = managedOwnerName
            self.modificationTime = modificationTime
            self.mutationProtection = mutationProtection
            self.name = name
            self.priority = priority
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallRuleGroupAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupAssociationStatus] {
            return [
                .complete,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallRuleGroupAssociationStatus(rawValue: rawValue) ?? FirewallRuleGroupAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.FirewallRuleGroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creatorRequestId = "CreatorRequestId"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
    }
}

extension Route53ResolverClientTypes {
    /// Minimal high-level information for a firewall rule group. The action [ListFirewallRuleGroups] returns an array of these objects. To retrieve full information for a firewall rule group, call [GetFirewallRuleGroup] and [ListFirewallRules].
    public struct FirewallRuleGroupMetadata: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the rule group.
        public var arn: Swift.String?
        /// A unique string defined by you to identify the request. This allows you to retry failed requests without the risk of running the operation twice. This can be any unique string, for example, a timestamp.
        public var creatorRequestId: Swift.String?
        /// The ID of the rule group.
        public var id: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the rule group. When a rule group is shared with your account, this is the account that has shared the rule group with you.
        public var ownerId: Swift.String?
        /// Whether the rule group is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?

        public init (
            arn: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil
        )
        {
            self.arn = arn
            self.creatorRequestId = creatorRequestId
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
        }
    }

}

extension Route53ResolverClientTypes {
    public enum FirewallRuleGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleGroupStatus] {
            return [
                .complete,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirewallRuleGroupStatus(rawValue: rawValue) ?? FirewallRuleGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetFirewallConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetFirewallConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallConfigInput: Swift.Equatable {
    /// The ID of the VPC from Amazon VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetFirewallConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetFirewallConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetFirewallConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFirewallConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct GetFirewallConfigOutputResponse: Swift.Equatable {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC from AmazonVPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init (
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct GetFirewallConfigOutputResponseBody: Swift.Equatable {
    let firewallConfig: Route53ResolverClientTypes.FirewallConfig?
}

extension GetFirewallConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

extension GetFirewallDomainListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
    }
}

extension GetFirewallDomainListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallDomainListInput: Swift.Equatable {
    /// The ID of the domain list.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init (
        firewallDomainListId: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
    }
}

struct GetFirewallDomainListInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
}

extension GetFirewallDomainListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
    }
}

extension GetFirewallDomainListOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallDomainListOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallDomainListOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallDomainListOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFirewallDomainListOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainList = output.firewallDomainList
        } else {
            self.firewallDomainList = nil
        }
    }
}

public struct GetFirewallDomainListOutputResponse: Swift.Equatable {
    /// The domain list that you requested.
    public var firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?

    public init (
        firewallDomainList: Route53ResolverClientTypes.FirewallDomainList? = nil
    )
    {
        self.firewallDomainList = firewallDomainList
    }
}

struct GetFirewallDomainListOutputResponseBody: Swift.Equatable {
    let firewallDomainList: Route53ResolverClientTypes.FirewallDomainList?
}

extension GetFirewallDomainListOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainList = "FirewallDomainList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainList.self, forKey: .firewallDomainList)
        firewallDomainList = firewallDomainListDecoded
    }
}

extension GetFirewallRuleGroupAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
    }
}

extension GetFirewallRuleGroupAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupAssociationInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?

    public init (
        firewallRuleGroupAssociationId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
    }
}

struct GetFirewallRuleGroupAssociationInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
}

extension GetFirewallRuleGroupAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
    }
}

extension GetFirewallRuleGroupAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFirewallRuleGroupAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct GetFirewallRuleGroupAssociationOutputResponse: Swift.Equatable {
    /// The association that you requested.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct GetFirewallRuleGroupAssociationOutputResponseBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension GetFirewallRuleGroupAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

extension GetFirewallRuleGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
    }
}

extension GetFirewallRuleGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?

    public init (
        firewallRuleGroupId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
    }
}

struct GetFirewallRuleGroupInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
}

extension GetFirewallRuleGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
    }
}

extension GetFirewallRuleGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFirewallRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroup = output.firewallRuleGroup
        } else {
            self.firewallRuleGroup = nil
        }
    }
}

public struct GetFirewallRuleGroupOutputResponse: Swift.Equatable {
    /// A collection of rules used to filter DNS network traffic.
    public var firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?

    public init (
        firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup? = nil
    )
    {
        self.firewallRuleGroup = firewallRuleGroup
    }
}

struct GetFirewallRuleGroupOutputResponseBody: Swift.Equatable {
    let firewallRuleGroup: Route53ResolverClientTypes.FirewallRuleGroup?
}

extension GetFirewallRuleGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroup = "FirewallRuleGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroup.self, forKey: .firewallRuleGroup)
        firewallRuleGroup = firewallRuleGroupDecoded
    }
}

extension GetFirewallRuleGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetFirewallRuleGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFirewallRuleGroupPolicyInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) for the rule group.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetFirewallRuleGroupPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetFirewallRuleGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetFirewallRuleGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFirewallRuleGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFirewallRuleGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFirewallRuleGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFirewallRuleGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupPolicy = output.firewallRuleGroupPolicy
        } else {
            self.firewallRuleGroupPolicy = nil
        }
    }
}

public struct GetFirewallRuleGroupPolicyOutputResponse: Swift.Equatable {
    /// The Identity and Access Management (Amazon Web Services IAM) policy for sharing the specified rule group. You can use the policy to share the rule group using Resource Access Manager (RAM).
    public var firewallRuleGroupPolicy: Swift.String?

    public init (
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct GetFirewallRuleGroupPolicyOutputResponseBody: Swift.Equatable {
    let firewallRuleGroupPolicy: Swift.String?
}

extension GetFirewallRuleGroupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

extension GetResolverConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetResolverConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverConfigInput: Swift.Equatable {
    /// Resource ID of the Amazon VPC that you want to get information about.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetResolverConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetResolverConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetResolverConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverConfig = output.resolverConfig
        } else {
            self.resolverConfig = nil
        }
    }
}

public struct GetResolverConfigOutputResponse: Swift.Equatable {
    /// Information about the behavior configuration of Route 53 Resolver behavior for the VPC you specified in the GetResolverConfig request.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init (
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

struct GetResolverConfigOutputResponseBody: Swift.Equatable {
    let resolverConfig: Route53ResolverClientTypes.ResolverConfig?
}

extension GetResolverConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverConfig = "ResolverConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverConfig.self, forKey: .resolverConfig)
        resolverConfig = resolverConfigDecoded
    }
}

extension GetResolverDnssecConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension GetResolverDnssecConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverDnssecConfigInput: Swift.Equatable {
    /// The ID of the virtual private cloud (VPC) for the DNSSEC validation status.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct GetResolverDnssecConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
}

extension GetResolverDnssecConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GetResolverDnssecConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverDnssecConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverDnssecConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverDnssecConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverDnssecConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct GetResolverDnssecConfigOutputResponse: Swift.Equatable {
    /// The information about a configuration for DNSSEC validation.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init (
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct GetResolverDnssecConfigOutputResponseBody: Swift.Equatable {
    let resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?
}

extension GetResolverDnssecConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

extension GetResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension GetResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverEndpointInput: Swift.Equatable {
    /// The ID of the Resolver endpoint that you want to get information about.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.resolverEndpointId = resolverEndpointId
    }
}

struct GetResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
}

extension GetResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension GetResolverEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct GetResolverEndpointOutputResponse: Swift.Equatable {
    /// Information about the Resolver endpoint that you specified in a GetResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct GetResolverEndpointOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension GetResolverEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension GetResolverQueryLogConfigAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId {
            try encodeContainer.encode(resolverQueryLogConfigAssociationId, forKey: .resolverQueryLogConfigAssociationId)
        }
    }
}

extension GetResolverQueryLogConfigAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigAssociationInput: Swift.Equatable {
    /// The ID of the Resolver query logging configuration association that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigAssociationId: Swift.String?

    public init (
        resolverQueryLogConfigAssociationId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationId
    }
}

struct GetResolverQueryLogConfigAssociationInputBody: Swift.Equatable {
    let resolverQueryLogConfigAssociationId: Swift.String?
}

extension GetResolverQueryLogConfigAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociationId = "ResolverQueryLogConfigAssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigAssociationId)
        resolverQueryLogConfigAssociationId = resolverQueryLogConfigAssociationIdDecoded
    }
}

extension GetResolverQueryLogConfigAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverQueryLogConfigAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigAssociation = output.resolverQueryLogConfigAssociation
        } else {
            self.resolverQueryLogConfigAssociation = nil
        }
    }
}

public struct GetResolverQueryLogConfigAssociationOutputResponse: Swift.Equatable {
    /// Information about the Resolver query logging configuration association that you specified in a GetQueryLogConfigAssociation request.
    public var resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?

    public init (
        resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation? = nil
    )
    {
        self.resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociation
    }
}

struct GetResolverQueryLogConfigAssociationOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfigAssociation: Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?
}

extension GetResolverQueryLogConfigAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigAssociation = "ResolverQueryLogConfigAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociation.self, forKey: .resolverQueryLogConfigAssociation)
        resolverQueryLogConfigAssociation = resolverQueryLogConfigAssociationDecoded
    }
}

extension GetResolverQueryLogConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
    }
}

extension GetResolverQueryLogConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigInput: Swift.Equatable {
    /// The ID of the Resolver query logging configuration that you want to get information about.
    /// This member is required.
    public var resolverQueryLogConfigId: Swift.String?

    public init (
        resolverQueryLogConfigId: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigId = resolverQueryLogConfigId
    }
}

struct GetResolverQueryLogConfigInputBody: Swift.Equatable {
    let resolverQueryLogConfigId: Swift.String?
}

extension GetResolverQueryLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
    }
}

extension GetResolverQueryLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverQueryLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfig = output.resolverQueryLogConfig
        } else {
            self.resolverQueryLogConfig = nil
        }
    }
}

public struct GetResolverQueryLogConfigOutputResponse: Swift.Equatable {
    /// Information about the Resolver query logging configuration that you specified in a GetQueryLogConfig request.
    public var resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?

    public init (
        resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig? = nil
    )
    {
        self.resolverQueryLogConfig = resolverQueryLogConfig
    }
}

struct GetResolverQueryLogConfigOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfig: Route53ResolverClientTypes.ResolverQueryLogConfig?
}

extension GetResolverQueryLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfig = "ResolverQueryLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfig.self, forKey: .resolverQueryLogConfig)
        resolverQueryLogConfig = resolverQueryLogConfigDecoded
    }
}

extension GetResolverQueryLogConfigPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetResolverQueryLogConfigPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverQueryLogConfigPolicyInput: Swift.Equatable {
    /// The ARN of the query logging configuration that you want to get the query logging policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverQueryLogConfigPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetResolverQueryLogConfigPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverQueryLogConfigPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverQueryLogConfigPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverQueryLogConfigPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverQueryLogConfigPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverQueryLogConfigPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverQueryLogConfigPolicy = output.resolverQueryLogConfigPolicy
        } else {
            self.resolverQueryLogConfigPolicy = nil
        }
    }
}

public struct GetResolverQueryLogConfigPolicyOutputResponse: Swift.Equatable {
    /// Information about the query logging policy for the query logging configuration that you specified in a GetResolverQueryLogConfigPolicy request.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init (
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct GetResolverQueryLogConfigPolicyOutputResponseBody: Swift.Equatable {
    let resolverQueryLogConfigPolicy: Swift.String?
}

extension GetResolverQueryLogConfigPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

extension GetResolverRuleAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleAssociationId = resolverRuleAssociationId {
            try encodeContainer.encode(resolverRuleAssociationId, forKey: .resolverRuleAssociationId)
        }
    }
}

extension GetResolverRuleAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRuleAssociationInput: Swift.Equatable {
    /// The ID of the Resolver rule association that you want to get information about.
    /// This member is required.
    public var resolverRuleAssociationId: Swift.String?

    public init (
        resolverRuleAssociationId: Swift.String? = nil
    )
    {
        self.resolverRuleAssociationId = resolverRuleAssociationId
    }
}

struct GetResolverRuleAssociationInputBody: Swift.Equatable {
    let resolverRuleAssociationId: Swift.String?
}

extension GetResolverRuleAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociationId = "ResolverRuleAssociationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleAssociationId)
        resolverRuleAssociationId = resolverRuleAssociationIdDecoded
    }
}

extension GetResolverRuleAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRuleAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRuleAssociationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRuleAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverRuleAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRuleAssociation = output.resolverRuleAssociation
        } else {
            self.resolverRuleAssociation = nil
        }
    }
}

public struct GetResolverRuleAssociationOutputResponse: Swift.Equatable {
    /// Information about the Resolver rule association that you specified in a GetResolverRuleAssociation request.
    public var resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?

    public init (
        resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation? = nil
    )
    {
        self.resolverRuleAssociation = resolverRuleAssociation
    }
}

struct GetResolverRuleAssociationOutputResponseBody: Swift.Equatable {
    let resolverRuleAssociation: Route53ResolverClientTypes.ResolverRuleAssociation?
}

extension GetResolverRuleAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleAssociation = "ResolverRuleAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociation.self, forKey: .resolverRuleAssociation)
        resolverRuleAssociation = resolverRuleAssociationDecoded
    }
}

extension GetResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension GetResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRuleInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to get information about.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init (
        resolverRuleId: Swift.String? = nil
    )
    {
        self.resolverRuleId = resolverRuleId
    }
}

struct GetResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
}

extension GetResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
    }
}

extension GetResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct GetResolverRuleOutputResponse: Swift.Equatable {
    /// Information about the Resolver rule that you specified in a GetResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init (
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct GetResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension GetResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

extension GetResolverRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetResolverRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResolverRulePolicyInput: Swift.Equatable {
    /// The ID of the Resolver rule that you want to get the Resolver rule policy for.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResolverRulePolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetResolverRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetResolverRulePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverRulePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverRulePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverRulePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResolverRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRulePolicy = output.resolverRulePolicy
        } else {
            self.resolverRulePolicy = nil
        }
    }
}

public struct GetResolverRulePolicyOutputResponse: Swift.Equatable {
    /// The Resolver rule policy for the rule that you specified in a GetResolverRulePolicy request.
    public var resolverRulePolicy: Swift.String?

    public init (
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct GetResolverRulePolicyOutputResponseBody: Swift.Equatable {
    let resolverRulePolicy: Swift.String?
}

extension GetResolverRulePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

extension ImportFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainFileUrl = domainFileUrl {
            try encodeContainer.encode(domainFileUrl, forKey: .domainFileUrl)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

extension ImportFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportFirewallDomainsInput: Swift.Equatable {
    /// The fully qualified URL or URI of the file stored in Amazon Simple Storage Service (Amazon S3) that contains the list of domains to import. The file must be in an S3 bucket that's in the same Region as your DNS Firewall. The file must be a text file and must contain a single domain per line.
    /// This member is required.
    public var domainFileUrl: Swift.String?
    /// The ID of the domain list that you want to modify with the import operation.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that are listed in the file. This must be set to REPLACE, which updates the domain list to exactly match the list in the file.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainImportOperation?

    public init (
        domainFileUrl: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainImportOperation? = nil
    )
    {
        self.domainFileUrl = domainFileUrl
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct ImportFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let operation: Route53ResolverClientTypes.FirewallDomainImportOperation?
    let domainFileUrl: Swift.String?
}

extension ImportFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainFileUrl = "DomainFileUrl"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainImportOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainFileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainFileUrl)
        domainFileUrl = domainFileUrlDecoded
    }
}

extension ImportFirewallDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportFirewallDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportFirewallDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportFirewallDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct ImportFirewallDomainsOutputResponse: Swift.Equatable {
    /// The Id of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    ///
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct ImportFirewallDomainsOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let status: Route53ResolverClientTypes.FirewallDomainListStatus?
    let statusMessage: Swift.String?
}

extension ImportFirewallDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We encountered an unknown error. Try again in a few minutes.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value that you specified for NextToken in a List request isn't valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldName = output.fieldName
            self.message = output.message
        } else {
            self.fieldName = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters in this request are not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// For an InvalidParameterException error, the name of the parameter that's invalid.
    public var fieldName: Swift.String?
    /// This member is required.
    public var message: Swift.String?

    public init (
        fieldName: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.fieldName = fieldName
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let fieldName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName = "FieldName"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension InvalidPolicyDocument {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPolicyDocumentBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Resolver rule policy is invalid.
public struct InvalidPolicyDocument: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyDocumentBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyDocumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is invalid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified tag is invalid.
public struct InvalidTagException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53ResolverClientTypes.IpAddressRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request, the IP address that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints). IpAddressRequest also includes the ID of the subnet that contains the IP address.
    public struct IpAddressRequest: Swift.Equatable {
        /// The IP address that you want to use for DNS queries.
        public var ip: Swift.String?
        /// The ID of the subnet that contains the IP address.
        /// This member is required.
        public var subnetId: Swift.String?

        public init (
            ip: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.subnetId = subnetId
        }
    }

}

extension Route53ResolverClientTypes.IpAddressResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case ip = "Ip"
        case ipId = "IpId"
        case modificationTime = "ModificationTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.IpAddressStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html) request, information about the IP addresses that the Resolver endpoint uses for DNS queries.
    public struct IpAddressResponse: Swift.Equatable {
        /// The date and time that the IP address was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// One IP address that the Resolver endpoint uses for DNS queries.
        public var ip: Swift.String?
        /// The ID of one IP address.
        public var ipId: Swift.String?
        /// The date and time that the IP address was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// A status code that gives the current status of the request.
        public var status: Route53ResolverClientTypes.IpAddressStatus?
        /// A message that provides additional information about the status of the request.
        public var statusMessage: Swift.String?
        /// The ID of one subnet.
        public var subnetId: Swift.String?

        public init (
            creationTime: Swift.String? = nil,
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            status: Route53ResolverClientTypes.IpAddressStatus? = nil,
            statusMessage: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.ip = ip
            self.ipId = ipId
            self.modificationTime = modificationTime
            self.status = status
            self.statusMessage = statusMessage
            self.subnetId = subnetId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum IpAddressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attached
        case attaching
        case creating
        case deletefailedfasexpired
        case deleting
        case detaching
        case failedcreation
        case failedresourcegone
        case remapattaching
        case remapdetaching
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressStatus] {
            return [
                .attached,
                .attaching,
                .creating,
                .deletefailedfasexpired,
                .deleting,
                .detaching,
                .failedcreation,
                .failedresourcegone,
                .remapattaching,
                .remapdetaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attached: return "ATTACHED"
            case .attaching: return "ATTACHING"
            case .creating: return "CREATING"
            case .deletefailedfasexpired: return "DELETE_FAILED_FAS_EXPIRED"
            case .deleting: return "DELETING"
            case .detaching: return "DETACHING"
            case .failedcreation: return "FAILED_CREATION"
            case .failedresourcegone: return "FAILED_RESOURCE_GONE"
            case .remapattaching: return "REMAP_ATTACHING"
            case .remapdetaching: return "REMAP_DETACHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressStatus(rawValue: rawValue) ?? IpAddressStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.IpAddressUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case ipId = "IpId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let ipId = ipId {
            try encodeContainer.encode(ipId, forKey: .ipId)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipId)
        ipId = ipIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, information about an IP address to update.
    public struct IpAddressUpdate: Swift.Equatable {
        /// The new IP address.
        public var ip: Swift.String?
        /// Only when removing an IP address from a Resolver endpoint: The ID of the IP address that you want to remove. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var ipId: Swift.String?
        /// The ID of the subnet that includes the IP address that you want to update. To get this ID, use [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html).
        public var subnetId: Swift.String?

        public init (
            ip: Swift.String? = nil,
            ipId: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.ip = ip
            self.ipId = ipId
            self.subnetId = subnetId
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request caused one or more limits to be exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// For a LimitExceededException error, the type of resource that exceeded the current limit.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListFirewallConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallConfigsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfigs = output.firewallConfigs
            self.nextToken = output.nextToken
        } else {
            self.firewallConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallConfigsOutputResponse: Swift.Equatable {
    /// The configurations for the firewall behavior provided by DNS Firewall for VPCs from Amazon Virtual Private Cloud (Amazon VPC).
    public var firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallConfigs = firewallConfigs
        self.nextToken = nextToken
    }
}

struct ListFirewallConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallConfigs: [Route53ResolverClientTypes.FirewallConfig]?
}

extension ListFirewallConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfigs = "FirewallConfigs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallConfig?].self, forKey: .firewallConfigs)
        var firewallConfigsDecoded0:[Route53ResolverClientTypes.FirewallConfig]? = nil
        if let firewallConfigsContainer = firewallConfigsContainer {
            firewallConfigsDecoded0 = [Route53ResolverClientTypes.FirewallConfig]()
            for structure0 in firewallConfigsContainer {
                if let structure0 = structure0 {
                    firewallConfigsDecoded0?.append(structure0)
                }
            }
        }
        firewallConfigs = firewallConfigsDecoded0
    }
}

extension ListFirewallDomainListsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallDomainListsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallDomainListsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallDomainListsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainListsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallDomainListsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallDomainListsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallDomainListsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallDomainListsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallDomainLists = output.firewallDomainLists
            self.nextToken = output.nextToken
        } else {
            self.firewallDomainLists = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainListsOutputResponse: Swift.Equatable {
    /// A list of the domain lists that you have defined. This might be a partial list of the domain lists that you've defined. For information, see MaxResults.
    public var firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainLists = firewallDomainLists
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainListsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallDomainLists: [Route53ResolverClientTypes.FirewallDomainListMetadata]?
}

extension ListFirewallDomainListsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainLists = "FirewallDomainLists"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallDomainListsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallDomainListMetadata?].self, forKey: .firewallDomainLists)
        var firewallDomainListsDecoded0:[Route53ResolverClientTypes.FirewallDomainListMetadata]? = nil
        if let firewallDomainListsContainer = firewallDomainListsContainer {
            firewallDomainListsDecoded0 = [Route53ResolverClientTypes.FirewallDomainListMetadata]()
            for structure0 in firewallDomainListsContainer {
                if let structure0 = structure0 {
                    firewallDomainListsDecoded0?.append(structure0)
                }
            }
        }
        firewallDomainLists = firewallDomainListsDecoded0
    }
}

extension ListFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallDomainsInput: Swift.Equatable {
    /// The ID of the domain list whose domains you want to retrieve.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallDomainListId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallDomainListId = firewallDomainListId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallDomainListId = "FirewallDomainListId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallDomainsOutputResponse: Swift.Equatable {
    /// A list of the domains in the firewall domain list. This might be a partial list of the domains that you've defined in the domain list. For information, see MaxResults.
    public var domains: [Swift.String]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        domains: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListFirewallDomainsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let domains: [Swift.String]?
}

extension ListFirewallDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension ListFirewallRuleGroupAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension ListFirewallRuleGroupAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRuleGroupAssociationsInput: Swift.Equatable {
    /// The unique identifier of the firewall rule group that you want to retrieve the associations for. Leave this blank to retrieve associations for any rule group.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that are associated with a single VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting.
    public var priority: Swift.Int?
    /// The association Status setting that you want DNS Firewall to filter on for the list. If you don't specify this, then DNS Firewall returns all associations, regardless of status.
    public var status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
    /// The unique identifier of the VPC that you want to retrieve the associations for. Leave this blank to retrieve associations for any VPC.
    public var vpcId: Swift.String?

    public init (
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil,
        status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
        self.status = status
        self.vpcId = vpcId
    }
}

struct ListFirewallRuleGroupAssociationsInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let vpcId: Swift.String?
    let priority: Swift.Int?
    let status: Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRuleGroupAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
        case status = "Status"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRuleGroupAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRuleGroupAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRuleGroupAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallRuleGroupAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociations = output.firewallRuleGroupAssociations
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroupAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupAssociationsOutputResponse: Swift.Equatable {
    /// A list of your firewall rule group associations. This might be a partial list of the associations that you have defined. For information, see MaxResults.
    public var firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroupAssociations = firewallRuleGroupAssociations
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupAssociationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRuleGroupAssociations: [Route53ResolverClientTypes.FirewallRuleGroupAssociation]?
}

extension ListFirewallRuleGroupAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociations = "FirewallRuleGroupAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRuleGroupAssociation?].self, forKey: .firewallRuleGroupAssociations)
        var firewallRuleGroupAssociationsDecoded0:[Route53ResolverClientTypes.FirewallRuleGroupAssociation]? = nil
        if let firewallRuleGroupAssociationsContainer = firewallRuleGroupAssociationsContainer {
            firewallRuleGroupAssociationsDecoded0 = [Route53ResolverClientTypes.FirewallRuleGroupAssociation]()
            for structure0 in firewallRuleGroupAssociationsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupAssociationsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroupAssociations = firewallRuleGroupAssociationsDecoded0
    }
}

extension ListFirewallRuleGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFirewallRuleGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRuleGroupsInput: Swift.Equatable {
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRuleGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRuleGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRuleGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRuleGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRuleGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroups = output.firewallRuleGroups
            self.nextToken = output.nextToken
        } else {
            self.firewallRuleGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRuleGroupsOutputResponse: Swift.Equatable {
    /// A list of your firewall rule groups. This might be a partial list of the rule groups that you have defined. For information, see MaxResults.
    public var firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRuleGroups = firewallRuleGroups
        self.nextToken = nextToken
    }
}

struct ListFirewallRuleGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRuleGroups: [Route53ResolverClientTypes.FirewallRuleGroupMetadata]?
}

extension ListFirewallRuleGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroups = "FirewallRuleGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRuleGroupsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRuleGroupMetadata?].self, forKey: .firewallRuleGroups)
        var firewallRuleGroupsDecoded0:[Route53ResolverClientTypes.FirewallRuleGroupMetadata]? = nil
        if let firewallRuleGroupsContainer = firewallRuleGroupsContainer {
            firewallRuleGroupsDecoded0 = [Route53ResolverClientTypes.FirewallRuleGroupMetadata]()
            for structure0 in firewallRuleGroupsContainer {
                if let structure0 = structure0 {
                    firewallRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        firewallRuleGroups = firewallRuleGroupsDecoded0
    }
}

extension ListFirewallRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension ListFirewallRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFirewallRulesInput: Swift.Equatable {
    /// Optional additional filter for the rules to retrieve. The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. If this is specified, additional handling details are provided in the rule's BlockResponse setting.
    public var action: Route53ResolverClientTypes.Action?
    /// The unique identifier of the firewall rule group that you want to retrieve the rules for.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The maximum number of objects that you want Resolver to return for this request. If more objects are available, in the response, Resolver provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify a value for MaxResults, Resolver returns up to 100 objects.
    public var maxResults: Swift.Int?
    /// For the first call to this list request, omit this value. When you request a list of objects, Resolver returns at most the number of objects specified in MaxResults. If more objects are available for retrieval, Resolver returns a NextToken value in the response. To retrieve the next batch of objects, use the token that was returned for the prior request in your next request.
    public var nextToken: Swift.String?
    /// Optional additional filter for the rules to retrieve. The setting that determines the processing order of the rules in a rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    public var priority: Swift.Int?

    public init (
        action: Route53ResolverClientTypes.Action? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.firewallRuleGroupId = firewallRuleGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.priority = priority
    }
}

struct ListFirewallRulesInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFirewallRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case priority = "Priority"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFirewallRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFirewallRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRules = output.firewallRules
            self.nextToken = output.nextToken
        } else {
            self.firewallRules = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallRulesOutputResponse: Swift.Equatable {
    /// A list of the rules that you have defined. This might be a partial list of the firewall rules that you've defined. For information, see MaxResults.
    public var firewallRules: [Route53ResolverClientTypes.FirewallRule]?
    /// If objects are still available for retrieval, Resolver returns this token in the response. To retrieve the next batch of objects, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        firewallRules: [Route53ResolverClientTypes.FirewallRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.firewallRules = firewallRules
        self.nextToken = nextToken
    }
}

struct ListFirewallRulesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let firewallRules: [Route53ResolverClientTypes.FirewallRule]?
}

extension ListFirewallRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRules = "FirewallRules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallRulesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.FirewallRule?].self, forKey: .firewallRules)
        var firewallRulesDecoded0:[Route53ResolverClientTypes.FirewallRule]? = nil
        if let firewallRulesContainer = firewallRulesContainer {
            firewallRulesDecoded0 = [Route53ResolverClientTypes.FirewallRule]()
            for structure0 in firewallRulesContainer {
                if let structure0 = structure0 {
                    firewallRulesDecoded0?.append(structure0)
                }
            }
        }
        firewallRules = firewallRulesDecoded0
    }
}

extension ListResolverConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverConfigsInput: Swift.Equatable {
    /// The maximum number of Resolver configurations that you want to return in the response to a ListResolverConfigs request. If you don't specify a value for MaxResults, up to 100 Resolver configurations are returned.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults Resolver configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResolverConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolverConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverConfigs = output.resolverConfigs
        } else {
            self.nextToken = nil
            self.resolverConfigs = nil
        }
    }
}

public struct ListResolverConfigsOutputResponse: Swift.Equatable {
    /// If a response includes the last of the Resolver configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another ListResolverConfigs request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one ResolverConfigs element for each Resolver configuration that is associated with the current Amazon Web Services account.
    public var resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]?

    public init (
        nextToken: Swift.String? = nil,
        resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverConfigs = resolverConfigs
    }
}

struct ListResolverConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resolverConfigs: [Route53ResolverClientTypes.ResolverConfig]?
}

extension ListResolverConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverConfigs = "ResolverConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resolverConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverConfig?].self, forKey: .resolverConfigs)
        var resolverConfigsDecoded0:[Route53ResolverClientTypes.ResolverConfig]? = nil
        if let resolverConfigsContainer = resolverConfigsContainer {
            resolverConfigsDecoded0 = [Route53ResolverClientTypes.ResolverConfig]()
            for structure0 in resolverConfigsContainer {
                if let structure0 = structure0 {
                    resolverConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverConfigs = resolverConfigsDecoded0
    }
}

extension ListResolverDnssecConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverDnssecConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverDnssecConfigsInput: Swift.Equatable {
    /// An optional specification to return a subset of objects.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// Optional: An integer that specifies the maximum number of DNSSEC configuration results that you want Amazon Route 53 to return. If you don't specify a value for MaxResults, Route 53 returns up to 100 configuration per page.
    public var maxResults: Swift.Int?
    /// (Optional) If the current Amazon Web Services account has more than MaxResults DNSSEC configurations, use NextToken to get the second and subsequent pages of results. For the first ListResolverDnssecConfigs request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request.
    public var nextToken: Swift.String?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverDnssecConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverDnssecConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverDnssecConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverDnssecConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverDnssecConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverDnssecConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverDnssecConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverDnssecConfigs = output.resolverDnssecConfigs
        } else {
            self.nextToken = nil
            self.resolverDnssecConfigs = nil
        }
    }
}

public struct ListResolverDnssecConfigsOutputResponse: Swift.Equatable {
    /// If a response includes the last of the DNSSEC configurations that are associated with the current Amazon Web Services account, NextToken doesn't appear in the response. If a response doesn't include the last of the configurations, you can get more configurations by submitting another [ListResolverDnssecConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListResolverDnssecConfigs.html) request. Get the value of NextToken that Amazon Route 53 returned in the previous response and include it in NextToken in the next request.
    public var nextToken: Swift.String?
    /// An array that contains one [ResolverDnssecConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResolverDnssecConfig.html) element for each configuration for DNSSEC validation that is associated with the current Amazon Web Services account.
    public var resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]?

    public init (
        nextToken: Swift.String? = nil,
        resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolverDnssecConfigs = resolverDnssecConfigs
    }
}

struct ListResolverDnssecConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resolverDnssecConfigs: [Route53ResolverClientTypes.ResolverDnssecConfig]?
}

extension ListResolverDnssecConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverDnssecConfigs = "ResolverDnssecConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resolverDnssecConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverDnssecConfig?].self, forKey: .resolverDnssecConfigs)
        var resolverDnssecConfigsDecoded0:[Route53ResolverClientTypes.ResolverDnssecConfig]? = nil
        if let resolverDnssecConfigsContainer = resolverDnssecConfigsContainer {
            resolverDnssecConfigsDecoded0 = [Route53ResolverClientTypes.ResolverDnssecConfig]()
            for structure0 in resolverDnssecConfigsContainer {
                if let structure0 = structure0 {
                    resolverDnssecConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverDnssecConfigs = resolverDnssecConfigsDecoded0
    }
}

extension ListResolverEndpointIpAddressesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension ListResolverEndpointIpAddressesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverEndpointIpAddressesInput: Swift.Equatable {
    /// The maximum number of IP addresses that you want to return in the response to a ListResolverEndpointIpAddresses request. If you don't specify a value for MaxResults, Resolver returns up to 100 IP addresses.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpointIpAddresses request, omit this value. If the specified Resolver endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The ID of the Resolver endpoint that you want to get IP addresses for.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpointId = resolverEndpointId
    }
}

struct ListResolverEndpointIpAddressesInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListResolverEndpointIpAddressesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolverEndpointIpAddressesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverEndpointIpAddressesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverEndpointIpAddressesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverEndpointIpAddressesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverEndpointIpAddressesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAddresses = output.ipAddresses
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.ipAddresses = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListResolverEndpointIpAddressesOutputResponse: Swift.Equatable {
    /// Information about the IP addresses in your VPC that DNS queries originate from (for outbound endpoints) or that you forward DNS queries to (for inbound endpoints).
    public var ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]?
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If the specified endpoint has more than MaxResults IP addresses, you can submit another ListResolverEndpointIpAddresses request to get the next group of IP addresses. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init (
        ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipAddresses = ipAddresses
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointIpAddressesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let ipAddresses: [Route53ResolverClientTypes.IpAddressResponse]?
}

extension ListResolverEndpointIpAddressesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddresses = "IpAddresses"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let ipAddressesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.IpAddressResponse?].self, forKey: .ipAddresses)
        var ipAddressesDecoded0:[Route53ResolverClientTypes.IpAddressResponse]? = nil
        if let ipAddressesContainer = ipAddressesContainer {
            ipAddressesDecoded0 = [Route53ResolverClientTypes.IpAddressResponse]()
            for structure0 in ipAddressesContainer {
                if let structure0 = structure0 {
                    ipAddressesDecoded0?.append(structure0)
                }
            }
        }
        ipAddresses = ipAddressesDecoded0
    }
}

extension ListResolverEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverEndpointsInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver endpoints, such as all inbound Resolver endpoints. If you submit a second or subsequent ListResolverEndpoints request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver endpoints that you want to return in the response to a ListResolverEndpoints request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver endpoints.
    public var maxResults: Swift.Int?
    /// For the first ListResolverEndpoints request, omit this value. If you have more than MaxResults Resolver endpoints, you can submit another ListResolverEndpoints request to get the next group of Resolver endpoints. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverEndpointsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverEndpointsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverEndpoints = output.resolverEndpoints
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverEndpoints = nil
        }
    }
}

public struct ListResolverEndpointsOutputResponse: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults IP addresses match the specified criteria, you can submit another ListResolverEndpoint request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver endpoints that were created by using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverEndpoints = resolverEndpoints
    }
}

struct ListResolverEndpointsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverEndpoints: [Route53ResolverClientTypes.ResolverEndpoint]?
}

extension ListResolverEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverEndpoints = "ResolverEndpoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverEndpointsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverEndpoint?].self, forKey: .resolverEndpoints)
        var resolverEndpointsDecoded0:[Route53ResolverClientTypes.ResolverEndpoint]? = nil
        if let resolverEndpointsContainer = resolverEndpointsContainer {
            resolverEndpointsDecoded0 = [Route53ResolverClientTypes.ResolverEndpoint]()
            for structure0 in resolverEndpointsContainer {
                if let structure0 = structure0 {
                    resolverEndpointsDecoded0?.append(structure0)
                }
            }
        }
        resolverEndpoints = resolverEndpointsDecoded0
    }
}

extension ListResolverQueryLogConfigAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListResolverQueryLogConfigAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverQueryLogConfigAssociationsInput: Swift.Equatable {
    /// An optional specification to return a subset of query logging associations. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging associations that you want to return in the response to a ListResolverQueryLogConfigAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigAssociations request, omit this value. If there are more than MaxResults query logging associations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging associations by. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * CreationTime: The ID of the query logging association.
    ///
    /// * Error: If the value of Status is FAILED, the value of Error indicates the cause:
    ///
    /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
    ///
    ///
    /// If Status is a value other than FAILED, ERROR is null.
    ///
    /// * Id: The ID of the query logging association
    ///
    /// * ResolverQueryLogConfigId: The ID of the query logging configuration
    ///
    /// * ResourceId: The ID of the VPC that is associated with the query logging configuration
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
    ///
    /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging association.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging associations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigAssociations request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigAssociationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
    let sortBy: Swift.String?
    let sortOrder: Route53ResolverClientTypes.SortOrder?
}

extension ListResolverQueryLogConfigAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverQueryLogConfigAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverQueryLogConfigAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverQueryLogConfigAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverQueryLogConfigAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigAssociations = output.resolverQueryLogConfigAssociations
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigAssociations = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigAssociationsOutputResponse: Swift.Equatable {
    /// If there are more than MaxResults query logging associations, you can submit another ListResolverQueryLogConfigAssociations request to get the next group of associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfigAssociations element for each query logging association that matches the values that you specified for Filter.
    public var resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]?
    /// The total number of query logging associations that were created by the current account in the specified Region. This count can differ from the number of associations that are returned in a ListResolverQueryLogConfigAssociations response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging associations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigAssociations request. For the total number of associations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init (
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociations
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigAssociationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totalCount: Swift.Int
    let totalFilteredCount: Swift.Int
    let resolverQueryLogConfigAssociations: [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]?
}

extension ListResolverQueryLogConfigAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigAssociations = "ResolverQueryLogConfigAssociations"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalFilteredCount)
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverQueryLogConfigAssociation?].self, forKey: .resolverQueryLogConfigAssociations)
        var resolverQueryLogConfigAssociationsDecoded0:[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]? = nil
        if let resolverQueryLogConfigAssociationsContainer = resolverQueryLogConfigAssociationsContainer {
            resolverQueryLogConfigAssociationsDecoded0 = [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]()
            for structure0 in resolverQueryLogConfigAssociationsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigAssociations = resolverQueryLogConfigAssociationsDecoded0
    }
}

extension ListResolverQueryLogConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

extension ListResolverQueryLogConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverQueryLogConfigsInput: Swift.Equatable {
    /// An optional specification to return a subset of query logging configurations. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of query logging configurations that you want to return in the response to a ListResolverQueryLogConfigs request. If you don't specify a value for MaxResults, Resolver returns up to 100 query logging configurations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverQueryLogConfigs request, omit this value. If there are more than MaxResults query logging configurations that match the values that you specify for Filters, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The element that you want Resolver to sort query logging configurations by. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortBy, if any, as in the previous request. Valid values include the following elements:
    ///
    /// * Arn: The ARN of the query logging configuration
    ///
    /// * AssociationCount: The number of VPCs that are associated with the specified configuration
    ///
    /// * CreationTime: The date and time that Resolver returned when the configuration was created
    ///
    /// * CreatorRequestId: The value that was specified for CreatorRequestId when the configuration was created
    ///
    /// * DestinationArn: The location that logs are sent to
    ///
    /// * Id: The ID of the configuration
    ///
    /// * Name: The name of the configuration
    ///
    /// * OwnerId: The Amazon Web Services account number of the account that created the configuration
    ///
    /// * ShareStatus: Whether the configuration is shared with other Amazon Web Services accounts or shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
    ///
    /// * Status: The current status of the configuration. Valid values include the following:
    ///
    /// * CREATING: Resolver is creating the query logging configuration.
    ///
    /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
    ///
    /// * DELETING: Resolver is deleting this query logging configuration.
    ///
    /// * FAILED: Resolver either couldn't create or couldn't delete the query logging configuration. Here are two common causes:
    ///
    /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
    ///
    /// * Permissions don't allow sending logs to the destination.
    public var sortBy: Swift.String?
    /// If you specified a value for SortBy, the order that you want query logging configurations to be listed in, ASCENDING or DESCENDING. If you submit a second or subsequent ListResolverQueryLogConfigs request and specify the NextToken parameter, you must use the same value for SortOrder, if any, as in the previous request.
    public var sortOrder: Route53ResolverClientTypes.SortOrder?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: Route53ResolverClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListResolverQueryLogConfigsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
    let sortBy: Swift.String?
    let sortOrder: Route53ResolverClientTypes.SortOrder?
}

extension ListResolverQueryLogConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ListResolverQueryLogConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverQueryLogConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverQueryLogConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverQueryLogConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverQueryLogConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolverQueryLogConfigs = output.resolverQueryLogConfigs
            self.totalCount = output.totalCount
            self.totalFilteredCount = output.totalFilteredCount
        } else {
            self.nextToken = nil
            self.resolverQueryLogConfigs = nil
            self.totalCount = 0
            self.totalFilteredCount = 0
        }
    }
}

public struct ListResolverQueryLogConfigsOutputResponse: Swift.Equatable {
    /// If there are more than MaxResults query logging configurations, you can submit another ListResolverQueryLogConfigs request to get the next group of configurations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// A list that contains one ResolverQueryLogConfig element for each query logging configuration that matches the values that you specified for Filter.
    public var resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]?
    /// The total number of query logging configurations that were created by the current account in the specified Region. This count can differ from the number of query logging configurations that are returned in a ListResolverQueryLogConfigs response, depending on the values that you specify in the request.
    public var totalCount: Swift.Int
    /// The total number of query logging configurations that were created by the current account in the specified Region and that match the filters that were specified in the ListResolverQueryLogConfigs request. For the total number of query logging configurations that were created by the current account in the specified Region, see TotalCount.
    public var totalFilteredCount: Swift.Int

    public init (
        nextToken: Swift.String? = nil,
        resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]? = nil,
        totalCount: Swift.Int = 0,
        totalFilteredCount: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resolverQueryLogConfigs = resolverQueryLogConfigs
        self.totalCount = totalCount
        self.totalFilteredCount = totalFilteredCount
    }
}

struct ListResolverQueryLogConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totalCount: Swift.Int
    let totalFilteredCount: Swift.Int
    let resolverQueryLogConfigs: [Route53ResolverClientTypes.ResolverQueryLogConfig]?
}

extension ListResolverQueryLogConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resolverQueryLogConfigs = "ResolverQueryLogConfigs"
        case totalCount = "TotalCount"
        case totalFilteredCount = "TotalFilteredCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalFilteredCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalFilteredCount)
        totalFilteredCount = totalFilteredCountDecoded
        let resolverQueryLogConfigsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverQueryLogConfig?].self, forKey: .resolverQueryLogConfigs)
        var resolverQueryLogConfigsDecoded0:[Route53ResolverClientTypes.ResolverQueryLogConfig]? = nil
        if let resolverQueryLogConfigsContainer = resolverQueryLogConfigsContainer {
            resolverQueryLogConfigsDecoded0 = [Route53ResolverClientTypes.ResolverQueryLogConfig]()
            for structure0 in resolverQueryLogConfigsContainer {
                if let structure0 = structure0 {
                    resolverQueryLogConfigsDecoded0?.append(structure0)
                }
            }
        }
        resolverQueryLogConfigs = resolverQueryLogConfigsDecoded0
    }
}

extension ListResolverRuleAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverRuleAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverRuleAssociationsInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver rules, such as Resolver rules that are associated with the same VPC ID. If you submit a second or subsequent ListResolverRuleAssociations request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of rule associations that you want to return in the response to a ListResolverRuleAssociations request. If you don't specify a value for MaxResults, Resolver returns up to 100 rule associations.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRuleAssociation request, omit this value. If you have more than MaxResults rule associations, you can submit another ListResolverRuleAssociation request to get the next group of rule associations. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRuleAssociationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverRuleAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRuleAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverRuleAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverRuleAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverRuleAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverRuleAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRuleAssociations = output.resolverRuleAssociations
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRuleAssociations = nil
        }
    }
}

public struct ListResolverRuleAssociationsOutputResponse: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults rule associations match the specified criteria, you can submit another ListResolverRuleAssociation request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The associations that were created between Resolver rules and VPCs using the current Amazon Web Services account, and that match the specified filters, if any.
    public var resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRuleAssociations = resolverRuleAssociations
    }
}

struct ListResolverRuleAssociationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverRuleAssociations: [Route53ResolverClientTypes.ResolverRuleAssociation]?
}

extension ListResolverRuleAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRuleAssociations = "ResolverRuleAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRuleAssociationsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverRuleAssociation?].self, forKey: .resolverRuleAssociations)
        var resolverRuleAssociationsDecoded0:[Route53ResolverClientTypes.ResolverRuleAssociation]? = nil
        if let resolverRuleAssociationsContainer = resolverRuleAssociationsContainer {
            resolverRuleAssociationsDecoded0 = [Route53ResolverClientTypes.ResolverRuleAssociation]()
            for structure0 in resolverRuleAssociationsContainer {
                if let structure0 = structure0 {
                    resolverRuleAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resolverRuleAssociations = resolverRuleAssociationsDecoded0
    }
}

extension ListResolverRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResolverRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResolverRulesInput: Swift.Equatable {
    /// An optional specification to return a subset of Resolver rules, such as all Resolver rules that are associated with the same Resolver endpoint. If you submit a second or subsequent ListResolverRules request and specify the NextToken parameter, you must use the same values for Filters, if any, as in the previous request.
    public var filters: [Route53ResolverClientTypes.Filter]?
    /// The maximum number of Resolver rules that you want to return in the response to a ListResolverRules request. If you don't specify a value for MaxResults, Resolver returns up to 100 Resolver rules.
    public var maxResults: Swift.Int?
    /// For the first ListResolverRules request, omit this value. If you have more than MaxResults Resolver rules, you can submit another ListResolverRules request to get the next group of Resolver rules. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?

    public init (
        filters: [Route53ResolverClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolverRulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [Route53ResolverClientTypes.Filter]?
}

extension ListResolverRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Route53ResolverClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Route53ResolverClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListResolverRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolverRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolverRulesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolverRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResolverRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.resolverRules = output.resolverRules
        } else {
            self.maxResults = nil
            self.nextToken = nil
            self.resolverRules = nil
        }
    }
}

public struct ListResolverRulesOutputResponse: Swift.Equatable {
    /// The value that you specified for MaxResults in the request.
    public var maxResults: Swift.Int?
    /// If more than MaxResults Resolver rules match the specified criteria, you can submit another ListResolverRules request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Resolver rules that were created using the current Amazon Web Services account and that match the specified filters, if any.
    public var resolverRules: [Route53ResolverClientTypes.ResolverRule]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolverRules: [Route53ResolverClientTypes.ResolverRule]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolverRules = resolverRules
    }
}

struct ListResolverRulesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resolverRules: [Route53ResolverClientTypes.ResolverRule]?
}

extension ListResolverRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resolverRules = "ResolverRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resolverRulesContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.ResolverRule?].self, forKey: .resolverRules)
        var resolverRulesDecoded0:[Route53ResolverClientTypes.ResolverRule]? = nil
        if let resolverRulesContainer = resolverRulesContainer {
            resolverRulesDecoded0 = [Route53ResolverClientTypes.ResolverRule]()
            for structure0 in resolverRulesContainer {
                if let structure0 = structure0 {
                    resolverRulesDecoded0?.append(structure0)
                }
            }
        }
        resolverRules = resolverRulesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of tags that you want to return in the response to a ListTagsForResource request. If you don't specify a value for MaxResults, Resolver returns up to 100 tags.
    public var maxResults: Swift.Int?
    /// For the first ListTagsForResource request, omit this value. If you have more than MaxResults tags, you can submit another ListTagsForResource request to get the next group of tags for the resource. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the resource that you want to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// If more than MaxResults tags match the specified criteria, you can submit another ListTagsForResource request to get the next group of results. In the next request, specify the value of NextToken from the previous response.
    public var nextToken: Swift.String?
    /// The tags that are associated with the resource that you specified in the ListTagsForResource request.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Route53ResolverClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum MutationProtectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MutationProtectionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MutationProtectionStatus(rawValue: rawValue) ?? MutationProtectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutFirewallRuleGroupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let firewallRuleGroupPolicy = firewallRuleGroupPolicy {
            try encodeContainer.encode(firewallRuleGroupPolicy, forKey: .firewallRuleGroupPolicy)
        }
    }
}

extension PutFirewallRuleGroupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutFirewallRuleGroupPolicyInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) for the rule group that you want to share.
    /// This member is required.
    public var arn: Swift.String?
    /// The Identity and Access Management (Amazon Web Services IAM) policy to attach to the rule group.
    /// This member is required.
    public var firewallRuleGroupPolicy: Swift.String?

    public init (
        arn: Swift.String? = nil,
        firewallRuleGroupPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.firewallRuleGroupPolicy = firewallRuleGroupPolicy
    }
}

struct PutFirewallRuleGroupPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let firewallRuleGroupPolicy: Swift.String?
}

extension PutFirewallRuleGroupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case firewallRuleGroupPolicy = "FirewallRuleGroupPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let firewallRuleGroupPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupPolicy)
        firewallRuleGroupPolicy = firewallRuleGroupPolicyDecoded
    }
}

extension PutFirewallRuleGroupPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFirewallRuleGroupPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFirewallRuleGroupPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFirewallRuleGroupPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutFirewallRuleGroupPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

public struct PutFirewallRuleGroupPolicyOutputResponse: Swift.Equatable {
    ///
    public var returnValue: Swift.Bool

    public init (
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutFirewallRuleGroupPolicyOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutFirewallRuleGroupPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension PutResolverQueryLogConfigPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy {
            try encodeContainer.encode(resolverQueryLogConfigPolicy, forKey: .resolverQueryLogConfigPolicy)
        }
    }
}

extension PutResolverQueryLogConfigPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResolverQueryLogConfigPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the account that you want to share rules with.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the query logging configurations that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Actions section of the statement:
    ///
    /// * route53resolver:AssociateResolverQueryLogConfig
    ///
    /// * route53resolver:DisassociateResolverQueryLogConfig
    ///
    /// * route53resolver:ListResolverQueryLogConfigAssociations
    ///
    /// * route53resolver:ListResolverQueryLogConfigs
    ///
    ///
    /// In the Resource section of the statement, you specify the ARNs for the query logging configurations that you want to share with the account that you specified in Arn.
    /// This member is required.
    public var resolverQueryLogConfigPolicy: Swift.String?

    public init (
        arn: Swift.String? = nil,
        resolverQueryLogConfigPolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicy
    }
}

struct PutResolverQueryLogConfigPolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let resolverQueryLogConfigPolicy: Swift.String?
}

extension PutResolverQueryLogConfigPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverQueryLogConfigPolicy = "ResolverQueryLogConfigPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resolverQueryLogConfigPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigPolicy)
        resolverQueryLogConfigPolicy = resolverQueryLogConfigPolicyDecoded
    }
}

extension PutResolverQueryLogConfigPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResolverQueryLogConfigPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyDocument" : self = .invalidPolicyDocument(try InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResolverQueryLogConfigPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPolicyDocument(InvalidPolicyDocument)
    case invalidRequestException(InvalidRequestException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResolverQueryLogConfigPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResolverQueryLogConfigPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// The response to a PutResolverQueryLogConfigPolicy request.
public struct PutResolverQueryLogConfigPolicyOutputResponse: Swift.Equatable {
    /// Whether the PutResolverQueryLogConfigPolicy request was successful.
    public var returnValue: Swift.Bool

    public init (
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverQueryLogConfigPolicyOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutResolverQueryLogConfigPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension PutResolverRulePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let resolverRulePolicy = resolverRulePolicy {
            try encodeContainer.encode(resolverRulePolicy, forKey: .resolverRulePolicy)
        }
    }
}

extension PutResolverRulePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResolverRulePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rule that you want to share with another account.
    /// This member is required.
    public var arn: Swift.String?
    /// An Identity and Access Management policy statement that lists the rules that you want to share with another Amazon Web Services account and the operations that you want the account to be able to perform. You can specify the following operations in the Action section of the statement:
    ///
    /// * route53resolver:GetResolverRule
    ///
    /// * route53resolver:AssociateResolverRule
    ///
    /// * route53resolver:DisassociateResolverRule
    ///
    /// * route53resolver:ListResolverRules
    ///
    /// * route53resolver:ListResolverRuleAssociations
    ///
    ///
    /// In the Resource section of the statement, specify the ARN for the rule that you want to share with another account. Specify the same ARN that you specified in Arn.
    /// This member is required.
    public var resolverRulePolicy: Swift.String?

    public init (
        arn: Swift.String? = nil,
        resolverRulePolicy: Swift.String? = nil
    )
    {
        self.arn = arn
        self.resolverRulePolicy = resolverRulePolicy
    }
}

struct PutResolverRulePolicyInputBody: Swift.Equatable {
    let arn: Swift.String?
    let resolverRulePolicy: Swift.String?
}

extension PutResolverRulePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case resolverRulePolicy = "ResolverRulePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resolverRulePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRulePolicy)
        resolverRulePolicy = resolverRulePolicyDecoded
    }
}

extension PutResolverRulePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResolverRulePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyDocument" : self = .invalidPolicyDocument(try InvalidPolicyDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResolverRulePolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidPolicyDocument(InvalidPolicyDocument)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResolverRulePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutResolverRulePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = false
        }
    }
}

/// The response to a PutResolverRulePolicy request.
public struct PutResolverRulePolicyOutputResponse: Swift.Equatable {
    /// Whether the PutResolverRulePolicy request was successful.
    public var returnValue: Swift.Bool

    public init (
        returnValue: Swift.Bool = false
    )
    {
        self.returnValue = returnValue
    }
}

struct PutResolverRulePolicyOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool
}

extension PutResolverRulePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue = "ReturnValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverAutodefinedReverseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverAutodefinedReverseStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverAutodefinedReverseStatus(rawValue: rawValue) ?? ResolverAutodefinedReverseStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverse = "AutodefinedReverse"
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autodefinedReverse = autodefinedReverse {
            try encodeContainer.encode(autodefinedReverse.rawValue, forKey: .autodefinedReverse)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let autodefinedReverseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverAutodefinedReverseStatus.self, forKey: .autodefinedReverse)
        autodefinedReverse = autodefinedReverseDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a Resolver configuration for a VPC.
    public struct ResolverConfig: Swift.Equatable {
        /// The status of whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. The status can be one of following: Status of the rules generated by VPCs based on CIDR/Region for reverse DNS resolution. The status can be one of following:
        ///
        /// * ENABLING: Autodefined rules for reverse DNS lookups are being enabled but are not complete.
        ///
        /// * ENABLED: Autodefined rules for reverse DNS lookups are enabled.
        ///
        /// * DISABLING: Autodefined rules for reverse DNS lookups are being disabled but are not complete.
        ///
        /// * DISABLED: Autodefined rules for reverse DNS lookups are disabled.
        public var autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus?
        /// ID for the Resolver configuration.
        public var id: Swift.String?
        /// The owner account ID of the Amazon Virtual Private Cloud VPC.
        public var ownerId: Swift.String?
        /// The ID of the Amazon Virtual Private Cloud VPC that you're configuring Resolver for.
        public var resourceId: Swift.String?

        public init (
            autodefinedReverse: Route53ResolverClientTypes.ResolverAutodefinedReverseStatus? = nil,
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.autodefinedReverse = autodefinedReverse
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverDNSSECValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverDNSSECValidationStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverDNSSECValidationStatus(rawValue: rawValue) ?? ResolverDNSSECValidationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverDnssecConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case ownerId = "OwnerId"
        case resourceId = "ResourceId"
        case validationStatus = "ValidationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validationStatus = validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDNSSECValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension Route53ResolverClientTypes {
    /// A complex type that contains information about a configuration for DNSSEC validation.
    public struct ResolverDnssecConfig: Swift.Equatable {
        /// The ID for a configuration for DNSSEC validation.
        public var id: Swift.String?
        /// The owner account ID of the virtual private cloud (VPC) for a configuration for DNSSEC validation.
        public var ownerId: Swift.String?
        /// The ID of the virtual private cloud (VPC) that you're configuring the DNSSEC validation status for.
        public var resourceId: Swift.String?
        /// The validation status for a DNSSEC configuration. The status can be one of the following:
        ///
        /// * ENABLING: DNSSEC validation is being enabled but is not complete.
        ///
        /// * ENABLED: DNSSEC validation is enabled.
        ///
        /// * DISABLING: DNSSEC validation is being disabled but is not complete.
        ///
        /// * DISABLED DNSSEC validation is disabled.
        public var validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus?

        public init (
            id: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            validationStatus: Route53ResolverClientTypes.ResolverDNSSECValidationStatus? = nil
        )
        {
            self.id = id
            self.ownerId = ownerId
            self.resourceId = resourceId
            self.validationStatus = validationStatus
        }
    }

}

extension Route53ResolverClientTypes.ResolverEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case direction = "Direction"
        case hostVPCId = "HostVPCId"
        case id = "Id"
        case ipAddressCount = "IpAddressCount"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case securityGroupIds = "SecurityGroupIds"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let hostVPCId = hostVPCId {
            try encodeContainer.encode(hostVPCId, forKey: .hostVPCId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ipAddressCount = ipAddressCount {
            try encodeContainer.encode(ipAddressCount, forKey: .ipAddressCount)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let directionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointDirection.self, forKey: .direction)
        direction = directionDecoded
        let ipAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipAddressCount)
        ipAddressCount = ipAddressCountDecoded
        let hostVPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostVPCId)
        hostVPCId = hostVPCIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html), [DeleteResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverEndpoint.html), [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html), [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html), or [UpdateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverEndpoint.html) request, a complex type that contains settings for an existing inbound or outbound Resolver endpoint.
    public struct ResolverEndpoint: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the Resolver endpoint.
        public var arn: Swift.String?
        /// The date and time that the endpoint was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the Resolver endpoint. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// Indicates whether the Resolver endpoint allows inbound or outbound DNS queries:
        ///
        /// * INBOUND: allows DNS queries to your VPC from your network
        ///
        /// * OUTBOUND: allows DNS queries from your VPC to your network
        public var direction: Route53ResolverClientTypes.ResolverEndpointDirection?
        /// The ID of the VPC that you want to create the Resolver endpoint in.
        public var hostVPCId: Swift.String?
        /// The ID of the Resolver endpoint.
        public var id: Swift.String?
        /// The number of IP addresses that the Resolver endpoint can use for DNS queries.
        public var ipAddressCount: Swift.Int?
        /// The date and time that the endpoint was last modified, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name that you assigned to the Resolver endpoint when you submitted a [CreateResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverEndpoint.html) request.
        public var name: Swift.String?
        /// The ID of one or more security groups that control access to this VPC. The security group must include one or more inbound rules (for inbound endpoints) or outbound rules (for outbound endpoints). Inbound and outbound rules must allow TCP and UDP access. For inbound access, open port 53. For outbound access, open the port that you're using for DNS queries on your network.
        public var securityGroupIds: [Swift.String]?
        /// A code that specifies the current status of the Resolver endpoint. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating and configuring one or more Amazon VPC network interfaces for this endpoint.
        ///
        /// * OPERATIONAL: The Amazon VPC network interfaces for this endpoint are correctly configured and able to pass inbound or outbound DNS queries between your network and Resolver.
        ///
        /// * UPDATING: Resolver is associating or disassociating one or more network interfaces with this endpoint.
        ///
        /// * AUTO_RECOVERING: Resolver is trying to recover one or more of the network interfaces that are associated with this endpoint. During the recovery process, the endpoint functions with limited capacity because of the limit on the number of DNS queries per IP address (per network interface). For the current limit, see [Limits on Route 53 Resolver](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html#limits-api-entities-resolver).
        ///
        /// * ACTION_NEEDED: This endpoint is unhealthy, and Resolver can't automatically recover it. To resolve the problem, we recommend that you check each IP address that you associated with the endpoint. For each IP address that isn't available, add another IP address and then delete the IP address that isn't available. (An endpoint must always include at least two IP addresses.) A status of ACTION_NEEDED can have a variety of causes. Here are two common causes:
        ///
        /// * One or more of the network interfaces that are associated with the endpoint were deleted using Amazon VPC.
        ///
        /// * The network interface couldn't be created for some reason that's outside the control of Resolver.
        ///
        ///
        ///
        ///
        /// * DELETING: Resolver is deleting this endpoint and the associated network interfaces.
        public var status: Route53ResolverClientTypes.ResolverEndpointStatus?
        /// A detailed description of the status of the Resolver endpoint.
        public var statusMessage: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            direction: Route53ResolverClientTypes.ResolverEndpointDirection? = nil,
            hostVPCId: Swift.String? = nil,
            id: Swift.String? = nil,
            ipAddressCount: Swift.Int? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: Route53ResolverClientTypes.ResolverEndpointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.direction = direction
            self.hostVPCId = hostVPCId
            self.id = id
            self.ipAddressCount = ipAddressCount
            self.modificationTime = modificationTime
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverEndpointDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inbound
        case outbound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointDirection] {
            return [
                .inbound,
                .outbound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inbound: return "INBOUND"
            case .outbound: return "OUTBOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverEndpointDirection(rawValue: rawValue) ?? ResolverEndpointDirection.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionneeded
        case autorecovering
        case creating
        case deleting
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverEndpointStatus] {
            return [
                .actionneeded,
                .autorecovering,
                .creating,
                .deleting,
                .operational,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .autorecovering: return "AUTO_RECOVERING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverEndpointStatus(rawValue: rawValue) ?? ResolverEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverQueryLogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationCount = "AssociationCount"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case destinationArn = "DestinationArn"
        case id = "Id"
        case name = "Name"
        case ownerId = "OwnerId"
        case shareStatus = "ShareStatus"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationCount != 0 {
            try encodeContainer.encode(associationCount, forKey: .associationCount)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigStatus.self, forKey: .status)
        status = statusDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let associationCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .associationCount)
        associationCount = associationCountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to a [CreateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverQueryLogConfig.html), [DeleteResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverQueryLogConfig.html), [GetResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfig.html), or [ListResolverQueryLogConfigs](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigs.html) request, a complex type that contains settings for one query logging configuration.
    public struct ResolverQueryLogConfig: Swift.Equatable {
        /// The ARN for the query logging configuration.
        public var arn: Swift.String?
        /// The number of VPCs that are associated with the query logging configuration.
        public var associationCount: Swift.Int
        /// The date and time that the query logging configuration was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that identifies the request that created the query logging configuration. The CreatorRequestId allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// The ARN of the resource that you want Resolver to send query logs: an Amazon S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream.
        public var destinationArn: Swift.String?
        /// The ID for the query logging configuration.
        public var id: Swift.String?
        /// The name of the query logging configuration.
        public var name: Swift.String?
        /// The Amazon Web Services account ID for the account that created the query logging configuration.
        public var ownerId: Swift.String?
        /// An indication of whether the query logging configuration is shared with other Amazon Web Services accounts, or was shared with the current account by another Amazon Web Services account. Sharing is configured through Resource Access Manager (RAM).
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// The status of the specified query logging configuration. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating the query logging configuration.
        ///
        /// * CREATED: The query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging configuration.
        ///
        /// * FAILED: Resolver can't deliver logs to the location that is specified in the query logging configuration. Here are two common causes:
        ///
        /// * The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * Permissions don't allow sending logs to the destination.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus?

        public init (
            arn: Swift.String? = nil,
            associationCount: Swift.Int = 0,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigStatus? = nil
        )
        {
            self.arn = arn
            self.associationCount = associationCount
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.destinationArn = destinationArn
            self.id = id
            self.name = name
            self.ownerId = ownerId
            self.shareStatus = shareStatus
            self.status = status
        }
    }

}

extension Route53ResolverClientTypes.ResolverQueryLogConfigAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case error = "Error"
        case errorMessage = "ErrorMessage"
        case id = "Id"
        case resolverQueryLogConfigId = "ResolverQueryLogConfigId"
        case resourceId = "ResourceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resolverQueryLogConfigId = resolverQueryLogConfigId {
            try encodeContainer.encode(resolverQueryLogConfigId, forKey: .resolverQueryLogConfigId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resolverQueryLogConfigIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverQueryLogConfigId)
        resolverQueryLogConfigId = resolverQueryLogConfigIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError.self, forKey: .error)
        error = errorDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverQueryLogConfig.html), [DisassociateResolverQueryLogConfig](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverQueryLogConfig.html), [GetResolverQueryLogConfigAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverQueryLogConfigAssociation.html), or [ListResolverQueryLogConfigAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverQueryLogConfigAssociations.html), request, a complex type that contains settings for a specified association between an Amazon VPC and a query logging configuration.
    public struct ResolverQueryLogConfigAssociation: Swift.Equatable {
        /// The date and time that the VPC was associated with the query logging configuration, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// If the value of Status is FAILED, the value of Error indicates the cause:
        ///
        /// * DESTINATION_NOT_FOUND: The specified destination (for example, an Amazon S3 bucket) was deleted.
        ///
        /// * ACCESS_DENIED: Permissions don't allow sending logs to the destination.
        ///
        ///
        /// If the value of Status is a value other than FAILED, Error is null.
        public var error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError?
        /// Contains additional information about the error. If the value or Error is null, the value of ErrorMessage also is null.
        public var errorMessage: Swift.String?
        /// The ID of the query logging association.
        public var id: Swift.String?
        /// The ID of the query logging configuration that a VPC is associated with.
        public var resolverQueryLogConfigId: Swift.String?
        /// The ID of the Amazon VPC that is associated with the query logging configuration.
        public var resourceId: Swift.String?
        /// The status of the specified query logging association. Valid values include the following:
        ///
        /// * CREATING: Resolver is creating an association between an Amazon VPC and a query logging configuration.
        ///
        /// * CREATED: The association between an Amazon VPC and a query logging configuration was successfully created. Resolver is logging queries that originate in the specified VPC.
        ///
        /// * DELETING: Resolver is deleting this query logging association.
        ///
        /// * FAILED: Resolver either couldn't create or couldn't delete the query logging association.
        public var status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus?

        public init (
            creationTime: Swift.String? = nil,
            error: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationError? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            resolverQueryLogConfigId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverQueryLogConfigAssociationStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.error = error
            self.errorMessage = errorMessage
            self.id = id
            self.resolverQueryLogConfigId = resolverQueryLogConfigId
            self.resourceId = resourceId
            self.status = status
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigAssociationError: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case destinationnotfound
        case internalserviceerror
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationError] {
            return [
                .accessdenied,
                .destinationnotfound,
                .internalserviceerror,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "ACCESS_DENIED"
            case .destinationnotfound: return "DESTINATION_NOT_FOUND"
            case .internalserviceerror: return "INTERNAL_SERVICE_ERROR"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigAssociationError(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationError.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actionneeded
        case active
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigAssociationStatus] {
            return [
                .actionneeded,
                .active,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actionneeded: return "ACTION_NEEDED"
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigAssociationStatus(rawValue: rawValue) ?? ResolverQueryLogConfigAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ResolverQueryLogConfigStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverQueryLogConfigStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverQueryLogConfigStatus(rawValue: rawValue) ?? ResolverQueryLogConfigStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case creatorRequestId = "CreatorRequestId"
        case domainName = "DomainName"
        case id = "Id"
        case modificationTime = "ModificationTime"
        case name = "Name"
        case ownerId = "OwnerId"
        case resolverEndpointId = "ResolverEndpointId"
        case ruleType = "RuleType"
        case shareStatus = "ShareStatus"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modificationTime = modificationTime {
            try encodeContainer.encode(modificationTime, forKey: .modificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let ruleType = ruleType {
            try encodeContainer.encode(ruleType.rawValue, forKey: .ruleType)
        }
        if let shareStatus = shareStatus {
            try encodeContainer.encode(shareStatus.rawValue, forKey: .shareStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let ruleTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.RuleTypeOption.self, forKey: .ruleType)
        ruleType = ruleTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let shareStatusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ShareStatus.self, forKey: .shareStatus)
        shareStatus = shareStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let modificationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modificationTime)
        modificationTime = modificationTimeDecoded
    }
}

extension Route53ResolverClientTypes {
    /// For queries that originate in your VPC, detailed information about a Resolver rule, which specifies how to route DNS queries out of the VPC. The ResolverRule parameter appears in the response to a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html), [DeleteResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DeleteResolverRule.html), [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html), [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html), or [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request.
    public struct ResolverRule: Swift.Equatable {
        /// The ARN (Amazon Resource Name) for the Resolver rule specified by Id.
        public var arn: Swift.String?
        /// The date and time that the Resolver rule was created, in Unix time format and Coordinated Universal Time (UTC).
        public var creationTime: Swift.String?
        /// A unique string that you specified when you created the Resolver rule. CreatorRequestId identifies the request and allows failed requests to be retried without the risk of running the operation twice.
        public var creatorRequestId: Swift.String?
        /// DNS queries for this domain name are forwarded to the IP addresses that are specified in TargetIps. If a query matches multiple Resolver rules (example.com and www.example.com), the query is routed using the Resolver rule that contains the most specific domain name (www.example.com).
        public var domainName: Swift.String?
        /// The ID that Resolver assigned to the Resolver rule when you created it.
        public var id: Swift.String?
        /// The date and time that the Resolver rule was last updated, in Unix time format and Coordinated Universal Time (UTC).
        public var modificationTime: Swift.String?
        /// The name for the Resolver rule, which you specified when you created the Resolver rule.
        public var name: Swift.String?
        /// When a rule is shared with another Amazon Web Services account, the account ID of the account that the rule is shared with.
        public var ownerId: Swift.String?
        /// The ID of the endpoint that the rule is associated with.
        public var resolverEndpointId: Swift.String?
        /// When you want to forward DNS queries for specified domain name to resolvers on your network, specify FORWARD. When you have a forwarding rule to forward DNS queries for a domain to your network and you want Resolver to process queries for a subdomain of that domain, specify SYSTEM. For example, to forward DNS queries for example.com to resolvers on your network, you create a rule and specify FORWARD for RuleType. To then have Resolver process queries for apex.example.com, you create a rule and specify SYSTEM for RuleType. Currently, only Resolver can create rules that have a value of RECURSIVE for RuleType.
        public var ruleType: Route53ResolverClientTypes.RuleTypeOption?
        /// Whether the rule is shared and, if so, whether the current account is sharing the rule with another account, or another account is sharing the rule with the current account.
        public var shareStatus: Route53ResolverClientTypes.ShareStatus?
        /// A code that specifies the current status of the Resolver rule.
        public var status: Route53ResolverClientTypes.ResolverRuleStatus?
        /// A detailed description of the status of a Resolver rule.
        public var statusMessage: Swift.String?
        /// An array that contains the IP addresses and ports that an outbound endpoint forwards DNS queries to. Typically, these are the IP addresses of DNS resolvers on your network. Specify IPv4 addresses. IPv6 is not supported.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            creatorRequestId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            modificationTime: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            ruleType: Route53ResolverClientTypes.RuleTypeOption? = nil,
            shareStatus: Route53ResolverClientTypes.ShareStatus? = nil,
            status: Route53ResolverClientTypes.ResolverRuleStatus? = nil,
            statusMessage: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.creatorRequestId = creatorRequestId
            self.domainName = domainName
            self.id = id
            self.modificationTime = modificationTime
            self.name = name
            self.ownerId = ownerId
            self.resolverEndpointId = resolverEndpointId
            self.ruleType = ruleType
            self.shareStatus = shareStatus
            self.status = status
            self.statusMessage = statusMessage
            self.targetIps = targetIps
        }
    }

}

extension Route53ResolverClientTypes.ResolverRuleAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case resolverRuleId = "ResolverRuleId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vPCId = vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let vPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In the response to an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html), [DisassociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_DisassociateResolverRule.html), or [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html) request, provides information about an association between a Resolver rule and a VPC. The association determines which DNS queries that originate in the VPC are forwarded to your network.
    public struct ResolverRuleAssociation: Swift.Equatable {
        /// The ID of the association between a Resolver rule and a VPC. Resolver assigns this value when you submit an [AssociateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_AssociateResolverRule.html) request.
        public var id: Swift.String?
        /// The name of an association between a Resolver rule and a VPC.
        public var name: Swift.String?
        /// The ID of the Resolver rule that you associated with the VPC that is specified by VPCId.
        public var resolverRuleId: Swift.String?
        /// A code that specifies the current status of the association between a Resolver rule and a VPC.
        public var status: Route53ResolverClientTypes.ResolverRuleAssociationStatus?
        /// A detailed description of the status of the association between a Resolver rule and a VPC.
        public var statusMessage: Swift.String?
        /// The ID of the VPC that you associated the Resolver rule with.
        public var vPCId: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resolverRuleId: Swift.String? = nil,
            status: Route53ResolverClientTypes.ResolverRuleAssociationStatus? = nil,
            statusMessage: Swift.String? = nil,
            vPCId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.resolverRuleId = resolverRuleId
            self.status = status
            self.statusMessage = statusMessage
            self.vPCId = vPCId
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverRuleAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case creating
        case deleting
        case failed
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleAssociationStatus] {
            return [
                .complete,
                .creating,
                .deleting,
                .failed,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverRuleAssociationStatus(rawValue: rawValue) ?? ResolverRuleAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.ResolverRuleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
        case targetIps = "TargetIps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
        if let targetIps = targetIps {
            var targetIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIps)
            for targetlist0 in targetIps {
                try targetIpsContainer.encode(targetlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetIpsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.TargetAddress?].self, forKey: .targetIps)
        var targetIpsDecoded0:[Route53ResolverClientTypes.TargetAddress]? = nil
        if let targetIpsContainer = targetIpsContainer {
            targetIpsDecoded0 = [Route53ResolverClientTypes.TargetAddress]()
            for structure0 in targetIpsContainer {
                if let structure0 = structure0 {
                    targetIpsDecoded0?.append(structure0)
                }
            }
        }
        targetIps = targetIpsDecoded0
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In an [UpdateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_UpdateResolverRule.html) request, information about the changes that you want to make.
    public struct ResolverRuleConfig: Swift.Equatable {
        /// The new name for the Resolver rule. The name that you specify appears in the Resolver dashboard in the Route 53 console.
        public var name: Swift.String?
        /// The ID of the new outbound Resolver endpoint that you want to use to route DNS queries to the IP addresses that you specify in TargetIps.
        public var resolverEndpointId: Swift.String?
        /// For DNS queries that originate in your VPC, the new IP addresses that you want to route outbound DNS queries to.
        public var targetIps: [Route53ResolverClientTypes.TargetAddress]?

        public init (
            name: Swift.String? = nil,
            resolverEndpointId: Swift.String? = nil,
            targetIps: [Route53ResolverClientTypes.TargetAddress]? = nil
        )
        {
            self.name = name
            self.resolverEndpointId = resolverEndpointId
            self.targetIps = targetIps
        }
    }

}

extension Route53ResolverClientTypes {
    public enum ResolverRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverRuleStatus] {
            return [
                .complete,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolverRuleStatus(rawValue: rawValue) ?? ResolverRuleStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you tried to create already exists.
public struct ResourceExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// For a ResourceExistsException error, the type of resource that the error applies to.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you tried to update or delete is currently in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// For a ResourceInUseException error, the type of resource that is currently in use.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// For a ResourceNotFoundException error, the type of resource that doesn't exist.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource isn't available.
public struct ResourceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// For a ResourceUnavailableException error, the type of resource that isn't available.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum RuleTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forward
        case recursive
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleTypeOption] {
            return [
                .forward,
                .recursive,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forward: return "FORWARD"
            case .recursive: return "RECURSIVE"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleTypeOption(rawValue: rawValue) ?? RuleTypeOption.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notshared
        case sharedbyme
        case sharedwithme
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .notshared,
                .sharedbyme,
                .sharedwithme,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notshared: return "NOT_SHARED"
            case .sharedbyme: return "SHARED_BY_ME"
            case .sharedwithme: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension Route53ResolverClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Route53ResolverClientTypes {
    /// One tag that you want to add to the specified resource. A tag consists of a Key (a name for the tag) and a Value.
    public struct Tag: Swift.Equatable {
        /// The name for the tag. For example, if you want to associate Resolver resources with the account IDs of your customers for billing purposes, the value of Key might be account-id.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the tag. For example, if Key is account-id, then Value might be the ID of the customer account that you're creating the resource for.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource that you want to add tags to. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to add to the specified resource.
    /// This member is required.
    public var tags: [Route53ResolverClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Route53ResolverClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Route53ResolverClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Route53ResolverClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Route53ResolverClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Route53ResolverClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagException" : self = .invalidTagException(try InvalidTagException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case invalidTagException(InvalidTagException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension Route53ResolverClientTypes.TargetAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ip = "Ip"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ip = ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension Route53ResolverClientTypes {
    /// In a [CreateResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_CreateResolverRule.html) request, an array of the IPs that you want to forward DNS queries to.
    public struct TargetAddress: Swift.Equatable {
        /// One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses.
        /// This member is required.
        public var ip: Swift.String?
        /// The port at Ip that you want to forward DNS queries to.
        public var port: Swift.Int?

        public init (
            ip: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.ip = ip
            self.port = port
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was throttled. Try again in a few minutes.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource doesn't exist.
public struct UnknownResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource that you want to remove tags from. To get the ARN for a resource, use the applicable Get or List command:
    ///
    /// * [GetResolverEndpoint](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverEndpoint.html)
    ///
    /// * [GetResolverRule](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRule.html)
    ///
    /// * [GetResolverRuleAssociation](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_GetResolverRuleAssociation.html)
    ///
    /// * [ListResolverEndpoints](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverEndpoints.html)
    ///
    /// * [ListResolverRuleAssociations](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRuleAssociations.html)
    ///
    /// * [ListResolverRules](https://docs.aws.amazon.com/Route53/latest/APIReference/API_route53resolver_ListResolverRules.html)
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to remove to the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateFirewallConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallFailOpen = firewallFailOpen {
            try encodeContainer.encode(firewallFailOpen.rawValue, forKey: .firewallFailOpen)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension UpdateFirewallConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallConfigInput: Swift.Equatable {
    /// Determines how Route 53 Resolver handles queries during failures, for example when all traffic that is sent to DNS Firewall fails to receive a reply.
    ///
    /// * By default, fail open is disabled, which means the failure mode is closed. This approach favors security over availability. DNS Firewall blocks queries that it is unable to evaluate properly.
    ///
    /// * If you enable this option, the failure mode is open. This approach favors availability over security. DNS Firewall allows queries to proceed if it is unable to properly evaluate them.
    ///
    ///
    /// This behavior is only enforced for VPCs that have at least one DNS Firewall rule group association.
    /// This member is required.
    public var firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
    /// The ID of the VPC that the configuration is for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.firewallFailOpen = firewallFailOpen
        self.resourceId = resourceId
    }
}

struct UpdateFirewallConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let firewallFailOpen: Route53ResolverClientTypes.FirewallFailOpenStatus?
}

extension UpdateFirewallConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallFailOpen = "FirewallFailOpen"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let firewallFailOpenDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallFailOpenStatus.self, forKey: .firewallFailOpen)
        firewallFailOpen = firewallFailOpenDecoded
    }
}

extension UpdateFirewallConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFirewallConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallConfig = output.firewallConfig
        } else {
            self.firewallConfig = nil
        }
    }
}

public struct UpdateFirewallConfigOutputResponse: Swift.Equatable {
    /// Configuration of the firewall behavior provided by DNS Firewall for a single VPC.
    public var firewallConfig: Route53ResolverClientTypes.FirewallConfig?

    public init (
        firewallConfig: Route53ResolverClientTypes.FirewallConfig? = nil
    )
    {
        self.firewallConfig = firewallConfig
    }
}

struct UpdateFirewallConfigOutputResponseBody: Swift.Equatable {
    let firewallConfig: Route53ResolverClientTypes.FirewallConfig?
}

extension UpdateFirewallConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallConfig = "FirewallConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallConfig.self, forKey: .firewallConfig)
        firewallConfig = firewallConfigDecoded
    }
}

extension UpdateFirewallDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for firewalldomains0 in domains {
                try domainsContainer.encode(firewalldomains0)
            }
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
    }
}

extension UpdateFirewallDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallDomainsInput: Swift.Equatable {
    /// A list of domains to use in the update operation. Each domain specification in your domain list must satisfy the following requirements:
    ///
    /// * It can optionally start with * (asterisk).
    ///
    /// * With the exception of the optional starting asterisk, it must only contain the following characters: A-Z, a-z, 0-9, - (hyphen).
    ///
    /// * It must be from 1-255 characters in length.
    /// This member is required.
    public var domains: [Swift.String]?
    /// The ID of the domain list whose domains you want to update.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// What you want DNS Firewall to do with the domains that you are providing:
    ///
    /// * ADD - Add the domains to the ones that are already in the domain list.
    ///
    /// * REMOVE - Search the domain list for the domains and remove them from the list.
    ///
    /// * REPLACE - Update the domain list to exactly match the list that you are providing.
    /// This member is required.
    public var operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation?

    public init (
        domains: [Swift.String]? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation? = nil
    )
    {
        self.domains = domains
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

struct UpdateFirewallDomainsInputBody: Swift.Equatable {
    let firewallDomainListId: Swift.String?
    let operation: Route53ResolverClientTypes.FirewallDomainUpdateOperation?
    let domains: [Swift.String]?
}

extension UpdateFirewallDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case firewallDomainListId = "FirewallDomainListId"
        case operation = "Operation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainUpdateOperation.self, forKey: .operation)
        operation = operationDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension UpdateFirewallDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFirewallDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct UpdateFirewallDomainsOutputResponse: Swift.Equatable {
    /// The ID of the firewall domain list that DNS Firewall just updated.
    public var id: Swift.String?
    /// The name of the domain list.
    public var name: Swift.String?
    ///
    public var status: Route53ResolverClientTypes.FirewallDomainListStatus?
    /// Additional information about the status of the list, if available.
    public var statusMessage: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53ResolverClientTypes.FirewallDomainListStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct UpdateFirewallDomainsOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let status: Route53ResolverClientTypes.FirewallDomainListStatus?
    let statusMessage: Swift.String?
}

extension UpdateFirewallDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallDomainListStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension UpdateFirewallRuleGroupAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallRuleGroupAssociationId = firewallRuleGroupAssociationId {
            try encodeContainer.encode(firewallRuleGroupAssociationId, forKey: .firewallRuleGroupAssociationId)
        }
        if let mutationProtection = mutationProtection {
            try encodeContainer.encode(mutationProtection.rawValue, forKey: .mutationProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateFirewallRuleGroupAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallRuleGroupAssociationInput: Swift.Equatable {
    /// The identifier of the [FirewallRuleGroupAssociation].
    /// This member is required.
    public var firewallRuleGroupAssociationId: Swift.String?
    /// If enabled, this setting disallows modification or removal of the association, to help prevent against accidentally altering DNS firewall protections.
    public var mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    /// The name of the rule group association.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule group among the rule groups that you associate with the specified VPC. DNS Firewall filters VPC traffic starting from the rule group with the lowest numeric priority setting. You must specify a unique priority for each rule group that you associate with a single VPC. To make it easier to insert rule groups later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for a rule group association after you create it.
    public var priority: Swift.Int?

    public init (
        firewallRuleGroupAssociationId: Swift.String? = nil,
        mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.firewallRuleGroupAssociationId = firewallRuleGroupAssociationId
        self.mutationProtection = mutationProtection
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleGroupAssociationInputBody: Swift.Equatable {
    let firewallRuleGroupAssociationId: Swift.String?
    let priority: Swift.Int?
    let mutationProtection: Route53ResolverClientTypes.MutationProtectionStatus?
    let name: Swift.String?
}

extension UpdateFirewallRuleGroupAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociationId = "FirewallRuleGroupAssociationId"
        case mutationProtection = "MutationProtection"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupAssociationId)
        firewallRuleGroupAssociationId = firewallRuleGroupAssociationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let mutationProtectionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.MutationProtectionStatus.self, forKey: .mutationProtection)
        mutationProtection = mutationProtectionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleGroupAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallRuleGroupAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallRuleGroupAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallRuleGroupAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFirewallRuleGroupAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRuleGroupAssociation = output.firewallRuleGroupAssociation
        } else {
            self.firewallRuleGroupAssociation = nil
        }
    }
}

public struct UpdateFirewallRuleGroupAssociationOutputResponse: Swift.Equatable {
    /// The association that you just updated.
    public var firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?

    public init (
        firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation? = nil
    )
    {
        self.firewallRuleGroupAssociation = firewallRuleGroupAssociation
    }
}

struct UpdateFirewallRuleGroupAssociationOutputResponseBody: Swift.Equatable {
    let firewallRuleGroupAssociation: Route53ResolverClientTypes.FirewallRuleGroupAssociation?
}

extension UpdateFirewallRuleGroupAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRuleGroupAssociation = "FirewallRuleGroupAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupAssociationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRuleGroupAssociation.self, forKey: .firewallRuleGroupAssociation)
        firewallRuleGroupAssociation = firewallRuleGroupAssociationDecoded
    }
}

extension UpdateFirewallRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let blockOverrideDnsType = blockOverrideDnsType {
            try encodeContainer.encode(blockOverrideDnsType.rawValue, forKey: .blockOverrideDnsType)
        }
        if let blockOverrideDomain = blockOverrideDomain {
            try encodeContainer.encode(blockOverrideDomain, forKey: .blockOverrideDomain)
        }
        if let blockOverrideTtl = blockOverrideTtl {
            try encodeContainer.encode(blockOverrideTtl, forKey: .blockOverrideTtl)
        }
        if let blockResponse = blockResponse {
            try encodeContainer.encode(blockResponse.rawValue, forKey: .blockResponse)
        }
        if let firewallDomainListId = firewallDomainListId {
            try encodeContainer.encode(firewallDomainListId, forKey: .firewallDomainListId)
        }
        if let firewallRuleGroupId = firewallRuleGroupId {
            try encodeContainer.encode(firewallRuleGroupId, forKey: .firewallRuleGroupId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateFirewallRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFirewallRuleInput: Swift.Equatable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request to go through but send an alert to the logs.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    public var action: Route53ResolverClientTypes.Action?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    ///
    /// * NODATA - Respond indicating that the query was successful, but no response is available for it.
    ///
    /// * NXDOMAIN - Respond indicating that the domain name that's in the query doesn't exist.
    ///
    /// * OVERRIDE - Provide a custom override in the response. This option requires custom handling details in the rule's BlockOverride* settings.
    public var blockResponse: Route53ResolverClientTypes.BlockResponse?
    /// The ID of the domain list to use in the rule.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the firewall rule group for the rule.
    /// This member is required.
    public var firewallRuleGroupId: Swift.String?
    /// The name of the rule.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting. You must specify a unique priority for each rule in a rule group. To make it easier to insert rules later, leave space between the numbers, for example, use 100, 200, and so on. You can change the priority setting for the rules in a rule group at any time.
    public var priority: Swift.Int?

    public init (
        action: Route53ResolverClientTypes.Action? = nil,
        blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53ResolverClientTypes.BlockResponse? = nil,
        firewallDomainListId: Swift.String? = nil,
        firewallRuleGroupId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.firewallDomainListId = firewallDomainListId
        self.firewallRuleGroupId = firewallRuleGroupId
        self.name = name
        self.priority = priority
    }
}

struct UpdateFirewallRuleInputBody: Swift.Equatable {
    let firewallRuleGroupId: Swift.String?
    let firewallDomainListId: Swift.String?
    let priority: Swift.Int?
    let action: Route53ResolverClientTypes.Action?
    let blockResponse: Route53ResolverClientTypes.BlockResponse?
    let blockOverrideDomain: Swift.String?
    let blockOverrideDnsType: Route53ResolverClientTypes.BlockOverrideDnsType?
    let blockOverrideTtl: Swift.Int?
    let name: Swift.String?
}

extension UpdateFirewallRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case blockOverrideDnsType = "BlockOverrideDnsType"
        case blockOverrideDomain = "BlockOverrideDomain"
        case blockOverrideTtl = "BlockOverrideTtl"
        case blockResponse = "BlockResponse"
        case firewallDomainListId = "FirewallDomainListId"
        case firewallRuleGroupId = "FirewallRuleGroupId"
        case name = "Name"
        case priority = "Priority"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallRuleGroupId)
        firewallRuleGroupId = firewallRuleGroupIdDecoded
        let firewallDomainListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallDomainListId)
        firewallDomainListId = firewallDomainListIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let blockResponseDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockResponse.self, forKey: .blockResponse)
        blockResponse = blockResponseDecoded
        let blockOverrideDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockOverrideDomain)
        blockOverrideDomain = blockOverrideDomainDecoded
        let blockOverrideDnsTypeDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.BlockOverrideDnsType.self, forKey: .blockOverrideDnsType)
        blockOverrideDnsType = blockOverrideDnsTypeDecoded
        let blockOverrideTtlDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockOverrideTtl)
        blockOverrideTtl = blockOverrideTtlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFirewallRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceErrorException(InternalServiceErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFirewallRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.firewallRule = output.firewallRule
        } else {
            self.firewallRule = nil
        }
    }
}

public struct UpdateFirewallRuleOutputResponse: Swift.Equatable {
    /// The firewall rule that you just updated.
    public var firewallRule: Route53ResolverClientTypes.FirewallRule?

    public init (
        firewallRule: Route53ResolverClientTypes.FirewallRule? = nil
    )
    {
        self.firewallRule = firewallRule
    }
}

struct UpdateFirewallRuleOutputResponseBody: Swift.Equatable {
    let firewallRule: Route53ResolverClientTypes.FirewallRule?
}

extension UpdateFirewallRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firewallRule = "FirewallRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.FirewallRule.self, forKey: .firewallRule)
        firewallRule = firewallRuleDecoded
    }
}

extension UpdateResolverConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverseFlag = "AutodefinedReverseFlag"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autodefinedReverseFlag = autodefinedReverseFlag {
            try encodeContainer.encode(autodefinedReverseFlag.rawValue, forKey: .autodefinedReverseFlag)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension UpdateResolverConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverConfigInput: Swift.Equatable {
    /// Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. This is enabled by default. Disabling this option will also affect EC2-Classic instances using ClassicLink. For more information, see [ClassicLink](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html) in the Amazon EC2 guide. It can take some time for the status change to be completed.
    /// This member is required.
    public var autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag?
    /// Resource ID of the Amazon VPC that you want to update the Resolver configuration for.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.autodefinedReverseFlag = autodefinedReverseFlag
        self.resourceId = resourceId
    }
}

struct UpdateResolverConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let autodefinedReverseFlag: Route53ResolverClientTypes.AutodefinedReverseFlag?
}

extension UpdateResolverConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autodefinedReverseFlag = "AutodefinedReverseFlag"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let autodefinedReverseFlagDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.AutodefinedReverseFlag.self, forKey: .autodefinedReverseFlag)
        autodefinedReverseFlag = autodefinedReverseFlagDecoded
    }
}

extension UpdateResolverConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverConfig = output.resolverConfig
        } else {
            self.resolverConfig = nil
        }
    }
}

public struct UpdateResolverConfigOutputResponse: Swift.Equatable {
    /// An array that contains settings for the specified Resolver configuration.
    public var resolverConfig: Route53ResolverClientTypes.ResolverConfig?

    public init (
        resolverConfig: Route53ResolverClientTypes.ResolverConfig? = nil
    )
    {
        self.resolverConfig = resolverConfig
    }
}

struct UpdateResolverConfigOutputResponseBody: Swift.Equatable {
    let resolverConfig: Route53ResolverClientTypes.ResolverConfig?
}

extension UpdateResolverConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverConfig = "ResolverConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverConfig.self, forKey: .resolverConfig)
        resolverConfig = resolverConfigDecoded
    }
}

extension UpdateResolverDnssecConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let validation = validation {
            try encodeContainer.encode(validation.rawValue, forKey: .validation)
        }
    }
}

extension UpdateResolverDnssecConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverDnssecConfigInput: Swift.Equatable {
    /// The ID of the virtual private cloud (VPC) that you're updating the DNSSEC validation status for.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The new value that you are specifying for DNSSEC validation for the VPC. The value can be ENABLE or DISABLE. Be aware that it can take time for a validation status change to be completed.
    /// This member is required.
    public var validation: Route53ResolverClientTypes.Validation?

    public init (
        resourceId: Swift.String? = nil,
        validation: Route53ResolverClientTypes.Validation? = nil
    )
    {
        self.resourceId = resourceId
        self.validation = validation
    }
}

struct UpdateResolverDnssecConfigInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let validation: Route53ResolverClientTypes.Validation?
}

extension UpdateResolverDnssecConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case validation = "Validation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let validationDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.Validation.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension UpdateResolverDnssecConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverDnssecConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverDnssecConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverDnssecConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverDnssecConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverDNSSECConfig = output.resolverDNSSECConfig
        } else {
            self.resolverDNSSECConfig = nil
        }
    }
}

public struct UpdateResolverDnssecConfigOutputResponse: Swift.Equatable {
    /// A complex type that contains settings for the specified DNSSEC configuration.
    public var resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?

    public init (
        resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig? = nil
    )
    {
        self.resolverDNSSECConfig = resolverDNSSECConfig
    }
}

struct UpdateResolverDnssecConfigOutputResponseBody: Swift.Equatable {
    let resolverDNSSECConfig: Route53ResolverClientTypes.ResolverDnssecConfig?
}

extension UpdateResolverDnssecConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverDNSSECConfig = "ResolverDNSSECConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDNSSECConfigDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverDnssecConfig.self, forKey: .resolverDNSSECConfig)
        resolverDNSSECConfig = resolverDNSSECConfigDecoded
    }
}

extension UpdateResolverEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolverEndpointId = resolverEndpointId {
            try encodeContainer.encode(resolverEndpointId, forKey: .resolverEndpointId)
        }
    }
}

extension UpdateResolverEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverEndpointInput: Swift.Equatable {
    /// The name of the Resolver endpoint that you want to update.
    public var name: Swift.String?
    /// The ID of the Resolver endpoint that you want to update.
    /// This member is required.
    public var resolverEndpointId: Swift.String?

    public init (
        name: Swift.String? = nil,
        resolverEndpointId: Swift.String? = nil
    )
    {
        self.name = name
        self.resolverEndpointId = resolverEndpointId
    }
}

struct UpdateResolverEndpointInputBody: Swift.Equatable {
    let resolverEndpointId: Swift.String?
    let name: Swift.String?
}

extension UpdateResolverEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resolverEndpointId = "ResolverEndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverEndpointId)
        resolverEndpointId = resolverEndpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateResolverEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverEndpoint = output.resolverEndpoint
        } else {
            self.resolverEndpoint = nil
        }
    }
}

public struct UpdateResolverEndpointOutputResponse: Swift.Equatable {
    /// The response to an UpdateResolverEndpoint request.
    public var resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?

    public init (
        resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint? = nil
    )
    {
        self.resolverEndpoint = resolverEndpoint
    }
}

struct UpdateResolverEndpointOutputResponseBody: Swift.Equatable {
    let resolverEndpoint: Route53ResolverClientTypes.ResolverEndpoint?
}

extension UpdateResolverEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverEndpoint = "ResolverEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverEndpointDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverEndpoint.self, forKey: .resolverEndpoint)
        resolverEndpoint = resolverEndpointDecoded
    }
}

extension UpdateResolverRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let resolverRuleId = resolverRuleId {
            try encodeContainer.encode(resolverRuleId, forKey: .resolverRuleId)
        }
    }
}

extension UpdateResolverRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateResolverRuleInput: Swift.Equatable {
    /// The new settings for the Resolver rule.
    /// This member is required.
    public var config: Route53ResolverClientTypes.ResolverRuleConfig?
    /// The ID of the Resolver rule that you want to update.
    /// This member is required.
    public var resolverRuleId: Swift.String?

    public init (
        config: Route53ResolverClientTypes.ResolverRuleConfig? = nil,
        resolverRuleId: Swift.String? = nil
    )
    {
        self.config = config
        self.resolverRuleId = resolverRuleId
    }
}

struct UpdateResolverRuleInputBody: Swift.Equatable {
    let resolverRuleId: Swift.String?
    let config: Route53ResolverClientTypes.ResolverRuleConfig?
}

extension UpdateResolverRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case resolverRuleId = "ResolverRuleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolverRuleId)
        resolverRuleId = resolverRuleIdDecoded
        let configDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRuleConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension UpdateResolverRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceUnavailableException" : self = .resourceUnavailableException(try ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverRuleOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceUnavailableException(ResourceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResolverRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resolverRule = output.resolverRule
        } else {
            self.resolverRule = nil
        }
    }
}

public struct UpdateResolverRuleOutputResponse: Swift.Equatable {
    /// The response to an UpdateResolverRule request.
    public var resolverRule: Route53ResolverClientTypes.ResolverRule?

    public init (
        resolverRule: Route53ResolverClientTypes.ResolverRule? = nil
    )
    {
        self.resolverRule = resolverRule
    }
}

struct UpdateResolverRuleOutputResponseBody: Swift.Equatable {
    let resolverRule: Route53ResolverClientTypes.ResolverRule?
}

extension UpdateResolverRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolverRule = "ResolverRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverRuleDecoded = try containerValues.decodeIfPresent(Route53ResolverClientTypes.ResolverRule.self, forKey: .resolverRule)
        resolverRule = resolverRuleDecoded
    }
}

extension Route53ResolverClientTypes {
    public enum Validation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [Validation] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Validation(rawValue: rawValue) ?? Validation.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
