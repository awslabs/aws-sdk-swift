// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetAccountAuthorizationDetailsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetAccountAuthorizationDetailsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetAccountAuthorizationDetailsOutputResponse`
extension IamClient {
    public func getAccountAuthorizationDetailsPaginated(input: GetAccountAuthorizationDetailsInput) -> ClientRuntime.PaginatorSequence<GetAccountAuthorizationDetailsInput, GetAccountAuthorizationDetailsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetAccountAuthorizationDetailsInput, GetAccountAuthorizationDetailsOutputResponse>(input: input, inputKey: \GetAccountAuthorizationDetailsInput.marker, outputKey: \GetAccountAuthorizationDetailsOutputResponse.marker, paginationFunction: self.getAccountAuthorizationDetails(input:))
    }
}

extension GetAccountAuthorizationDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAccountAuthorizationDetailsInput {
        return GetAccountAuthorizationDetailsInput(
            filter: self.filter,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// Paginate over `[GetGroupOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetGroupInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetGroupOutputResponse`
extension IamClient {
    public func getGroupPaginated(input: GetGroupInput) -> ClientRuntime.PaginatorSequence<GetGroupInput, GetGroupOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetGroupInput, GetGroupOutputResponse>(input: input, inputKey: \GetGroupInput.marker, outputKey: \GetGroupOutputResponse.marker, paginationFunction: self.getGroup(input:))
    }
}

extension GetGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetGroupInput {
        return GetGroupInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getGroupPaginated`
/// to access the nested member `[IamClientTypes.User]`
/// - Returns: `[IamClientTypes.User]`
extension PaginatorSequence where Input == GetGroupInput, Output == GetGroupOutputResponse {
    func users() async throws -> [IamClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}

/// Paginate over `[ListAccessKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAccessKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAccessKeysOutputResponse`
extension IamClient {
    public func listAccessKeysPaginated(input: ListAccessKeysInput) -> ClientRuntime.PaginatorSequence<ListAccessKeysInput, ListAccessKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAccessKeysInput, ListAccessKeysOutputResponse>(input: input, inputKey: \ListAccessKeysInput.marker, outputKey: \ListAccessKeysOutputResponse.marker, paginationFunction: self.listAccessKeys(input:))
    }
}

extension ListAccessKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessKeysInput {
        return ListAccessKeysInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAccessKeysPaginated`
/// to access the nested member `[IamClientTypes.AccessKeyMetadata]`
/// - Returns: `[IamClientTypes.AccessKeyMetadata]`
extension PaginatorSequence where Input == ListAccessKeysInput, Output == ListAccessKeysOutputResponse {
    func accessKeyMetadata() async throws -> [IamClientTypes.AccessKeyMetadata] {
        return try await self.asyncCompactMap { item in item.accessKeyMetadata }
    }
}

/// Paginate over `[ListAccountAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAccountAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAccountAliasesOutputResponse`
extension IamClient {
    public func listAccountAliasesPaginated(input: ListAccountAliasesInput) -> ClientRuntime.PaginatorSequence<ListAccountAliasesInput, ListAccountAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAccountAliasesInput, ListAccountAliasesOutputResponse>(input: input, inputKey: \ListAccountAliasesInput.marker, outputKey: \ListAccountAliasesOutputResponse.marker, paginationFunction: self.listAccountAliases(input:))
    }
}

extension ListAccountAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountAliasesInput {
        return ListAccountAliasesInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAccountAliasesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListAccountAliasesInput, Output == ListAccountAliasesOutputResponse {
    func accountAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.accountAliases }
    }
}

/// Paginate over `[ListAttachedGroupPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttachedGroupPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttachedGroupPoliciesOutputResponse`
extension IamClient {
    public func listAttachedGroupPoliciesPaginated(input: ListAttachedGroupPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedGroupPoliciesInput, ListAttachedGroupPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttachedGroupPoliciesInput, ListAttachedGroupPoliciesOutputResponse>(input: input, inputKey: \ListAttachedGroupPoliciesInput.marker, outputKey: \ListAttachedGroupPoliciesOutputResponse.marker, paginationFunction: self.listAttachedGroupPolicies(input:))
    }
}

extension ListAttachedGroupPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedGroupPoliciesInput {
        return ListAttachedGroupPoliciesInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttachedGroupPoliciesPaginated`
/// to access the nested member `[IamClientTypes.AttachedPolicy]`
/// - Returns: `[IamClientTypes.AttachedPolicy]`
extension PaginatorSequence where Input == ListAttachedGroupPoliciesInput, Output == ListAttachedGroupPoliciesOutputResponse {
    func attachedPolicies() async throws -> [IamClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}

/// Paginate over `[ListAttachedRolePoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttachedRolePoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttachedRolePoliciesOutputResponse`
extension IamClient {
    public func listAttachedRolePoliciesPaginated(input: ListAttachedRolePoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedRolePoliciesInput, ListAttachedRolePoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttachedRolePoliciesInput, ListAttachedRolePoliciesOutputResponse>(input: input, inputKey: \ListAttachedRolePoliciesInput.marker, outputKey: \ListAttachedRolePoliciesOutputResponse.marker, paginationFunction: self.listAttachedRolePolicies(input:))
    }
}

extension ListAttachedRolePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedRolePoliciesInput {
        return ListAttachedRolePoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            roleName: self.roleName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttachedRolePoliciesPaginated`
/// to access the nested member `[IamClientTypes.AttachedPolicy]`
/// - Returns: `[IamClientTypes.AttachedPolicy]`
extension PaginatorSequence where Input == ListAttachedRolePoliciesInput, Output == ListAttachedRolePoliciesOutputResponse {
    func attachedPolicies() async throws -> [IamClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}

/// Paginate over `[ListAttachedUserPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttachedUserPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttachedUserPoliciesOutputResponse`
extension IamClient {
    public func listAttachedUserPoliciesPaginated(input: ListAttachedUserPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedUserPoliciesInput, ListAttachedUserPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttachedUserPoliciesInput, ListAttachedUserPoliciesOutputResponse>(input: input, inputKey: \ListAttachedUserPoliciesInput.marker, outputKey: \ListAttachedUserPoliciesOutputResponse.marker, paginationFunction: self.listAttachedUserPolicies(input:))
    }
}

extension ListAttachedUserPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedUserPoliciesInput {
        return ListAttachedUserPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttachedUserPoliciesPaginated`
/// to access the nested member `[IamClientTypes.AttachedPolicy]`
/// - Returns: `[IamClientTypes.AttachedPolicy]`
extension PaginatorSequence where Input == ListAttachedUserPoliciesInput, Output == ListAttachedUserPoliciesOutputResponse {
    func attachedPolicies() async throws -> [IamClientTypes.AttachedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedPolicies }
    }
}

/// Paginate over `[ListEntitiesForPolicyOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEntitiesForPolicyInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEntitiesForPolicyOutputResponse`
extension IamClient {
    public func listEntitiesForPolicyPaginated(input: ListEntitiesForPolicyInput) -> ClientRuntime.PaginatorSequence<ListEntitiesForPolicyInput, ListEntitiesForPolicyOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEntitiesForPolicyInput, ListEntitiesForPolicyOutputResponse>(input: input, inputKey: \ListEntitiesForPolicyInput.marker, outputKey: \ListEntitiesForPolicyOutputResponse.marker, paginationFunction: self.listEntitiesForPolicy(input:))
    }
}

extension ListEntitiesForPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntitiesForPolicyInput {
        return ListEntitiesForPolicyInput(
            entityFilter: self.entityFilter,
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix,
            policyArn: self.policyArn,
            policyUsageFilter: self.policyUsageFilter
        )}
}

/// Paginate over `[ListGroupPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGroupPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGroupPoliciesOutputResponse`
extension IamClient {
    public func listGroupPoliciesPaginated(input: ListGroupPoliciesInput) -> ClientRuntime.PaginatorSequence<ListGroupPoliciesInput, ListGroupPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupPoliciesInput, ListGroupPoliciesOutputResponse>(input: input, inputKey: \ListGroupPoliciesInput.marker, outputKey: \ListGroupPoliciesOutputResponse.marker, paginationFunction: self.listGroupPolicies(input:))
    }
}

extension ListGroupPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupPoliciesInput {
        return ListGroupPoliciesInput(
            groupName: self.groupName,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGroupPoliciesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListGroupPoliciesInput, Output == ListGroupPoliciesOutputResponse {
    func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}

/// Paginate over `[ListGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutputResponse`
extension IamClient {
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutputResponse>(input: input, inputKey: \ListGroupsInput.marker, outputKey: \ListGroupsOutputResponse.marker, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGroupsPaginated`
/// to access the nested member `[IamClientTypes.Group]`
/// - Returns: `[IamClientTypes.Group]`
extension PaginatorSequence where Input == ListGroupsInput, Output == ListGroupsOutputResponse {
    func groups() async throws -> [IamClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groups }
    }
}

/// Paginate over `[ListGroupsForUserOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGroupsForUserInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGroupsForUserOutputResponse`
extension IamClient {
    public func listGroupsForUserPaginated(input: ListGroupsForUserInput) -> ClientRuntime.PaginatorSequence<ListGroupsForUserInput, ListGroupsForUserOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGroupsForUserInput, ListGroupsForUserOutputResponse>(input: input, inputKey: \ListGroupsForUserInput.marker, outputKey: \ListGroupsForUserOutputResponse.marker, paginationFunction: self.listGroupsForUser(input:))
    }
}

extension ListGroupsForUserInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsForUserInput {
        return ListGroupsForUserInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGroupsForUserPaginated`
/// to access the nested member `[IamClientTypes.Group]`
/// - Returns: `[IamClientTypes.Group]`
extension PaginatorSequence where Input == ListGroupsForUserInput, Output == ListGroupsForUserOutputResponse {
    func groups() async throws -> [IamClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groups }
    }
}

/// Paginate over `[ListInstanceProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceProfilesOutputResponse`
extension IamClient {
    public func listInstanceProfilesPaginated(input: ListInstanceProfilesInput) -> ClientRuntime.PaginatorSequence<ListInstanceProfilesInput, ListInstanceProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceProfilesInput, ListInstanceProfilesOutputResponse>(input: input, inputKey: \ListInstanceProfilesInput.marker, outputKey: \ListInstanceProfilesOutputResponse.marker, paginationFunction: self.listInstanceProfiles(input:))
    }
}

extension ListInstanceProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceProfilesInput {
        return ListInstanceProfilesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceProfilesPaginated`
/// to access the nested member `[IamClientTypes.InstanceProfile]`
/// - Returns: `[IamClientTypes.InstanceProfile]`
extension PaginatorSequence where Input == ListInstanceProfilesInput, Output == ListInstanceProfilesOutputResponse {
    func instanceProfiles() async throws -> [IamClientTypes.InstanceProfile] {
        return try await self.asyncCompactMap { item in item.instanceProfiles }
    }
}

/// Paginate over `[ListInstanceProfilesForRoleOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInstanceProfilesForRoleInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInstanceProfilesForRoleOutputResponse`
extension IamClient {
    public func listInstanceProfilesForRolePaginated(input: ListInstanceProfilesForRoleInput) -> ClientRuntime.PaginatorSequence<ListInstanceProfilesForRoleInput, ListInstanceProfilesForRoleOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInstanceProfilesForRoleInput, ListInstanceProfilesForRoleOutputResponse>(input: input, inputKey: \ListInstanceProfilesForRoleInput.marker, outputKey: \ListInstanceProfilesForRoleOutputResponse.marker, paginationFunction: self.listInstanceProfilesForRole(input:))
    }
}

extension ListInstanceProfilesForRoleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceProfilesForRoleInput {
        return ListInstanceProfilesForRoleInput(
            marker: token,
            maxItems: self.maxItems,
            roleName: self.roleName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInstanceProfilesForRolePaginated`
/// to access the nested member `[IamClientTypes.InstanceProfile]`
/// - Returns: `[IamClientTypes.InstanceProfile]`
extension PaginatorSequence where Input == ListInstanceProfilesForRoleInput, Output == ListInstanceProfilesForRoleOutputResponse {
    func instanceProfiles() async throws -> [IamClientTypes.InstanceProfile] {
        return try await self.asyncCompactMap { item in item.instanceProfiles }
    }
}

/// Paginate over `[ListMFADevicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMFADevicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMFADevicesOutputResponse`
extension IamClient {
    public func listMFADevicesPaginated(input: ListMFADevicesInput) -> ClientRuntime.PaginatorSequence<ListMFADevicesInput, ListMFADevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMFADevicesInput, ListMFADevicesOutputResponse>(input: input, inputKey: \ListMFADevicesInput.marker, outputKey: \ListMFADevicesOutputResponse.marker, paginationFunction: self.listMFADevices(input:))
    }
}

extension ListMFADevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMFADevicesInput {
        return ListMFADevicesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMFADevicesPaginated`
/// to access the nested member `[IamClientTypes.MFADevice]`
/// - Returns: `[IamClientTypes.MFADevice]`
extension PaginatorSequence where Input == ListMFADevicesInput, Output == ListMFADevicesOutputResponse {
    func mFADevices() async throws -> [IamClientTypes.MFADevice] {
        return try await self.asyncCompactMap { item in item.mFADevices }
    }
}

/// Paginate over `[ListPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutputResponse`
extension IamClient {
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutputResponse>(input: input, inputKey: \ListPoliciesInput.marker, outputKey: \ListPoliciesOutputResponse.marker, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            onlyAttached: self.onlyAttached,
            pathPrefix: self.pathPrefix,
            policyUsageFilter: self.policyUsageFilter,
            scope: self.scope
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
/// to access the nested member `[IamClientTypes.Policy]`
/// - Returns: `[IamClientTypes.Policy]`
extension PaginatorSequence where Input == ListPoliciesInput, Output == ListPoliciesOutputResponse {
    func policies() async throws -> [IamClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}

/// Paginate over `[ListPolicyVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPolicyVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPolicyVersionsOutputResponse`
extension IamClient {
    public func listPolicyVersionsPaginated(input: ListPolicyVersionsInput) -> ClientRuntime.PaginatorSequence<ListPolicyVersionsInput, ListPolicyVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPolicyVersionsInput, ListPolicyVersionsOutputResponse>(input: input, inputKey: \ListPolicyVersionsInput.marker, outputKey: \ListPolicyVersionsOutputResponse.marker, paginationFunction: self.listPolicyVersions(input:))
    }
}

extension ListPolicyVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyVersionsInput {
        return ListPolicyVersionsInput(
            marker: token,
            maxItems: self.maxItems,
            policyArn: self.policyArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPolicyVersionsPaginated`
/// to access the nested member `[IamClientTypes.PolicyVersion]`
/// - Returns: `[IamClientTypes.PolicyVersion]`
extension PaginatorSequence where Input == ListPolicyVersionsInput, Output == ListPolicyVersionsOutputResponse {
    func versions() async throws -> [IamClientTypes.PolicyVersion] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}

/// Paginate over `[ListRolePoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRolePoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRolePoliciesOutputResponse`
extension IamClient {
    public func listRolePoliciesPaginated(input: ListRolePoliciesInput) -> ClientRuntime.PaginatorSequence<ListRolePoliciesInput, ListRolePoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRolePoliciesInput, ListRolePoliciesOutputResponse>(input: input, inputKey: \ListRolePoliciesInput.marker, outputKey: \ListRolePoliciesOutputResponse.marker, paginationFunction: self.listRolePolicies(input:))
    }
}

extension ListRolePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRolePoliciesInput {
        return ListRolePoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            roleName: self.roleName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRolePoliciesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListRolePoliciesInput, Output == ListRolePoliciesOutputResponse {
    func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}

/// Paginate over `[ListRolesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListRolesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListRolesOutputResponse`
extension IamClient {
    public func listRolesPaginated(input: ListRolesInput) -> ClientRuntime.PaginatorSequence<ListRolesInput, ListRolesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListRolesInput, ListRolesOutputResponse>(input: input, inputKey: \ListRolesInput.marker, outputKey: \ListRolesOutputResponse.marker, paginationFunction: self.listRoles(input:))
    }
}

extension ListRolesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRolesInput {
        return ListRolesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listRolesPaginated`
/// to access the nested member `[IamClientTypes.Role]`
/// - Returns: `[IamClientTypes.Role]`
extension PaginatorSequence where Input == ListRolesInput, Output == ListRolesOutputResponse {
    func roles() async throws -> [IamClientTypes.Role] {
        return try await self.asyncCompactMap { item in item.roles }
    }
}

/// Paginate over `[ListServerCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListServerCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListServerCertificatesOutputResponse`
extension IamClient {
    public func listServerCertificatesPaginated(input: ListServerCertificatesInput) -> ClientRuntime.PaginatorSequence<ListServerCertificatesInput, ListServerCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListServerCertificatesInput, ListServerCertificatesOutputResponse>(input: input, inputKey: \ListServerCertificatesInput.marker, outputKey: \ListServerCertificatesOutputResponse.marker, paginationFunction: self.listServerCertificates(input:))
    }
}

extension ListServerCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServerCertificatesInput {
        return ListServerCertificatesInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listServerCertificatesPaginated`
/// to access the nested member `[IamClientTypes.ServerCertificateMetadata]`
/// - Returns: `[IamClientTypes.ServerCertificateMetadata]`
extension PaginatorSequence where Input == ListServerCertificatesInput, Output == ListServerCertificatesOutputResponse {
    func serverCertificateMetadataList() async throws -> [IamClientTypes.ServerCertificateMetadata] {
        return try await self.asyncCompactMap { item in item.serverCertificateMetadataList }
    }
}

/// Paginate over `[ListSigningCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSigningCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSigningCertificatesOutputResponse`
extension IamClient {
    public func listSigningCertificatesPaginated(input: ListSigningCertificatesInput) -> ClientRuntime.PaginatorSequence<ListSigningCertificatesInput, ListSigningCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSigningCertificatesInput, ListSigningCertificatesOutputResponse>(input: input, inputKey: \ListSigningCertificatesInput.marker, outputKey: \ListSigningCertificatesOutputResponse.marker, paginationFunction: self.listSigningCertificates(input:))
    }
}

extension ListSigningCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSigningCertificatesInput {
        return ListSigningCertificatesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSigningCertificatesPaginated`
/// to access the nested member `[IamClientTypes.SigningCertificate]`
/// - Returns: `[IamClientTypes.SigningCertificate]`
extension PaginatorSequence where Input == ListSigningCertificatesInput, Output == ListSigningCertificatesOutputResponse {
    func certificates() async throws -> [IamClientTypes.SigningCertificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}

/// Paginate over `[ListSSHPublicKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSSHPublicKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSSHPublicKeysOutputResponse`
extension IamClient {
    public func listSSHPublicKeysPaginated(input: ListSSHPublicKeysInput) -> ClientRuntime.PaginatorSequence<ListSSHPublicKeysInput, ListSSHPublicKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSSHPublicKeysInput, ListSSHPublicKeysOutputResponse>(input: input, inputKey: \ListSSHPublicKeysInput.marker, outputKey: \ListSSHPublicKeysOutputResponse.marker, paginationFunction: self.listSSHPublicKeys(input:))
    }
}

extension ListSSHPublicKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSSHPublicKeysInput {
        return ListSSHPublicKeysInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSSHPublicKeysPaginated`
/// to access the nested member `[IamClientTypes.SSHPublicKeyMetadata]`
/// - Returns: `[IamClientTypes.SSHPublicKeyMetadata]`
extension PaginatorSequence where Input == ListSSHPublicKeysInput, Output == ListSSHPublicKeysOutputResponse {
    func sSHPublicKeys() async throws -> [IamClientTypes.SSHPublicKeyMetadata] {
        return try await self.asyncCompactMap { item in item.sSHPublicKeys }
    }
}

/// Paginate over `[ListUserPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUserPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUserPoliciesOutputResponse`
extension IamClient {
    public func listUserPoliciesPaginated(input: ListUserPoliciesInput) -> ClientRuntime.PaginatorSequence<ListUserPoliciesInput, ListUserPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserPoliciesInput, ListUserPoliciesOutputResponse>(input: input, inputKey: \ListUserPoliciesInput.marker, outputKey: \ListUserPoliciesOutputResponse.marker, paginationFunction: self.listUserPolicies(input:))
    }
}

extension ListUserPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserPoliciesInput {
        return ListUserPoliciesInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUserPoliciesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListUserPoliciesInput, Output == ListUserPoliciesOutputResponse {
    func policyNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.policyNames }
    }
}

/// Paginate over `[ListUsersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUsersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutputResponse`
extension IamClient {
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutputResponse>(input: input, inputKey: \ListUsersInput.marker, outputKey: \ListUsersOutputResponse.marker, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            marker: token,
            maxItems: self.maxItems,
            pathPrefix: self.pathPrefix
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
/// to access the nested member `[IamClientTypes.User]`
/// - Returns: `[IamClientTypes.User]`
extension PaginatorSequence where Input == ListUsersInput, Output == ListUsersOutputResponse {
    func users() async throws -> [IamClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}

/// Paginate over `[ListUserTagsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUserTagsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUserTagsOutputResponse`
extension IamClient {
    public func listUserTagsPaginated(input: ListUserTagsInput) -> ClientRuntime.PaginatorSequence<ListUserTagsInput, ListUserTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserTagsInput, ListUserTagsOutputResponse>(input: input, inputKey: \ListUserTagsInput.marker, outputKey: \ListUserTagsOutputResponse.marker, paginationFunction: self.listUserTags(input:))
    }
}

extension ListUserTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserTagsInput {
        return ListUserTagsInput(
            marker: token,
            maxItems: self.maxItems,
            userName: self.userName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUserTagsPaginated`
/// to access the nested member `[IamClientTypes.Tag]`
/// - Returns: `[IamClientTypes.Tag]`
extension PaginatorSequence where Input == ListUserTagsInput, Output == ListUserTagsOutputResponse {
    func tags() async throws -> [IamClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}

/// Paginate over `[ListVirtualMFADevicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListVirtualMFADevicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListVirtualMFADevicesOutputResponse`
extension IamClient {
    public func listVirtualMFADevicesPaginated(input: ListVirtualMFADevicesInput) -> ClientRuntime.PaginatorSequence<ListVirtualMFADevicesInput, ListVirtualMFADevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListVirtualMFADevicesInput, ListVirtualMFADevicesOutputResponse>(input: input, inputKey: \ListVirtualMFADevicesInput.marker, outputKey: \ListVirtualMFADevicesOutputResponse.marker, paginationFunction: self.listVirtualMFADevices(input:))
    }
}

extension ListVirtualMFADevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVirtualMFADevicesInput {
        return ListVirtualMFADevicesInput(
            assignmentStatus: self.assignmentStatus,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listVirtualMFADevicesPaginated`
/// to access the nested member `[IamClientTypes.VirtualMFADevice]`
/// - Returns: `[IamClientTypes.VirtualMFADevice]`
extension PaginatorSequence where Input == ListVirtualMFADevicesInput, Output == ListVirtualMFADevicesOutputResponse {
    func virtualMFADevices() async throws -> [IamClientTypes.VirtualMFADevice] {
        return try await self.asyncCompactMap { item in item.virtualMFADevices }
    }
}

/// Paginate over `[SimulateCustomPolicyOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SimulateCustomPolicyInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SimulateCustomPolicyOutputResponse`
extension IamClient {
    public func simulateCustomPolicyPaginated(input: SimulateCustomPolicyInput) -> ClientRuntime.PaginatorSequence<SimulateCustomPolicyInput, SimulateCustomPolicyOutputResponse> {
        return ClientRuntime.PaginatorSequence<SimulateCustomPolicyInput, SimulateCustomPolicyOutputResponse>(input: input, inputKey: \SimulateCustomPolicyInput.marker, outputKey: \SimulateCustomPolicyOutputResponse.marker, paginationFunction: self.simulateCustomPolicy(input:))
    }
}

extension SimulateCustomPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SimulateCustomPolicyInput {
        return SimulateCustomPolicyInput(
            actionNames: self.actionNames,
            callerArn: self.callerArn,
            contextEntries: self.contextEntries,
            marker: token,
            maxItems: self.maxItems,
            permissionsBoundaryPolicyInputList: self.permissionsBoundaryPolicyInputList,
            policyInputList: self.policyInputList,
            resourceArns: self.resourceArns,
            resourceHandlingOption: self.resourceHandlingOption,
            resourceOwner: self.resourceOwner,
            resourcePolicy: self.resourcePolicy
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `simulateCustomPolicyPaginated`
/// to access the nested member `[IamClientTypes.EvaluationResult]`
/// - Returns: `[IamClientTypes.EvaluationResult]`
extension PaginatorSequence where Input == SimulateCustomPolicyInput, Output == SimulateCustomPolicyOutputResponse {
    func evaluationResults() async throws -> [IamClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}

/// Paginate over `[SimulatePrincipalPolicyOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SimulatePrincipalPolicyInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SimulatePrincipalPolicyOutputResponse`
extension IamClient {
    public func simulatePrincipalPolicyPaginated(input: SimulatePrincipalPolicyInput) -> ClientRuntime.PaginatorSequence<SimulatePrincipalPolicyInput, SimulatePrincipalPolicyOutputResponse> {
        return ClientRuntime.PaginatorSequence<SimulatePrincipalPolicyInput, SimulatePrincipalPolicyOutputResponse>(input: input, inputKey: \SimulatePrincipalPolicyInput.marker, outputKey: \SimulatePrincipalPolicyOutputResponse.marker, paginationFunction: self.simulatePrincipalPolicy(input:))
    }
}

extension SimulatePrincipalPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SimulatePrincipalPolicyInput {
        return SimulatePrincipalPolicyInput(
            actionNames: self.actionNames,
            callerArn: self.callerArn,
            contextEntries: self.contextEntries,
            marker: token,
            maxItems: self.maxItems,
            permissionsBoundaryPolicyInputList: self.permissionsBoundaryPolicyInputList,
            policyInputList: self.policyInputList,
            policySourceArn: self.policySourceArn,
            resourceArns: self.resourceArns,
            resourceHandlingOption: self.resourceHandlingOption,
            resourceOwner: self.resourceOwner,
            resourcePolicy: self.resourcePolicy
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `simulatePrincipalPolicyPaginated`
/// to access the nested member `[IamClientTypes.EvaluationResult]`
/// - Returns: `[IamClientTypes.EvaluationResult]`
extension PaginatorSequence where Input == SimulatePrincipalPolicyInput, Output == SimulatePrincipalPolicyOutputResponse {
    func evaluationResults() async throws -> [IamClientTypes.EvaluationResult] {
        return try await self.asyncCompactMap { item in item.evaluationResults }
    }
}
