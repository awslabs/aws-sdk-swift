// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.BatchPutPropertyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = self.entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyValueEntry.self, forKey: .entry)
        entry = entryDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An error returned by the BatchPutProperty action.
    public struct BatchPutPropertyError: Swift.Equatable {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var entry: IoTTwinMakerClientTypes.PropertyValueEntry?
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init (
            entry: IoTTwinMakerClientTypes.PropertyValueEntry? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputpropertyerror0 in errors {
                try errorsContainer.encode(batchputpropertyerror0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about errors returned by the BatchPutProperty action.
    public struct BatchPutPropertyErrorEntry: Swift.Equatable {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]?

        public init (
            errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        )
        {
            self.errors = errors
        }
    }

}

extension BatchPutPropertyValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for propertyvalueentry0 in entries {
                try entriesContainer.encode(propertyvalueentry0)
            }
        }
    }
}

extension BatchPutPropertyValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties"
    }
}

public struct BatchPutPropertyValuesInput: Swift.Equatable {
    /// An object that maps strings to the property value entries to set. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
    /// The ID of the workspace that contains the properties to set.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entries: [IoTTwinMakerClientTypes.PropertyValueEntry]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entries = entries
        self.workspaceId = workspaceId
    }
}

struct BatchPutPropertyValuesInputBody: Swift.Equatable {
    let entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
}

extension BatchPutPropertyValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTTwinMakerClientTypes.PropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutPropertyValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutPropertyValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchPutPropertyValuesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutPropertyValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchPutPropertyValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutPropertyValuesOutputResponse: Swift.Equatable {
    /// Entries that caused errors in the batch put operation.
    /// This member is required.
    public var errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?

    public init (
        errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutPropertyValuesOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?
}

extension BatchPutPropertyValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IoTTwinMakerClientTypes.BundleInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingTier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleNames = bundleNames {
            var bundleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleNames)
            for bundlename0 in bundleNames {
                try bundleNamesContainer.encode(bundlename0)
            }
        }
        if let pricingTier = self.pricingTier {
            try encodeContainer.encode(pricingTier.rawValue, forKey: .pricingTier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleNames)
        var bundleNamesDecoded0:[Swift.String]? = nil
        if let bundleNamesContainer = bundleNamesContainer {
            bundleNamesDecoded0 = [Swift.String]()
            for string0 in bundleNamesContainer {
                if let string0 = string0 {
                    bundleNamesDecoded0?.append(string0)
                }
            }
        }
        bundleNames = bundleNamesDecoded0
        let pricingTierDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingTier.self, forKey: .pricingTier)
        pricingTier = pricingTierDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Information about pricing bundle.
    public struct BundleInformation: Swift.Equatable {
        /// The bundle names.
        /// This member is required.
        public var bundleNames: [Swift.String]?
        /// The pricing tier.
        public var pricingTier: IoTTwinMakerClientTypes.PricingTier?

        public init (
            bundleNames: [Swift.String]? = nil,
            pricingTier: IoTTwinMakerClientTypes.PricingTier? = nil
        )
        {
            self.bundleNames = bundleNames
            self.pricingTier = pricingTier
        }
    }

}

extension IoTTwinMakerClientTypes.ColumnDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ColumnType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// A description of the column in the query results.
    public struct ColumnDescription: Swift.Equatable {
        /// The name of the column description.
        public var name: Swift.String?
        /// The type of the column description.
        public var type: IoTTwinMakerClientTypes.ColumnType?

        public init (
            name: Swift.String? = nil,
            type: IoTTwinMakerClientTypes.ColumnType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ColumnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case node
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnType] {
            return [
                .edge,
                .node,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .node: return "NODE"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnType(rawValue: rawValue) ?? ColumnType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case propertyNames
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyGroupUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    ///
    public struct ComponentPropertyGroupRequest: Swift.Equatable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The property names.
        public var propertyNames: [Swift.String]?
        /// The update type.
        public var updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType?

        public init (
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case isInherited
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The component property group response.
    public struct ComponentPropertyGroupResponse: Swift.Equatable {
        /// The group type.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init (
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case properties
        case propertyGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyRequests0) in properties {
                try propertiesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertiesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertiesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        properties = propertiesDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupsContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a component type create or update request.
    public struct ComponentRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?

        public init (
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case definedIn
        case description
        case properties
        case propertyGroups
        case status
        case syncSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let definedIn = self.definedIn {
            try encodeContainer.encode(definedIn, forKey: .definedIn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyResponses0) in properties {
                try propertiesContainer.encode(propertyResponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, componentPropertyGroupResponses0) in propertyGroups {
                try propertyGroupsContainer.encode(componentPropertyGroupResponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncSource = self.syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let definedInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definedIn)
        definedIn = definedInDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyResponse?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]()
            for (key0, propertyresponse0) in propertiesContainer {
                if let propertyresponse0 = propertyresponse0 {
                    propertiesDecoded0?[key0] = propertyresponse0
                }
            }
        }
        properties = propertiesDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]()
            for (key0, componentpropertygroupresponse0) in propertyGroupsContainer {
                if let componentpropertygroupresponse0 = componentpropertygroupresponse0 {
                    propertyGroupsDecoded0?[key0] = componentpropertygroupresponse0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that returns information about a component type create or update request.
    public struct ComponentResponse: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]?
        /// The property groups.
        public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public var syncSource: Swift.String?

        public init (
            componentName: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil,
            propertyGroups: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            syncSource: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case componentTypeName
        case creationDateTime
        case description
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a component type.
    public struct ComponentTypeSummary: Swift.Equatable {
        /// The ARN of the component type.
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The component type name.
        public var componentTypeName: Swift.String?
        /// The date and time when the component type was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the component type.
        public var description: Swift.String?
        /// The current status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The date and time when the component type was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            componentTypeName: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case propertyGroupUpdates
        case propertyUpdates
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertyGroupUpdates = propertyGroupUpdates {
            var propertyGroupUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroupUpdates)
            for (dictKey0, componentPropertyGroupRequests0) in propertyGroupUpdates {
                try propertyGroupUpdatesContainer.encode(componentPropertyGroupRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyUpdates = propertyUpdates {
            var propertyUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyUpdates)
            for (dictKey0, propertyRequests0) in propertyUpdates {
                try propertyUpdatesContainer.encode(propertyRequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ComponentUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertyUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .propertyUpdates)
        var propertyUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertyUpdatesContainer = propertyUpdatesContainer {
            propertyUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertyUpdatesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertyUpdatesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        propertyUpdates = propertyUpdatesDecoded0
        let propertyGroupUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?].self, forKey: .propertyGroupUpdates)
        var propertyGroupUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        if let propertyGroupUpdatesContainer = propertyGroupUpdatesContainer {
            propertyGroupUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]()
            for (key0, componentpropertygrouprequest0) in propertyGroupUpdatesContainer {
                if let componentpropertygrouprequest0 = componentpropertygrouprequest0 {
                    propertyGroupUpdatesDecoded0?[key0] = componentpropertygrouprequest0
                }
            }
        }
        propertyGroupUpdates = propertyGroupUpdatesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The component update request.
    public struct ComponentUpdateRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// The property group updates.
        public var propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init (
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyGroupUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil,
            propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ComponentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentUpdateType(rawValue: rawValue) ?? ComponentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflict occurred.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConnectorFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The connector failed.
public struct ConnectorFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConnectorTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The connector timed out.
public struct ConnectorTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for componenttypeid0 in extendsFrom {
                try extendsFromContainer.encode(componenttypeid0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsRequest0) in functions {
                try functionsContainer.encode(functionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = self.isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertyDefinitionsRequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertyDefinitionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, propertyGroupsRequest0) in propertyGroups {
                try propertyGroupsContainer.encode(propertyGroupsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct CreateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// A friendly name for the component type.
    public var componentTypeName: Swift.String?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the parent component type to extend.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    ///
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// Metadata that you can use to manage the component type.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    let tags: [Swift.String:Swift.String]?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    let componentTypeName: Swift.String?
}

extension CreateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]()
            for (key0, propertygrouprequest0) in propertyGroupsContainer {
                if let propertygrouprequest0 = propertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = propertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
    }
}

extension CreateComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.state = nil
        }
    }
}

public struct CreateComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

struct CreateComponentTypeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .components)
            for (dictKey0, componentsMapRequest0) in components {
                try componentsContainer.encode(componentsMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities"
    }
}

public struct CreateEntityInput: Swift.Equatable {
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// The ID of the entity's parent entity.
    public var parentEntityId: Swift.String?
    /// Metadata that you can use to manage the entity.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.components = components
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityId = parentEntityId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateEntityInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    let parentEntityId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentRequest?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]()
            for (key0, componentrequest0) in componentsContainer {
                if let componentrequest0 = componentrequest0 {
                    componentsDecoded0?[key0] = componentrequest0
                }
            }
        }
        components = componentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEntityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.entityId = output.entityId
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.entityId = nil
            self.state = nil
        }
    }
}

public struct CreateEntityOutputResponse: Swift.Equatable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The current state of the entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.entityId = entityId
        self.state = state
    }
}

struct CreateEntityOutputResponseBody: Swift.Equatable {
    let entityId: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case entityId
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapability0 in capabilities {
                try capabilitiesContainer.encode(scenecapability0)
            }
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = self.sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes"
    }
}

public struct CreateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render itself.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The description for this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// Metadata that you can use to manage the scene.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateSceneInputBody: Swift.Equatable {
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateSceneOutputResponse: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateSceneOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateSyncJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncRole
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncRole = self.syncRole {
            try encodeContainer.encode(syncRole, forKey: .syncRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct CreateSyncJobInput: Swift.Equatable {
    /// The SyncJob IAM role. This IAM role is used by the sync job to read from the syncSource, and create, update or delete the corresponding resources.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync source. Currently the only supported syncSoucre is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The SyncJob tags.
    public var tags: [Swift.String:Swift.String]?
    /// The workspace Id.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateSyncJobInputBody: Swift.Equatable {
    let syncRole: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSyncJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case syncRole
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncRole)
        syncRole = syncRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSyncJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSyncJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSyncJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSyncJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSyncJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.state = nil
        }
    }
}

public struct CreateSyncJobOutputResponse: Swift.Equatable {
    /// The SyncJob ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time for the SyncJob creation.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

struct CreateSyncJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.SyncJobState?
}

extension CreateSyncJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct CreateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    /// This member is required.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    /// This member is required.
    public var s3Location: Swift.String?
    /// Metadata that you can use to manage the workspace
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let s3Location: Swift.String?
    let role: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateWorkspaceOutputResponse: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateWorkspaceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes.DataConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isNative
        case lambda
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isNative = self.isNative {
            try encodeContainer.encode(isNative, forKey: .isNative)
        }
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.LambdaFunction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let isNativeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNative)
        isNative = isNativeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The data connector.
    public struct DataConnector: Swift.Equatable {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public var isNative: Swift.Bool?
        /// The Lambda function associated with this data connector.
        public var lambda: IoTTwinMakerClientTypes.LambdaFunction?

        public init (
            isNative: Swift.Bool? = nil,
            lambda: IoTTwinMakerClientTypes.LambdaFunction? = nil
        )
        {
            self.isNative = isNative
            self.lambda = lambda
        }
    }

}

extension IoTTwinMakerClientTypes.DataType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case nestedType
        case relationship
        case type
        case unitOfMeasure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for datavalue0 in allowedValues {
                try allowedValuesContainer.encode(datavalue0)
            }
        }
        if let nestedType = self.nestedType {
            try encodeContainer.encode(nestedType.value, forKey: .nestedType)
        }
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship, forKey: .relationship)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let unitOfMeasure = self.unitOfMeasure {
            try encodeContainer.encode(unitOfMeasure, forKey: .unitOfMeasure)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let nestedTypeDecoded = try containerValues.decodeIfPresent(Box<IoTTwinMakerClientTypes.DataType>.self, forKey: .nestedType)
        nestedType = nestedTypeDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in allowedValuesContainer {
                if let structure0 = structure0 {
                    allowedValuesDecoded0?.append(structure0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let unitOfMeasureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitOfMeasure)
        unitOfMeasure = unitOfMeasureDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Relationship.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies the data type of a property.
    public struct DataType: Swift.Equatable {
        /// The allowed values for this data type.
        public var allowedValues: [IoTTwinMakerClientTypes.DataValue]?
        /// The nested type in the data type.
        public var nestedType: Box<IoTTwinMakerClientTypes.DataType>?
        /// A relationship that associates a component with another component.
        public var relationship: IoTTwinMakerClientTypes.Relationship?
        /// The underlying type of the data type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.ModelType?
        /// The unit of measure used in this data type.
        public var unitOfMeasure: Swift.String?

        public init (
            allowedValues: [IoTTwinMakerClientTypes.DataValue]? = nil,
            nestedType: Box<IoTTwinMakerClientTypes.DataType>? = nil,
            relationship: IoTTwinMakerClientTypes.Relationship? = nil,
            type: IoTTwinMakerClientTypes.ModelType? = nil,
            unitOfMeasure: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }
    }

}

extension IoTTwinMakerClientTypes.DataValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case expression
        case integerValue
        case listValue
        case longValue
        case mapValue
        case relationshipValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = self.booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let integerValue = self.integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let listValue = listValue {
            var listValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listValue)
            for datavalue0 in listValue {
                try listValueContainer.encode(datavalue0)
            }
        }
        if let longValue = self.longValue {
            try encodeContainer.encode(longValue, forKey: .longValue)
        }
        if let mapValue = mapValue {
            var mapValueContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mapValue)
            for (dictKey0, dataValueMap0) in mapValue {
                try mapValueContainer.encode(dataValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relationshipValue = self.relationshipValue {
            try encodeContainer.encode(relationshipValue, forKey: .relationshipValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let longValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .longValue)
        longValue = longValueDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let listValueContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .listValue)
        var listValueDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let listValueContainer = listValueContainer {
            listValueDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in listValueContainer {
                if let structure0 = structure0 {
                    listValueDecoded0?.append(structure0)
                }
            }
        }
        listValue = listValueDecoded0
        let mapValueContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.DataValue?].self, forKey: .mapValue)
        var mapValueDecoded0: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil
        if let mapValueContainer = mapValueContainer {
            mapValueDecoded0 = [Swift.String:IoTTwinMakerClientTypes.DataValue]()
            for (key0, datavalue0) in mapValueContainer {
                if let datavalue0 = datavalue0 {
                    mapValueDecoded0?[key0] = datavalue0
                }
            }
        }
        mapValue = mapValueDecoded0
        let relationshipValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.RelationshipValue.self, forKey: .relationshipValue)
        relationshipValue = relationshipValueDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a value for a property.
    public struct DataValue: Swift.Equatable {
        /// A Boolean value.
        public var booleanValue: Swift.Bool?
        /// A double value.
        public var doubleValue: Swift.Double?
        /// An expression that produces the value.
        public var expression: Swift.String?
        /// An integer value.
        public var integerValue: Swift.Int?
        /// A list of multiple values.
        public var listValue: [IoTTwinMakerClientTypes.DataValue]?
        /// A long value.
        public var longValue: Swift.Int?
        /// An object that maps strings to multiple DataValue objects.
        public var mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]?
        /// A value that relates a component to another component.
        public var relationshipValue: IoTTwinMakerClientTypes.RelationshipValue?
        /// A string value.
        public var stringValue: Swift.String?

        public init (
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            expression: Swift.String? = nil,
            integerValue: Swift.Int? = nil,
            listValue: [IoTTwinMakerClientTypes.DataValue]? = nil,
            longValue: Swift.Int? = nil,
            mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil,
            relationshipValue: IoTTwinMakerClientTypes.RelationshipValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }
    }

}

extension DeleteComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct DeleteComponentTypeInput: Swift.Equatable {
    /// The ID of the component type to delete.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct DeleteComponentTypeInputBody: Swift.Equatable {
}

extension DeleteComponentTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteComponentTypeOutputResponse: Swift.Equatable {
    /// The current state of the component type to be deleted.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteComponentTypeOutputResponseBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteEntityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let isRecursive = isRecursive {
                let isRecursiveQueryItem = ClientRuntime.URLQueryItem(name: "isRecursive".urlPercentEncoding(), value: Swift.String(isRecursive).urlPercentEncoding())
                items.append(isRecursiveQueryItem)
            }
            return items
        }
    }
}

extension DeleteEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct DeleteEntityInput: Swift.Equatable {
    /// The ID of the entity to delete.
    /// This member is required.
    public var entityId: Swift.String?
    /// A Boolean value that specifies whether the operation deletes child entities.
    public var isRecursive: Swift.Bool?
    /// The ID of the workspace that contains the entity to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        isRecursive: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.isRecursive = isRecursive
        self.workspaceId = workspaceId
    }
}

struct DeleteEntityInputBody: Swift.Equatable {
}

extension DeleteEntityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEntityOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteEntityOutputResponse: Swift.Equatable {
    /// The current state of the deleted entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteEntityOutputResponseBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct DeleteSceneInput: Swift.Equatable {
    /// The ID of the scene to delete.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct DeleteSceneInputBody: Swift.Equatable {
}

extension DeleteSceneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSceneOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct DeleteSyncJobInput: Swift.Equatable {
    /// The sync source. Currently the only supported syncSoucre is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace Id.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct DeleteSyncJobInputBody: Swift.Equatable {
}

extension DeleteSyncJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSyncJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSyncJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSyncJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSyncJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSyncJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteSyncJobOutputResponse: Swift.Equatable {
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init (
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.state = state
    }
}

struct DeleteSyncJobOutputResponseBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.SyncJobState?
}

extension DeleteSyncJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTTwinMakerClientTypes.EntityPropertyReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case entityId
        case externalIdProperty
        case propertyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let externalIdProperty = externalIdProperty {
            var externalIdPropertyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalIdProperty)
            for (dictKey0, externalIdProperty0) in externalIdProperty {
                try externalIdPropertyContainer.encode(externalIdProperty0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let externalIdPropertyContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .externalIdProperty)
        var externalIdPropertyDecoded0: [Swift.String:Swift.String]? = nil
        if let externalIdPropertyContainer = externalIdPropertyContainer {
            externalIdPropertyDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in externalIdPropertyContainer {
                if let string0 = string0 {
                    externalIdPropertyDecoded0?[key0] = string0
                }
            }
        }
        externalIdProperty = externalIdPropertyDecoded0
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that uniquely identifies an entity property.
    public struct EntityPropertyReference: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the entity.
        public var entityId: Swift.String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public var externalIdProperty: [Swift.String:Swift.String]?
        /// The name of the property.
        /// This member is required.
        public var propertyName: Swift.String?

        public init (
            componentName: Swift.String? = nil,
            entityId: Swift.String? = nil,
            externalIdProperty: [Swift.String:Swift.String]? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }
    }

}

extension IoTTwinMakerClientTypes.EntitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let hasChildEntities = self.hasChildEntities {
            try encodeContainer.encode(hasChildEntities, forKey: .hasChildEntities)
        }
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about an entity.
    public struct EntitySummary: Swift.Equatable {
        /// The ARN of the entity.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the entity was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the entity.
        public var description: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the entity.
        /// This member is required.
        public var entityName: Swift.String?
        /// A Boolean value that specifies whether the entity has child entities or not.
        public var hasChildEntities: Swift.Bool?
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The current status of the entity.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The last date and time when the entity was updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityName: Swift.String? = nil,
            hasChildEntities: Swift.Bool? = nil,
            parentEntityId: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case syncCreatingError
        case syncInitializingError
        case syncProcessingError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .syncCreatingError,
                .syncInitializingError,
                .syncProcessingError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .syncCreatingError: return "SYNC_CREATING_ERROR"
            case .syncInitializingError: return "SYNC_INITIALIZING_ERROR"
            case .syncProcessingError: return "SYNC_PROCESSING_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The error details.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTTwinMakerClientTypes.ErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init (
            code: IoTTwinMakerClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension ExecuteQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryStatement
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }
}

extension ExecuteQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/queries/execution"
    }
}

public struct ExecuteQueryInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The query statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatement = queryStatement
        self.workspaceId = workspaceId
    }
}

struct ExecuteQueryInputBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let queryStatement: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ExecuteQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryStatement
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExecuteQueryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteQueryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryTimeoutException" : self = .queryTimeoutException(try QueryTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExecuteQueryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case queryTimeoutException(QueryTimeoutException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteQueryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExecuteQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columnDescriptions = output.columnDescriptions
            self.nextToken = output.nextToken
            self.rows = output.rows
        } else {
            self.columnDescriptions = nil
            self.nextToken = nil
            self.rows = nil
        }
    }
}

public struct ExecuteQueryOutputResponse: Swift.Equatable {
    /// A list of ColumnDescription objects.
    public var columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Represents a single row in the query results.
    public var rows: [IoTTwinMakerClientTypes.Row]?

    public init (
        columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]? = nil,
        nextToken: Swift.String? = nil,
        rows: [IoTTwinMakerClientTypes.Row]? = nil
    )
    {
        self.columnDescriptions = columnDescriptions
        self.nextToken = nextToken
        self.rows = rows
    }
}

struct ExecuteQueryOutputResponseBody: Swift.Equatable {
    let columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]?
    let rows: [IoTTwinMakerClientTypes.Row]?
    let nextToken: Swift.String?
}

extension ExecuteQueryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescriptions
        case nextToken
        case rows
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDescriptionsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ColumnDescription?].self, forKey: .columnDescriptions)
        var columnDescriptionsDecoded0:[IoTTwinMakerClientTypes.ColumnDescription]? = nil
        if let columnDescriptionsContainer = columnDescriptionsContainer {
            columnDescriptionsDecoded0 = [IoTTwinMakerClientTypes.ColumnDescription]()
            for structure0 in columnDescriptionsContainer {
                if let structure0 = structure0 {
                    columnDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        columnDescriptions = columnDescriptionsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[IoTTwinMakerClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [IoTTwinMakerClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTTwinMakerClientTypes.FunctionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = self.implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for name0 in requiredProperties {
                try requiredPropertiesContainer.encode(name0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:[Swift.String]? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = [Swift.String]()
            for string0 in requiredPropertiesContainer {
                if let string0 = string0 {
                    requiredPropertiesDecoded0?.append(string0)
                }
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function request body.
    public struct FunctionRequest: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init (
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension IoTTwinMakerClientTypes.FunctionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case isInherited
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = self.implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for name0 in requiredProperties {
                try requiredPropertiesContainer.encode(name0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:[Swift.String]? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = [Swift.String]()
            for string0 in requiredPropertiesContainer {
                if let string0 = string0 {
                    requiredPropertiesDecoded0?.append(string0)
                }
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function response.
    public struct FunctionResponse: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// Indicates whether this function is inherited.
        public var isInherited: Swift.Bool?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init (
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            isInherited: Swift.Bool? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension GetComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct GetComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeInputBody: Swift.Equatable {
}

extension GetComponentTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.componentTypeName = output.componentTypeName
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.extendsFrom = output.extendsFrom
            self.functions = output.functions
            self.isAbstract = output.isAbstract
            self.isSchemaInitialized = output.isSchemaInitialized
            self.isSingleton = output.isSingleton
            self.propertyDefinitions = output.propertyDefinitions
            self.propertyGroups = output.propertyGroups
            self.status = output.status
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.componentTypeName = nil
            self.creationDateTime = nil
            self.description = nil
            self.extendsFrom = nil
            self.functions = nil
            self.isAbstract = nil
            self.isSchemaInitialized = nil
            self.isSingleton = nil
            self.propertyDefinitions = nil
            self.propertyGroups = nil
            self.status = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// The date and time when the component type was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the component type.
    public var description: Swift.String?
    /// The name of the parent component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    /// A Boolean value that specifies whether the component type is abstract.
    public var isAbstract: Swift.Bool?
    /// A Boolean value that specifies whether the component type has a schema initializer and that the schema initializer has run.
    public var isSchemaInitialized: Swift.Bool?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]?
    /// The current status of the component type.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the sync job, if this entity was created by a sync job.
    public var syncSource: Swift.String?
    /// The date and time when the component was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil,
        isAbstract: Swift.Bool? = nil,
        isSchemaInitialized: Swift.Bool? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.creationDateTime = creationDateTime
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isAbstract = isAbstract
        self.isSchemaInitialized = isSchemaInitialized
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let isSingleton: Swift.Bool?
    let componentTypeId: Swift.String?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let arn: Swift.String?
    let isAbstract: Swift.Bool?
    let isSchemaInitialized: Swift.Bool?
    let status: IoTTwinMakerClientTypes.Status?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]?
    let syncSource: Swift.String?
    let componentTypeName: Swift.String?
}

extension GetComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case componentTypeName
        case creationDateTime
        case description
        case extendsFrom
        case functions
        case isAbstract
        case isSchemaInitialized
        case isSingleton
        case propertyDefinitions
        case propertyGroups
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionResponse?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]()
            for (key0, propertydefinitionresponse0) in propertyDefinitionsContainer {
                if let propertydefinitionresponse0 = propertydefinitionresponse0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionresponse0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionResponse?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]()
            for (key0, functionresponse0) in functionsContainer {
                if let functionresponse0 = functionresponse0 {
                    functionsDecoded0?[key0] = functionresponse0
                }
            }
        }
        functions = functionsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isAbstractDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAbstract)
        isAbstract = isAbstractDecoded
        let isSchemaInitializedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSchemaInitialized)
        isSchemaInitialized = isSchemaInitializedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupResponse?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupResponse]()
            for (key0, propertygroupresponse0) in propertyGroupsContainer {
                if let propertygroupresponse0 = propertygroupresponse0 {
                    propertyGroupsDecoded0?[key0] = propertygroupresponse0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
    }
}

extension GetEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct GetEntityInput: Swift.Equatable {
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.workspaceId = workspaceId
    }
}

struct GetEntityInputBody: Swift.Equatable {
}

extension GetEntityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEntityOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.components = output.components
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.entityId = output.entityId
            self.entityName = output.entityName
            self.hasChildEntities = output.hasChildEntities
            self.parentEntityId = output.parentEntityId
            self.status = output.status
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.components = nil
            self.creationDateTime = nil
            self.description = nil
            self.entityId = nil
            self.entityName = nil
            self.hasChildEntities = nil
            self.parentEntityId = nil
            self.status = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetEntityOutputResponse: Swift.Equatable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// A Boolean value that specifies whether the entity has associated child entities.
    /// This member is required.
    public var hasChildEntities: Swift.Bool?
    /// The ID of the parent entity for this entity.
    /// This member is required.
    public var parentEntityId: Swift.String?
    /// The current status of the entity.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the sync job, if this entity was created by a sync job.
    public var syncSource: Swift.String?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        hasChildEntities: Swift.Bool? = nil,
        parentEntityId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.components = components
        self.creationDateTime = creationDateTime
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.hasChildEntities = hasChildEntities
        self.parentEntityId = parentEntityId
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetEntityOutputResponseBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let arn: Swift.String?
    let status: IoTTwinMakerClientTypes.Status?
    let workspaceId: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    let parentEntityId: Swift.String?
    let hasChildEntities: Swift.Bool?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let syncSource: Swift.String?
}

extension GetEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case components
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentResponse?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]()
            for (key0, componentresponse0) in componentsContainer {
                if let componentresponse0 = componentresponse0 {
                    componentsDecoded0?[key0] = componentresponse0
                }
            }
        }
        components = componentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension GetPricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pricingplan"
    }
}

public struct GetPricingPlanInput: Swift.Equatable {

    public init () { }
}

struct GetPricingPlanInputBody: Swift.Equatable {
}

extension GetPricingPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentPricingPlan = output.currentPricingPlan
            self.pendingPricingPlan = output.pendingPricingPlan
        } else {
            self.currentPricingPlan = nil
            self.pendingPricingPlan = nil
        }
    }
}

public struct GetPricingPlanOutputResponse: Swift.Equatable {
    /// The chosen pricing plan for the current billing cycle.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// The pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init (
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

struct GetPricingPlanOutputResponseBody: Swift.Equatable {
    let currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    let pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
}

extension GetPricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPricingPlan
        case pendingPricingPlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .currentPricingPlan)
        currentPricingPlan = currentPricingPlanDecoded
        let pendingPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .pendingPricingPlan)
        pendingPricingPlan = pendingPricingPlanDecoded
    }
}

extension GetPropertyValueHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case endDateTime
        case endTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let interpolation = self.interpolation {
            try encodeContainer.encode(interpolation, forKey: .interpolation)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderByTime = self.orderByTime {
            try encodeContainer.encode(orderByTime.rawValue, forKey: .orderByTime)
        }
        if let propertyFilters = propertyFilters {
            var propertyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyFilters)
            for propertyfilter0 in propertyFilters {
                try propertyFiltersContainer.encode(propertyfilter0)
            }
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for string0 in selectedProperties {
                try selectedPropertiesContainer.encode(string0)
            }
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

extension GetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/history"
    }
}

public struct GetPropertyValueHistoryInput: Swift.Equatable {
    /// The name of the component.
    public var componentName: Swift.String?
    /// The ID of the component type.
    public var componentTypeId: Swift.String?
    /// The date and time of the latest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use endTime instead.")
    public var endDateTime: ClientRuntime.Date?
    /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var endTime: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// An object that specifies the interpolation type and the interval over which to interpolate data.
    public var interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The time direction to use in the result order.
    public var orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    /// A list of objects that filter the property value history request.
    public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    /// A list of properties whose value histories the request retrieves.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The date and time of the earliest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use startTime instead.")
    public var startDateTime: ClientRuntime.Date?
    /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var startTime: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        endTime: Swift.String? = nil,
        entityId: Swift.String? = nil,
        interpolation: IoTTwinMakerClientTypes.InterpolationParameters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderByTime: IoTTwinMakerClientTypes.OrderByTime? = nil,
        propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil,
        selectedProperties: [Swift.String]? = nil,
        startDateTime: ClientRuntime.Date? = nil,
        startTime: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentTypeId = componentTypeId
        self.endDateTime = endDateTime
        self.endTime = endTime
        self.entityId = entityId
        self.interpolation = interpolation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderByTime = orderByTime
        self.propertyFilters = propertyFilters
        self.selectedProperties = selectedProperties
        self.startDateTime = startDateTime
        self.startTime = startTime
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueHistoryInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let componentName: Swift.String?
    let componentTypeId: Swift.String?
    let selectedProperties: [Swift.String]?
    let propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    let startTime: Swift.String?
    let endTime: Swift.String?
}

extension GetPropertyValueHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case endDateTime
        case endTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
        case startTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
        let propertyFiltersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyFilter?].self, forKey: .propertyFilters)
        var propertyFiltersDecoded0:[IoTTwinMakerClientTypes.PropertyFilter]? = nil
        if let propertyFiltersContainer = propertyFiltersContainer {
            propertyFiltersDecoded0 = [IoTTwinMakerClientTypes.PropertyFilter]()
            for structure0 in propertyFiltersContainer {
                if let structure0 = structure0 {
                    propertyFiltersDecoded0?.append(structure0)
                }
            }
        }
        propertyFilters = propertyFiltersDecoded0
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let interpolationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationParameters.self, forKey: .interpolation)
        interpolation = interpolationDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let orderByTimeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.OrderByTime.self, forKey: .orderByTime)
        orderByTime = orderByTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPropertyValueHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorFailureException" : self = .connectorFailureException(try ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorTimeoutException" : self = .connectorTimeoutException(try ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPropertyValueHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case connectorFailureException(ConnectorFailureException)
    case connectorTimeoutException(ConnectorTimeoutException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPropertyValueHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertyValues = output.propertyValues
        } else {
            self.nextToken = nil
            self.propertyValues = nil
        }
    }
}

public struct GetPropertyValueHistoryOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?

    public init (
        nextToken: Swift.String? = nil,
        propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
    }
}

struct GetPropertyValueHistoryOutputResponseBody: Swift.Equatable {
    let propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?
    let nextToken: Swift.String?
}

extension GetPropertyValueHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertyValues
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueHistory?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueHistory]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case entityId
        case maxResults
        case nextToken
        case propertyGroupName
        case selectedProperties
        case tabularConditions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = self.componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let propertyGroupName = self.propertyGroupName {
            try encodeContainer.encode(propertyGroupName, forKey: .propertyGroupName)
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for string0 in selectedProperties {
                try selectedPropertiesContainer.encode(string0)
            }
        }
        if let tabularConditions = self.tabularConditions {
            try encodeContainer.encode(tabularConditions, forKey: .tabularConditions)
        }
    }
}

extension GetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/value"
    }
}

public struct GetPropertyValueInput: Swift.Equatable {
    /// The name of the component whose property values the operation returns.
    public var componentName: Swift.String?
    /// The ID of the component type whose property values the operation returns.
    public var componentTypeId: Swift.String?
    /// The ID of the entity whose property values the operation returns.
    public var entityId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The property group name.
    public var propertyGroupName: Swift.String?
    /// The properties whose values the operation returns.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The tabular conditions.
    public var tabularConditions: IoTTwinMakerClientTypes.TabularConditions?
    /// The ID of the workspace whose values the operation returns.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyGroupName: Swift.String? = nil,
        selectedProperties: [Swift.String]? = nil,
        tabularConditions: IoTTwinMakerClientTypes.TabularConditions? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentTypeId = componentTypeId
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyGroupName = propertyGroupName
        self.selectedProperties = selectedProperties
        self.tabularConditions = tabularConditions
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let componentTypeId: Swift.String?
    let entityId: Swift.String?
    let selectedProperties: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let propertyGroupName: Swift.String?
    let tabularConditions: IoTTwinMakerClientTypes.TabularConditions?
}

extension GetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case entityId
        case maxResults
        case nextToken
        case propertyGroupName
        case selectedProperties
        case tabularConditions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let propertyGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyGroupName)
        propertyGroupName = propertyGroupNameDecoded
        let tabularConditionsDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.TabularConditions.self, forKey: .tabularConditions)
        tabularConditions = tabularConditionsDecoded
    }
}

extension GetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorFailureException" : self = .connectorFailureException(try ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorTimeoutException" : self = .connectorTimeoutException(try ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case connectorFailureException(ConnectorFailureException)
    case connectorTimeoutException(ConnectorTimeoutException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertyValues = output.propertyValues
            self.tabularPropertyValues = output.tabularPropertyValues
        } else {
            self.nextToken = nil
            self.propertyValues = nil
            self.tabularPropertyValues = nil
        }
    }
}

public struct GetPropertyValueOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the properties and latest property values in the response. Each string in the mapping must be unique to this object.
    public var propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?
    /// A table of property values.
    public var tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]?

    public init (
        nextToken: Swift.String? = nil,
        propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil,
        tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
        self.tabularPropertyValues = tabularPropertyValues
    }
}

struct GetPropertyValueOutputResponseBody: Swift.Equatable {
    let propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?
    let nextToken: Swift.String?
    let tabularPropertyValues: [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]?
}

extension GetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertyValues
        case tabularPropertyValues
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyLatestValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]()
            for (key0, propertylatestvalue0) in propertyValuesContainer {
                if let propertylatestvalue0 = propertylatestvalue0 {
                    propertyValuesDecoded0?[key0] = propertylatestvalue0
                }
            }
        }
        propertyValues = propertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tabularPropertyValuesContainer = try containerValues.decodeIfPresent([[[Swift.String: IoTTwinMakerClientTypes.DataValue?]?]?].self, forKey: .tabularPropertyValues)
        var tabularPropertyValuesDecoded0:[[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]? = nil
        if let tabularPropertyValuesContainer = tabularPropertyValuesContainer {
            tabularPropertyValuesDecoded0 = [[[Swift.String:IoTTwinMakerClientTypes.DataValue]]]()
            for list0 in tabularPropertyValuesContainer {
                var list0Decoded0: [[Swift.String: IoTTwinMakerClientTypes.DataValue]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.String: IoTTwinMakerClientTypes.DataValue]]()
                    for map1 in list0 {
                        var list0Decoded1: [Swift.String: IoTTwinMakerClientTypes.DataValue]? = nil
                        if let map1 = map1 {
                            list0Decoded1 = [Swift.String: IoTTwinMakerClientTypes.DataValue]()
                            for (key2, datavalue2) in map1 {
                                if let datavalue2 = datavalue2 {
                                    list0Decoded1?[key2] = datavalue2
                                }
                            }
                        }
                        if let list0Decoded1 = list0Decoded1 {
                            list0Decoded0?.append(list0Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    tabularPropertyValuesDecoded0?.append(list0Decoded0)
                }
            }
        }
        tabularPropertyValues = tabularPropertyValuesDecoded0
    }
}

extension GetSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct GetSceneInput: Swift.Equatable {
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct GetSceneInputBody: Swift.Equatable {
}

extension GetSceneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.capabilities = output.capabilities
            self.contentLocation = output.contentLocation
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.sceneId = output.sceneId
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.capabilities = nil
            self.contentLocation = nil
            self.creationDateTime = nil
            self.description = nil
            self.sceneId = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetSceneOutputResponse: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.creationDateTime = creationDateTime
        self.description = description
        self.sceneId = sceneId
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetSceneOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let description: Swift.String?
    let capabilities: [Swift.String]?
}

extension GetSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case capabilities
        case contentLocation
        case creationDateTime
        case description
        case sceneId
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension GetSyncJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let workspaceId = workspaceId {
                let workspaceIdQueryItem = ClientRuntime.URLQueryItem(name: "workspace".urlPercentEncoding(), value: Swift.String(workspaceId).urlPercentEncoding())
                items.append(workspaceIdQueryItem)
            }
            return items
        }
    }
}

extension GetSyncJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let syncSource = syncSource else {
            return nil
        }
        return "/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

public struct GetSyncJobInput: Swift.Equatable {
    /// The sync soucre. Currently the only supported syncSoucre is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace Id.
    public var workspaceId: Swift.String?

    public init (
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct GetSyncJobInputBody: Swift.Equatable {
}

extension GetSyncJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSyncJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSyncJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSyncJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSyncJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSyncJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.status = output.status
            self.syncRole = output.syncRole
            self.syncSource = output.syncSource
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.status = nil
            self.syncRole = nil
            self.syncSource = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetSyncJobOutputResponse: Swift.Equatable {
    /// The sync job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation date and time.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The SyncJob response status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.SyncJobStatus?
    /// The sync IAM role.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync soucre. Currently the only supported syncSoucre is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The update date and time.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.status = status
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetSyncJobOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let workspaceId: Swift.String?
    let syncSource: Swift.String?
    let syncRole: Swift.String?
    let status: IoTTwinMakerClientTypes.SyncJobStatus?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetSyncJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case status
        case syncRole
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let syncRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncRole)
        syncRole = syncRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension GetWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct GetWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceInputBody: Swift.Equatable {
}

extension GetWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.role = output.role
            self.s3Location = output.s3Location
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.role = nil
            self.s3Location = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetWorkspaceOutputResponse: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    /// This member is required.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    /// This member is required.
    public var s3Location: Swift.String?
    /// The date and time when the workspace was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let s3Location: Swift.String?
    let role: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case role
        case s3Location
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum GroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupType] {
            return [
                .tabular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupType(rawValue: rawValue) ?? GroupType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error has occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.InterpolationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolationType
        case intervalInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpolationType = self.interpolationType {
            try encodeContainer.encode(interpolationType.rawValue, forKey: .interpolationType)
        }
        if let intervalInSeconds = self.intervalInSeconds {
            try encodeContainer.encode(intervalInSeconds, forKey: .intervalInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolationTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationType.self, forKey: .interpolationType)
        interpolationType = interpolationTypeDecoded
        let intervalInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intervalInSeconds)
        intervalInSeconds = intervalInSecondsDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies how to interpolate data in a list.
    public struct InterpolationParameters: Swift.Equatable {
        /// The interpolation type.
        public var interpolationType: IoTTwinMakerClientTypes.InterpolationType?
        /// The interpolation time interval in seconds.
        public var intervalInSeconds: Swift.Int?

        public init (
            interpolationType: IoTTwinMakerClientTypes.InterpolationType? = nil,
            intervalInSeconds: Swift.Int? = nil
        )
        {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum InterpolationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [InterpolationType] {
            return [
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InterpolationType(rawValue: rawValue) ?? InterpolationType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.LambdaFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The Lambda function.
    public struct LambdaFunction: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTTwinMakerClientTypes.ListComponentTypesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extendsfrom = "extendsFrom"
        case isabstract = "isAbstract"
        case namespace
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .extendsfrom(extendsfrom):
                try container.encode(extendsfrom, forKey: .extendsfrom)
            case let .isabstract(isabstract):
                try container.encode(isabstract, forKey: .isabstract)
            case let .namespace(namespace):
                try container.encode(namespace, forKey: .namespace)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let extendsfromDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .extendsfrom)
        if let extendsfrom = extendsfromDecoded {
            self = .extendsfrom(extendsfrom)
            return
        }
        let namespaceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .namespace)
        if let namespace = namespaceDecoded {
            self = .namespace(namespace)
            return
        }
        let isabstractDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isabstract)
        if let isabstract = isabstractDecoded {
            self = .isabstract(isabstract)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of component types. Only one object is accepted as a valid input.
    public enum ListComponentTypesFilter: Swift.Equatable {
        /// The component type that the component types in the list extend.
        case extendsfrom(Swift.String)
        /// The namespace to which the component types in the list belong.
        case namespace(Swift.String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isabstract(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension ListComponentTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listcomponenttypesfilter0 in filters {
                try filtersContainer.encode(listcomponenttypesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types-list"
    }
}

public struct ListComponentTypesInput: Swift.Equatable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListComponentTypesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListComponentTypesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentTypeSummaries = output.componentTypeSummaries
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.workspaceId = output.workspaceId
        } else {
            self.componentTypeSummaries = nil
            self.maxResults = nil
            self.nextToken = nil
            self.workspaceId = nil
        }
    }
}

public struct ListComponentTypesOutputResponse: Swift.Equatable {
    /// A list of objects that contain information about the component types.
    /// This member is required.
    public var componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeSummaries = componentTypeSummaries
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeSummaries
        case maxResults
        case nextToken
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let componentTypeSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ComponentTypeSummary?].self, forKey: .componentTypeSummaries)
        var componentTypeSummariesDecoded0:[IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil
        if let componentTypeSummariesContainer = componentTypeSummariesContainer {
            componentTypeSummariesDecoded0 = [IoTTwinMakerClientTypes.ComponentTypeSummary]()
            for structure0 in componentTypeSummariesContainer {
                if let structure0 = structure0 {
                    componentTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        componentTypeSummaries = componentTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension IoTTwinMakerClientTypes.ListEntitiesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componenttypeid = "componentTypeId"
        case externalid = "externalId"
        case parententityid = "parentEntityId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .componenttypeid(componenttypeid):
                try container.encode(componenttypeid, forKey: .componenttypeid)
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .parententityid(parententityid):
                try container.encode(parententityid, forKey: .parententityid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let parententityidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .parententityid)
        if let parententityid = parententityidDecoded {
            self = .parententityid(parententityid)
            return
        }
        let componenttypeidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .componenttypeid)
        if let componenttypeid = componenttypeidDecoded {
            self = .componenttypeid(componenttypeid)
            return
        }
        let externalidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of entities.
    public enum ListEntitiesFilter: Swift.Equatable, Swift.Hashable {
        /// The parent of the entities in the list.
        case parententityid(Swift.String)
        /// The ID of the component type in the entities in the list.
        case componenttypeid(Swift.String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ListEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listentitiesfilter0 in filters {
                try filtersContainer.encode(listentitiesfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities-list"
    }
}

public struct ListEntitiesInput: Swift.Equatable {
    /// A list of objects that filter the request. Only one object is accepted as a valid input.
    public var filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListEntitiesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListEntitiesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListEntitiesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitySummaries = output.entitySummaries
            self.nextToken = output.nextToken
        } else {
            self.entitySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutputResponse: Swift.Equatable {
    /// A list of objects that contain information about the entities.
    public var entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init (
        entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaries = entitySummaries
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputResponseBody: Swift.Equatable {
    let entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    let nextToken: Swift.String?
}

extension ListEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.EntitySummary?].self, forKey: .entitySummaries)
        var entitySummariesDecoded0:[IoTTwinMakerClientTypes.EntitySummary]? = nil
        if let entitySummariesContainer = entitySummariesContainer {
            entitySummariesDecoded0 = [IoTTwinMakerClientTypes.EntitySummary]()
            for structure0 in entitySummariesContainer {
                if let structure0 = structure0 {
                    entitySummariesDecoded0?.append(structure0)
                }
            }
        }
        entitySummaries = entitySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScenesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListScenesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes-list"
    }
}

public struct ListScenesInput: Swift.Equatable {
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the scenes.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListScenesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListScenesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScenesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScenesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListScenesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScenesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListScenesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sceneSummaries = output.sceneSummaries
        } else {
            self.nextToken = nil
            self.sceneSummaries = nil
        }
    }
}

public struct ListScenesOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the scenes.
    public var sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?

    public init (
        nextToken: Swift.String? = nil,
        sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sceneSummaries = sceneSummaries
    }
}

struct ListScenesOutputResponseBody: Swift.Equatable {
    let sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?
    let nextToken: Swift.String?
}

extension ListScenesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sceneSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SceneSummary?].self, forKey: .sceneSummaries)
        var sceneSummariesDecoded0:[IoTTwinMakerClientTypes.SceneSummary]? = nil
        if let sceneSummariesContainer = sceneSummariesContainer {
            sceneSummariesDecoded0 = [IoTTwinMakerClientTypes.SceneSummary]()
            for structure0 in sceneSummariesContainer {
                if let structure0 = structure0 {
                    sceneSummariesDecoded0?.append(structure0)
                }
            }
        }
        sceneSummaries = sceneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSyncJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs-list"
    }
}

public struct ListSyncJobsInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListSyncJobsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSyncJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSyncJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSyncJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSyncJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSyncJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncJobSummaries = output.syncJobSummaries
        } else {
            self.nextToken = nil
            self.syncJobSummaries = nil
        }
    }
}

public struct ListSyncJobsOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The listed SyncJob summaries.
    public var syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]?

    public init (
        nextToken: Swift.String? = nil,
        syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncJobSummaries = syncJobSummaries
    }
}

struct ListSyncJobsOutputResponseBody: Swift.Equatable {
    let syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]?
    let nextToken: Swift.String?
}

extension ListSyncJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncJobSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncJobSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncJobSummary?].self, forKey: .syncJobSummaries)
        var syncJobSummariesDecoded0:[IoTTwinMakerClientTypes.SyncJobSummary]? = nil
        if let syncJobSummariesContainer = syncJobSummariesContainer {
            syncJobSummariesDecoded0 = [IoTTwinMakerClientTypes.SyncJobSummary]()
            for structure0 in syncJobSummariesContainer {
                if let structure0 = structure0 {
                    syncJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        syncJobSummaries = syncJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for syncresourcefilter0 in filters {
                try filtersContainer.encode(syncresourcefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSyncResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let syncSource = syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())/resources-list"
    }
}

public struct ListSyncResourcesInput: Swift.Equatable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.SyncResourceFilter]?
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync soucre. Currently the only supported syncSoucre is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        filters: [IoTTwinMakerClientTypes.SyncResourceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

struct ListSyncResourcesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.SyncResourceFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSyncResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncResourceFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.SyncResourceFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.SyncResourceFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSyncResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSyncResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSyncResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSyncResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSyncResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.syncResources = output.syncResources
        } else {
            self.nextToken = nil
            self.syncResources = nil
        }
    }
}

public struct ListSyncResourcesOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync resources.
    public var syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncResources = syncResources
    }
}

struct ListSyncResourcesOutputResponseBody: Swift.Equatable {
    let syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]?
    let nextToken: Swift.String?
}

extension ListSyncResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case syncResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncResourcesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SyncResourceSummary?].self, forKey: .syncResources)
        var syncResourcesDecoded0:[IoTTwinMakerClientTypes.SyncResourceSummary]? = nil
        if let syncResourcesContainer = syncResourcesContainer {
            syncResourcesDecoded0 = [IoTTwinMakerClientTypes.SyncResourceSummary]()
            for structure0 in syncResourcesContainer {
                if let structure0 = structure0 {
                    syncResourcesDecoded0?.append(structure0)
                }
            }
        }
        syncResources = syncResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags-list"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Metadata that you can use to manage a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces-list"
    }
}

public struct ListWorkspacesInput: Swift.Equatable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaceSummaries = output.workspaceSummaries
        } else {
            self.nextToken = nil
            self.workspaceSummaries = nil
        }
    }
}

public struct ListWorkspacesOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the workspaces.
    public var workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceSummaries = workspaceSummaries
    }
}

struct ListWorkspacesOutputResponseBody: Swift.Equatable {
    let workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaceSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.WorkspaceSummary?].self, forKey: .workspaceSummaries)
        var workspaceSummariesDecoded0:[IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
        if let workspaceSummariesContainer = workspaceSummariesContainer {
            workspaceSummariesDecoded0 = [IoTTwinMakerClientTypes.WorkspaceSummary]()
            for structure0 in workspaceSummariesContainer {
                if let structure0 = structure0 {
                    workspaceSummariesDecoded0?.append(structure0)
                }
            }
        }
        workspaceSummaries = workspaceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.OrderBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order
        case propertyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Order.self, forKey: .order)
        order = orderDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// Filter criteria that orders the return output. It can be sorted in ascending or descending order.
    public struct OrderBy: Swift.Equatable {
        /// The set order that filters results.
        public var order: IoTTwinMakerClientTypes.Order?
        /// The property name.
        /// This member is required.
        public var propertyName: Swift.String?

        public init (
            order: IoTTwinMakerClientTypes.Order? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.order = order
            self.propertyName = propertyName
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum OrderByTime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByTime] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderByTime(rawValue: rawValue) ?? OrderByTime.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ParentEntityUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentEntityId
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentEntityId = self.parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The parent entity update request.
    public struct ParentEntityUpdateRequest: Swift.Equatable {
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The type of the update.
        /// This member is required.
        public var updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType?

        public init (
            parentEntityId: Swift.String? = nil,
            updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType? = nil
        )
        {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ParentEntityUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ParentEntityUpdateType] {
            return [
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParentEntityUpdateType(rawValue: rawValue) ?? ParentEntityUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes {
    public enum PricingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case standard
        case tieredBundle
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingMode] {
            return [
                .basic,
                .standard,
                .tieredBundle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case .tieredBundle: return "TIERED_BUNDLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingMode(rawValue: rawValue) ?? PricingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PricingPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billableEntityCount
        case bundleInformation
        case effectiveDateTime
        case pricingMode
        case updateDateTime
        case updateReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billableEntityCount = self.billableEntityCount {
            try encodeContainer.encode(billableEntityCount, forKey: .billableEntityCount)
        }
        if let bundleInformation = self.bundleInformation {
            try encodeContainer.encode(bundleInformation, forKey: .bundleInformation)
        }
        if let effectiveDateTime = self.effectiveDateTime {
            try encodeContainer.encodeTimestamp(effectiveDateTime, format: .epochSeconds, forKey: .effectiveDateTime)
        }
        if let pricingMode = self.pricingMode {
            try encodeContainer.encode(pricingMode.rawValue, forKey: .pricingMode)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason.rawValue, forKey: .updateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billableEntityCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .billableEntityCount)
        billableEntityCount = billableEntityCountDecoded
        let bundleInformationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.BundleInformation.self, forKey: .bundleInformation)
        bundleInformation = bundleInformationDecoded
        let effectiveDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .effectiveDateTime)
        effectiveDateTime = effectiveDateTimeDecoded
        let pricingModeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingMode.self, forKey: .pricingMode)
        pricingMode = pricingModeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.UpdateReason.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The pricing plan.
    public struct PricingPlan: Swift.Equatable {
        /// The billable entity count.
        public var billableEntityCount: Swift.Int?
        /// The pricing plan's bundle information.
        public var bundleInformation: IoTTwinMakerClientTypes.BundleInformation?
        /// The effective date and time of the pricing plan.
        /// This member is required.
        public var effectiveDateTime: ClientRuntime.Date?
        /// The pricing mode.
        /// This member is required.
        public var pricingMode: IoTTwinMakerClientTypes.PricingMode?
        /// The set date and time for updating a pricing plan.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?
        /// The update reason, for changing a pricing plan.
        /// This member is required.
        public var updateReason: IoTTwinMakerClientTypes.UpdateReason?

        public init (
            billableEntityCount: Swift.Int? = nil,
            bundleInformation: IoTTwinMakerClientTypes.BundleInformation? = nil,
            effectiveDateTime: ClientRuntime.Date? = nil,
            pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            updateReason: IoTTwinMakerClientTypes.UpdateReason? = nil
        )
        {
            self.billableEntityCount = billableEntityCount
            self.bundleInformation = bundleInformation
            self.effectiveDateTime = effectiveDateTime
            self.pricingMode = pricingMode
            self.updateDateTime = updateDateTime
            self.updateReason = updateReason
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PricingTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tier1
        case tier2
        case tier3
        case tier4
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingTier] {
            return [
                .tier1,
                .tier2,
                .tier3,
                .tier4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tier1: return "TIER_1"
            case .tier2: return "TIER_2"
            case .tier3: return "TIER_3"
            case .tier4: return "TIER_4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingTier(rawValue: rawValue) ?? PricingTier.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyDefinitionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case displayName
        case isExternalId
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let isExternalId = self.isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isRequiredInEntity = self.isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = self.isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = self.isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyDefinitionRequest: Swift.Equatable {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public var isTimeSeries: Swift.Bool?

        public init (
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyDefinitionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case displayName
        case isExternalId
        case isFinal
        case isImported
        case isInherited
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let isExternalId = self.isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isFinal = self.isFinal {
            try encodeContainer.encode(isFinal, forKey: .isFinal)
        }
        if let isImported = self.isImported {
            try encodeContainer.encode(isImported, forKey: .isImported)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let isRequiredInEntity = self.isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = self.isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = self.isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isImportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isImported)
        isImported = isImportedDecoded
        let isFinalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isFinal)
        isFinal = isFinalDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains response data from a property definition request.
    public struct PropertyDefinitionResponse: Swift.Equatable {
        /// A mapping that specifies configuration information about the property.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        /// This member is required.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        /// This member is required.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property definition can be updated.
        /// This member is required.
        public var isFinal: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        /// This member is required.
        public var isImported: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// A Boolean value that specifies whether the property is required in an entity.
        /// This member is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        /// This member is required.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        /// This member is required.
        public var isTimeSeries: Swift.Bool?

        public init (
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isFinal: Swift.Bool? = nil,
            isImported: Swift.Bool? = nil,
            isInherited: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "operator"
        case propertyName
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let propertyName = self.propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items returned by a property request.
    public struct PropertyFilter: Swift.Equatable {
        /// The operator associated with this property filter.
        public var `operator`: Swift.String?
        /// The property name associated with this property filter.
        public var propertyName: Swift.String?
        /// The value associated with this property filter.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            `operator`: Swift.String? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyGroupRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    ///
    public struct PropertyGroupRequest: Swift.Equatable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The names of properties.
        public var propertyNames: [Swift.String]?

        public init (
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyGroupResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupType
        case isInherited
        case propertyNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupType = self.groupType {
            try encodeContainer.encode(groupType.rawValue, forKey: .groupType)
        }
        if let isInherited = self.isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let propertyNames = propertyNames {
            var propertyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyNames)
            for name0 in propertyNames {
                try propertyNamesContainer.encode(name0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.GroupType.self, forKey: .groupType)
        groupType = groupTypeDecoded
        let propertyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .propertyNames)
        var propertyNamesDecoded0:[Swift.String]? = nil
        if let propertyNamesContainer = propertyNamesContainer {
            propertyNamesDecoded0 = [Swift.String]()
            for string0 in propertyNamesContainer {
                if let string0 = string0 {
                    propertyNamesDecoded0?.append(string0)
                }
            }
        }
        propertyNames = propertyNamesDecoded0
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The property group response
    public struct PropertyGroupResponse: Swift.Equatable {
        /// The group types.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties.
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init (
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PropertyGroupUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyGroupUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyGroupUpdateType(rawValue: rawValue) ?? PropertyGroupUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyLatestValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyReference
        case propertyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyReference = self.propertyReference {
            try encodeContainer.encode(propertyReference, forKey: .propertyReference)
        }
        if let propertyValue = self.propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .propertyReference)
        propertyReference = propertyReferenceDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The latest value of the property.
    public struct PropertyLatestValue: Swift.Equatable {
        /// An object that specifies information about a property.>
        /// This member is required.
        public var propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// The value of the property.
        public var propertyValue: IoTTwinMakerClientTypes.DataValue?

        public init (
            propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValue: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case updateType
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let updateType = self.updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionRequest.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyRequest: Swift.Equatable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest?
        /// The update type of the update property request.
        public var updateType: IoTTwinMakerClientTypes.PropertyUpdateType?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyUpdateType? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionResponse.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a property response.
    public struct PropertyResponse: Swift.Equatable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PropertyUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyUpdateType(rawValue: rawValue) ?? PropertyUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case time
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = self.time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .time)
        time = timeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a value for a time series property.
    public struct PropertyValue: Swift.Equatable {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].
        ///
        /// * [YYYY]: year
        ///
        /// * [MM]: month
        ///
        /// * [DD]: day
        ///
        /// * [hh]: hour
        ///
        /// * [mm]: minute
        ///
        /// * [ss]: seconds
        ///
        /// * [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.
        ///
        /// * Z: default timezone UTC
        ///
        /// * ± HH:mm: time zone offset in Hours and Minutes.
        ///
        ///
        /// Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public var time: Swift.String?
        /// The timestamp of a value for a time series property.
        @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use time instead.")
        public var timestamp: ClientRuntime.Date?
        /// An object that specifies a value for a time series property.
        /// This member is required.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            time: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = self.entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for propertyvalue0 in propertyValues {
                try propertyValuesContainer.encode(propertyvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies information about time series property values. This object is used and consumed by the [BatchPutPropertyValues](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_BatchPutPropertyValues.html) action.
    public struct PropertyValueEntry: Swift.Equatable {
        /// An object that contains information about the entity that has the property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that specify time series property values.
        public var propertyValues: [IoTTwinMakerClientTypes.PropertyValue]?

        public init (
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValues: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = self.entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for propertyvalue0 in values {
                try valuesContainer.encode(propertyvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let valuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .values)
        var valuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The history of values for a time series property.
    public struct PropertyValueHistory: Swift.Equatable {
        /// An object that uniquely identifies an entity property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that contain information about the values in the history of a time series property.
        public var values: [IoTTwinMakerClientTypes.PropertyValue]?

        public init (
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            values: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }
    }

}

extension QueryTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: QueryTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The query timeout exception.
public struct QueryTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.Relationship: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationshipType
        case targetComponentTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType, forKey: .relationshipType)
        }
        if let targetComponentTypeId = self.targetComponentTypeId {
            try encodeContainer.encode(targetComponentTypeId, forKey: .targetComponentTypeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetComponentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentTypeId)
        targetComponentTypeId = targetComponentTypeIdDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a relationship with another component type.
    public struct Relationship: Swift.Equatable {
        /// The type of the relationship.
        public var relationshipType: Swift.String?
        /// The ID of the target component type associated with this relationship.
        public var targetComponentTypeId: Swift.String?

        public init (
            relationshipType: Swift.String? = nil,
            targetComponentTypeId: Swift.String? = nil
        )
        {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }
    }

}

extension IoTTwinMakerClientTypes.RelationshipValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetComponentName
        case targetEntityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetComponentName = self.targetComponentName {
            try encodeContainer.encode(targetComponentName, forKey: .targetComponentName)
        }
        if let targetEntityId = self.targetEntityId {
            try encodeContainer.encode(targetEntityId, forKey: .targetEntityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEntityId)
        targetEntityId = targetEntityIdDecoded
        let targetComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentName)
        targetComponentName = targetComponentNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// A value that associates a component and an entity.
    public struct RelationshipValue: Swift.Equatable {
        /// The name of the target component associated with the relationship value.
        public var targetComponentName: Swift.String?
        /// The ID of the target entity associated with this relationship value.
        public var targetEntityId: Swift.String?

        public init (
            targetComponentName: Swift.String? = nil,
            targetEntityId: Swift.String? = nil
        )
        {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowData = rowData {
            var rowDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowData)
            for queryresultvalue0 in rowData {
                try rowDataContainer.encode(queryresultvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowDataContainer = try containerValues.decodeIfPresent([ClientRuntime.Document?].self, forKey: .rowData)
        var rowDataDecoded0:[ClientRuntime.Document]? = nil
        if let rowDataContainer = rowDataContainer {
            rowDataDecoded0 = [ClientRuntime.Document]()
            for document0 in rowDataContainer {
                if let document0 = document0 {
                    rowDataDecoded0?.append(document0)
                }
            }
        }
        rowData = rowDataDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// Represents a single row in the query results.
    public struct Row: Swift.Equatable {
        /// The data in a row of query results.
        public var rowData: [ClientRuntime.Document]?

        public init (
            rowData: [ClientRuntime.Document]? = nil
        )
        {
            self.rowData = rowData
        }
    }

}

extension IoTTwinMakerClientTypes.SceneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentLocation
        case creationDateTime
        case description
        case sceneId
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = self.sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a scene.
    public struct SceneSummary: Swift.Equatable {
        /// The ARN of the scene.
        /// This member is required.
        public var arn: Swift.String?
        /// The relative path that specifies the location of the content definition file.
        /// This member is required.
        public var contentLocation: Swift.String?
        /// The date and time when the scene was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The scene description.
        public var description: Swift.String?
        /// The ID of the scene.
        /// This member is required.
        public var sceneId: Swift.String?
        /// The date and time when the scene was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            contentLocation: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            sceneId: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum Scope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entity
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [Scope] {
            return [
                .entity,
                .workspace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entity: return "ENTITY"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Scope(rawValue: rawValue) ?? Scope.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota was exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.Status: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that represents the status of an entity, component, component type, or workspace.
    public struct Status: Swift.Equatable {
        /// The error message.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public var state: IoTTwinMakerClientTypes.State?

        public init (
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.State? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case initializing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncJobState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .initializing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncJobState(rawValue: rawValue) ?? SyncJobState.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.SyncJobStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The SyncJob status.
    public struct SyncJobStatus: Swift.Equatable {
        /// The SyncJob error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The SyncJob status state.
        public var state: IoTTwinMakerClientTypes.SyncJobState?

        public init (
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncJobState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes.SyncJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case status
        case syncSource
        case updateDateTime
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncSource = self.syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The SyncJob summary.
    public struct SyncJobSummary: Swift.Equatable {
        /// The SyncJob summary ARN.
        public var arn: Swift.String?
        /// The creation date and time.
        public var creationDateTime: ClientRuntime.Date?
        /// The SyncJob summaries status.
        public var status: IoTTwinMakerClientTypes.SyncJobStatus?
        /// The sync source.
        public var syncSource: Swift.String?
        /// The update date and time.
        public var updateDateTime: ClientRuntime.Date?
        /// The ID of the workspace that contains the sync job.
        public var workspaceId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
            syncSource: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }

}

extension IoTTwinMakerClientTypes.SyncResourceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalid = "externalId"
        case resourceid = "resourceId"
        case resourcetype = "resourceType"
        case sdkUnknown
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .resourceid(resourceid):
                try container.encode(resourceid, forKey: .resourceid)
            case let .resourcetype(resourcetype):
                try container.encode(resourcetype.rawValue, forKey: .resourcetype)
            case let .state(state):
                try container.encode(state.rawValue, forKey: .state)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceState.self, forKey: .state)
        if let state = stateDecoded {
            self = .state(state)
            return
        }
        let resourcetypeDecoded = try values.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceType.self, forKey: .resourcetype)
        if let resourcetype = resourcetypeDecoded {
            self = .resourcetype(resourcetype)
            return
        }
        let resourceidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .resourceid)
        if let resourceid = resourceidDecoded {
            self = .resourceid(resourceid)
            return
        }
        let externalidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource filter.
    public enum SyncResourceFilter: Swift.Equatable {
        /// The sync resource filter's state.
        case state(IoTTwinMakerClientTypes.SyncResourceState)
        /// The sync resource filter resoucre type
        case resourcetype(IoTTwinMakerClientTypes.SyncResourceType)
        /// The sync resource filter resource Id.
        case resourceid(Swift.String)
        /// The external Id.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncResourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case error
        case initializing
        case inSync
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceState] {
            return [
                .deleted,
                .error,
                .initializing,
                .inSync,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case .inSync: return "IN_SYNC"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncResourceState(rawValue: rawValue) ?? SyncResourceState.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.SyncResourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource status.
    public struct SyncResourceStatus: Swift.Equatable {
        /// The status error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The sync resource status state.
        public var state: IoTTwinMakerClientTypes.SyncResourceState?

        public init (
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncResourceState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTTwinMakerClientTypes.SyncResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId
        case resourceId
        case resourceType
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.SyncResourceStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The sync resource summary.
    public struct SyncResourceSummary: Swift.Equatable {
        /// The external Id.
        public var externalId: Swift.String?
        /// The resource Id.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: IoTTwinMakerClientTypes.SyncResourceType?
        /// The sync resource summary status.
        public var status: IoTTwinMakerClientTypes.SyncResourceStatus?
        /// The update date and time.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            externalId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: IoTTwinMakerClientTypes.SyncResourceType? = nil,
            status: IoTTwinMakerClientTypes.SyncResourceStatus? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.externalId = externalId
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum SyncResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case componentType
        case entity
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceType] {
            return [
                .componentType,
                .entity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .componentType: return "COMPONENT_TYPE"
            case .entity: return "ENTITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncResourceType(rawValue: rawValue) ?? SyncResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.TabularConditions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case orderBy
        case propertyFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for orderby0 in orderBy {
                try orderByContainer.encode(orderby0)
            }
        }
        if let propertyFilters = propertyFilters {
            var propertyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyFilters)
            for propertyfilter0 in propertyFilters {
                try propertyFiltersContainer.encode(propertyfilter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderByContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.OrderBy?].self, forKey: .orderBy)
        var orderByDecoded0:[IoTTwinMakerClientTypes.OrderBy]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [IoTTwinMakerClientTypes.OrderBy]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
        let propertyFiltersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyFilter?].self, forKey: .propertyFilters)
        var propertyFiltersDecoded0:[IoTTwinMakerClientTypes.PropertyFilter]? = nil
        if let propertyFiltersContainer = propertyFiltersContainer {
            propertyFiltersDecoded0 = [IoTTwinMakerClientTypes.PropertyFilter]()
            for structure0 in propertyFiltersContainer {
                if let structure0 = structure0 {
                    propertyFiltersDecoded0?.append(structure0)
                }
            }
        }
        propertyFilters = propertyFiltersDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The tabular conditions.
    public struct TabularConditions: Swift.Equatable {
        /// Filter criteria that orders the output. It can be sorted in ascending or descending order.
        public var orderBy: [IoTTwinMakerClientTypes.OrderBy]?
        /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"}
        public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?

        public init (
            orderBy: [IoTTwinMakerClientTypes.OrderBy]? = nil,
            propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil
        )
        {
            self.orderBy = orderBy
            self.propertyFilters = propertyFilters
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Metadata to add to this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of tags exceeds the limit.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case list
        case long
        case map
        case relationship
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .boolean,
                .double,
                .integer,
                .list,
                .long,
                .map,
                .relationship,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .list: return "LIST"
            case .long: return "LONG"
            case .map: return "MAP"
            case .relationship: return "RELATIONSHIP"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "resourceARN".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeName = self.componentTypeName {
            try encodeContainer.encode(componentTypeName, forKey: .componentTypeName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for componenttypeid0 in extendsFrom {
                try extendsFromContainer.encode(componenttypeid0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsRequest0) in functions {
                try functionsContainer.encode(functionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = self.isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertyDefinitionsRequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertyDefinitionsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyGroups = propertyGroups {
            var propertyGroupsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyGroups)
            for (dictKey0, propertyGroupsRequest0) in propertyGroups {
                try propertyGroupsContainer.encode(propertyGroupsRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct UpdateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    /// The property groups
    public var propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    let propertyGroups: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]?
    let componentTypeName: Swift.String?
}

extension UpdateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeName
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case propertyGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
        let propertyGroupsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest?].self, forKey: .propertyGroups)
        var propertyGroupsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil
        if let propertyGroupsContainer = propertyGroupsContainer {
            propertyGroupsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyGroupRequest]()
            for (key0, propertygrouprequest0) in propertyGroupsContainer {
                if let propertygrouprequest0 = propertygrouprequest0 {
                    propertyGroupsDecoded0?[key0] = propertygrouprequest0
                }
            }
        }
        propertyGroups = propertyGroupsDecoded0
        let componentTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeName)
        componentTypeName = componentTypeNameDecoded
    }
}

extension UpdateComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.state = output.state
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.state = nil
            self.workspaceId = nil
        }
    }
}

public struct UpdateComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.state = state
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let componentTypeId: Swift.String?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case state
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdates = componentUpdates {
            var componentUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .componentUpdates)
            for (dictKey0, componentUpdatesMapRequest0) in componentUpdates {
                try componentUpdatesContainer.encode(componentUpdatesMapRequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityUpdate = self.parentEntityUpdate {
            try encodeContainer.encode(parentEntityUpdate, forKey: .parentEntityUpdate)
        }
    }
}

extension UpdateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct UpdateEntityInput: Swift.Equatable {
    /// An object that maps strings to the component updates in the request. Each string in the mapping must be unique to this object.
    public var componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    public var entityName: Swift.String?
    /// An object that describes the update request for a parent entity.
    public var parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentUpdates = componentUpdates
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityUpdate = parentEntityUpdate
        self.workspaceId = workspaceId
    }
}

struct UpdateEntityInputBody: Swift.Equatable {
    let entityName: Swift.String?
    let description: Swift.String?
    let componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    let parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
}

extension UpdateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentUpdateRequest?].self, forKey: .componentUpdates)
        var componentUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil
        if let componentUpdatesContainer = componentUpdatesContainer {
            componentUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]()
            for (key0, componentupdaterequest0) in componentUpdatesContainer {
                if let componentupdaterequest0 = componentupdaterequest0 {
                    componentUpdatesDecoded0?[key0] = componentupdaterequest0
                }
            }
        }
        componentUpdates = componentUpdatesDecoded0
        let parentEntityUpdateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateRequest.self, forKey: .parentEntityUpdate)
        parentEntityUpdate = parentEntityUpdateDecoded
    }
}

extension UpdateEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEntityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.updateDateTime = output.updateDateTime
        } else {
            self.state = nil
            self.updateDateTime = nil
        }
    }
}

public struct UpdateEntityOutputResponse: Swift.Equatable {
    /// The current state of the entity update.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.state = state
        self.updateDateTime = updateDateTime
    }
}

struct UpdateEntityOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleNames = bundleNames {
            var bundleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bundleNames)
            for bundlename0 in bundleNames {
                try bundleNamesContainer.encode(bundlename0)
            }
        }
        if let pricingMode = self.pricingMode {
            try encodeContainer.encode(pricingMode.rawValue, forKey: .pricingMode)
        }
    }
}

extension UpdatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/pricingplan"
    }
}

public struct UpdatePricingPlanInput: Swift.Equatable {
    /// The bundle names.
    public var bundleNames: [Swift.String]?
    /// The pricing mode.
    /// This member is required.
    public var pricingMode: IoTTwinMakerClientTypes.PricingMode?

    public init (
        bundleNames: [Swift.String]? = nil,
        pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil
    )
    {
        self.bundleNames = bundleNames
        self.pricingMode = pricingMode
    }
}

struct UpdatePricingPlanInputBody: Swift.Equatable {
    let pricingMode: IoTTwinMakerClientTypes.PricingMode?
    let bundleNames: [Swift.String]?
}

extension UpdatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleNames
        case pricingMode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingModeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingMode.self, forKey: .pricingMode)
        pricingMode = pricingModeDecoded
        let bundleNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bundleNames)
        var bundleNamesDecoded0:[Swift.String]? = nil
        if let bundleNamesContainer = bundleNamesContainer {
            bundleNamesDecoded0 = [Swift.String]()
            for string0 in bundleNamesContainer {
                if let string0 = string0 {
                    bundleNamesDecoded0?.append(string0)
                }
            }
        }
        bundleNames = bundleNamesDecoded0
    }
}

extension UpdatePricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentPricingPlan = output.currentPricingPlan
            self.pendingPricingPlan = output.pendingPricingPlan
        } else {
            self.currentPricingPlan = nil
            self.pendingPricingPlan = nil
        }
    }
}

public struct UpdatePricingPlanOutputResponse: Swift.Equatable {
    /// Update the current pricing plan.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// Update the pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init (
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

struct UpdatePricingPlanOutputResponseBody: Swift.Equatable {
    let currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    let pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
}

extension UpdatePricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentPricingPlan
        case pendingPricingPlan
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .currentPricingPlan)
        currentPricingPlan = currentPricingPlanDecoded
        let pendingPricingPlanDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PricingPlan.self, forKey: .pendingPricingPlan)
        pendingPricingPlan = pendingPricingPlanDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum UpdateReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case entityCountUpdate
        case overwritten
        case pricingModeUpdate
        case pricingTierUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateReason] {
            return [
                .default,
                .entityCountUpdate,
                .overwritten,
                .pricingModeUpdate,
                .pricingTierUpdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .entityCountUpdate: return "ENTITY_COUNT_UPDATE"
            case .overwritten: return "OVERWRITTEN"
            case .pricingModeUpdate: return "PRICING_MODE_UPDATE"
            case .pricingTierUpdate: return "PRICING_TIER_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateReason(rawValue: rawValue) ?? UpdateReason.sdkUnknown(rawValue)
        }
    }
}

extension UpdateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapability0 in capabilities {
                try capabilitiesContainer.encode(scenecapability0)
            }
        }
        if let contentLocation = self.contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct UpdateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    public var contentLocation: Swift.String?
    /// The description of this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct UpdateSceneInputBody: Swift.Equatable {
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
}

extension UpdateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension UpdateSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateSceneOutputResponse: Swift.Equatable {
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateSceneOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension UpdateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }
}

extension UpdateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct UpdateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let role: Swift.String?
}

extension UpdateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
    }
}

extension UpdateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateWorkspaceOutputResponse: Swift.Equatable {
    /// The date and time of the current update.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateWorkspaceOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Failed
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case updateDateTime
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
        if let workspaceId = self.workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a workspace.
    public struct WorkspaceSummary: Swift.Equatable {
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the workspace was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the workspace.
        public var description: Swift.String?
        /// The date and time when the workspace was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?
        /// The ID of the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }

}
