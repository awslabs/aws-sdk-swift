// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.BatchPutPropertyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entry
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyValueEntry.self, forKey: .entry)
        entry = entryDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An error returned by the BatchPutProperty action.
    public struct BatchPutPropertyError: Swift.Equatable {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var entry: IoTTwinMakerClientTypes.PropertyValueEntry?
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init (
            entry: IoTTwinMakerClientTypes.PropertyValueEntry? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for errors0 in errors {
                try errorsContainer.encode(errors0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about errors returned by the BatchPutProperty action.
    public struct BatchPutPropertyErrorEntry: Swift.Equatable {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]?

        public init (
            errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        )
        {
            self.errors = errors
        }
    }

}

extension BatchPutPropertyValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for entries0 in entries {
                try entriesContainer.encode(entries0)
            }
        }
    }
}

extension BatchPutPropertyValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties"
    }
}

public struct BatchPutPropertyValuesInput: Swift.Equatable {
    /// An object that maps strings to the property value entries to set. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
    /// The ID of the workspace that contains the properties to set.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entries: [IoTTwinMakerClientTypes.PropertyValueEntry]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entries = entries
        self.workspaceId = workspaceId
    }
}

struct BatchPutPropertyValuesInputBody: Swift.Equatable {
    let entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
}

extension BatchPutPropertyValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTTwinMakerClientTypes.PropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutPropertyValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutPropertyValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutPropertyValuesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutPropertyValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutPropertyValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutPropertyValuesOutputResponse: Swift.Equatable {
    /// Entries that caused errors in the batch put operation.
    /// This member is required.
    public var errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?

    public init (
        errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutPropertyValuesOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?
}

extension BatchPutPropertyValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IoTTwinMakerClientTypes.ComponentRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyrequests0) in properties {
                try propertiesContainer.encode(propertyrequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertiesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertiesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a component type create or update request.
    public struct ComponentRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?

        public init (
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case definedIn
        case description
        case properties
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let definedIn = definedIn {
            try encodeContainer.encode(definedIn, forKey: .definedIn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, propertyresponses0) in properties {
                try propertiesContainer.encode(propertyresponses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let definedInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definedIn)
        definedIn = definedInDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyResponse?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]()
            for (key0, propertyresponse0) in propertiesContainer {
                if let propertyresponse0 = propertyresponse0 {
                    propertiesDecoded0?[key0] = propertyresponse0
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that returns information about a component type create or update request.
    public struct ComponentResponse: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]?
        /// The status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?

        public init (
            componentName: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String:IoTTwinMakerClientTypes.PropertyResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil
        )
        {
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.status = status
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentTypeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case creationDateTime
        case description
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a component type.
    public struct ComponentTypeSummary: Swift.Equatable {
        /// The ARN of the component type.
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The date and time when the component type was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the component type.
        public var description: Swift.String?
        /// The current status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The date and time when the component type was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes.ComponentUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeId
        case description
        case propertyUpdates
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let propertyUpdates = propertyUpdates {
            var propertyUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyUpdates)
            for (dictKey0, propertyrequests0) in propertyUpdates {
                try propertyUpdatesContainer.encode(propertyrequests0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateType = updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ComponentUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let propertyUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyRequest?].self, forKey: .propertyUpdates)
        var propertyUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil
        if let propertyUpdatesContainer = propertyUpdatesContainer {
            propertyUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]()
            for (key0, propertyrequest0) in propertyUpdatesContainer {
                if let propertyrequest0 = propertyrequest0 {
                    propertyUpdatesDecoded0?[key0] = propertyrequest0
                }
            }
        }
        propertyUpdates = propertyUpdatesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The component update request.
    public struct ComponentUpdateRequest: Swift.Equatable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init (
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyUpdates: [Swift.String:IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ComponentUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentUpdateType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentUpdateType(rawValue: rawValue) ?? ComponentUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflict occurred.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The connector failed.
public struct ConnectorFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectorTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectorTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The connector timed out.
public struct ConnectorTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectorTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for extendsfrom0 in extendsFrom {
                try extendsFromContainer.encode(extendsfrom0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsrequest0) in functions {
                try functionsContainer.encode(functionsrequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertydefinitionsrequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertydefinitionsrequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct CreateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the parent component type to extend.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    /// Metadata that you can use to manage the component type.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.state = nil
        }
    }
}

public struct CreateComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

struct CreateComponentTypeOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .components)
            for (dictKey0, componentsmaprequest0) in components {
                try componentsContainer.encode(componentsmaprequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityId = parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities"
    }
}

public struct CreateEntityInput: Swift.Equatable {
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// The ID of the entity's parent entity.
    public var parentEntityId: Swift.String?
    /// Metadata that you can use to manage the entity.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.components = components
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityId = parentEntityId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateEntityInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]?
    let parentEntityId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components
        case description
        case entityId
        case entityName
        case parentEntityId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentRequest?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentRequest]()
            for (key0, componentrequest0) in componentsContainer {
                if let componentrequest0 = componentrequest0 {
                    componentsDecoded0?[key0] = componentrequest0
                }
            }
        }
        components = componentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEntityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.entityId = output.entityId
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.entityId = nil
            self.state = nil
        }
    }
}

public struct CreateEntityOutputResponse: Swift.Equatable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The current state of the entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.entityId = entityId
        self.state = state
    }
}

struct CreateEntityOutputResponseBody: Swift.Equatable {
    let entityId: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension CreateEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case entityId
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension CreateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapabilities0 in capabilities {
                try capabilitiesContainer.encode(scenecapabilities0)
            }
        }
        if let contentLocation = contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes"
    }
}

public struct CreateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render itself.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The description for this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// Metadata that you can use to manage the scene.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateSceneInputBody: Swift.Equatable {
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
        case sceneId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateSceneOutputResponse: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateSceneOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CreateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct CreateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    /// This member is required.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    /// This member is required.
    public var s3Location: Swift.String?
    /// Metadata that you can use to manage the workspace
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let s3Location: Swift.String?
    let role: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
        case s3Location
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
        } else {
            self.arn = nil
            self.creationDateTime = nil
        }
    }
}

public struct CreateWorkspaceOutputResponse: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

struct CreateWorkspaceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
}

extension CreateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes.DataConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isNative
        case lambda
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isNative = isNative {
            try encodeContainer.encode(isNative, forKey: .isNative)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.LambdaFunction.self, forKey: .lambda)
        lambda = lambdaDecoded
        let isNativeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNative)
        isNative = isNativeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The data connector.
    public struct DataConnector: Swift.Equatable {
        /// A Boolean value that specifies whether the data connector is native to TwinMaker.
        public var isNative: Swift.Bool?
        /// The Lambda function associated with this data connector.
        public var lambda: IoTTwinMakerClientTypes.LambdaFunction?

        public init (
            isNative: Swift.Bool? = nil,
            lambda: IoTTwinMakerClientTypes.LambdaFunction? = nil
        )
        {
            self.isNative = isNative
            self.lambda = lambda
        }
    }

}

extension IoTTwinMakerClientTypes.DataType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case nestedType
        case relationship
        case type
        case unitOfMeasure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for datavaluelist0 in allowedValues {
                try allowedValuesContainer.encode(datavaluelist0)
            }
        }
        if let nestedType = nestedType {
            try encodeContainer.encode(nestedType.value, forKey: .nestedType)
        }
        if let relationship = relationship {
            try encodeContainer.encode(relationship, forKey: .relationship)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let unitOfMeasure = unitOfMeasure {
            try encodeContainer.encode(unitOfMeasure, forKey: .unitOfMeasure)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let nestedTypeDecoded = try containerValues.decodeIfPresent(Box<IoTTwinMakerClientTypes.DataType>.self, forKey: .nestedType)
        nestedType = nestedTypeDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in allowedValuesContainer {
                if let structure0 = structure0 {
                    allowedValuesDecoded0?.append(structure0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let unitOfMeasureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unitOfMeasure)
        unitOfMeasure = unitOfMeasureDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Relationship.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies the data type of a property.
    public struct DataType: Swift.Equatable {
        /// The allowed values for this data type.
        public var allowedValues: [IoTTwinMakerClientTypes.DataValue]?
        /// The nested type in the data type.
        public var nestedType: Box<IoTTwinMakerClientTypes.DataType>?
        /// A relationship that associates a component with another component.
        public var relationship: IoTTwinMakerClientTypes.Relationship?
        /// The underlying type of the data type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.ModelType?
        /// The unit of measure used in this data type.
        public var unitOfMeasure: Swift.String?

        public init (
            allowedValues: [IoTTwinMakerClientTypes.DataValue]? = nil,
            nestedType: Box<IoTTwinMakerClientTypes.DataType>? = nil,
            relationship: IoTTwinMakerClientTypes.Relationship? = nil,
            type: IoTTwinMakerClientTypes.ModelType? = nil,
            unitOfMeasure: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }
    }

}

extension IoTTwinMakerClientTypes.DataValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case expression
        case integerValue
        case listValue
        case longValue
        case mapValue
        case relationshipValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let listValue = listValue {
            var listValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listValue)
            for datavaluelist0 in listValue {
                try listValueContainer.encode(datavaluelist0)
            }
        }
        if let longValue = longValue {
            try encodeContainer.encode(longValue, forKey: .longValue)
        }
        if let mapValue = mapValue {
            var mapValueContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mapValue)
            for (dictKey0, datavaluemap0) in mapValue {
                try mapValueContainer.encode(datavaluemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let relationshipValue = relationshipValue {
            try encodeContainer.encode(relationshipValue, forKey: .relationshipValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let longValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .longValue)
        longValue = longValueDecoded
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let listValueContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.DataValue?].self, forKey: .listValue)
        var listValueDecoded0:[IoTTwinMakerClientTypes.DataValue]? = nil
        if let listValueContainer = listValueContainer {
            listValueDecoded0 = [IoTTwinMakerClientTypes.DataValue]()
            for structure0 in listValueContainer {
                if let structure0 = structure0 {
                    listValueDecoded0?.append(structure0)
                }
            }
        }
        listValue = listValueDecoded0
        let mapValueContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.DataValue?].self, forKey: .mapValue)
        var mapValueDecoded0: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil
        if let mapValueContainer = mapValueContainer {
            mapValueDecoded0 = [Swift.String:IoTTwinMakerClientTypes.DataValue]()
            for (key0, datavalue0) in mapValueContainer {
                if let datavalue0 = datavalue0 {
                    mapValueDecoded0?[key0] = datavalue0
                }
            }
        }
        mapValue = mapValueDecoded0
        let relationshipValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.RelationshipValue.self, forKey: .relationshipValue)
        relationshipValue = relationshipValueDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a value for a property.
    public struct DataValue: Swift.Equatable {
        /// A Boolean value.
        public var booleanValue: Swift.Bool?
        /// A double value.
        public var doubleValue: Swift.Double?
        /// An expression that produces the value.
        public var expression: Swift.String?
        /// An integer value.
        public var integerValue: Swift.Int?
        /// A list of multiple values.
        public var listValue: [IoTTwinMakerClientTypes.DataValue]?
        /// A long value.
        public var longValue: Swift.Int?
        /// An object that maps strings to multiple DataValue objects.
        public var mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]?
        /// A value that relates a component to another component.
        public var relationshipValue: IoTTwinMakerClientTypes.RelationshipValue?
        /// A string value.
        public var stringValue: Swift.String?

        public init (
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            expression: Swift.String? = nil,
            integerValue: Swift.Int? = nil,
            listValue: [IoTTwinMakerClientTypes.DataValue]? = nil,
            longValue: Swift.Int? = nil,
            mapValue: [Swift.String:IoTTwinMakerClientTypes.DataValue]? = nil,
            relationshipValue: IoTTwinMakerClientTypes.RelationshipValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }
    }

}

extension DeleteComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct DeleteComponentTypeInput: Swift.Equatable {
    /// The ID of the component type to delete.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct DeleteComponentTypeInputBody: Swift.Equatable {
}

extension DeleteComponentTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteComponentTypeOutputResponse: Swift.Equatable {
    /// The current state of the component type to be deleted.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteComponentTypeOutputResponseBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteEntityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let isRecursive = isRecursive {
            let isRecursiveQueryItem = ClientRuntime.URLQueryItem(name: "isRecursive".urlPercentEncoding(), value: Swift.String(isRecursive).urlPercentEncoding())
            items.append(isRecursiveQueryItem)
        }
        return items
    }
}

extension DeleteEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct DeleteEntityInput: Swift.Equatable {
    /// The ID of the entity to delete.
    /// This member is required.
    public var entityId: Swift.String?
    /// A Boolean value that specifies whether the operation deletes child entities.
    public var isRecursive: Swift.Bool?
    /// The ID of the workspace that contains the entity to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        isRecursive: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.isRecursive = isRecursive
        self.workspaceId = workspaceId
    }
}

struct DeleteEntityInputBody: Swift.Equatable {
}

extension DeleteEntityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEntityOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct DeleteEntityOutputResponse: Swift.Equatable {
    /// The current state of the deleted entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

struct DeleteEntityOutputResponseBody: Swift.Equatable {
    let state: IoTTwinMakerClientTypes.State?
}

extension DeleteEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension DeleteSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct DeleteSceneInput: Swift.Equatable {
    /// The ID of the scene to delete.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct DeleteSceneInputBody: Swift.Equatable {
}

extension DeleteSceneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSceneOutputResponse: Swift.Equatable {

}

extension DeleteWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct DeleteWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceOutputResponse: Swift.Equatable {

}

extension IoTTwinMakerClientTypes.EntityPropertyReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case entityId
        case externalIdProperty
        case propertyName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let externalIdProperty = externalIdProperty {
            var externalIdPropertyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalIdProperty)
            for (dictKey0, externalidproperty0) in externalIdProperty {
                try externalIdPropertyContainer.encode(externalidproperty0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let propertyName = propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let externalIdPropertyContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .externalIdProperty)
        var externalIdPropertyDecoded0: [Swift.String:Swift.String]? = nil
        if let externalIdPropertyContainer = externalIdPropertyContainer {
            externalIdPropertyDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in externalIdPropertyContainer {
                if let string0 = string0 {
                    externalIdPropertyDecoded0?[key0] = string0
                }
            }
        }
        externalIdProperty = externalIdPropertyDecoded0
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that uniquely identifies an entity property.
    public struct EntityPropertyReference: Swift.Equatable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the entity.
        public var entityId: Swift.String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public var externalIdProperty: [Swift.String:Swift.String]?
        /// The name of the property.
        /// This member is required.
        public var propertyName: Swift.String?

        public init (
            componentName: Swift.String? = nil,
            entityId: Swift.String? = nil,
            externalIdProperty: [Swift.String:Swift.String]? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }
    }

}

extension IoTTwinMakerClientTypes.EntitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityName = entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let hasChildEntities = hasChildEntities {
            try encodeContainer.encode(hasChildEntities, forKey: .hasChildEntities)
        }
        if let parentEntityId = parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about an entity.
    public struct EntitySummary: Swift.Equatable {
        /// The ARN of the entity.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the entity was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the entity.
        public var description: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the entity.
        /// This member is required.
        public var entityName: Swift.String?
        /// A Boolean value that specifies whether the entity has child entities or not.
        public var hasChildEntities: Swift.Bool?
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The current status of the entity.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The last date and time when the entity was updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityName: Swift.String? = nil,
            hasChildEntities: Swift.Bool? = nil,
            parentEntityId: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The error details.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTTwinMakerClientTypes.ErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init (
            code: IoTTwinMakerClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTTwinMakerClientTypes.FunctionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for requiredproperties0 in requiredProperties {
                try requiredPropertiesContainer.encode(requiredproperties0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent(Swift.Set<Swift.String>.self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:Swift.Set<Swift.String>? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = Swift.Set<Swift.String>()
            for string0 in requiredPropertiesContainer {
                requiredPropertiesDecoded0?.insert(string0)
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function request body.
    public struct FunctionRequest: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// The required properties of the function.
        public var requiredProperties: Swift.Set<Swift.String>?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init (
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            requiredProperties: Swift.Set<Swift.String>? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension IoTTwinMakerClientTypes.FunctionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case implementedBy
        case isInherited
        case requiredProperties
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let implementedBy = implementedBy {
            try encodeContainer.encode(implementedBy, forKey: .implementedBy)
        }
        if let isInherited = isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let requiredProperties = requiredProperties {
            var requiredPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredProperties)
            for requiredproperties0 in requiredProperties {
                try requiredPropertiesContainer.encode(requiredproperties0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredPropertiesContainer = try containerValues.decodeIfPresent(Swift.Set<Swift.String>.self, forKey: .requiredProperties)
        var requiredPropertiesDecoded0:Swift.Set<Swift.String>? = nil
        if let requiredPropertiesContainer = requiredPropertiesContainer {
            requiredPropertiesDecoded0 = Swift.Set<Swift.String>()
            for string0 in requiredPropertiesContainer {
                requiredPropertiesDecoded0?.insert(string0)
            }
        }
        requiredProperties = requiredPropertiesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Scope.self, forKey: .scope)
        scope = scopeDecoded
        let implementedByDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataConnector.self, forKey: .implementedBy)
        implementedBy = implementedByDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The function response.
    public struct FunctionResponse: Swift.Equatable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// Indicates whether this function is inherited.
        public var isInherited: Swift.Bool?
        /// The required properties of the function.
        public var requiredProperties: Swift.Set<Swift.String>?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init (
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            isInherited: Swift.Bool? = nil,
            requiredProperties: Swift.Set<Swift.String>? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }

}

extension GetComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct GetComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeInputBody: Swift.Equatable {
}

extension GetComponentTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.extendsFrom = output.extendsFrom
            self.functions = output.functions
            self.isAbstract = output.isAbstract
            self.isSchemaInitialized = output.isSchemaInitialized
            self.isSingleton = output.isSingleton
            self.propertyDefinitions = output.propertyDefinitions
            self.status = output.status
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.creationDateTime = nil
            self.description = nil
            self.extendsFrom = nil
            self.functions = nil
            self.isAbstract = nil
            self.isSchemaInitialized = nil
            self.isSingleton = nil
            self.propertyDefinitions = nil
            self.status = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The date and time when the component type was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the component type.
    public var description: Swift.String?
    /// The name of the parent component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    /// A Boolean value that specifies whether the component type is abstract.
    public var isAbstract: Swift.Bool?
    /// A Boolean value that specifies whether the component type has a schema initializer and that the schema initializer has run.
    public var isSchemaInitialized: Swift.Bool?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    /// The current status of the component type.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The date and time when the component was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil,
        isAbstract: Swift.Bool? = nil,
        isSchemaInitialized: Swift.Bool? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.creationDateTime = creationDateTime
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isAbstract = isAbstract
        self.isSchemaInitialized = isSchemaInitialized
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.status = status
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetComponentTypeOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let isSingleton: Swift.Bool?
    let componentTypeId: Swift.String?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let arn: Swift.String?
    let isAbstract: Swift.Bool?
    let isSchemaInitialized: Swift.Bool?
    let status: IoTTwinMakerClientTypes.Status?
}

extension GetComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case creationDateTime
        case description
        case extendsFrom
        case functions
        case isAbstract
        case isSchemaInitialized
        case isSingleton
        case propertyDefinitions
        case status
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionResponse?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionResponse]()
            for (key0, propertydefinitionresponse0) in propertyDefinitionsContainer {
                if let propertydefinitionresponse0 = propertydefinitionresponse0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionresponse0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionResponse?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionResponse]()
            for (key0, functionresponse0) in functionsContainer {
                if let functionresponse0 = functionresponse0 {
                    functionsDecoded0?[key0] = functionresponse0
                }
            }
        }
        functions = functionsDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isAbstractDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAbstract)
        isAbstract = isAbstractDecoded
        let isSchemaInitializedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSchemaInitialized)
        isSchemaInitialized = isSchemaInitializedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct GetEntityInput: Swift.Equatable {
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.workspaceId = workspaceId
    }
}

struct GetEntityInputBody: Swift.Equatable {
}

extension GetEntityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEntityOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.components = output.components
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.entityId = output.entityId
            self.entityName = output.entityName
            self.hasChildEntities = output.hasChildEntities
            self.parentEntityId = output.parentEntityId
            self.status = output.status
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.components = nil
            self.creationDateTime = nil
            self.description = nil
            self.entityId = nil
            self.entityName = nil
            self.hasChildEntities = nil
            self.parentEntityId = nil
            self.status = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetEntityOutputResponse: Swift.Equatable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// A Boolean value that specifies whether the entity has associated child entities.
    /// This member is required.
    public var hasChildEntities: Swift.Bool?
    /// The ID of the parent entity for this entity.
    /// This member is required.
    public var parentEntityId: Swift.String?
    /// The current status of the entity.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        hasChildEntities: Swift.Bool? = nil,
        parentEntityId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.components = components
        self.creationDateTime = creationDateTime
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.hasChildEntities = hasChildEntities
        self.parentEntityId = parentEntityId
        self.status = status
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetEntityOutputResponseBody: Swift.Equatable {
    let entityId: Swift.String?
    let entityName: Swift.String?
    let arn: Swift.String?
    let status: IoTTwinMakerClientTypes.Status?
    let workspaceId: Swift.String?
    let description: Swift.String?
    let components: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]?
    let parentEntityId: Swift.String?
    let hasChildEntities: Swift.Bool?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case components
        case creationDateTime
        case description
        case entityId
        case entityName
        case hasChildEntities
        case parentEntityId
        case status
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentResponse?].self, forKey: .components)
        var componentsDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentResponse]()
            for (key0, componentresponse0) in componentsContainer {
                if let componentresponse0 = componentresponse0 {
                    componentsDecoded0?[key0] = componentresponse0
                }
            }
        }
        components = componentsDecoded0
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
        let hasChildEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasChildEntities)
        hasChildEntities = hasChildEntitiesDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension GetPropertyValueHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case endDateTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime.timeIntervalSince1970, forKey: .endDateTime)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let interpolation = interpolation {
            try encodeContainer.encode(interpolation, forKey: .interpolation)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderByTime = orderByTime {
            try encodeContainer.encode(orderByTime.rawValue, forKey: .orderByTime)
        }
        if let propertyFilters = propertyFilters {
            var propertyFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyFilters)
            for propertyfilters0 in propertyFilters {
                try propertyFiltersContainer.encode(propertyfilters0)
            }
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for selectedpropertylist0 in selectedProperties {
                try selectedPropertiesContainer.encode(selectedpropertylist0)
            }
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime.timeIntervalSince1970, forKey: .startDateTime)
        }
    }
}

extension GetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/history"
    }
}

public struct GetPropertyValueHistoryInput: Swift.Equatable {
    /// The name of the component.
    public var componentName: Swift.String?
    /// The ID of the component type.
    public var componentTypeId: Swift.String?
    /// The date and time of the latest property value to return.
    /// This member is required.
    public var endDateTime: ClientRuntime.Date?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// An object that specifies the interpolation type and the interval over which to interpolate data.
    public var interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The time direction to use in the result order.
    public var orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    /// A list of objects that filter the property value history request.
    public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    /// A list of properties whose value histories the request retrieves.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The date and time of the earliest property value to return.
    /// This member is required.
    public var startDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        endDateTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        interpolation: IoTTwinMakerClientTypes.InterpolationParameters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderByTime: IoTTwinMakerClientTypes.OrderByTime? = nil,
        propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil,
        selectedProperties: [Swift.String]? = nil,
        startDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentTypeId = componentTypeId
        self.endDateTime = endDateTime
        self.entityId = entityId
        self.interpolation = interpolation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderByTime = orderByTime
        self.propertyFilters = propertyFilters
        self.selectedProperties = selectedProperties
        self.startDateTime = startDateTime
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueHistoryInputBody: Swift.Equatable {
    let entityId: Swift.String?
    let componentName: Swift.String?
    let componentTypeId: Swift.String?
    let selectedProperties: [Swift.String]?
    let propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    let startDateTime: ClientRuntime.Date?
    let endDateTime: ClientRuntime.Date?
    let interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let orderByTime: IoTTwinMakerClientTypes.OrderByTime?
}

extension GetPropertyValueHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case endDateTime
        case entityId
        case interpolation
        case maxResults
        case nextToken
        case orderByTime
        case propertyFilters
        case selectedProperties
        case startDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
        let propertyFiltersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyFilter?].self, forKey: .propertyFilters)
        var propertyFiltersDecoded0:[IoTTwinMakerClientTypes.PropertyFilter]? = nil
        if let propertyFiltersContainer = propertyFiltersContainer {
            propertyFiltersDecoded0 = [IoTTwinMakerClientTypes.PropertyFilter]()
            for structure0 in propertyFiltersContainer {
                if let structure0 = structure0 {
                    propertyFiltersDecoded0?.append(structure0)
                }
            }
        }
        propertyFilters = propertyFiltersDecoded0
        let startDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let interpolationDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationParameters.self, forKey: .interpolation)
        interpolation = interpolationDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let orderByTimeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.OrderByTime.self, forKey: .orderByTime)
        orderByTime = orderByTimeDecoded
    }
}

extension GetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPropertyValueHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorFailureException" : self = .connectorFailureException(try ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorTimeoutException" : self = .connectorTimeoutException(try ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPropertyValueHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case connectorFailureException(ConnectorFailureException)
    case connectorTimeoutException(ConnectorTimeoutException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPropertyValueHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.propertyValues = output.propertyValues
        } else {
            self.nextToken = nil
            self.propertyValues = nil
        }
    }
}

public struct GetPropertyValueHistoryOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?

    public init (
        nextToken: Swift.String? = nil,
        propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
    }
}

struct GetPropertyValueHistoryOutputResponseBody: Swift.Equatable {
    let propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?
    let nextToken: Swift.String?
}

extension GetPropertyValueHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case propertyValues
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValueHistory?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValueHistory]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case entityId
        case selectedProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentTypeId = componentTypeId {
            try encodeContainer.encode(componentTypeId, forKey: .componentTypeId)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let selectedProperties = selectedProperties {
            var selectedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedProperties)
            for selectedpropertylist0 in selectedProperties {
                try selectedPropertiesContainer.encode(selectedpropertylist0)
            }
        }
    }
}

extension GetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/value"
    }
}

public struct GetPropertyValueInput: Swift.Equatable {
    /// The name of the component whose property values the operation returns.
    public var componentName: Swift.String?
    /// The ID of the component type whose property values the operation returns.
    public var componentTypeId: Swift.String?
    /// The ID of the entity whose property values the operation returns.
    public var entityId: Swift.String?
    /// The properties whose values the operation returns.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The ID of the workspace whose values the operation returns.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentName: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        selectedProperties: [Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentTypeId = componentTypeId
        self.entityId = entityId
        self.selectedProperties = selectedProperties
        self.workspaceId = workspaceId
    }
}

struct GetPropertyValueInputBody: Swift.Equatable {
    let componentName: Swift.String?
    let componentTypeId: Swift.String?
    let entityId: Swift.String?
    let selectedProperties: [Swift.String]?
}

extension GetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case componentTypeId
        case entityId
        case selectedProperties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let selectedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedProperties)
        var selectedPropertiesDecoded0:[Swift.String]? = nil
        if let selectedPropertiesContainer = selectedPropertiesContainer {
            selectedPropertiesDecoded0 = [Swift.String]()
            for string0 in selectedPropertiesContainer {
                if let string0 = string0 {
                    selectedPropertiesDecoded0?.append(string0)
                }
            }
        }
        selectedProperties = selectedPropertiesDecoded0
    }
}

extension GetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorFailureException" : self = .connectorFailureException(try ConnectorFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectorTimeoutException" : self = .connectorTimeoutException(try ConnectorTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case connectorFailureException(ConnectorFailureException)
    case connectorTimeoutException(ConnectorTimeoutException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.propertyValues = output.propertyValues
        } else {
            self.propertyValues = nil
        }
    }
}

public struct GetPropertyValueOutputResponse: Swift.Equatable {
    /// An object that maps strings to the properties and latest property values in the response. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?

    public init (
        propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil
    )
    {
        self.propertyValues = propertyValues
    }
}

struct GetPropertyValueOutputResponseBody: Swift.Equatable {
    let propertyValues: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]?
}

extension GetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyValues
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValuesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyLatestValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyLatestValue]()
            for (key0, propertylatestvalue0) in propertyValuesContainer {
                if let propertylatestvalue0 = propertylatestvalue0 {
                    propertyValuesDecoded0?[key0] = propertylatestvalue0
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension GetSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct GetSceneInput: Swift.Equatable {
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct GetSceneInputBody: Swift.Equatable {
}

extension GetSceneInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.capabilities = output.capabilities
            self.contentLocation = output.contentLocation
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.sceneId = output.sceneId
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.capabilities = nil
            self.contentLocation = nil
            self.creationDateTime = nil
            self.description = nil
            self.sceneId = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetSceneOutputResponse: Swift.Equatable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.creationDateTime = creationDateTime
        self.description = description
        self.sceneId = sceneId
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetSceneOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let sceneId: Swift.String?
    let contentLocation: Swift.String?
    let arn: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
    let description: Swift.String?
    let capabilities: [Swift.String]?
}

extension GetSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case capabilities
        case contentLocation
        case creationDateTime
        case description
        case sceneId
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension GetWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct GetWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceInputBody: Swift.Equatable {
}

extension GetWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.role = output.role
            self.s3Location = output.s3Location
            self.updateDateTime = output.updateDateTime
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.role = nil
            self.s3Location = nil
            self.updateDateTime = nil
            self.workspaceId = nil
        }
    }
}

public struct GetWorkspaceOutputResponse: Swift.Equatable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: ClientRuntime.Date?
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    /// This member is required.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    /// This member is required.
    public var s3Location: Swift.String?
    /// The date and time when the workspace was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        updateDateTime: ClientRuntime.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

struct GetWorkspaceOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let s3Location: Swift.String?
    let role: Swift.String?
    let creationDateTime: ClientRuntime.Date?
    let updateDateTime: ClientRuntime.Date?
}

extension GetWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case role
        case s3Location
        case updateDateTime
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error has occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.InterpolationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolationType
        case intervalInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpolationType = interpolationType {
            try encodeContainer.encode(interpolationType.rawValue, forKey: .interpolationType)
        }
        if let intervalInSeconds = intervalInSeconds {
            try encodeContainer.encode(intervalInSeconds, forKey: .intervalInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolationTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.InterpolationType.self, forKey: .interpolationType)
        interpolationType = interpolationTypeDecoded
        let intervalInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intervalInSeconds)
        intervalInSeconds = intervalInSecondsDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies how to interpolate data in a list.
    public struct InterpolationParameters: Swift.Equatable {
        /// The interpolation type.
        public var interpolationType: IoTTwinMakerClientTypes.InterpolationType?
        /// The interpolation time interval in seconds.
        public var intervalInSeconds: Swift.Int?

        public init (
            interpolationType: IoTTwinMakerClientTypes.InterpolationType? = nil,
            intervalInSeconds: Swift.Int? = nil
        )
        {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum InterpolationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [InterpolationType] {
            return [
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InterpolationType(rawValue: rawValue) ?? InterpolationType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.LambdaFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The Lambda function.
    public struct LambdaFunction: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTTwinMakerClientTypes.ListComponentTypesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case extendsfrom = "extendsFrom"
        case isabstract = "isAbstract"
        case namespace
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .extendsfrom(extendsfrom):
                try container.encode(extendsfrom, forKey: .extendsfrom)
            case let .isabstract(isabstract):
                try container.encode(isabstract, forKey: .isabstract)
            case let .namespace(namespace):
                try container.encode(namespace, forKey: .namespace)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let extendsfromDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .extendsfrom)
        if let extendsfrom = extendsfromDecoded {
            self = .extendsfrom(extendsfrom)
            return
        }
        let namespaceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .namespace)
        if let namespace = namespaceDecoded {
            self = .namespace(namespace)
            return
        }
        let isabstractDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isabstract)
        if let isabstract = isabstractDecoded {
            self = .isabstract(isabstract)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of component types.
    public enum ListComponentTypesFilter: Swift.Equatable {
        /// The component type that the component types in the list extend.
        case extendsfrom(Swift.String)
        /// The namespace to which the component types in the list belong.
        case namespace(Swift.String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isabstract(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension ListComponentTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listcomponenttypesfilters0 in filters {
                try filtersContainer.encode(listcomponenttypesfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types-list"
    }
}

public struct ListComponentTypesInput: Swift.Equatable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListComponentTypesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListComponentTypesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComponentTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentTypeSummaries = output.componentTypeSummaries
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.workspaceId = output.workspaceId
        } else {
            self.componentTypeSummaries = nil
            self.maxResults = nil
            self.nextToken = nil
            self.workspaceId = nil
        }
    }
}

public struct ListComponentTypesOutputResponse: Swift.Equatable {
    /// A list of objects that contain information about the component types.
    /// This member is required.
    public var componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeSummaries = componentTypeSummaries
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListComponentTypesOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListComponentTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentTypeSummaries
        case maxResults
        case nextToken
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let componentTypeSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ComponentTypeSummary?].self, forKey: .componentTypeSummaries)
        var componentTypeSummariesDecoded0:[IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil
        if let componentTypeSummariesContainer = componentTypeSummariesContainer {
            componentTypeSummariesDecoded0 = [IoTTwinMakerClientTypes.ComponentTypeSummary]()
            for structure0 in componentTypeSummariesContainer {
                if let structure0 = structure0 {
                    componentTypeSummariesDecoded0?.append(structure0)
                }
            }
        }
        componentTypeSummaries = componentTypeSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension IoTTwinMakerClientTypes.ListEntitiesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componenttypeid = "componentTypeId"
        case parententityid = "parentEntityId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .componenttypeid(componenttypeid):
                try container.encode(componenttypeid, forKey: .componenttypeid)
            case let .parententityid(parententityid):
                try container.encode(parententityid, forKey: .parententityid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let parententityidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .parententityid)
        if let parententityid = parententityidDecoded {
            self = .parententityid(parententityid)
            return
        }
        let componenttypeidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .componenttypeid)
        if let componenttypeid = componenttypeidDecoded {
            self = .componenttypeid(componenttypeid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items in a list of entities.
    public enum ListEntitiesFilter: Swift.Equatable, Swift.Hashable {
        /// The parent of the entities in the list.
        case parententityid(Swift.String)
        /// The ID of the component type in the entities in the list.
        case componenttypeid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ListEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for listentitiesfilters0 in filters {
                try filtersContainer.encode(listentitiesfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities-list"
    }
}

public struct ListEntitiesInput: Swift.Equatable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListEntitiesInputBody: Swift.Equatable {
    let filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.ListEntitiesFilter?].self, forKey: .filters)
        var filtersDecoded0:[IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IoTTwinMakerClientTypes.ListEntitiesFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitySummaries = output.entitySummaries
            self.nextToken = output.nextToken
        } else {
            self.entitySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutputResponse: Swift.Equatable {
    /// A list of objects that contain information about the entities.
    public var entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init (
        entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaries = entitySummaries
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputResponseBody: Swift.Equatable {
    let entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    let nextToken: Swift.String?
}

extension ListEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.EntitySummary?].self, forKey: .entitySummaries)
        var entitySummariesDecoded0:[IoTTwinMakerClientTypes.EntitySummary]? = nil
        if let entitySummariesContainer = entitySummariesContainer {
            entitySummariesDecoded0 = [IoTTwinMakerClientTypes.EntitySummary]()
            for structure0 in entitySummariesContainer {
                if let structure0 = structure0 {
                    entitySummariesDecoded0?.append(structure0)
                }
            }
        }
        entitySummaries = entitySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScenesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListScenesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes-list"
    }
}

public struct ListScenesInput: Swift.Equatable {
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the scenes.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListScenesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListScenesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListScenesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListScenesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListScenesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListScenesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListScenesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sceneSummaries = output.sceneSummaries
        } else {
            self.nextToken = nil
            self.sceneSummaries = nil
        }
    }
}

public struct ListScenesOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the scenes.
    public var sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?

    public init (
        nextToken: Swift.String? = nil,
        sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sceneSummaries = sceneSummaries
    }
}

struct ListScenesOutputResponseBody: Swift.Equatable {
    let sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?
    let nextToken: Swift.String?
}

extension ListScenesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sceneSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.SceneSummary?].self, forKey: .sceneSummaries)
        var sceneSummariesDecoded0:[IoTTwinMakerClientTypes.SceneSummary]? = nil
        if let sceneSummariesContainer = sceneSummariesContainer {
            sceneSummariesDecoded0 = [IoTTwinMakerClientTypes.SceneSummary]()
            for structure0 in sceneSummariesContainer {
                if let structure0 = structure0 {
                    sceneSummariesDecoded0?.append(structure0)
                }
            }
        }
        sceneSummaries = sceneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags-list"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Metadata that you can use to manage a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workspaces-list"
    }
}

public struct ListWorkspacesInput: Swift.Equatable {
    /// The maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaceSummaries = output.workspaceSummaries
        } else {
            self.nextToken = nil
            self.workspaceSummaries = nil
        }
    }
}

public struct ListWorkspacesOutputResponse: Swift.Equatable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the workspaces.
    public var workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceSummaries = workspaceSummaries
    }
}

struct ListWorkspacesOutputResponseBody: Swift.Equatable {
    let workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?
    let nextToken: Swift.String?
}

extension ListWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaceSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceSummariesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.WorkspaceSummary?].self, forKey: .workspaceSummaries)
        var workspaceSummariesDecoded0:[IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
        if let workspaceSummariesContainer = workspaceSummariesContainer {
            workspaceSummariesDecoded0 = [IoTTwinMakerClientTypes.WorkspaceSummary]()
            for structure0 in workspaceSummariesContainer {
                if let structure0 = structure0 {
                    workspaceSummariesDecoded0?.append(structure0)
                }
            }
        }
        workspaceSummaries = workspaceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum OrderByTime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByTime] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderByTime(rawValue: rawValue) ?? OrderByTime.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.ParentEntityUpdateRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parentEntityId
        case updateType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parentEntityId = parentEntityId {
            try encodeContainer.encode(parentEntityId, forKey: .parentEntityId)
        }
        if let updateType = updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
        let parentEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentEntityId)
        parentEntityId = parentEntityIdDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The parent entity update request.
    public struct ParentEntityUpdateRequest: Swift.Equatable {
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The type of the update.
        /// This member is required.
        public var updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType?

        public init (
            parentEntityId: Swift.String? = nil,
            updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType? = nil
        )
        {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum ParentEntityUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ParentEntityUpdateType] {
            return [
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParentEntityUpdateType(rawValue: rawValue) ?? ParentEntityUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyDefinitionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case isExternalId
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let isExternalId = isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isRequiredInEntity = isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyDefinitionRequest: Swift.Equatable {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public var isTimeSeries: Swift.Bool?

        public init (
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            isExternalId: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyDefinitionResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case dataType
        case defaultValue
        case isExternalId
        case isFinal
        case isImported
        case isInherited
        case isRequiredInEntity
        case isStoredExternally
        case isTimeSeries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, configuration0) in configuration {
                try configurationContainer.encode(configuration0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let isExternalId = isExternalId {
            try encodeContainer.encode(isExternalId, forKey: .isExternalId)
        }
        if let isFinal = isFinal {
            try encodeContainer.encode(isFinal, forKey: .isFinal)
        }
        if let isImported = isImported {
            try encodeContainer.encode(isImported, forKey: .isImported)
        }
        if let isInherited = isInherited {
            try encodeContainer.encode(isInherited, forKey: .isInherited)
        }
        if let isRequiredInEntity = isRequiredInEntity {
            try encodeContainer.encode(isRequiredInEntity, forKey: .isRequiredInEntity)
        }
        if let isStoredExternally = isStoredExternally {
            try encodeContainer.encode(isStoredExternally, forKey: .isStoredExternally)
        }
        if let isTimeSeries = isTimeSeries {
            try encodeContainer.encode(isTimeSeries, forKey: .isTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimeSeries)
        isTimeSeries = isTimeSeriesDecoded
        let isRequiredInEntityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequiredInEntity)
        isRequiredInEntity = isRequiredInEntityDecoded
        let isExternalIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isExternalId)
        isExternalId = isExternalIdDecoded
        let isStoredExternallyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isStoredExternally)
        isStoredExternally = isStoredExternallyDecoded
        let isImportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isImported)
        isImported = isImportedDecoded
        let isFinalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isFinal)
        isFinal = isFinalDecoded
        let isInheritedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isInherited)
        isInherited = isInheritedDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in configurationContainer {
                if let value0 = value0 {
                    configurationDecoded0?[key0] = value0
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains response data from a property definition request.
    public struct PropertyDefinitionResponse: Swift.Equatable {
        /// A mapping that specifies configuration information about the property.
        public var configuration: [Swift.String:Swift.String]?
        /// An object that contains information about the data type.
        /// This member is required.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        /// This member is required.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property definition can be updated.
        /// This member is required.
        public var isFinal: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        /// This member is required.
        public var isImported: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// A Boolean value that specifies whether the property is required in an entity.
        /// This member is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        /// This member is required.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        /// This member is required.
        public var isTimeSeries: Swift.Bool?

        public init (
            configuration: [Swift.String:Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            isExternalId: Swift.Bool? = nil,
            isFinal: Swift.Bool? = nil,
            isImported: Swift.Bool? = nil,
            isInherited: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "operator"
        case propertyName
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let propertyName = propertyName {
            try encodeContainer.encode(propertyName, forKey: .propertyName)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyName)
        propertyName = propertyNameDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that filters items returned by a property request.
    public struct PropertyFilter: Swift.Equatable {
        /// The operator associated with this property filter.
        public var `operator`: Swift.String?
        /// The property name associated with this property filter.
        public var propertyName: Swift.String?
        /// The value associated with this property filter.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            `operator`: Swift.String? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyLatestValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyReference
        case propertyValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let propertyReference = propertyReference {
            try encodeContainer.encode(propertyReference, forKey: .propertyReference)
        }
        if let propertyValue = propertyValue {
            try encodeContainer.encode(propertyValue, forKey: .propertyValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .propertyReference)
        propertyReference = propertyReferenceDecoded
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// The latest value of the property.
    public struct PropertyLatestValue: Swift.Equatable {
        /// An object that specifies information about a property.>
        /// This member is required.
        public var propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// The value of the property.
        public var propertyValue: IoTTwinMakerClientTypes.DataValue?

        public init (
            propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValue: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case updateType
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let updateType = updateType {
            try encodeContainer.encode(updateType.rawValue, forKey: .updateType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionRequest.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
        let updateTypeDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyUpdateType.self, forKey: .updateType)
        updateType = updateTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that sets information about a property.
    public struct PropertyRequest: Swift.Equatable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest?
        /// The update type of the update property request.
        public var updateType: IoTTwinMakerClientTypes.PropertyUpdateType?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyUpdateType? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.PropertyDefinitionResponse.self, forKey: .definition)
        definition = definitionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a property response.
    public struct PropertyResponse: Swift.Equatable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum PropertyUpdateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyUpdateType] {
            return [
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyUpdateType(rawValue: rawValue) ?? PropertyUpdateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.PropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.DataValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a value for a time series property.
    public struct PropertyValue: Swift.Equatable {
        /// The timestamp of a value for a time series property.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// An object that specifies a value for a time series property.
        /// This member is required.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for propertyvalues0 in propertyValues {
                try propertyValuesContainer.encode(propertyvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies information about time series property values.
    public struct PropertyValueEntry: Swift.Equatable {
        /// An object that contains information about the entity that has the property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that specify time series property values.
        public var propertyValues: [IoTTwinMakerClientTypes.PropertyValue]?

        public init (
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValues: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }
    }

}

extension IoTTwinMakerClientTypes.PropertyValueHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityPropertyReference
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityPropertyReference = entityPropertyReference {
            try encodeContainer.encode(entityPropertyReference, forKey: .entityPropertyReference)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityPropertyReferenceDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.EntityPropertyReference.self, forKey: .entityPropertyReference)
        entityPropertyReference = entityPropertyReferenceDecoded
        let valuesContainer = try containerValues.decodeIfPresent([IoTTwinMakerClientTypes.PropertyValue?].self, forKey: .values)
        var valuesDecoded0:[IoTTwinMakerClientTypes.PropertyValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [IoTTwinMakerClientTypes.PropertyValue]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension IoTTwinMakerClientTypes {
    /// The history of values for a time series property.
    public struct PropertyValueHistory: Swift.Equatable {
        /// An object that uniquely identifies an entity property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that contain information about the values in the history of a time series property.
        public var values: [IoTTwinMakerClientTypes.PropertyValue]?

        public init (
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            values: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }
    }

}

extension IoTTwinMakerClientTypes.Relationship: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationshipType
        case targetComponentTypeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType, forKey: .relationshipType)
        }
        if let targetComponentTypeId = targetComponentTypeId {
            try encodeContainer.encode(targetComponentTypeId, forKey: .targetComponentTypeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetComponentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentTypeId)
        targetComponentTypeId = targetComponentTypeIdDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that specifies a relationship with another component type.
    public struct Relationship: Swift.Equatable {
        /// The type of the relationship.
        public var relationshipType: Swift.String?
        /// The ID of the target component type associated with this relationship.
        public var targetComponentTypeId: Swift.String?

        public init (
            relationshipType: Swift.String? = nil,
            targetComponentTypeId: Swift.String? = nil
        )
        {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }
    }

}

extension IoTTwinMakerClientTypes.RelationshipValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetComponentName
        case targetEntityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetComponentName = targetComponentName {
            try encodeContainer.encode(targetComponentName, forKey: .targetComponentName)
        }
        if let targetEntityId = targetEntityId {
            try encodeContainer.encode(targetEntityId, forKey: .targetEntityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEntityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEntityId)
        targetEntityId = targetEntityIdDecoded
        let targetComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetComponentName)
        targetComponentName = targetComponentNameDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// A value that associates a component and an entity.
    public struct RelationshipValue: Swift.Equatable {
        /// The name of the target component associated with the relationship value.
        public var targetComponentName: Swift.String?
        /// The ID of the target entity associated with this relationship value.
        public var targetEntityId: Swift.String?

        public init (
            targetComponentName: Swift.String? = nil,
            targetEntityId: Swift.String? = nil
        )
        {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.SceneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case contentLocation
        case creationDateTime
        case description
        case sceneId
        case updateDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let contentLocation = contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sceneId = sceneId {
            try encodeContainer.encode(sceneId, forKey: .sceneId)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sceneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sceneId)
        sceneId = sceneIdDecoded
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a scene.
    public struct SceneSummary: Swift.Equatable {
        /// The ARN of the scene.
        /// This member is required.
        public var arn: Swift.String?
        /// The relative path that specifies the location of the content definition file.
        /// This member is required.
        public var contentLocation: Swift.String?
        /// The date and time when the scene was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The scene description.
        public var description: Swift.String?
        /// The ID of the scene.
        /// This member is required.
        public var sceneId: Swift.String?
        /// The date and time when the scene was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            contentLocation: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            sceneId: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }
    }

}

extension IoTTwinMakerClientTypes {
    public enum Scope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entity
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [Scope] {
            return [
                .entity,
                .workspace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entity: return "ENTITY"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Scope(rawValue: rawValue) ?? Scope.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota was exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension IoTTwinMakerClientTypes.Status: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that represents the status of an entity, component, component type, or workspace.
    public struct Status: Swift.Equatable {
        /// The error message.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public var state: IoTTwinMakerClientTypes.State?

        public init (
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.State? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Metadata to add to this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of tags exceeds the limit.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case list
        case long
        case map
        case relationship
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .boolean,
                .double,
                .integer,
                .list,
                .long,
                .map,
                .relationship,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .list: return "LIST"
            case .long: return "LONG"
            case .map: return "MAP"
            case .relationship: return "RELATIONSHIP"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let resourceARN = resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "resourceARN".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateComponentTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let extendsFrom = extendsFrom {
            var extendsFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendsFrom)
            for extendsfrom0 in extendsFrom {
                try extendsFromContainer.encode(extendsfrom0)
            }
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .functions)
            for (dictKey0, functionsrequest0) in functions {
                try functionsContainer.encode(functionsrequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isSingleton = isSingleton {
            try encodeContainer.encode(isSingleton, forKey: .isSingleton)
        }
        if let propertyDefinitions = propertyDefinitions {
            var propertyDefinitionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .propertyDefinitions)
            for (dictKey0, propertydefinitionsrequest0) in propertyDefinitions {
                try propertyDefinitionsContainer.encode(propertydefinitionsrequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateComponentTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let componentTypeId = componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

public struct UpdateComponentTypeInput: Swift.Equatable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentTypeId: Swift.String? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeInputBody: Swift.Equatable {
    let isSingleton: Swift.Bool?
    let description: Swift.String?
    let propertyDefinitions: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    let extendsFrom: [Swift.String]?
    let functions: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]?
}

extension UpdateComponentTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case extendsFrom
        case functions
        case isSingleton
        case propertyDefinitions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSingletonDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSingleton)
        isSingleton = isSingletonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let propertyDefinitionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest?].self, forKey: .propertyDefinitions)
        var propertyDefinitionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil
        if let propertyDefinitionsContainer = propertyDefinitionsContainer {
            propertyDefinitionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.PropertyDefinitionRequest]()
            for (key0, propertydefinitionrequest0) in propertyDefinitionsContainer {
                if let propertydefinitionrequest0 = propertydefinitionrequest0 {
                    propertyDefinitionsDecoded0?[key0] = propertydefinitionrequest0
                }
            }
        }
        propertyDefinitions = propertyDefinitionsDecoded0
        let extendsFromContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .extendsFrom)
        var extendsFromDecoded0:[Swift.String]? = nil
        if let extendsFromContainer = extendsFromContainer {
            extendsFromDecoded0 = [Swift.String]()
            for string0 in extendsFromContainer {
                if let string0 = string0 {
                    extendsFromDecoded0?.append(string0)
                }
            }
        }
        extendsFrom = extendsFromDecoded0
        let functionsContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.FunctionRequest?].self, forKey: .functions)
        var functionsDecoded0: [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [Swift.String:IoTTwinMakerClientTypes.FunctionRequest]()
            for (key0, functionrequest0) in functionsContainer {
                if let functionrequest0 = functionrequest0 {
                    functionsDecoded0?[key0] = functionrequest0
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension UpdateComponentTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateComponentTypeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateComponentTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.componentTypeId = output.componentTypeId
            self.state = output.state
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.componentTypeId = nil
            self.state = nil
            self.workspaceId = nil
        }
    }
}

public struct UpdateComponentTypeOutputResponse: Swift.Equatable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.state = state
        self.workspaceId = workspaceId
    }
}

struct UpdateComponentTypeOutputResponseBody: Swift.Equatable {
    let workspaceId: Swift.String?
    let arn: Swift.String?
    let componentTypeId: Swift.String?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateComponentTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case componentTypeId
        case state
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let componentTypeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentTypeId)
        componentTypeId = componentTypeIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentUpdates = componentUpdates {
            var componentUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .componentUpdates)
            for (dictKey0, componentupdatesmaprequest0) in componentUpdates {
                try componentUpdatesContainer.encode(componentupdatesmaprequest0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityName = entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let parentEntityUpdate = parentEntityUpdate {
            try encodeContainer.encode(parentEntityUpdate, forKey: .parentEntityUpdate)
        }
    }
}

extension UpdateEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let entityId = entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

public struct UpdateEntityInput: Swift.Equatable {
    /// An object that maps strings to the component updates in the request. Each string in the mapping must be unique to this object.
    public var componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    public var entityName: Swift.String?
    /// An object that describes the update request for a parent entity.
    public var parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentUpdates = componentUpdates
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityUpdate = parentEntityUpdate
        self.workspaceId = workspaceId
    }
}

struct UpdateEntityInputBody: Swift.Equatable {
    let entityName: Swift.String?
    let description: Swift.String?
    let componentUpdates: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    let parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
}

extension UpdateEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentUpdates
        case description
        case entityName
        case parentEntityUpdate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let componentUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: IoTTwinMakerClientTypes.ComponentUpdateRequest?].self, forKey: .componentUpdates)
        var componentUpdatesDecoded0: [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil
        if let componentUpdatesContainer = componentUpdatesContainer {
            componentUpdatesDecoded0 = [Swift.String:IoTTwinMakerClientTypes.ComponentUpdateRequest]()
            for (key0, componentupdaterequest0) in componentUpdatesContainer {
                if let componentupdaterequest0 = componentupdaterequest0 {
                    componentUpdatesDecoded0?[key0] = componentupdaterequest0
                }
            }
        }
        componentUpdates = componentUpdatesDecoded0
        let parentEntityUpdateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.ParentEntityUpdateRequest.self, forKey: .parentEntityUpdate)
        parentEntityUpdate = parentEntityUpdateDecoded
    }
}

extension UpdateEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEntityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
            self.updateDateTime = output.updateDateTime
        } else {
            self.state = nil
            self.updateDateTime = nil
        }
    }
}

public struct UpdateEntityOutputResponse: Swift.Equatable {
    /// The current state of the entity update.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        state: IoTTwinMakerClientTypes.State? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.state = state
        self.updateDateTime = updateDateTime
    }
}

struct UpdateEntityOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
    let state: IoTTwinMakerClientTypes.State?
}

extension UpdateEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTTwinMakerClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateSceneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for scenecapabilities0 in capabilities {
                try capabilitiesContainer.encode(scenecapabilities0)
            }
        }
        if let contentLocation = contentLocation {
            try encodeContainer.encode(contentLocation, forKey: .contentLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateSceneInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        guard let sceneId = sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

public struct UpdateSceneInput: Swift.Equatable {
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    public var contentLocation: Swift.String?
    /// The description of this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

struct UpdateSceneInputBody: Swift.Equatable {
    let contentLocation: Swift.String?
    let description: Swift.String?
    let capabilities: [Swift.String]?
}

extension UpdateSceneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case contentLocation
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentLocation)
        contentLocation = contentLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension UpdateSceneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSceneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSceneOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSceneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSceneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateSceneOutputResponse: Swift.Equatable {
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateSceneOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateSceneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension UpdateWorkspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }
}

extension UpdateWorkspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workspaceId = workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

public struct UpdateWorkspaceInput: Swift.Equatable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let role: Swift.String?
}

extension UpdateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case role
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
    }
}

extension UpdateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateDateTime = output.updateDateTime
        } else {
            self.updateDateTime = nil
        }
    }
}

public struct UpdateWorkspaceOutputResponse: Swift.Equatable {
    /// The date and time of the current update.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

struct UpdateWorkspaceOutputResponseBody: Swift.Equatable {
    let updateDateTime: ClientRuntime.Date?
}

extension UpdateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateDateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Failed
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTTwinMakerClientTypes.WorkspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case updateDateTime
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension IoTTwinMakerClientTypes {
    /// An object that contains information about a workspace.
    public struct WorkspaceSummary: Swift.Equatable {
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the workspace was created.
        /// This member is required.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the workspace.
        public var description: Swift.String?
        /// The date and time when the workspace was last updated.
        /// This member is required.
        public var updateDateTime: ClientRuntime.Date?
        /// The ID of the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }

}
