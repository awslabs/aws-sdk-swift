// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension BaselineOverride: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case globalFilters = "GlobalFilters"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}
