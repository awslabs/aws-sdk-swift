// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountSharingInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension AccountSharingInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountSharingInfo(accountId: \(String(describing: accountId)), sharedDocumentVersion: \(String(describing: sharedDocumentVersion)))"}
}

/// <p>Information includes the AWS account ID where the current document is shared and the version
///    shared with that account.</p>
public struct AccountSharingInfo: Equatable {
    /// <p>The AWS account ID where the current document is shared.</p>
    public let accountId: String?
    /// <p>The version of the current document shared with the account.</p>
    public let sharedDocumentVersion: String?

    public init (
        accountId: String? = nil,
        sharedDocumentVersion: String? = nil
    )
    {
        self.accountId = accountId
        self.sharedDocumentVersion = sharedDocumentVersion
    }
}

extension Activation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationId = "ActivationId"
        case createdDate = "CreatedDate"
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case expired = "Expired"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case registrationsCount = "RegistrationsCount"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if expired != false {
            try encodeContainer.encode(expired, forKey: .expired)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if registrationsCount != 0 {
            try encodeContainer.encode(registrationsCount, forKey: .registrationsCount)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let registrationsCountDecoded = try containerValues.decode(Int.self, forKey: .registrationsCount)
        registrationsCount = registrationsCountDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let expiredDecoded = try containerValues.decode(Bool.self, forKey: .expired)
        expired = expiredDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Activation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Activation(activationId: \(String(describing: activationId)), createdDate: \(String(describing: createdDate)), defaultInstanceName: \(String(describing: defaultInstanceName)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), expired: \(String(describing: expired)), iamRole: \(String(describing: iamRole)), registrationLimit: \(String(describing: registrationLimit)), registrationsCount: \(String(describing: registrationsCount)), tags: \(String(describing: tags)))"}
}

/// <p>An activation registers one or more on-premises servers or virtual machines (VMs) with AWS
///    so that you can configure those servers or VMs using Run Command. A server or VM that has been
///    registered with AWS is called a managed instance.</p>
public struct Activation: Equatable {
    /// <p>The ID created by Systems Manager when you submitted the activation.</p>
    public let activationId: String?
    /// <p>The date the activation was created.</p>
    public let createdDate: Date?
    /// <p>A name for the managed instance when it is created.</p>
    public let defaultInstanceName: String?
    /// <p>A user defined description of the activation.</p>
    public let description: String?
    /// <p>The date when this activation can no longer be used to register managed instances.</p>
    public let expirationDate: Date?
    /// <p>Whether or not the activation is expired.</p>
    public let expired: Bool
    /// <p>The Amazon Identity and Access Management (IAM) role to assign to the managed
    ///    instance.</p>
    public let iamRole: String?
    /// <p>The maximum number of managed instances that can be registered using this activation.</p>
    public let registrationLimit: Int
    /// <p>The number of managed instances already registered with this activation.</p>
    public let registrationsCount: Int
    /// <p>Tags assigned to the activation.</p>
    public let tags: [Tag]?

    public init (
        activationId: String? = nil,
        createdDate: Date? = nil,
        defaultInstanceName: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        expired: Bool = false,
        iamRole: String? = nil,
        registrationLimit: Int = 0,
        registrationsCount: Int = 0,
        tags: [Tag]? = nil
    )
    {
        self.activationId = activationId
        self.createdDate = createdDate
        self.defaultInstanceName = defaultInstanceName
        self.description = description
        self.expirationDate = expirationDate
        self.expired = expired
        self.iamRole = iamRole
        self.registrationLimit = registrationLimit
        self.registrationsCount = registrationsCount
        self.tags = tags
    }
}

public struct AddTagsToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceInput(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), tags: \(String(describing: tags)))"}
}

extension AddTagsToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Equatable {
    /// <p>The resource ID you want to tag.</p>
    ///          <p>Use the ID of the resource. Here are some examples:</p>
    ///          <p>ManagedInstance: mi-012345abcde</p>
    ///          <p>MaintenanceWindow: mw-012345abcde</p>
    ///          <p>PatchBaseline: pb-012345abcde</p>
    ///          <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
    ///    Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
    ///    come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
    ///    an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
    ///    has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
    ///     <code>/aws/ssm/MyGroup/appmanager</code>.</p>
    ///          <p>For the Document and Parameter values, use the name of the resource.</p>
    ///          <note>
    ///             <p>The ManagedInstance type for this API action is only for on-premises managed instances. You
    ///     must specify the name of the managed instance in the following format: mi-ID_number. For
    ///     example, mi-1a2b3c4d5e6f.</p>
    ///          </note>
    public let resourceId: String?
    /// <p>Specifies the type of resource you are tagging.</p>
    ///          <note>
    ///             <p>The ManagedInstance type for this API action is for on-premises managed instances. You must
    ///     specify the name of the managed instance in the following format: mi-ID_number. For example,
    ///     mi-1a2b3c4d5e6f.</p>
    ///          </note>
    public let resourceType: ResourceTypeForTagging?
    /// <p>One or more tags. The value parameter is required.</p>
    ///          <important>
    ///             <p>Do not enter personally identifiable information in this field.</p>
    ///          </important>
    public let tags: [Tag]?

    public init (
        resourceId: String? = nil,
        resourceType: ResourceTypeForTagging? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Equatable {
    public let resourceType: ResourceTypeForTagging?
    public let resourceId: String?
    public let tags: [Tag]?
}

extension AddTagsToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsError" : self = .tooManyTagsError(try TooManyTagsError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyTagsError(TooManyTagsError)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Equatable {
}

extension AddTagsToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error returned if an attempt is made to register a patch group with a patch baseline that is
///    already registered with a different patch baseline.</p>
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateOpsItemRelatedItemInputBodyMiddleware: Middleware {
    public let id: String = "AssociateOpsItemRelatedItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateOpsItemRelatedItemOutputError>
}

extension AssociateOpsItemRelatedItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateOpsItemRelatedItemInput(associationType: \(String(describing: associationType)), opsItemId: \(String(describing: opsItemId)), resourceType: \(String(describing: resourceType)), resourceUri: \(String(describing: resourceUri)))"}
}

extension AssociateOpsItemRelatedItemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }
}

public struct AssociateOpsItemRelatedItemInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateOpsItemRelatedItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateOpsItemRelatedItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<AssociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateOpsItemRelatedItemOutputError>
}

public struct AssociateOpsItemRelatedItemInput: Equatable {
    /// <p>The type of association that you want to create between an OpsItem and a resource. OpsCenter
    ///    supports <code>IsParentOf</code> and <code>RelatesTo</code> association types.</p>
    public let associationType: String?
    /// <p>The ID of the OpsItem to which you want to associate a resource as a related item.</p>
    public let opsItemId: String?
    /// <p>The type of resource that you want to associate with an OpsItem. OpsCenter supports the
    ///    following types:</p>
    ///          <p>
    ///             <code>AWS::SSMIncidents::IncidentRecord</code>: an Incident Manager incident. Incident
    ///    Manager is a capability of AWS Systems Manager.</p>
    ///          <p>
    ///             <code>AWS::SSM::Document</code>: a Systems Manager (SSM) document.</p>
    public let resourceType: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS resource that you want to associate with the
    ///    OpsItem.</p>
    public let resourceUri: String?

    public init (
        associationType: String? = nil,
        opsItemId: String? = nil,
        resourceType: String? = nil,
        resourceUri: String? = nil
    )
    {
        self.associationType = associationType
        self.opsItemId = opsItemId
        self.resourceType = resourceType
        self.resourceUri = resourceUri
    }
}

struct AssociateOpsItemRelatedItemInputBody: Equatable {
    public let opsItemId: String?
    public let associationType: String?
    public let resourceType: String?
    public let resourceUri: String?
}

extension AssociateOpsItemRelatedItemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationType = "AssociationType"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
    }
}

extension AssociateOpsItemRelatedItemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateOpsItemRelatedItemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAlreadyExistsException" : self = .opsItemRelatedItemAlreadyExistsException(try OpsItemRelatedItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateOpsItemRelatedItemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAlreadyExistsException(OpsItemRelatedItemAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateOpsItemRelatedItemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateOpsItemRelatedItemOutputResponse(associationId: \(String(describing: associationId)))"}
}

extension AssociateOpsItemRelatedItemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateOpsItemRelatedItemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationId = output.associationId
        } else {
            self.associationId = nil
        }
    }
}

public struct AssociateOpsItemRelatedItemOutputResponse: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?

    public init (
        associationId: String? = nil
    )
    {
        self.associationId = associationId
    }
}

struct AssociateOpsItemRelatedItemOutputResponseBody: Equatable {
    public let associationId: String?
}

extension AssociateOpsItemRelatedItemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension AssociatedInstances: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatedInstances()"}
}

extension AssociatedInstances: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You must disassociate a document from all instances before you can delete it.</p>
public struct AssociatedInstances: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension Association: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case name = "Name"
        case overview = "Overview"
        case scheduleExpression = "ScheduleExpression"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension Association: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Association(associationId: \(String(describing: associationId)), associationName: \(String(describing: associationName)), associationVersion: \(String(describing: associationVersion)), documentVersion: \(String(describing: documentVersion)), instanceId: \(String(describing: instanceId)), lastExecutionDate: \(String(describing: lastExecutionDate)), name: \(String(describing: name)), overview: \(String(describing: overview)), scheduleExpression: \(String(describing: scheduleExpression)), targets: \(String(describing: targets)))"}
}

/// <p>Describes an association of a Systems Manager document and an instance.</p>
public struct Association: Equatable {
    /// <p>The ID created by the system when you create an association. An association is a binding
    ///    between a document and a set of targets with a schedule.</p>
    public let associationId: String?
    /// <p>The association name.</p>
    public let associationName: String?
    /// <p>The association version.</p>
    public let associationVersion: String?
    /// <p>The version of the document used in the association.</p>
    public let documentVersion: String?
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>The date on which the association was last run.</p>
    public let lastExecutionDate: Date?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>Information about the association.</p>
    public let overview: AssociationOverview?
    /// <p>A cron expression that specifies a schedule when the association runs. The schedule runs in
    ///    Coordinated Universal Time (UTC).</p>
    public let scheduleExpression: String?
    /// <p>The instances targeted by the request to create an association. </p>
    public let targets: [Target]?

    public init (
        associationId: String? = nil,
        associationName: String? = nil,
        associationVersion: String? = nil,
        documentVersion: String? = nil,
        instanceId: String? = nil,
        lastExecutionDate: Date? = nil,
        name: String? = nil,
        overview: AssociationOverview? = nil,
        scheduleExpression: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.lastExecutionDate = lastExecutionDate
        self.name = name
        self.overview = overview
        self.scheduleExpression = scheduleExpression
        self.targets = targets
    }
}

extension AssociationAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationAlreadyExists()"}
}

extension AssociationAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified association already exists.</p>
public struct AssociationAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

public enum AssociationComplianceSeverity {
    case critical
    case high
    case low
    case medium
    case unspecified
    case sdkUnknown(String)
}

extension AssociationComplianceSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationComplianceSeverity] {
        return [
            .critical,
            .high,
            .low,
            .medium,
            .unspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .unspecified: return "UNSPECIFIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationComplianceSeverity(rawValue: rawValue) ?? AssociationComplianceSeverity.sdkUnknown(rawValue)
    }
}

extension AssociationDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case date = "Date"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case lastExecutionDate = "LastExecutionDate"
        case lastSuccessfulExecutionDate = "LastSuccessfulExecutionDate"
        case lastUpdateAssociationDate = "LastUpdateAssociationDate"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case overview = "Overview"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case status = "Status"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let lastSuccessfulExecutionDate = lastSuccessfulExecutionDate {
            try encodeContainer.encode(lastSuccessfulExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulExecutionDate)
        }
        if let lastUpdateAssociationDate = lastUpdateAssociationDate {
            try encodeContainer.encode(lastUpdateAssociationDate.timeIntervalSince1970, forKey: .lastUpdateAssociationDate)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let overview = overview {
            try encodeContainer.encode(overview, forKey: .overview)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
        let lastUpdateAssociationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateAssociationDate)
        lastUpdateAssociationDate = lastUpdateAssociationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssociationStatus.self, forKey: .status)
        status = statusDecoded
        let overviewDecoded = try containerValues.decodeIfPresent(AssociationOverview.self, forKey: .overview)
        overview = overviewDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let lastSuccessfulExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulExecutionDate)
        lastSuccessfulExecutionDate = lastSuccessfulExecutionDateDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension AssociationDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationDescription(applyOnlyAtCronInterval: \(String(describing: applyOnlyAtCronInterval)), associationId: \(String(describing: associationId)), associationName: \(String(describing: associationName)), associationVersion: \(String(describing: associationVersion)), automationTargetParameterName: \(String(describing: automationTargetParameterName)), calendarNames: \(String(describing: calendarNames)), complianceSeverity: \(String(describing: complianceSeverity)), date: \(String(describing: date)), documentVersion: \(String(describing: documentVersion)), instanceId: \(String(describing: instanceId)), lastExecutionDate: \(String(describing: lastExecutionDate)), lastSuccessfulExecutionDate: \(String(describing: lastSuccessfulExecutionDate)), lastUpdateAssociationDate: \(String(describing: lastUpdateAssociationDate)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), overview: \(String(describing: overview)), parameters: \(String(describing: parameters)), scheduleExpression: \(String(describing: scheduleExpression)), status: \(String(describing: status)), syncCompliance: \(String(describing: syncCompliance)), targetLocations: \(String(describing: targetLocations)), targets: \(String(describing: targets)))"}
}

/// <p>Describes the parameters for a document.</p>
public struct AssociationDescription: Equatable {
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    ///    created and then according to the schedule you specified. Specify this option if you don't want
    ///    an association to run immediately after you create it. This parameter is not supported for rate
    ///    expressions.</p>
    public let applyOnlyAtCronInterval: Bool
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>The association name.</p>
    public let associationName: String?
    /// <p>The association version.</p>
    public let associationVersion: String?
    /// <p>Specify the target for the association. This target is required for associations that use an
    ///    Automation document and target resources by using rate controls.</p>
    public let automationTargetParameterName: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    ///   documents your associations are gated under. The associations only run when that Change
    ///   Calendar is open. For more information, see
    ///   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    public let calendarNames: [String]?
    /// <p>The severity level that is assigned to the association.</p>
    public let complianceSeverity: AssociationComplianceSeverity?
    /// <p>The date when the association was made.</p>
    public let date: Date?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>The date on which the association was last run.</p>
    public let lastExecutionDate: Date?
    /// <p>The last date on which the association was successfully run.</p>
    public let lastSuccessfulExecutionDate: Date?
    /// <p>The date when the association was last updated.</p>
    public let lastUpdateAssociationDate: Date?
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    ///    specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    ///    value is 100%, which means all targets run the association at the same time.</p>
    ///          <p>If a new instance starts and attempts to run an association while Systems Manager is running
    ///    MaxConcurrency associations, the association is allowed to run. During the next association
    ///    interval, the new instance will process its association within the limit specified for
    ///    MaxConcurrency.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    ///    association on additional targets. You can specify either an absolute number of errors, for
    ///    example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    ///    the system stops sending requests when the fourth error is received. If you specify 0, then the
    ///    system stops sending requests after the first error is returned. If you run an association on 50
    ///    instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    ///    is received.</p>
    ///          <p>Executions that are already running an association when MaxErrors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>An S3 bucket where you want to store the output details of the request.</p>
    public let outputLocation: InstanceAssociationOutputLocation?
    /// <p>Information about the association.</p>
    public let overview: AssociationOverview?
    /// <p>A description of the parameters for a document. </p>
    public let parameters: [String:[String]]?
    /// <p>A cron expression that specifies a schedule when the association runs.</p>
    public let scheduleExpression: String?
    /// <p>The association status.</p>
    public let status: AssociationStatus?
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    ///     <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    ///    execution to determine the compliance status. If the association execution runs successfully,
    ///    then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    ///    successfully, the association is <code>NON-COMPLIANT</code>.</p>
    ///          <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    ///    for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    ///    managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    ///          <p>By default, all associations use <code>AUTO</code> mode.</p>
    public let syncCompliance: AssociationSyncCompliance?
    /// <p>The combination of AWS Regions and AWS accounts where you want to run the
    ///    association.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The instances targeted by the request. </p>
    public let targets: [Target]?

    public init (
        applyOnlyAtCronInterval: Bool = false,
        associationId: String? = nil,
        associationName: String? = nil,
        associationVersion: String? = nil,
        automationTargetParameterName: String? = nil,
        calendarNames: [String]? = nil,
        complianceSeverity: AssociationComplianceSeverity? = nil,
        date: Date? = nil,
        documentVersion: String? = nil,
        instanceId: String? = nil,
        lastExecutionDate: Date? = nil,
        lastSuccessfulExecutionDate: Date? = nil,
        lastUpdateAssociationDate: Date? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        outputLocation: InstanceAssociationOutputLocation? = nil,
        overview: AssociationOverview? = nil,
        parameters: [String:[String]]? = nil,
        scheduleExpression: String? = nil,
        status: AssociationStatus? = nil,
        syncCompliance: AssociationSyncCompliance? = nil,
        targetLocations: [TargetLocation]? = nil,
        targets: [Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.date = date
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.lastExecutionDate = lastExecutionDate
        self.lastSuccessfulExecutionDate = lastSuccessfulExecutionDate
        self.lastUpdateAssociationDate = lastUpdateAssociationDate
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.overview = overview
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.status = status
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

extension AssociationDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationDoesNotExist(message: \(String(describing: message)))"}
}

extension AssociationDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociationDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified association does not exist.</p>
public struct AssociationDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationDoesNotExistBody: Equatable {
    public let message: String?
}

extension AssociationDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociationExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case createdTime = "CreatedTime"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case resourceCountByStatus = "ResourceCountByStatus"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let resourceCountByStatus = resourceCountByStatus {
            try encodeContainer.encode(resourceCountByStatus, forKey: .resourceCountByStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let resourceCountByStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceCountByStatus)
        resourceCountByStatus = resourceCountByStatusDecoded
    }
}

extension AssociationExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationExecution(associationId: \(String(describing: associationId)), associationVersion: \(String(describing: associationVersion)), createdTime: \(String(describing: createdTime)), detailedStatus: \(String(describing: detailedStatus)), executionId: \(String(describing: executionId)), lastExecutionDate: \(String(describing: lastExecutionDate)), resourceCountByStatus: \(String(describing: resourceCountByStatus)), status: \(String(describing: status)))"}
}

/// <p>Includes information about the specified association.</p>
public struct AssociationExecution: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>The association version.</p>
    public let associationVersion: String?
    /// <p>The time the execution started.</p>
    public let createdTime: Date?
    /// <p>Detailed status information about the execution.</p>
    public let detailedStatus: String?
    /// <p>The execution ID for the association.</p>
    public let executionId: String?
    /// <p>The date of the last execution.</p>
    public let lastExecutionDate: Date?
    /// <p>An aggregate status of the resources in the execution based on the status type.</p>
    public let resourceCountByStatus: String?
    /// <p>The status of the association execution.</p>
    public let status: String?

    public init (
        associationId: String? = nil,
        associationVersion: String? = nil,
        createdTime: Date? = nil,
        detailedStatus: String? = nil,
        executionId: String? = nil,
        lastExecutionDate: Date? = nil,
        resourceCountByStatus: String? = nil,
        status: String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.createdTime = createdTime
        self.detailedStatus = detailedStatus
        self.executionId = executionId
        self.lastExecutionDate = lastExecutionDate
        self.resourceCountByStatus = resourceCountByStatus
        self.status = status
    }
}

extension AssociationExecutionDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationExecutionDoesNotExist(message: \(String(describing: message)))"}
}

extension AssociationExecutionDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociationExecutionDoesNotExistBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified execution ID does not exist. Verify the ID number and try again.</p>
public struct AssociationExecutionDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationExecutionDoesNotExistBody: Equatable {
    public let message: String?
}

extension AssociationExecutionDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociationExecutionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AssociationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AssociationFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AssociationExecutionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationExecutionFilter(key: \(String(describing: key)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Filters used in the request.</p>
public struct AssociationExecutionFilter: Equatable {
    /// <p>The key value used in the request.</p>
    public let key: AssociationExecutionFilterKey?
    /// <p>The filter type specified in the request.</p>
    public let type: AssociationFilterOperatorType?
    /// <p>The value specified for the key.</p>
    public let value: String?

    public init (
        key: AssociationExecutionFilterKey? = nil,
        type: AssociationFilterOperatorType? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.type = type
        self.value = value
    }
}

public enum AssociationExecutionFilterKey {
    case createdtime
    case executionid
    case status
    case sdkUnknown(String)
}

extension AssociationExecutionFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationExecutionFilterKey] {
        return [
            .createdtime,
            .executionid,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createdtime: return "CreatedTime"
        case .executionid: return "ExecutionId"
        case .status: return "Status"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationExecutionFilterKey(rawValue: rawValue) ?? AssociationExecutionFilterKey.sdkUnknown(rawValue)
    }
}

extension AssociationExecutionTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case executionId = "ExecutionId"
        case lastExecutionDate = "LastExecutionDate"
        case outputSource = "OutputSource"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let outputSource = outputSource {
            try encodeContainer.encode(outputSource, forKey: .outputSource)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let outputSourceDecoded = try containerValues.decodeIfPresent(OutputSource.self, forKey: .outputSource)
        outputSource = outputSourceDecoded
    }
}

extension AssociationExecutionTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationExecutionTarget(associationId: \(String(describing: associationId)), associationVersion: \(String(describing: associationVersion)), detailedStatus: \(String(describing: detailedStatus)), executionId: \(String(describing: executionId)), lastExecutionDate: \(String(describing: lastExecutionDate)), outputSource: \(String(describing: outputSource)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), status: \(String(describing: status)))"}
}

/// <p>Includes information about the specified association execution.</p>
public struct AssociationExecutionTarget: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>The association version.</p>
    public let associationVersion: String?
    /// <p>Detailed information about the execution status.</p>
    public let detailedStatus: String?
    /// <p>The execution ID.</p>
    public let executionId: String?
    /// <p>The date of the last execution.</p>
    public let lastExecutionDate: Date?
    /// <p>The location where the association details are saved.</p>
    public let outputSource: OutputSource?
    /// <p>The resource ID, for example, the instance ID where the association ran.</p>
    public let resourceId: String?
    /// <p>The resource type, for example, instance.</p>
    public let resourceType: String?
    /// <p>The association execution status.</p>
    public let status: String?

    public init (
        associationId: String? = nil,
        associationVersion: String? = nil,
        detailedStatus: String? = nil,
        executionId: String? = nil,
        lastExecutionDate: Date? = nil,
        outputSource: OutputSource? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        status: String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.detailedStatus = detailedStatus
        self.executionId = executionId
        self.lastExecutionDate = lastExecutionDate
        self.outputSource = outputSource
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.status = status
    }
}

extension AssociationExecutionTargetsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AssociationExecutionTargetsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AssociationExecutionTargetsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationExecutionTargetsFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Filters for the association execution.</p>
public struct AssociationExecutionTargetsFilter: Equatable {
    /// <p>The key value used in the request.</p>
    public let key: AssociationExecutionTargetsFilterKey?
    /// <p>The value specified for the key.</p>
    public let value: String?

    public init (
        key: AssociationExecutionTargetsFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum AssociationExecutionTargetsFilterKey {
    case resourceid
    case resourcetype
    case status
    case sdkUnknown(String)
}

extension AssociationExecutionTargetsFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationExecutionTargetsFilterKey] {
        return [
            .resourceid,
            .resourcetype,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resourceid: return "ResourceId"
        case .resourcetype: return "ResourceType"
        case .status: return "Status"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationExecutionTargetsFilterKey(rawValue: rawValue) ?? AssociationExecutionTargetsFilterKey.sdkUnknown(rawValue)
    }
}

extension AssociationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AssociationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AssociationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a filter.</p>
public struct AssociationFilter: Equatable {
    /// <p>The name of the filter.</p>
    ///          <note>
    ///             <p>
    ///                <code>InstanceId</code> has been deprecated.</p>
    ///          </note>
    public let key: AssociationFilterKey?
    /// <p>The filter value.</p>
    public let value: String?

    public init (
        key: AssociationFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum AssociationFilterKey {
    case associationid
    case associationname
    case instanceid
    case lastexecutedafter
    case lastexecutedbefore
    case name
    case resourcegroupname
    case status
    case sdkUnknown(String)
}

extension AssociationFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationFilterKey] {
        return [
            .associationid,
            .associationname,
            .instanceid,
            .lastexecutedafter,
            .lastexecutedbefore,
            .name,
            .resourcegroupname,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associationid: return "AssociationId"
        case .associationname: return "AssociationName"
        case .instanceid: return "InstanceId"
        case .lastexecutedafter: return "LastExecutedAfter"
        case .lastexecutedbefore: return "LastExecutedBefore"
        case .name: return "Name"
        case .resourcegroupname: return "ResourceGroupName"
        case .status: return "AssociationStatusName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationFilterKey(rawValue: rawValue) ?? AssociationFilterKey.sdkUnknown(rawValue)
    }
}

public enum AssociationFilterOperatorType {
    case equal
    case greaterthan
    case lessthan
    case sdkUnknown(String)
}

extension AssociationFilterOperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationFilterOperatorType] {
        return [
            .equal,
            .greaterthan,
            .lessthan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "EQUAL"
        case .greaterthan: return "GREATER_THAN"
        case .lessthan: return "LESS_THAN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationFilterOperatorType(rawValue: rawValue) ?? AssociationFilterOperatorType.sdkUnknown(rawValue)
    }
}

extension AssociationLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationLimitExceeded()"}
}

extension AssociationLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can have at most 2,000 active associations.</p>
public struct AssociationLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension AssociationOverview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationStatusAggregatedCount = "AssociationStatusAggregatedCount"
        case detailedStatus = "DetailedStatus"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatusAggregatedCount = associationStatusAggregatedCount {
            var associationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .associationStatusAggregatedCount)
            for (dictKey0, associationstatusaggregatedcount0) in associationStatusAggregatedCount {
                try associationStatusAggregatedCountContainer.encode(associationstatusaggregatedcount0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let associationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .associationStatusAggregatedCount)
        var associationStatusAggregatedCountDecoded0: [String:Int]? = nil
        if let associationStatusAggregatedCountContainer = associationStatusAggregatedCountContainer {
            associationStatusAggregatedCountDecoded0 = [String:Int]()
            for (key0, instancecount0) in associationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    associationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        associationStatusAggregatedCount = associationStatusAggregatedCountDecoded0
    }
}

extension AssociationOverview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationOverview(associationStatusAggregatedCount: \(String(describing: associationStatusAggregatedCount)), detailedStatus: \(String(describing: detailedStatus)), status: \(String(describing: status)))"}
}

/// <p>Information about the association.</p>
public struct AssociationOverview: Equatable {
    /// <p>Returns the number of targets for the association status. For example, if you created an
    ///    association with two instances, and one of them was successful, this would return the count of
    ///    instances by status.</p>
    public let associationStatusAggregatedCount: [String:Int]?
    /// <p>A detailed status of the association.</p>
    public let detailedStatus: String?
    /// <p>The status of the association. Status can be: Pending, Success, or Failed.</p>
    public let status: String?

    public init (
        associationStatusAggregatedCount: [String:Int]? = nil,
        detailedStatus: String? = nil,
        status: String? = nil
    )
    {
        self.associationStatusAggregatedCount = associationStatusAggregatedCount
        self.detailedStatus = detailedStatus
        self.status = status
    }
}

extension AssociationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalInfo = "AdditionalInfo"
        case date = "Date"
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            try encodeContainer.encode(additionalInfo, forKey: .additionalInfo)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(AssociationStatusName.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
    }
}

extension AssociationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationStatus(additionalInfo: \(String(describing: additionalInfo)), date: \(String(describing: date)), message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Describes an association status.</p>
public struct AssociationStatus: Equatable {
    /// <p>A user-defined string.</p>
    public let additionalInfo: String?
    /// <p>The date when the status changed.</p>
    public let date: Date?
    /// <p>The reason for the status.</p>
    public let message: String?
    /// <p>The status.</p>
    public let name: AssociationStatusName?

    public init (
        additionalInfo: String? = nil,
        date: Date? = nil,
        message: String? = nil,
        name: AssociationStatusName? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.date = date
        self.message = message
        self.name = name
    }
}

public enum AssociationStatusName {
    case failed
    case pending
    case success
    case sdkUnknown(String)
}

extension AssociationStatusName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationStatusName] {
        return [
            .failed,
            .pending,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .pending: return "Pending"
        case .success: return "Success"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationStatusName(rawValue: rawValue) ?? AssociationStatusName.sdkUnknown(rawValue)
    }
}

public enum AssociationSyncCompliance {
    case auto
    case manual
    case sdkUnknown(String)
}

extension AssociationSyncCompliance : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssociationSyncCompliance] {
        return [
            .auto,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "AUTO"
        case .manual: return "MANUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssociationSyncCompliance(rawValue: rawValue) ?? AssociationSyncCompliance.sdkUnknown(rawValue)
    }
}

extension AssociationVersionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case createdDate = "CreatedDate"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension AssociationVersionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationVersionInfo(applyOnlyAtCronInterval: \(String(describing: applyOnlyAtCronInterval)), associationId: \(String(describing: associationId)), associationName: \(String(describing: associationName)), associationVersion: \(String(describing: associationVersion)), calendarNames: \(String(describing: calendarNames)), complianceSeverity: \(String(describing: complianceSeverity)), createdDate: \(String(describing: createdDate)), documentVersion: \(String(describing: documentVersion)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), parameters: \(String(describing: parameters)), scheduleExpression: \(String(describing: scheduleExpression)), syncCompliance: \(String(describing: syncCompliance)), targetLocations: \(String(describing: targetLocations)), targets: \(String(describing: targets)))"}
}

/// <p>Information about the association version.</p>
public struct AssociationVersionInfo: Equatable {
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    ///    created and then according to the schedule you specified. Specify this option if you don't want
    ///    an association to run immediately after you create it. This parameter is not supported for rate
    ///    expressions.</p>
    public let applyOnlyAtCronInterval: Bool
    /// <p>The ID created by the system when the association was created.</p>
    public let associationId: String?
    /// <p>The name specified for the association version when the association version was
    ///    created.</p>
    public let associationName: String?
    /// <p>The association version.</p>
    public let associationVersion: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    ///   documents your associations are gated under. The associations for this version only run when
    ///   that Change Calendar is open.  For more information, see
    ///   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    public let calendarNames: [String]?
    /// <p>The severity level that is assigned to the association.</p>
    public let complianceSeverity: AssociationComplianceSeverity?
    /// <p>The date the association version was created.</p>
    public let createdDate: Date?
    /// <p>The version of a Systems Manager document used when the association version was created.</p>
    public let documentVersion: String?
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    ///    specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    ///    value is 100%, which means all targets run the association at the same time.</p>
    ///          <p>If a new instance starts and attempts to run an association while Systems Manager is running
    ///    MaxConcurrency associations, the association is allowed to run. During the next association
    ///    interval, the new instance will process its association within the limit specified for
    ///    MaxConcurrency.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    ///    association on additional targets. You can specify either an absolute number of errors, for
    ///    example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    ///    the system stops sending requests when the fourth error is received. If you specify 0, then the
    ///    system stops sending requests after the first error is returned. If you run an association on 50
    ///    instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    ///    is received.</p>
    ///          <p>Executions that are already running an association when MaxErrors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The name specified when the association was created.</p>
    public let name: String?
    /// <p>The location in Amazon S3 specified for the association when the association version was
    ///    created.</p>
    public let outputLocation: InstanceAssociationOutputLocation?
    /// <p>Parameters specified when the association version was created.</p>
    public let parameters: [String:[String]]?
    /// <p>The cron or rate schedule specified for the association when the association version was
    ///    created.</p>
    public let scheduleExpression: String?
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    ///     <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    ///    execution to determine the compliance status. If the association execution runs successfully,
    ///    then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    ///    successfully, the association is <code>NON-COMPLIANT</code>.</p>
    ///          <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    ///    for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    ///    managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    ///          <p>By default, all associations use <code>AUTO</code> mode.</p>
    public let syncCompliance: AssociationSyncCompliance?
    /// <p>The combination of AWS Regions and AWS accounts where you wanted to run the association when
    ///    this association version was created.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The targets specified for the association when the association version was created. </p>
    public let targets: [Target]?

    public init (
        applyOnlyAtCronInterval: Bool = false,
        associationId: String? = nil,
        associationName: String? = nil,
        associationVersion: String? = nil,
        calendarNames: [String]? = nil,
        complianceSeverity: AssociationComplianceSeverity? = nil,
        createdDate: Date? = nil,
        documentVersion: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        outputLocation: InstanceAssociationOutputLocation? = nil,
        parameters: [String:[String]]? = nil,
        scheduleExpression: String? = nil,
        syncCompliance: AssociationSyncCompliance? = nil,
        targetLocations: [TargetLocation]? = nil,
        targets: [Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.createdDate = createdDate
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

extension AssociationVersionLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociationVersionLimitExceeded(message: \(String(describing: message)))"}
}

extension AssociationVersionLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociationVersionLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number versions allowed for an association. Each association
///    has a limit of 1,000 versions. </p>
public struct AssociationVersionLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AssociationVersionLimitExceededBody: Equatable {
    public let message: String?
}

extension AssociationVersionLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hash = "Hash"
        case hashType = "HashType"
        case name = "Name"
        case size = "Size"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let hashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(AttachmentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension AttachmentContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentContent(hash: \(String(describing: hash)), hashType: \(String(describing: hashType)), name: \(String(describing: name)), size: \(String(describing: size)), url: \(String(describing: url)))"}
}

/// <p>A structure that includes attributes that describe a document attachment.</p>
public struct AttachmentContent: Equatable {
    /// <p>The cryptographic hash value of the document content.</p>
    public let hash: String?
    /// <p>The hash algorithm used to calculate the hash value.</p>
    public let hashType: AttachmentHashType?
    /// <p>The name of an attachment.</p>
    public let name: String?
    /// <p>The size of an attachment in bytes.</p>
    public let size: Int
    /// <p>The URL location of the attachment content.</p>
    public let url: String?

    public init (
        hash: String? = nil,
        hashType: AttachmentHashType? = nil,
        name: String? = nil,
        size: Int = 0,
        url: String? = nil
    )
    {
        self.hash = hash
        self.hashType = hashType
        self.name = name
        self.size = size
        self.url = url
    }
}

public enum AttachmentHashType {
    case sha256
    case sdkUnknown(String)
}

extension AttachmentHashType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttachmentHashType] {
        return [
            .sha256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sha256: return "Sha256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttachmentHashType(rawValue: rawValue) ?? AttachmentHashType.sdkUnknown(rawValue)
    }
}

extension AttachmentInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AttachmentInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentInformation(name: \(String(describing: name)))"}
}

/// <p>An attribute of an attachment, such as the attachment name.</p>
public struct AttachmentInformation: Equatable {
    /// <p>The name of the attachment.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension AttachmentsSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for attachmentssourcevalues0 in values {
                try valuesContainer.encode(attachmentssourcevalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AttachmentsSourceKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AttachmentsSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentsSource(key: \(String(describing: key)), name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Identifying information about a document attachment, including the file name and a key-value
///    pair that identifies the location of an attachment to a document.</p>
public struct AttachmentsSource: Equatable {
    /// <p>The key of a key-value pair that identifies the location of an attachment to a
    ///    document.</p>
    public let key: AttachmentsSourceKey?
    /// <p>The name of the document attachment file.</p>
    public let name: String?
    /// <p>The value of a key-value pair that identifies the location of an attachment to a document.
    ///    The format for <b>Value</b> depends on the type of key you
    ///    specify.</p>
    ///          <ul>
    ///             <li>
    ///                <p>For the key <i>SourceUrl</i>, the value is an S3 bucket location. For
    ///      example:</p>
    ///                <p>
    ///                   <code>"Values": [ "s3://doc-example-bucket/my-folder" ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For the key <i>S3FileUrl</i>, the value is a file in an S3 bucket. For
    ///      example:</p>
    ///                <p>
    ///                   <code>"Values": [ "s3://doc-example-bucket/my-folder/my-file.py" ]</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For the key <i>AttachmentReference</i>, the value is constructed from the
    ///      name of another SSM document in your account, a version number of that document, and a file
    ///      attached to that document version that you want to reuse. For example:</p>
    ///                <p>
    ///                   <code>"Values": [ "MyOtherDocument/3/my-other-file.py" ]</code>
    ///                </p>
    ///                <p>However, if the SSM document is shared with you from another account, the full SSM
    ///      document ARN must be specified instead of the document name only. For example:</p>
    ///                <p>
    ///                   <code>"Values": [
    ///       "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py"
    ///       ]</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        key: AttachmentsSourceKey? = nil,
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.name = name
        self.values = values
    }
}

public enum AttachmentsSourceKey {
    case attachmentreference
    case s3fileurl
    case sourceurl
    case sdkUnknown(String)
}

extension AttachmentsSourceKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttachmentsSourceKey] {
        return [
            .attachmentreference,
            .s3fileurl,
            .sourceurl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .attachmentreference: return "AttachmentReference"
        case .s3fileurl: return "S3FileUrl"
        case .sourceurl: return "SourceUrl"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttachmentsSourceKey(rawValue: rawValue) ?? AttachmentsSourceKey.sdkUnknown(rawValue)
    }
}

extension AutomationDefinitionNotApprovedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationDefinitionNotApprovedException(message: \(String(describing: message)))"}
}

extension AutomationDefinitionNotApprovedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationDefinitionNotApprovedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the Change Manager change template used in the change request was rejected or is
///    still in a pending state.</p>
public struct AutomationDefinitionNotApprovedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotApprovedExceptionBody: Equatable {
    public let message: String?
}

extension AutomationDefinitionNotApprovedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationDefinitionNotFoundException(message: \(String(describing: message)))"}
}

extension AutomationDefinitionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationDefinitionNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Automation document with the specified name could not be found.</p>
public struct AutomationDefinitionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AutomationDefinitionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationDefinitionVersionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationDefinitionVersionNotFoundException(message: \(String(describing: message)))"}
}

extension AutomationDefinitionVersionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationDefinitionVersionNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Automation document with the specified name and version could not be found.</p>
public struct AutomationDefinitionVersionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationDefinitionVersionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AutomationDefinitionVersionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parameters = "Parameters"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case progressCounters = "ProgressCounters"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case stepExecutions = "StepExecutions"
        case stepExecutionsTruncated = "StepExecutionsTruncated"
        case target = "Target"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let progressCounters = progressCounters {
            try encodeContainer.encode(progressCounters, forKey: .progressCounters)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let stepExecutions = stepExecutions {
            var stepExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepExecutions)
            for stepexecutionlist0 in stepExecutions {
                try stepExecutionsContainer.encode(stepexecutionlist0)
            }
        }
        if stepExecutionsTruncated != false {
            try encodeContainer.encode(stepExecutionsTruncated, forKey: .stepExecutionsTruncated)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedContainer(keyedBy: Key.self)
                    for (dictKey2, targetmapvaluelist2) in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2, forKey: Key(stringValue: dictKey2))
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let stepExecutionsContainer = try containerValues.decodeIfPresent([StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let stepExecutionsTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .stepExecutionsTruncated)
        stepExecutionsTruncated = stepExecutionsTruncatedDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .outputs)
        var outputsDecoded0: [String:[String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[String: [String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[String:[String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[String:[String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [String: [String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [String: [String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let progressCountersDecoded = try containerValues.decodeIfPresent(ProgressCounters.self, forKey: .progressCounters)
        progressCounters = progressCountersDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension AutomationExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecution(associationId: \(String(describing: associationId)), automationExecutionId: \(String(describing: automationExecutionId)), automationExecutionStatus: \(String(describing: automationExecutionStatus)), automationSubtype: \(String(describing: automationSubtype)), changeRequestName: \(String(describing: changeRequestName)), currentAction: \(String(describing: currentAction)), currentStepName: \(String(describing: currentStepName)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), executedBy: \(String(describing: executedBy)), executionEndTime: \(String(describing: executionEndTime)), executionStartTime: \(String(describing: executionStartTime)), failureMessage: \(String(describing: failureMessage)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), mode: \(String(describing: mode)), opsItemId: \(String(describing: opsItemId)), outputs: \(String(describing: outputs)), parameters: \(String(describing: parameters)), parentAutomationExecutionId: \(String(describing: parentAutomationExecutionId)), progressCounters: \(String(describing: progressCounters)), resolvedTargets: \(String(describing: resolvedTargets)), runbooks: \(String(describing: runbooks)), scheduledTime: \(String(describing: scheduledTime)), stepExecutions: \(String(describing: stepExecutions)), stepExecutionsTruncated: \(String(describing: stepExecutionsTruncated)), target: \(String(describing: target)), targetLocations: \(String(describing: targetLocations)), targetMaps: \(String(describing: targetMaps)), targetParameterName: \(String(describing: targetParameterName)), targets: \(String(describing: targets)))"}
}

/// <p>Detailed information about the current state of an individual Automation execution.</p>
public struct AutomationExecution: Equatable {
    /// <p>The ID of a State Manager association used in the Automation operation.</p>
    public let associationId: String?
    /// <p>The execution ID.</p>
    public let automationExecutionId: String?
    /// <p>The execution status of the Automation.</p>
    public let automationExecutionStatus: AutomationExecutionStatus?
    /// <p>The subtype of the Automation operation. Currently, the only supported value is
    ///     <code>ChangeRequest</code>.</p>
    public let automationSubtype: AutomationSubtype?
    /// <p>The name of the Change Manager change request.</p>
    public let changeRequestName: String?
    /// <p>The action of the step that is currently running.</p>
    public let currentAction: String?
    /// <p>The name of the step that is currently running.</p>
    public let currentStepName: String?
    /// <p>The name of the Automation document used during the execution.</p>
    public let documentName: String?
    /// <p>The version of the document to use during execution.</p>
    public let documentVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the user who ran the automation.</p>
    public let executedBy: String?
    /// <p>The time the execution finished.</p>
    public let executionEndTime: Date?
    /// <p>The time the execution started.</p>
    public let executionStartTime: Date?
    /// <p>A message describing why an execution has failed, if the status is set to Failed.</p>
    public let failureMessage: String?
    /// <p>The MaxConcurrency value specified by the user when the execution started.</p>
    public let maxConcurrency: String?
    /// <p>The MaxErrors value specified by the user when the execution started.</p>
    public let maxErrors: String?
    /// <p>The automation execution mode.</p>
    public let mode: ExecutionMode?
    /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
    public let opsItemId: String?
    /// <p>The list of execution outputs as defined in the automation document.</p>
    public let outputs: [String:[String]]?
    /// <p>The key-value map of execution parameters, which were supplied when calling
    ///    StartAutomationExecution.</p>
    public let parameters: [String:[String]]?
    /// <p>The AutomationExecutionId of the parent automation.</p>
    public let parentAutomationExecutionId: String?
    /// <p>An aggregate of step execution statuses displayed in the AWS Console for a multi-Region and
    ///    multi-account Automation execution.</p>
    public let progressCounters: ProgressCounters?
    /// <p>A list of resolved targets in the rate control execution.</p>
    public let resolvedTargets: ResolvedTargets?
    /// <p>Information about the Automation runbooks (Automation documents) that are run as part of a
    ///    runbook workflow.</p>
    ///          <note>
    ///             <p>The Automation runbooks specified for the runbook workflow can't run until all required
    ///     approvals for the change request have been received.</p>
    ///          </note>
    public let runbooks: [Runbook]?
    /// <p>The date and time the Automation operation is scheduled to start.</p>
    public let scheduledTime: Date?
    /// <p>A list of details about the current state of all steps that comprise an execution. An
    ///    Automation document contains a list of steps that are run in order.</p>
    public let stepExecutions: [StepExecution]?
    /// <p>A boolean value that indicates if the response contains the full list of the Automation step
    ///    executions. If true, use the DescribeAutomationStepExecutions API action to get the full list of
    ///    step executions.</p>
    public let stepExecutionsTruncated: Bool
    /// <p>The target of the execution.</p>
    public let target: String?
    /// <p>The combination of AWS Regions and/or AWS accounts where you want to run the
    ///    Automation.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The specified key-value mapping of document parameters to target resources.</p>
    public let targetMaps: [[String:[String]]]?
    /// <p>The parameter name.</p>
    public let targetParameterName: String?
    /// <p>The specified targets.</p>
    public let targets: [Target]?

    public init (
        associationId: String? = nil,
        automationExecutionId: String? = nil,
        automationExecutionStatus: AutomationExecutionStatus? = nil,
        automationSubtype: AutomationSubtype? = nil,
        changeRequestName: String? = nil,
        currentAction: String? = nil,
        currentStepName: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        executedBy: String? = nil,
        executionEndTime: Date? = nil,
        executionStartTime: Date? = nil,
        failureMessage: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        mode: ExecutionMode? = nil,
        opsItemId: String? = nil,
        outputs: [String:[String]]? = nil,
        parameters: [String:[String]]? = nil,
        parentAutomationExecutionId: String? = nil,
        progressCounters: ProgressCounters? = nil,
        resolvedTargets: ResolvedTargets? = nil,
        runbooks: [Runbook]? = nil,
        scheduledTime: Date? = nil,
        stepExecutions: [StepExecution]? = nil,
        stepExecutionsTruncated: Bool = false,
        target: String? = nil,
        targetLocations: [TargetLocation]? = nil,
        targetMaps: [[String:[String]]]? = nil,
        targetParameterName: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.associationId = associationId
        self.automationExecutionId = automationExecutionId
        self.automationExecutionStatus = automationExecutionStatus
        self.automationSubtype = automationSubtype
        self.changeRequestName = changeRequestName
        self.currentAction = currentAction
        self.currentStepName = currentStepName
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executedBy = executedBy
        self.executionEndTime = executionEndTime
        self.executionStartTime = executionStartTime
        self.failureMessage = failureMessage
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.opsItemId = opsItemId
        self.outputs = outputs
        self.parameters = parameters
        self.parentAutomationExecutionId = parentAutomationExecutionId
        self.progressCounters = progressCounters
        self.resolvedTargets = resolvedTargets
        self.runbooks = runbooks
        self.scheduledTime = scheduledTime
        self.stepExecutions = stepExecutions
        self.stepExecutionsTruncated = stepExecutionsTruncated
        self.target = target
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

extension AutomationExecutionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for automationexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(automationexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(AutomationExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AutomationExecutionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>A filter used to match specific automation executions. This is used to limit the scope of
///    Automation execution information returned.</p>
public struct AutomationExecutionFilter: Equatable {
    /// <p>One or more keys to limit the results.</p>
    public let key: AutomationExecutionFilterKey?
    /// <p>The values used to limit the execution information associated with the filter's key.</p>
    public let values: [String]?

    public init (
        key: AutomationExecutionFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public enum AutomationExecutionFilterKey {
    case automationSubtype
    case automationType
    case currentAction
    case documentNamePrefix
    case executionId
    case executionStatus
    case opsItemId
    case parentExecutionId
    case startTimeAfter
    case startTimeBefore
    case tagKey
    case targetResourceGroup
    case sdkUnknown(String)
}

extension AutomationExecutionFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutomationExecutionFilterKey] {
        return [
            .automationSubtype,
            .automationType,
            .currentAction,
            .documentNamePrefix,
            .executionId,
            .executionStatus,
            .opsItemId,
            .parentExecutionId,
            .startTimeAfter,
            .startTimeBefore,
            .tagKey,
            .targetResourceGroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automationSubtype: return "AutomationSubtype"
        case .automationType: return "AutomationType"
        case .currentAction: return "CurrentAction"
        case .documentNamePrefix: return "DocumentNamePrefix"
        case .executionId: return "ExecutionId"
        case .executionStatus: return "ExecutionStatus"
        case .opsItemId: return "OpsItemId"
        case .parentExecutionId: return "ParentExecutionId"
        case .startTimeAfter: return "StartTimeAfter"
        case .startTimeBefore: return "StartTimeBefore"
        case .tagKey: return "TagKey"
        case .targetResourceGroup: return "TargetResourceGroup"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutomationExecutionFilterKey(rawValue: rawValue) ?? AutomationExecutionFilterKey.sdkUnknown(rawValue)
    }
}

extension AutomationExecutionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionLimitExceededException(message: \(String(describing: message)))"}
}

extension AutomationExecutionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationExecutionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of simultaneously running Automation executions exceeded the allowable
///    limit.</p>
public struct AutomationExecutionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension AutomationExecutionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecutionMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case automationExecutionId = "AutomationExecutionId"
        case automationExecutionStatus = "AutomationExecutionStatus"
        case automationSubtype = "AutomationSubtype"
        case automationType = "AutomationType"
        case changeRequestName = "ChangeRequestName"
        case currentAction = "CurrentAction"
        case currentStepName = "CurrentStepName"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executedBy = "ExecutedBy"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureMessage = "FailureMessage"
        case logFile = "LogFile"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case opsItemId = "OpsItemId"
        case outputs = "Outputs"
        case parentAutomationExecutionId = "ParentAutomationExecutionId"
        case resolvedTargets = "ResolvedTargets"
        case runbooks = "Runbooks"
        case scheduledTime = "ScheduledTime"
        case target = "Target"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let automationExecutionStatus = automationExecutionStatus {
            try encodeContainer.encode(automationExecutionStatus.rawValue, forKey: .automationExecutionStatus)
        }
        if let automationSubtype = automationSubtype {
            try encodeContainer.encode(automationSubtype.rawValue, forKey: .automationSubtype)
        }
        if let automationType = automationType {
            try encodeContainer.encode(automationType.rawValue, forKey: .automationType)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let currentAction = currentAction {
            try encodeContainer.encode(currentAction, forKey: .currentAction)
        }
        if let currentStepName = currentStepName {
            try encodeContainer.encode(currentStepName, forKey: .currentStepName)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let executedBy = executedBy {
            try encodeContainer.encode(executedBy, forKey: .executedBy)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let logFile = logFile {
            try encodeContainer.encode(logFile, forKey: .logFile)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let parentAutomationExecutionId = parentAutomationExecutionId {
            try encodeContainer.encode(parentAutomationExecutionId, forKey: .parentAutomationExecutionId)
        }
        if let resolvedTargets = resolvedTargets {
            try encodeContainer.encode(resolvedTargets, forKey: .resolvedTargets)
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedContainer(keyedBy: Key.self)
                    for (dictKey2, targetmapvaluelist2) in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2, forKey: Key(stringValue: dictKey2))
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let automationExecutionStatusDecoded = try containerValues.decodeIfPresent(AutomationExecutionStatus.self, forKey: .automationExecutionStatus)
        automationExecutionStatus = automationExecutionStatusDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let executedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executedBy)
        executedBy = executedByDecoded
        let logFileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logFile)
        logFile = logFileDecoded
        let outputsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .outputs)
        var outputsDecoded0: [String:[String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let modeDecoded = try containerValues.decodeIfPresent(ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let parentAutomationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentAutomationExecutionId)
        parentAutomationExecutionId = parentAutomationExecutionIdDecoded
        let currentStepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentStepName)
        currentStepName = currentStepNameDecoded
        let currentActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentAction)
        currentAction = currentActionDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[String: [String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[String:[String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[String:[String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [String: [String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [String: [String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let resolvedTargetsDecoded = try containerValues.decodeIfPresent(ResolvedTargets.self, forKey: .resolvedTargets)
        resolvedTargets = resolvedTargetsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let automationTypeDecoded = try containerValues.decodeIfPresent(AutomationType.self, forKey: .automationType)
        automationType = automationTypeDecoded
        let automationSubtypeDecoded = try containerValues.decodeIfPresent(AutomationSubtype.self, forKey: .automationSubtype)
        automationSubtype = automationSubtypeDecoded
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
    }
}

extension AutomationExecutionMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionMetadata(associationId: \(String(describing: associationId)), automationExecutionId: \(String(describing: automationExecutionId)), automationExecutionStatus: \(String(describing: automationExecutionStatus)), automationSubtype: \(String(describing: automationSubtype)), automationType: \(String(describing: automationType)), changeRequestName: \(String(describing: changeRequestName)), currentAction: \(String(describing: currentAction)), currentStepName: \(String(describing: currentStepName)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), executedBy: \(String(describing: executedBy)), executionEndTime: \(String(describing: executionEndTime)), executionStartTime: \(String(describing: executionStartTime)), failureMessage: \(String(describing: failureMessage)), logFile: \(String(describing: logFile)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), mode: \(String(describing: mode)), opsItemId: \(String(describing: opsItemId)), outputs: \(String(describing: outputs)), parentAutomationExecutionId: \(String(describing: parentAutomationExecutionId)), resolvedTargets: \(String(describing: resolvedTargets)), runbooks: \(String(describing: runbooks)), scheduledTime: \(String(describing: scheduledTime)), target: \(String(describing: target)), targetMaps: \(String(describing: targetMaps)), targetParameterName: \(String(describing: targetParameterName)), targets: \(String(describing: targets)))"}
}

/// <p>Details about a specific Automation execution.</p>
public struct AutomationExecutionMetadata: Equatable {
    /// <p>The ID of a State Manager association used in the Automation operation.</p>
    public let associationId: String?
    /// <p>The execution ID.</p>
    public let automationExecutionId: String?
    /// <p>The status of the execution.</p>
    public let automationExecutionStatus: AutomationExecutionStatus?
    /// <p>The subtype of the Automation operation. Currently, the only supported value is
    ///     <code>ChangeRequest</code>.</p>
    public let automationSubtype: AutomationSubtype?
    /// <p>Use this filter with <a>DescribeAutomationExecutions</a>. Specify either Local or
    ///    CrossAccount. CrossAccount is an Automation that runs in multiple AWS Regions and accounts. For
    ///    more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
    ///     <i>AWS Systems Manager User Guide</i>. </p>
    public let automationType: AutomationType?
    /// <p>The name of the Change Manager change request.</p>
    public let changeRequestName: String?
    /// <p>The action of the step that is currently running.</p>
    public let currentAction: String?
    /// <p>The name of the step that is currently running.</p>
    public let currentStepName: String?
    /// <p>The name of the Automation document used during execution.</p>
    public let documentName: String?
    /// <p>The document version used during the execution.</p>
    public let documentVersion: String?
    /// <p>The IAM role ARN of the user who ran the Automation.</p>
    public let executedBy: String?
    /// <p>The time the execution finished. This is not populated if the execution is still in
    ///    progress.</p>
    public let executionEndTime: Date?
    /// <p>The time the execution started.</p>
    public let executionStartTime: Date?
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    public let failureMessage: String?
    /// <p>An S3 bucket where execution information is stored.</p>
    public let logFile: String?
    /// <p>The MaxConcurrency value specified by the user when starting the Automation.</p>
    public let maxConcurrency: String?
    /// <p>The MaxErrors value specified by the user when starting the Automation.</p>
    public let maxErrors: String?
    /// <p>The Automation execution mode.</p>
    public let mode: ExecutionMode?
    /// <p>The ID of an OpsItem that is created to represent a Change Manager change request.</p>
    public let opsItemId: String?
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    public let outputs: [String:[String]]?
    /// <p>The ExecutionId of the parent Automation.</p>
    public let parentAutomationExecutionId: String?
    /// <p>A list of targets that resolved during the execution.</p>
    public let resolvedTargets: ResolvedTargets?
    /// <p>Information about the Automation runbooks (Automation documents) that are run during a
    ///    runbook workflow in Change Manager.</p>
    ///          <note>
    ///             <p>The Automation runbooks specified for the runbook workflow can't run until all required
    ///     approvals for the change request have been received.</p>
    ///          </note>
    public let runbooks: [Runbook]?
    /// <p>The date and time the Automation operation is scheduled to start.</p>
    public let scheduledTime: Date?
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    public let target: String?
    /// <p>The specified key-value mapping of document parameters to target resources.</p>
    public let targetMaps: [[String:[String]]]?
    /// <p>The list of execution outputs as defined in the Automation document.</p>
    public let targetParameterName: String?
    /// <p>The targets defined by the user when starting the Automation.</p>
    public let targets: [Target]?

    public init (
        associationId: String? = nil,
        automationExecutionId: String? = nil,
        automationExecutionStatus: AutomationExecutionStatus? = nil,
        automationSubtype: AutomationSubtype? = nil,
        automationType: AutomationType? = nil,
        changeRequestName: String? = nil,
        currentAction: String? = nil,
        currentStepName: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        executedBy: String? = nil,
        executionEndTime: Date? = nil,
        executionStartTime: Date? = nil,
        failureMessage: String? = nil,
        logFile: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        mode: ExecutionMode? = nil,
        opsItemId: String? = nil,
        outputs: [String:[String]]? = nil,
        parentAutomationExecutionId: String? = nil,
        resolvedTargets: ResolvedTargets? = nil,
        runbooks: [Runbook]? = nil,
        scheduledTime: Date? = nil,
        target: String? = nil,
        targetMaps: [[String:[String]]]? = nil,
        targetParameterName: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.associationId = associationId
        self.automationExecutionId = automationExecutionId
        self.automationExecutionStatus = automationExecutionStatus
        self.automationSubtype = automationSubtype
        self.automationType = automationType
        self.changeRequestName = changeRequestName
        self.currentAction = currentAction
        self.currentStepName = currentStepName
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executedBy = executedBy
        self.executionEndTime = executionEndTime
        self.executionStartTime = executionStartTime
        self.failureMessage = failureMessage
        self.logFile = logFile
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.opsItemId = opsItemId
        self.outputs = outputs
        self.parentAutomationExecutionId = parentAutomationExecutionId
        self.resolvedTargets = resolvedTargets
        self.runbooks = runbooks
        self.scheduledTime = scheduledTime
        self.target = target
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

extension AutomationExecutionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionNotFoundException(message: \(String(describing: message)))"}
}

extension AutomationExecutionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationExecutionNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is no automation execution information for the requested automation execution
///    ID.</p>
public struct AutomationExecutionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AutomationExecutionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AutomationExecutionStatus {
    case approved
    case cancelled
    case cancelling
    case changeCalendarOverrideApproved
    case changeCalendarOverrideRejected
    case completedWithFailure
    case completedWithSuccess
    case failed
    case inprogress
    case pending
    case pendingApproval
    case pendingChangeCalendarOverride
    case rejected
    case runbookInprogress
    case scheduled
    case success
    case timedout
    case waiting
    case sdkUnknown(String)
}

extension AutomationExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutomationExecutionStatus] {
        return [
            .approved,
            .cancelled,
            .cancelling,
            .changeCalendarOverrideApproved,
            .changeCalendarOverrideRejected,
            .completedWithFailure,
            .completedWithSuccess,
            .failed,
            .inprogress,
            .pending,
            .pendingApproval,
            .pendingChangeCalendarOverride,
            .rejected,
            .runbookInprogress,
            .scheduled,
            .success,
            .timedout,
            .waiting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "Approved"
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
        case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
        case .completedWithFailure: return "CompletedWithFailure"
        case .completedWithSuccess: return "CompletedWithSuccess"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .pending: return "Pending"
        case .pendingApproval: return "PendingApproval"
        case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
        case .rejected: return "Rejected"
        case .runbookInprogress: return "RunbookInProgress"
        case .scheduled: return "Scheduled"
        case .success: return "Success"
        case .timedout: return "TimedOut"
        case .waiting: return "Waiting"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutomationExecutionStatus(rawValue: rawValue) ?? AutomationExecutionStatus.sdkUnknown(rawValue)
    }
}

extension AutomationStepNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationStepNotFoundException(message: \(String(describing: message)))"}
}

extension AutomationStepNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationStepNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified step name and execution ID don't exist. Verify the information and try
///    again.</p>
public struct AutomationStepNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationStepNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AutomationStepNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AutomationSubtype {
    case changerequest
    case sdkUnknown(String)
}

extension AutomationSubtype : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutomationSubtype] {
        return [
            .changerequest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .changerequest: return "ChangeRequest"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutomationSubtype(rawValue: rawValue) ?? AutomationSubtype.sdkUnknown(rawValue)
    }
}

public enum AutomationType {
    case crossaccount
    case local
    case sdkUnknown(String)
}

extension AutomationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutomationType] {
        return [
            .crossaccount,
            .local,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .crossaccount: return "CrossAccount"
        case .local: return "Local"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutomationType(rawValue: rawValue) ?? AutomationType.sdkUnknown(rawValue)
    }
}

extension BaselineOverride: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case globalFilters = "GlobalFilters"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension BaselineOverride: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaselineOverride(approvalRules: \(String(describing: approvalRules)), approvedPatches: \(String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(String(describing: approvedPatchesEnableNonSecurity)), globalFilters: \(String(describing: globalFilters)), operatingSystem: \(String(describing: operatingSystem)), rejectedPatches: \(String(describing: rejectedPatches)), rejectedPatchesAction: \(String(describing: rejectedPatchesAction)), sources: \(String(describing: sources)))"}
}

/// <p>Defines the basic information about a patch baseline override.</p>
public struct BaselineOverride: Equatable {
    /// <p>A set of rules defining the approval rules for a patch baseline.</p>
    public let approvalRules: PatchRuleGroup?
    /// <p>A list of explicitly approved patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let approvedPatches: [String]?
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
    ///    missing, this value describes the severity of the compliance violation.</p>
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    ///    applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    public let approvedPatchesEnableNonSecurity: Bool
    /// <p>A set of patch filters, typically used for approval rules.</p>
    public let globalFilters: PatchFilterGroup?
    /// <p>The operating system rule used by the patch baseline override.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let rejectedPatches: [String]?
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages list. A
    ///    patch can be allowed only if it is a dependency of another package, or blocked entirely along
    ///    with packages that include it as a dependency.</p>
    public let rejectedPatchesAction: PatchAction?
    /// <p>Information about the patches to use to update the instances, including target operating
    ///    systems and source repositories. Applies to Linux instances only.</p>
    public let sources: [PatchSource]?

    public init (
        approvalRules: PatchRuleGroup? = nil,
        approvedPatches: [String]? = nil,
        approvedPatchesComplianceLevel: PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Bool = false,
        globalFilters: PatchFilterGroup? = nil,
        operatingSystem: OperatingSystem? = nil,
        rejectedPatches: [String]? = nil,
        rejectedPatchesAction: PatchAction? = nil,
        sources: [PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.globalFilters = globalFilters
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

public enum CalendarState {
    case closed
    case `open`
    case sdkUnknown(String)
}

extension CalendarState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CalendarState] {
        return [
            .closed,
            .open,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "CLOSED"
        case .open: return "OPEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CalendarState(rawValue: rawValue) ?? CalendarState.sdkUnknown(rawValue)
    }
}

public struct CancelCommandInputBodyMiddleware: Middleware {
    public let id: String = "CancelCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelCommandInput>
    public typealias MOutput = OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelCommandOutputError>
}

extension CancelCommandInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelCommandInput(commandId: \(String(describing: commandId)), instanceIds: \(String(describing: instanceIds)))"}
}

extension CancelCommandInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
    }
}

public struct CancelCommandInputHeadersMiddleware: Middleware {
    public let id: String = "CancelCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelCommandInput>
    public typealias MOutput = OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelCommandOutputError>
}

public struct CancelCommandInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelCommandInput>
    public typealias MOutput = OperationOutput<CancelCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelCommandOutputError>
}

/// <p></p>
public struct CancelCommandInput: Equatable {
    /// <p>The ID of the command you want to cancel.</p>
    public let commandId: String?
    /// <p>(Optional) A list of instance IDs on which you want to cancel the command. If not provided,
    ///    the command is canceled on every instance on which it was requested.</p>
    public let instanceIds: [String]?

    public init (
        commandId: String? = nil,
        instanceIds: [String]? = nil
    )
    {
        self.commandId = commandId
        self.instanceIds = instanceIds
    }
}

struct CancelCommandInputBody: Equatable {
    public let commandId: String?
    public let instanceIds: [String]?
}

extension CancelCommandInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case instanceIds = "InstanceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension CancelCommandOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelCommandOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelCommandOutputError: Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelCommandOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelCommandOutputResponse()"}
}

extension CancelCommandOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Whether or not the command was successfully canceled. There is no guarantee that a request
///    can be canceled.</p>
public struct CancelCommandOutputResponse: Equatable {

    public init() {}
}

struct CancelCommandOutputResponseBody: Equatable {
}

extension CancelCommandOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelMaintenanceWindowExecutionInputBodyMiddleware: Middleware {
    public let id: String = "CancelMaintenanceWindowExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMaintenanceWindowExecutionOutputError>
}

extension CancelMaintenanceWindowExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMaintenanceWindowExecutionInput(windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension CancelMaintenanceWindowExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct CancelMaintenanceWindowExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "CancelMaintenanceWindowExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelMaintenanceWindowExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<CancelMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMaintenanceWindowExecutionOutputError>
}

public struct CancelMaintenanceWindowExecutionInput: Equatable {
    /// <p>The ID of the maintenance window execution to stop.</p>
    public let windowExecutionId: String?

    public init (
        windowExecutionId: String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionInputBody: Equatable {
    public let windowExecutionId: String?
}

extension CancelMaintenanceWindowExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension CancelMaintenanceWindowExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMaintenanceWindowExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMaintenanceWindowExecutionOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMaintenanceWindowExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMaintenanceWindowExecutionOutputResponse(windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension CancelMaintenanceWindowExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.windowExecutionId = nil
        }
    }
}

public struct CancelMaintenanceWindowExecutionOutputResponse: Equatable {
    /// <p>The ID of the maintenance window execution that has been stopped.</p>
    public let windowExecutionId: String?

    public init (
        windowExecutionId: String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct CancelMaintenanceWindowExecutionOutputResponseBody: Equatable {
    public let windowExecutionId: String?
}

extension CancelMaintenanceWindowExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension CloudWatchOutputConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupName = "CloudWatchLogGroupName"
        case cloudWatchOutputEnabled = "CloudWatchOutputEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if cloudWatchOutputEnabled != false {
            try encodeContainer.encode(cloudWatchOutputEnabled, forKey: .cloudWatchOutputEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let cloudWatchOutputEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cloudWatchOutputEnabled)
        cloudWatchOutputEnabled = cloudWatchOutputEnabledDecoded
    }
}

extension CloudWatchOutputConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchOutputConfig(cloudWatchLogGroupName: \(String(describing: cloudWatchLogGroupName)), cloudWatchOutputEnabled: \(String(describing: cloudWatchOutputEnabled)))"}
}

/// <p>Configuration options for sending command output to CloudWatch Logs.</p>
public struct CloudWatchOutputConfig: Equatable {
    /// <p>The name of the CloudWatch log group where you want to send command output. If you don't
    ///    specify a group name, Systems Manager automatically creates a log group for you. The log group uses the
    ///    following naming format: aws/ssm/<i>SystemsManagerDocumentName</i>.</p>
    public let cloudWatchLogGroupName: String?
    /// <p>Enables Systems Manager to send command output to CloudWatch Logs.</p>
    public let cloudWatchOutputEnabled: Bool

    public init (
        cloudWatchLogGroupName: String? = nil,
        cloudWatchOutputEnabled: Bool = false
    )
    {
        self.cloudWatchLogGroupName = cloudWatchLogGroupName
        self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
    }
}

extension Command: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case completedCount = "CompletedCount"
        case deliveryTimedOutCount = "DeliveryTimedOutCount"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case errorCount = "ErrorCount"
        case expiresAfter = "ExpiresAfter"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case targetCount = "TargetCount"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if completedCount != 0 {
            try encodeContainer.encode(completedCount, forKey: .completedCount)
        }
        if deliveryTimedOutCount != 0 {
            try encodeContainer.encode(deliveryTimedOutCount, forKey: .deliveryTimedOutCount)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if errorCount != 0 {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let expiresAfter = expiresAfter {
            try encodeContainer.encode(expiresAfter.timeIntervalSince1970, forKey: .expiresAfter)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if targetCount != 0 {
            try encodeContainer.encode(targetCount, forKey: .targetCount)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let expiresAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiresAfter)
        expiresAfter = expiresAfterDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CommandStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetCountDecoded = try containerValues.decode(Int.self, forKey: .targetCount)
        targetCount = targetCountDecoded
        let completedCountDecoded = try containerValues.decode(Int.self, forKey: .completedCount)
        completedCount = completedCountDecoded
        let errorCountDecoded = try containerValues.decode(Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
        let deliveryTimedOutCountDecoded = try containerValues.decode(Int.self, forKey: .deliveryTimedOutCount)
        deliveryTimedOutCount = deliveryTimedOutCountDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension Command: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Command(cloudWatchOutputConfig: \(String(describing: cloudWatchOutputConfig)), commandId: \(String(describing: commandId)), comment: \(String(describing: comment)), completedCount: \(String(describing: completedCount)), deliveryTimedOutCount: \(String(describing: deliveryTimedOutCount)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), errorCount: \(String(describing: errorCount)), expiresAfter: \(String(describing: expiresAfter)), instanceIds: \(String(describing: instanceIds)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), notificationConfig: \(String(describing: notificationConfig)), outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), outputS3Region: \(String(describing: outputS3Region)), parameters: \(String(describing: parameters)), requestedDateTime: \(String(describing: requestedDateTime)), serviceRole: \(String(describing: serviceRole)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), targetCount: \(String(describing: targetCount)), targets: \(String(describing: targets)), timeoutSeconds: \(String(describing: timeoutSeconds)))"}
}

/// <p>Describes a command request.</p>
public struct Command: Equatable {
    /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
    /// <p>A unique identifier for this command.</p>
    public let commandId: String?
    /// <p>User-specified information about the command, such as a brief description of what the
    ///    command should do.</p>
    public let comment: String?
    /// <p>The number of targets for which the command invocation reached a terminal state. Terminal
    ///    states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled,
    ///    Terminated, or Undeliverable.</p>
    public let completedCount: Int
    /// <p>The number of targets for which the status is Delivery Timed Out.</p>
    public let deliveryTimedOutCount: Int
    /// <p>The name of the document requested for execution.</p>
    public let documentName: String?
    /// <p>The SSM document version.</p>
    public let documentVersion: String?
    /// <p>The number of targets for which the status is Failed or Execution Timed Out.</p>
    public let errorCount: Int
    /// <p>If this time is reached and the command has not already started running, it will not run.
    ///    Calculated based on the ExpiresAfter user input provided as part of the SendCommand API.</p>
    public let expiresAfter: Date?
    /// <p>The instance IDs against which this command was requested.</p>
    public let instanceIds: [String]?
    /// <p>The maximum number of instances that are allowed to run the command at the same time. You
    ///    can specify a number of instances, such as 10, or a percentage of instances, such as 10%. The
    ///    default value is 50. For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
    ///     using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let maxConcurrency: String?
    /// <p>The maximum number of errors allowed before the system stops sending the command to
    ///    additional targets. You can specify a number of errors, such as 10, or a percentage or errors,
    ///    such as 10%. The default value is 0. For more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Running commands
    ///     using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let maxErrors: String?
    /// <p>Configurations for sending notifications about command status changes. </p>
    public let notificationConfig: NotificationConfig?
    /// <p>The S3 bucket where the responses to the command executions should be stored. This was
    ///    requested when issuing the command.</p>
    public let outputS3BucketName: String?
    /// <p>The S3 directory path inside the bucket where the responses to the command executions should
    ///    be stored. This was requested when issuing the command.</p>
    public let outputS3KeyPrefix: String?
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    ///    automatically determines the Region of the S3 bucket.</p>
    public let outputS3Region: String?
    /// <p>The parameter values to be inserted in the document when running the command.</p>
    public let parameters: [String:[String]]?
    /// <p>The date and time the command was requested.</p>
    public let requestedDateTime: Date?
    /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
    ///    about command status changes. </p>
    public let serviceRole: String?
    /// <p>The status of the command.</p>
    public let status: CommandStatus?
    /// <p>A detailed status of the command execution. StatusDetails includes more information than
    ///    Status because it includes states resulting from error and concurrency control parameters.
    ///    StatusDetails can show different results than Status. For more information about these statuses,
    ///    see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    ///    StatusDetails can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Pending: The command has not been sent to any instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>In Progress: The command has been sent to at least one instance but has not reached a
    ///      final state on all instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>Success: The command successfully ran on all invocations. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of
    ///      Delivery Timed Out. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Execution Timed Out: The value of MaxErrors or more command invocations shows a status of
    ///      Execution Timed Out. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Failed: The value of MaxErrors or more command invocations shows a status of Failed. This
    ///      is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Incomplete: The command was attempted on all instances and one or more invocations does
    ///      not have a value of Success but not enough invocations failed for the status to be Failed. This
    ///      is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Canceled: The command was terminated before it was completed. This is a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Rate Exceeded: The number of instances targeted by the command exceeded the account limit
    ///      for pending invocations. The system has canceled the command before running it on any instance.
    ///      This is a terminal state.</p>
    ///             </li>
    ///          </ul>
    public let statusDetails: String?
    /// <p>The number of targets for the command.</p>
    public let targetCount: Int
    /// <p>An array of search criteria that targets instances using a Key,Value combination that you
    ///    specify. Targets is required if you don't provide one or more instance IDs in the call.</p>
    public let targets: [Target]?
    /// <p>The <code>TimeoutSeconds</code> value specified for a command.</p>
    public let timeoutSeconds: Int

    public init (
        cloudWatchOutputConfig: CloudWatchOutputConfig? = nil,
        commandId: String? = nil,
        comment: String? = nil,
        completedCount: Int = 0,
        deliveryTimedOutCount: Int = 0,
        documentName: String? = nil,
        documentVersion: String? = nil,
        errorCount: Int = 0,
        expiresAfter: Date? = nil,
        instanceIds: [String]? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        notificationConfig: NotificationConfig? = nil,
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        outputS3Region: String? = nil,
        parameters: [String:[String]]? = nil,
        requestedDateTime: Date? = nil,
        serviceRole: String? = nil,
        status: CommandStatus? = nil,
        statusDetails: String? = nil,
        targetCount: Int = 0,
        targets: [Target]? = nil,
        timeoutSeconds: Int = 0
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.comment = comment
        self.completedCount = completedCount
        self.deliveryTimedOutCount = deliveryTimedOutCount
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.errorCount = errorCount
        self.expiresAfter = expiresAfter
        self.instanceIds = instanceIds
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.parameters = parameters
        self.requestedDateTime = requestedDateTime
        self.serviceRole = serviceRole
        self.status = status
        self.statusDetails = statusDetails
        self.targetCount = targetCount
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
    }
}

extension CommandFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CommandFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CommandFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommandFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a command filter.</p>
///          <note>
///             <p>An instance ID can't be specified when a command status is <code>Pending</code> because the
///     command hasn't run on the instance yet.</p>
///          </note>
public struct CommandFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: CommandFilterKey?
    /// <p>The filter value. Valid values for each filter key are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>InvokedAfter</b>: Specify a timestamp to limit your results.
    ///      For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions
    ///      occurring July 7, 2018, and later.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>InvokedBefore</b>: Specify a timestamp to limit your results.
    ///      For example, specify <code>2018-07-07T00:00:00Z</code> to see a list of command executions from
    ///      before July 7, 2018.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Status</b>: Specify a valid command status to see a list of
    ///      all command executions with that status. Status values you can specify include:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Pending</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>InProgress</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Success</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Cancelled</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Failed</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>TimedOut</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Cancelling</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DocumentName</b>: Specify name of the SSM document for which
    ///      you want to see command execution results. For example, specify
    ///       <code>AWS-RunPatchBaseline</code> to see command executions that used this SSM document to
    ///      perform security patching operations on instances. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ExecutionStage</b>: Specify one of the following
    ///      values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>Executing</code>: Returns a list of command executions that are currently still
    ///        running.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Complete</code>: Returns a list of command executions that have already completed.
    ///       </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        key: CommandFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum CommandFilterKey {
    case documentName
    case executionStage
    case invokedAfter
    case invokedBefore
    case status
    case sdkUnknown(String)
}

extension CommandFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommandFilterKey] {
        return [
            .documentName,
            .executionStage,
            .invokedAfter,
            .invokedBefore,
            .status,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .documentName: return "DocumentName"
        case .executionStage: return "ExecutionStage"
        case .invokedAfter: return "InvokedAfter"
        case .invokedBefore: return "InvokedBefore"
        case .status: return "Status"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommandFilterKey(rawValue: rawValue) ?? CommandFilterKey.sdkUnknown(rawValue)
    }
}

extension CommandInvocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case commandPlugins = "CommandPlugins"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case instanceName = "InstanceName"
        case notificationConfig = "NotificationConfig"
        case requestedDateTime = "RequestedDateTime"
        case serviceRole = "ServiceRole"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case traceOutput = "TraceOutput"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let commandPlugins = commandPlugins {
            var commandPluginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandPlugins)
            for commandpluginlist0 in commandPlugins {
                try commandPluginsContainer.encode(commandpluginlist0)
            }
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let requestedDateTime = requestedDateTime {
            try encodeContainer.encode(requestedDateTime.timeIntervalSince1970, forKey: .requestedDateTime)
        }
        if let serviceRole = serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let traceOutput = traceOutput {
            try encodeContainer.encode(traceOutput, forKey: .traceOutput)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let requestedDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .requestedDateTime)
        requestedDateTime = requestedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let traceOutputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceOutput)
        traceOutput = traceOutputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let commandPluginsContainer = try containerValues.decodeIfPresent([CommandPlugin?].self, forKey: .commandPlugins)
        var commandPluginsDecoded0:[CommandPlugin]? = nil
        if let commandPluginsContainer = commandPluginsContainer {
            commandPluginsDecoded0 = [CommandPlugin]()
            for structure0 in commandPluginsContainer {
                if let structure0 = structure0 {
                    commandPluginsDecoded0?.append(structure0)
                }
            }
        }
        commandPlugins = commandPluginsDecoded0
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension CommandInvocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommandInvocation(cloudWatchOutputConfig: \(String(describing: cloudWatchOutputConfig)), commandId: \(String(describing: commandId)), commandPlugins: \(String(describing: commandPlugins)), comment: \(String(describing: comment)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), instanceId: \(String(describing: instanceId)), instanceName: \(String(describing: instanceName)), notificationConfig: \(String(describing: notificationConfig)), requestedDateTime: \(String(describing: requestedDateTime)), serviceRole: \(String(describing: serviceRole)), standardErrorUrl: \(String(describing: standardErrorUrl)), standardOutputUrl: \(String(describing: standardOutputUrl)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), traceOutput: \(String(describing: traceOutput)))"}
}

/// <p>An invocation is copy of a command sent to a specific instance. A command can apply to one
///    or more instances. A command invocation applies to one instance. For example, if a user runs
///    SendCommand against three instances, then a command invocation is created for each requested
///    instance ID. A command invocation returns status and detail information about a command you ran.
///   </p>
public struct CommandInvocation: Equatable {
    /// <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
    /// <p>The command against which this invocation was requested.</p>
    public let commandId: String?
    /// <p>Plugins processed by the command.</p>
    public let commandPlugins: [CommandPlugin]?
    /// <p>User-specified information about the command, such as a brief description of what the
    ///    command should do.</p>
    public let comment: String?
    /// <p>The document name that was requested for execution.</p>
    public let documentName: String?
    /// <p>The SSM document version.</p>
    public let documentVersion: String?
    /// <p>The instance ID in which this invocation was requested.</p>
    public let instanceId: String?
    /// <p>The name of the invocation target. For EC2 instances this is the value for the aws:Name tag.
    ///    For on-premises instances, this is the name of the instance.</p>
    public let instanceName: String?
    /// <p>Configurations for sending notifications about command status changes on a per instance
    ///    basis.</p>
    public let notificationConfig: NotificationConfig?
    /// <p>The time and date the request was sent to this instance.</p>
    public let requestedDateTime: Date?
    /// <p>The IAM service role that Run Command uses to act on your behalf when sending notifications
    ///    about command status changes on a per instance basis.</p>
    public let serviceRole: String?
    /// <p>The URL to the plugin's StdErr file in Amazon S3, if the S3 bucket was defined for the parent
    ///    command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for
    ///    the command, and the S3 bucket was defined for the command.</p>
    public let standardErrorUrl: String?
    /// <p>The URL to the plugin's StdOut file in Amazon S3, if the S3 bucket was defined for the parent
    ///    command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined
    ///    for the command, and the S3 bucket was defined for the command.</p>
    public let standardOutputUrl: String?
    /// <p>Whether or not the invocation succeeded, failed, or is pending.</p>
    public let status: CommandInvocationStatus?
    /// <p>A detailed status of the command execution for each invocation (each instance targeted by
    ///    the command). StatusDetails includes more information than Status because it includes states
    ///    resulting from error and concurrency control parameters. StatusDetails can show different results
    ///    than Status. For more information about these statuses, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command
    ///     statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the
    ///    following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Pending: The command has not been sent to the instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>In Progress: The command has been sent to the instance but has not reached a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Success: The execution of the command or plugin was successfully completed. This is a
    ///      terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    ///      timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
    ///      but they do contribute to whether the parent command status is Success or Incomplete. This is a
    ///      terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Execution Timed Out: Command execution started on the instance, but the execution was not
    ///      complete before the execution timeout expired. Execution timeouts count against the MaxErrors
    ///      limit of the parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
    ///      the result code was not zero. For a command invocation, this indicates that the result code for
    ///      one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
    ///      parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Canceled: The command was terminated before it was completed. This is a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    ///      exist or might not be responding. Undeliverable invocations don't count against the parent
    ///      command's MaxErrors limit and don't contribute to whether the parent command status is Success
    ///      or Incomplete. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
    ///      invocations were canceled by the system. This is a terminal state.</p>
    ///             </li>
    ///          </ul>
    public let statusDetails: String?
    /// <p> Gets the trace output sent by the agent. </p>
    public let traceOutput: String?

    public init (
        cloudWatchOutputConfig: CloudWatchOutputConfig? = nil,
        commandId: String? = nil,
        commandPlugins: [CommandPlugin]? = nil,
        comment: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        instanceId: String? = nil,
        instanceName: String? = nil,
        notificationConfig: NotificationConfig? = nil,
        requestedDateTime: Date? = nil,
        serviceRole: String? = nil,
        standardErrorUrl: String? = nil,
        standardOutputUrl: String? = nil,
        status: CommandInvocationStatus? = nil,
        statusDetails: String? = nil,
        traceOutput: String? = nil
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.commandPlugins = commandPlugins
        self.comment = comment
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.instanceName = instanceName
        self.notificationConfig = notificationConfig
        self.requestedDateTime = requestedDateTime
        self.serviceRole = serviceRole
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
        self.traceOutput = traceOutput
    }
}

public enum CommandInvocationStatus {
    case cancelled
    case cancelling
    case delayed
    case failed
    case inProgress
    case pending
    case success
    case timedOut
    case sdkUnknown(String)
}

extension CommandInvocationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommandInvocationStatus] {
        return [
            .cancelled,
            .cancelling,
            .delayed,
            .failed,
            .inProgress,
            .pending,
            .success,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .delayed: return "Delayed"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .pending: return "Pending"
        case .success: return "Success"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommandInvocationStatus(rawValue: rawValue) ?? CommandInvocationStatus.sdkUnknown(rawValue)
    }
}

extension CommandPlugin: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case output = "Output"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case responseCode = "ResponseCode"
        case responseFinishDateTime = "ResponseFinishDateTime"
        case responseStartDateTime = "ResponseStartDateTime"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if responseCode != 0 {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let responseFinishDateTime = responseFinishDateTime {
            try encodeContainer.encode(responseFinishDateTime.timeIntervalSince1970, forKey: .responseFinishDateTime)
        }
        if let responseStartDateTime = responseStartDateTime {
            try encodeContainer.encode(responseStartDateTime.timeIntervalSince1970, forKey: .responseStartDateTime)
        }
        if let standardErrorUrl = standardErrorUrl {
            try encodeContainer.encode(standardErrorUrl, forKey: .standardErrorUrl)
        }
        if let standardOutputUrl = standardOutputUrl {
            try encodeContainer.encode(standardOutputUrl, forKey: .standardOutputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CommandPluginStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let responseCodeDecoded = try containerValues.decode(Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let responseStartDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .responseStartDateTime)
        responseStartDateTime = responseStartDateTimeDecoded
        let responseFinishDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .responseFinishDateTime)
        responseFinishDateTime = responseFinishDateTimeDecoded
        let outputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .output)
        output = outputDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension CommandPlugin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommandPlugin(name: \(String(describing: name)), output: \(String(describing: output)), outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), outputS3Region: \(String(describing: outputS3Region)), responseCode: \(String(describing: responseCode)), responseFinishDateTime: \(String(describing: responseFinishDateTime)), responseStartDateTime: \(String(describing: responseStartDateTime)), standardErrorUrl: \(String(describing: standardErrorUrl)), standardOutputUrl: \(String(describing: standardOutputUrl)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)))"}
}

/// <p>Describes plugin details.</p>
public struct CommandPlugin: Equatable {
    /// <p>The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin,
    ///    aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or
    ///    aws:updateSSMAgent. </p>
    public let name: String?
    /// <p>Output of the plugin execution.</p>
    public let output: String?
    /// <p>The S3 bucket where the responses to the command executions should be stored. This was
    ///    requested when issuing the command. For example, in the following response:</p>
    ///          <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
    ///          <p>doc-example-bucket is the name of the S3 bucket;</p>
    ///          <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
    ///          <p>i-02573cafcfEXAMPLE is the instance ID;</p>
    ///          <p>awsrunShellScript is the name of the plugin.</p>
    public let outputS3BucketName: String?
    /// <p>The S3 directory path inside the bucket where the responses to the command executions should
    ///    be stored. This was requested when issuing the command. For example, in the following
    ///    response:</p>
    ///          <p>doc-example-bucket/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-02573cafcfEXAMPLE/awsrunShellScript </p>
    ///          <p>doc-example-bucket is the name of the S3 bucket;</p>
    ///          <p>ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p>
    ///          <p>i-02573cafcfEXAMPLE is the instance ID;</p>
    ///          <p>awsrunShellScript is the name of the plugin.</p>
    public let outputS3KeyPrefix: String?
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    ///    automatically determines the S3 bucket region.</p>
    public let outputS3Region: String?
    /// <p>A numeric response code generated after running the plugin. </p>
    public let responseCode: Int
    /// <p>The time the plugin stopped running. Could stop prematurely if, for example, a cancel
    ///    command was sent. </p>
    public let responseFinishDateTime: Date?
    /// <p>The time the plugin started running. </p>
    public let responseStartDateTime: Date?
    /// <p>The URL for the complete text written by the plugin to stderr. If execution is not yet
    ///    complete, then this string is empty.</p>
    public let standardErrorUrl: String?
    /// <p>The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for
    ///    the command was not specified, then this string is empty.</p>
    public let standardOutputUrl: String?
    /// <p>The status of this plugin. You can run a document with multiple plugins.</p>
    public let status: CommandPluginStatus?
    /// <p>A detailed status of the plugin execution. StatusDetails includes more information than
    ///    Status because it includes states resulting from error and concurrency control parameters.
    ///    StatusDetails can show different results than Status. For more information about these statuses,
    ///    see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    ///    StatusDetails can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Pending: The command has not been sent to the instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>In Progress: The command has been sent to the instance but has not reached a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Success: The execution of the command or plugin was successfully completed. This is a
    ///      terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    ///      timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit,
    ///      but they do contribute to whether the parent command status is Success or Incomplete. This is a
    ///      terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Execution Timed Out: Command execution started on the instance, but the execution was not
    ///      complete before the execution timeout expired. Execution timeouts count against the MaxErrors
    ///      limit of the parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Failed: The command was not successful on the instance. For a plugin, this indicates that
    ///      the result code was not zero. For a command invocation, this indicates that the result code for
    ///      one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the
    ///      parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Canceled: The command was terminated before it was completed. This is a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    ///      exist, or it might not be responding. Undeliverable invocations don't count against the parent
    ///      command's MaxErrors limit, and they don't contribute to whether the parent command status is
    ///      Success or Incomplete. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command
    ///      invocations were canceled by the system. This is a terminal state.</p>
    ///             </li>
    ///          </ul>
    public let statusDetails: String?

    public init (
        name: String? = nil,
        output: String? = nil,
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        outputS3Region: String? = nil,
        responseCode: Int = 0,
        responseFinishDateTime: Date? = nil,
        responseStartDateTime: Date? = nil,
        standardErrorUrl: String? = nil,
        standardOutputUrl: String? = nil,
        status: CommandPluginStatus? = nil,
        statusDetails: String? = nil
    )
    {
        self.name = name
        self.output = output
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.responseCode = responseCode
        self.responseFinishDateTime = responseFinishDateTime
        self.responseStartDateTime = responseStartDateTime
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
    }
}

public enum CommandPluginStatus {
    case cancelled
    case failed
    case inProgress
    case pending
    case success
    case timedOut
    case sdkUnknown(String)
}

extension CommandPluginStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommandPluginStatus] {
        return [
            .cancelled,
            .failed,
            .inProgress,
            .pending,
            .success,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .pending: return "Pending"
        case .success: return "Success"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommandPluginStatus(rawValue: rawValue) ?? CommandPluginStatus.sdkUnknown(rawValue)
    }
}

public enum CommandStatus {
    case cancelled
    case cancelling
    case failed
    case inProgress
    case pending
    case success
    case timedOut
    case sdkUnknown(String)
}

extension CommandStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CommandStatus] {
        return [
            .cancelled,
            .cancelling,
            .failed,
            .inProgress,
            .pending,
            .success,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .pending: return "Pending"
        case .success: return "Success"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CommandStatus(rawValue: rawValue) ?? CommandStatus.sdkUnknown(rawValue)
    }
}

extension ComplianceExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionId = "ExecutionId"
        case executionTime = "ExecutionTime"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime.timeIntervalSince1970, forKey: .executionTime)
        }
        if let executionType = executionType {
            try encodeContainer.encode(executionType, forKey: .executionType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension ComplianceExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceExecutionSummary(executionId: \(String(describing: executionId)), executionTime: \(String(describing: executionTime)), executionType: \(String(describing: executionType)))"}
}

/// <p>A summary of the call execution that includes an execution ID, the type of execution (for
///    example, <code>Command</code>), and the date/time of the execution using a datetime object that
///    is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
public struct ComplianceExecutionSummary: Equatable {
    /// <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example,
    ///     <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
    public let executionId: String?
    /// <p>The time the execution ran as a datetime object that is saved in the following format:
    ///    yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
    public let executionTime: Date?
    /// <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
    public let executionType: String?

    public init (
        executionId: String? = nil,
        executionTime: Date? = nil,
        executionType: String? = nil
    )
    {
        self.executionId = executionId
        self.executionTime = executionTime
        self.executionType = executionType
    }
}

extension ComplianceItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case details = "Details"
        case executionSummary = "ExecutionSummary"
        case id = "Id"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let severityDecoded = try containerValues.decodeIfPresent(ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let detailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .details)
        var detailsDecoded0: [String:String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [String:String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension ComplianceItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceItem(complianceType: \(String(describing: complianceType)), details: \(String(describing: details)), executionSummary: \(String(describing: executionSummary)), id: \(String(describing: id)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), severity: \(String(describing: severity)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

/// <p>Information about the compliance as defined by the resource type. For example, for a patch
///    resource type, <code>Items</code> includes information about the PatchSeverity, Classification,
///    and so on.</p>
public struct ComplianceItem: Equatable {
    /// <p>The compliance type. For example, Association (for a State Manager association), Patch, or
    ///     Custom:<code>string</code> are all valid compliance types.</p>
    public let complianceType: String?
    /// <p>A "Key": "Value" tag combination for the compliance item.</p>
    public let details: [String:String]?
    /// <p>A summary for the compliance item. The summary includes an execution ID, the execution type
    ///    (for example, command), and the execution time.</p>
    public let executionSummary: ComplianceExecutionSummary?
    /// <p>An ID for the compliance item. For example, if the compliance item is a Windows patch, the
    ///    ID could be the number of the KB article; for example: KB4010320.</p>
    public let id: String?
    /// <p>An ID for the resource. For a managed instance, this is the instance ID.</p>
    public let resourceId: String?
    /// <p>The type of resource. <code>ManagedInstance</code> is currently the only supported resource
    ///    type.</p>
    public let resourceType: String?
    /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
    ///    Medium, Low, Informational, Unspecified.</p>
    public let severity: ComplianceSeverity?
    /// <p>The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty
    ///    string (for Windows patches that aren't applicable).</p>
    public let status: ComplianceStatus?
    /// <p>A title for the compliance item. For example, if the compliance item is a Windows patch, the
    ///    title could be the title of the KB article for the patch; for example: Security Update for Active
    ///    Directory Federation Services.</p>
    public let title: String?

    public init (
        complianceType: String? = nil,
        details: [String:String]? = nil,
        executionSummary: ComplianceExecutionSummary? = nil,
        id: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        severity: ComplianceSeverity? = nil,
        status: ComplianceStatus? = nil,
        title: String? = nil
    )
    {
        self.complianceType = complianceType
        self.details = details
        self.executionSummary = executionSummary
        self.id = id
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.severity = severity
        self.status = status
        self.title = title
    }
}

extension ComplianceItemEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case id = "Id"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .details)
            for (dictKey0, complianceitemdetails0) in details {
                try detailsContainer.encode(complianceitemdetails0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let severityDecoded = try containerValues.decodeIfPresent(ComplianceSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let detailsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .details)
        var detailsDecoded0: [String:String]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [String:String]()
            for (key0, attributevalue0) in detailsContainer {
                if let attributevalue0 = attributevalue0 {
                    detailsDecoded0?[key0] = attributevalue0
                }
            }
        }
        details = detailsDecoded0
    }
}

extension ComplianceItemEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceItemEntry(details: \(String(describing: details)), id: \(String(describing: id)), severity: \(String(describing: severity)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

/// <p>Information about a compliance item.</p>
public struct ComplianceItemEntry: Equatable {
    /// <p>A "Key": "Value" tag combination for the compliance item.</p>
    public let details: [String:String]?
    /// <p>The compliance item ID. For example, if the compliance item is a Windows patch, the ID could
    ///    be the number of the KB article.</p>
    public let id: String?
    /// <p>The severity of the compliance status. Severity can be one of the following: Critical, High,
    ///    Medium, Low, Informational, Unspecified.</p>
    public let severity: ComplianceSeverity?
    /// <p>The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.</p>
    public let status: ComplianceStatus?
    /// <p>The title of the compliance item. For example, if the compliance item is a Windows patch,
    ///    the title could be the title of the KB article for the patch; for example: Security Update for
    ///    Active Directory Federation Services. </p>
    public let title: String?

    public init (
        details: [String:String]? = nil,
        id: String? = nil,
        severity: ComplianceSeverity? = nil,
        status: ComplianceStatus? = nil,
        title: String? = nil
    )
    {
        self.details = details
        self.id = id
        self.severity = severity
        self.status = status
        self.title = title
    }
}

public enum ComplianceQueryOperatorType {
    case beginwith
    case equal
    case greaterthan
    case lessthan
    case notequal
    case sdkUnknown(String)
}

extension ComplianceQueryOperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceQueryOperatorType] {
        return [
            .beginwith,
            .equal,
            .greaterthan,
            .lessthan,
            .notequal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginwith: return "BEGIN_WITH"
        case .equal: return "EQUAL"
        case .greaterthan: return "GREATER_THAN"
        case .lessthan: return "LESS_THAN"
        case .notequal: return "NOT_EQUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceQueryOperatorType(rawValue: rawValue) ?? ComplianceQueryOperatorType.sdkUnknown(rawValue)
    }
}

public enum ComplianceSeverity {
    case critical
    case high
    case informational
    case low
    case medium
    case unspecified
    case sdkUnknown(String)
}

extension ComplianceSeverity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceSeverity] {
        return [
            .critical,
            .high,
            .informational,
            .low,
            .medium,
            .unspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .informational: return "INFORMATIONAL"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .unspecified: return "UNSPECIFIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceSeverity(rawValue: rawValue) ?? ComplianceSeverity.sdkUnknown(rawValue)
    }
}

public enum ComplianceStatus {
    case compliant
    case noncompliant
    case sdkUnknown(String)
}

extension ComplianceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceStatus] {
        return [
            .compliant,
            .noncompliant,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compliant: return "COMPLIANT"
        case .noncompliant: return "NON_COMPLIANT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
    }
}

extension ComplianceStringFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for compliancestringfiltervaluelist0 in values {
                try valuesContainer.encode(compliancestringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ComplianceQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ComplianceStringFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceStringFilter(key: \(String(describing: key)), type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
public struct ComplianceStringFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: String?
    /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith,
    ///    LessThan, or GreaterThan.</p>
    public let type: ComplianceQueryOperatorType?
    /// <p>The value for which to search.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        type: ComplianceQueryOperatorType? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.type = type
        self.values = values
    }
}

extension ComplianceSummaryItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case nonCompliantSummary = "NonCompliantSummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension ComplianceSummaryItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceSummaryItem(complianceType: \(String(describing: complianceType)), compliantSummary: \(String(describing: compliantSummary)), nonCompliantSummary: \(String(describing: nonCompliantSummary)))"}
}

/// <p>A summary of compliance information by compliance type.</p>
public struct ComplianceSummaryItem: Equatable {
    /// <p>The type of compliance item. For example, the compliance type can be Association, Patch, or
    ///    Custom:string.</p>
    public let complianceType: String?
    /// <p>A list of COMPLIANT items for the specified compliance type.</p>
    public let compliantSummary: CompliantSummary?
    /// <p>A list of NON_COMPLIANT items for the specified compliance type.</p>
    public let nonCompliantSummary: NonCompliantSummary?

    public init (
        complianceType: String? = nil,
        compliantSummary: CompliantSummary? = nil,
        nonCompliantSummary: NonCompliantSummary? = nil
    )
    {
        self.complianceType = complianceType
        self.compliantSummary = compliantSummary
        self.nonCompliantSummary = nonCompliantSummary
    }
}

extension ComplianceTypeCountLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComplianceTypeCountLimitExceededException(message: \(String(describing: message)))"}
}

extension ComplianceTypeCountLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ComplianceTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified too many custom compliance types. You can specify a maximum of 10 different
///    types. </p>
public struct ComplianceTypeCountLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ComplianceTypeCountLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ComplianceTypeCountLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ComplianceUploadType {
    case complete
    case partial
    case sdkUnknown(String)
}

extension ComplianceUploadType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComplianceUploadType] {
        return [
            .complete,
            .partial,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .partial: return "PARTIAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComplianceUploadType(rawValue: rawValue) ?? ComplianceUploadType.sdkUnknown(rawValue)
    }
}

extension CompliantSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compliantCount = "CompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if compliantCount != 0 {
            try encodeContainer.encode(compliantCount, forKey: .compliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compliantCountDecoded = try containerValues.decode(Int.self, forKey: .compliantCount)
        compliantCount = compliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension CompliantSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompliantSummary(compliantCount: \(String(describing: compliantCount)), severitySummary: \(String(describing: severitySummary)))"}
}

/// <p>A summary of resources that are compliant. The summary is organized according to the
///    resource count for each compliance type.</p>
public struct CompliantSummary: Equatable {
    /// <p>The total number of resources that are compliant.</p>
    public let compliantCount: Int
    /// <p>A summary of the compliance severity by compliance type.</p>
    public let severitySummary: SeveritySummary?

    public init (
        compliantCount: Int = 0,
        severitySummary: SeveritySummary? = nil
    )
    {
        self.compliantCount = compliantCount
        self.severitySummary = severitySummary
    }
}

public enum ConnectionStatus {
    case connected
    case notConnected
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .connected,
            .notConnected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "Connected"
        case .notConnected: return "NotConnected"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

public struct CreateActivationInputBodyMiddleware: Middleware {
    public let id: String = "CreateActivationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivationInput>
    public typealias MOutput = OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivationOutputError>
}

extension CreateActivationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActivationInput(defaultInstanceName: \(String(describing: defaultInstanceName)), description: \(String(describing: description)), expirationDate: \(String(describing: expirationDate)), iamRole: \(String(describing: iamRole)), registrationLimit: \(String(describing: registrationLimit)), tags: \(String(describing: tags)))"}
}

extension CreateActivationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultInstanceName = defaultInstanceName {
            try encodeContainer.encode(defaultInstanceName, forKey: .defaultInstanceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if registrationLimit != 0 {
            try encodeContainer.encode(registrationLimit, forKey: .registrationLimit)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateActivationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateActivationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivationInput>
    public typealias MOutput = OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivationOutputError>
}

public struct CreateActivationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateActivationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateActivationInput>
    public typealias MOutput = OperationOutput<CreateActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateActivationOutputError>
}

public struct CreateActivationInput: Equatable {
    /// <p>The name of the registered, managed instance as it will appear in the Systems Manager console or when
    ///    you use the AWS command line tools to list Systems Manager resources.</p>
    ///          <important>
    ///             <p>Do not enter personally identifiable information in this field.</p>
    ///          </important>
    public let defaultInstanceName: String?
    /// <p>A user-defined description of the resource that you want to register with Systems Manager. </p>
    ///          <important>
    ///             <p>Do not enter personally identifiable information in this field.</p>
    ///          </important>
    public let description: String?
    /// <p>The date by which this activation request should expire, in timestamp format, such as
    ///    "2021-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an
    ///    expiration date, the activation code expires in 24 hours.</p>
    public let expirationDate: Date?
    /// <p>The Amazon Identity and Access Management (IAM) role that you want to assign to the managed
    ///    instance. This IAM role must provide AssumeRole permissions for the Systems Manager service principal
    ///     <code>ssm.amazonaws.com</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-service-role.html">Create an IAM service role for a
    ///     hybrid environment</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let iamRole: String?
    /// <p>Specify the maximum number of managed instances you want to register. The default value is 1
    ///    instance.</p>
    public let registrationLimit: Int
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    ///    different ways, such as by purpose, owner, or environment. For example, you might want to tag an
    ///    activation to identify which servers or virtual machines (VMs) in your on-premises environment
    ///    you intend to activate. In this case, you could specify the following key name/value
    ///    pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Environment,Value=Production</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <important>
    ///             <p>When you install SSM Agent on your on-premises servers and VMs, you specify an activation
    ///     ID and code. When you specify the activation ID and code, tags assigned to the activation are
    ///     automatically applied to the on-premises servers or VMs.</p>
    ///          </important>
    ///          <p>You can't add tags to or delete tags from an existing activation. You can tag your
    ///    on-premises servers and VMs after they connect to Systems Manager for the first time and are assigned a
    ///    managed instance ID. This means they are listed in the AWS Systems Manager console with an ID that is
    ///    prefixed with "mi-". For information about how to add tags to your managed instances, see <a>AddTagsToResource</a>. For information about how to remove tags from your managed
    ///    instances, see <a>RemoveTagsFromResource</a>.</p>
    public let tags: [Tag]?

    public init (
        defaultInstanceName: String? = nil,
        description: String? = nil,
        expirationDate: Date? = nil,
        iamRole: String? = nil,
        registrationLimit: Int = 0,
        tags: [Tag]? = nil
    )
    {
        self.defaultInstanceName = defaultInstanceName
        self.description = description
        self.expirationDate = expirationDate
        self.iamRole = iamRole
        self.registrationLimit = registrationLimit
        self.tags = tags
    }
}

struct CreateActivationInputBody: Equatable {
    public let description: String?
    public let defaultInstanceName: String?
    public let iamRole: String?
    public let registrationLimit: Int
    public let expirationDate: Date?
    public let tags: [Tag]?
}

extension CreateActivationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultInstanceName = "DefaultInstanceName"
        case description = "Description"
        case expirationDate = "ExpirationDate"
        case iamRole = "IamRole"
        case registrationLimit = "RegistrationLimit"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultInstanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultInstanceName)
        defaultInstanceName = defaultInstanceNameDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationLimitDecoded = try containerValues.decode(Int.self, forKey: .registrationLimit)
        registrationLimit = registrationLimitDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateActivationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActivationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateActivationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActivationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateActivationOutputResponse(activationCode: \(String(describing: activationCode)), activationId: \(String(describing: activationId)))"}
}

extension CreateActivationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateActivationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activationCode = output.activationCode
            self.activationId = output.activationId
        } else {
            self.activationCode = nil
            self.activationId = nil
        }
    }
}

public struct CreateActivationOutputResponse: Equatable {
    /// <p>The code the system generates when it processes the activation. The activation code
    ///    functions like a password to validate the activation ID. </p>
    public let activationCode: String?
    /// <p>The ID number generated by the system when it processed the activation. The activation ID
    ///    functions like a user name.</p>
    public let activationId: String?

    public init (
        activationCode: String? = nil,
        activationId: String? = nil
    )
    {
        self.activationCode = activationCode
        self.activationId = activationId
    }
}

struct CreateActivationOutputResponseBody: Equatable {
    public let activationId: String?
    public let activationCode: String?
}

extension CreateActivationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationCode = "ActivationCode"
        case activationId = "ActivationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

public struct CreateAssociationBatchInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssociationBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationBatchOutputError>
}

extension CreateAssociationBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssociationBatchInput(entries: \(String(describing: entries)))"}
}

extension CreateAssociationBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for createassociationbatchrequestentries0 in entries {
                try entriesContainer.encode(createassociationbatchrequestentries0)
            }
        }
    }
}

public struct CreateAssociationBatchInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssociationBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssociationBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationBatchInput>
    public typealias MOutput = OperationOutput<CreateAssociationBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationBatchOutputError>
}

public struct CreateAssociationBatchInput: Equatable {
    /// <p>One or more associations.</p>
    public let entries: [CreateAssociationBatchRequestEntry]?

    public init (
        entries: [CreateAssociationBatchRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct CreateAssociationBatchInputBody: Equatable {
    public let entries: [CreateAssociationBatchRequestEntry]?
}

extension CreateAssociationBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([CreateAssociationBatchRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[CreateAssociationBatchRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [CreateAssociationBatchRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension CreateAssociationBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationBatchOutputError: Equatable {
    case associationLimitExceeded(AssociationLimitExceeded)
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssociationBatchOutputResponse(failed: \(String(describing: failed)), successful: \(String(describing: successful)))"}
}

extension CreateAssociationBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssociationBatchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failed = output.failed
            self.successful = output.successful
        } else {
            self.failed = nil
            self.successful = nil
        }
    }
}

public struct CreateAssociationBatchOutputResponse: Equatable {
    /// <p>Information about the associations that failed.</p>
    public let failed: [FailedCreateAssociation]?
    /// <p>Information about the associations that succeeded.</p>
    public let successful: [AssociationDescription]?

    public init (
        failed: [FailedCreateAssociation]? = nil,
        successful: [AssociationDescription]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

struct CreateAssociationBatchOutputResponseBody: Equatable {
    public let successful: [AssociationDescription]?
    public let failed: [FailedCreateAssociation]?
}

extension CreateAssociationBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failed = "Failed"
        case successful = "Successful"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([AssociationDescription?].self, forKey: .successful)
        var successfulDecoded0:[AssociationDescription]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [AssociationDescription]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let failedContainer = try containerValues.decodeIfPresent([FailedCreateAssociation?].self, forKey: .failed)
        var failedDecoded0:[FailedCreateAssociation]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [FailedCreateAssociation]()
            for structure0 in failedContainer {
                if let structure0 = structure0 {
                    failedDecoded0?.append(structure0)
                }
            }
        }
        failed = failedDecoded0
    }
}

extension CreateAssociationBatchRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension CreateAssociationBatchRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssociationBatchRequestEntry(applyOnlyAtCronInterval: \(String(describing: applyOnlyAtCronInterval)), associationName: \(String(describing: associationName)), automationTargetParameterName: \(String(describing: automationTargetParameterName)), calendarNames: \(String(describing: calendarNames)), complianceSeverity: \(String(describing: complianceSeverity)), documentVersion: \(String(describing: documentVersion)), instanceId: \(String(describing: instanceId)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), parameters: \(String(describing: parameters)), scheduleExpression: \(String(describing: scheduleExpression)), syncCompliance: \(String(describing: syncCompliance)), targetLocations: \(String(describing: targetLocations)), targets: \(String(describing: targets)))"}
}

/// <p>Describes the association of a Systems Manager SSM document and an instance.</p>
public struct CreateAssociationBatchRequestEntry: Equatable {
    /// <p>By default, when you create a new associations, the system runs it immediately after it is
    ///    created and then according to the schedule you specified. Specify this option if you don't want
    ///    an association to run immediately after you create it. This parameter is not supported for rate
    ///    expressions.</p>
    public let applyOnlyAtCronInterval: Bool
    /// <p>Specify a descriptive name for the association.</p>
    public let associationName: String?
    /// <p>Specify the target for the association. This target is required for associations that use an
    ///    Automation document and target resources by using rate controls.</p>
    public let automationTargetParameterName: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    ///   documents your associations are gated under. The associations only run when that Change
    ///   Calendar is open.  For more information, see
    ///   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change Calendar</a>.</p>
    public let calendarNames: [String]?
    /// <p>The severity level to assign to the association.</p>
    public let complianceSeverity: AssociationComplianceSeverity?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>The ID of the instance. </p>
    public let instanceId: String?
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    ///    specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    ///    value is 100%, which means all targets run the association at the same time.</p>
    ///          <p>If a new instance starts and attempts to run an association while Systems Manager is running
    ///    MaxConcurrency associations, the association is allowed to run. During the next association
    ///    interval, the new instance will process its association within the limit specified for
    ///    MaxConcurrency.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    ///    association on additional targets. You can specify either an absolute number of errors, for
    ///    example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    ///    the system stops sending requests when the fourth error is received. If you specify 0, then the
    ///    system stops sending requests after the first error is returned. If you run an association on 50
    ///    instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    ///    is received.</p>
    ///          <p>Executions that are already running an association when MaxErrors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    ///    You can specify Command or Automation documents.</p>
    ///          <p>You can specify AWS-predefined documents, documents you created, or a document that is
    ///    shared with you from another account.</p>
    ///          <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    ///    complete SSM document ARN, in the following format:</p>
    ///          <p>
    ///             <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    ///             </code>
    ///          </p>
    ///          <p>For example:</p>
    ///          <p>
    ///             <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    ///          </p>
    ///          <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    ///    specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    ///     <code>My-Document</code>.</p>
    public let name: String?
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    public let outputLocation: InstanceAssociationOutputLocation?
    /// <p>A description of the parameters for a document. </p>
    public let parameters: [String:[String]]?
    /// <p>A cron expression that specifies a schedule when the association runs.</p>
    public let scheduleExpression: String?
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    ///     <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    ///    execution to determine the compliance status. If the association execution runs successfully,
    ///    then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    ///    successfully, the association is <code>NON-COMPLIANT</code>. </p>
    ///          <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    ///    for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    ///    managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    ///          <p>By default, all associations use <code>AUTO</code> mode.</p>
    public let syncCompliance: AssociationSyncCompliance?
    /// <p>Use this action to create an association in multiple Regions and multiple accounts.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The instances targeted by the request.</p>
    public let targets: [Target]?

    public init (
        applyOnlyAtCronInterval: Bool = false,
        associationName: String? = nil,
        automationTargetParameterName: String? = nil,
        calendarNames: [String]? = nil,
        complianceSeverity: AssociationComplianceSeverity? = nil,
        documentVersion: String? = nil,
        instanceId: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        outputLocation: InstanceAssociationOutputLocation? = nil,
        parameters: [String:[String]]? = nil,
        scheduleExpression: String? = nil,
        syncCompliance: AssociationSyncCompliance? = nil,
        targetLocations: [TargetLocation]? = nil,
        targets: [Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationName = associationName
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

public struct CreateAssociationInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationOutputError>
}

extension CreateAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssociationInput(applyOnlyAtCronInterval: \(String(describing: applyOnlyAtCronInterval)), associationName: \(String(describing: associationName)), automationTargetParameterName: \(String(describing: automationTargetParameterName)), calendarNames: \(String(describing: calendarNames)), complianceSeverity: \(String(describing: complianceSeverity)), documentVersion: \(String(describing: documentVersion)), instanceId: \(String(describing: instanceId)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), parameters: \(String(describing: parameters)), scheduleExpression: \(String(describing: scheduleExpression)), syncCompliance: \(String(describing: syncCompliance)), targetLocations: \(String(describing: targetLocations)), targets: \(String(describing: targets)))"}
}

extension CreateAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct CreateAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssociationInput>
    public typealias MOutput = OperationOutput<CreateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssociationOutputError>
}

public struct CreateAssociationInput: Equatable {
    /// <p>By default, when you create a new association, the system runs it immediately after it is
    ///    created and then according to the schedule you specified. Specify this option if you don't want
    ///    an association to run immediately after you create it. This parameter is not supported for rate
    ///    expressions.</p>
    public let applyOnlyAtCronInterval: Bool
    /// <p>Specify a descriptive name for the association.</p>
    public let associationName: String?
    /// <p>Specify the target for the association. This target is required for associations that use an
    ///    Automation document and target resources by using rate controls.</p>
    public let automationTargetParameterName: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    ///    documents you want to gate your associations under. The associations only run when that Change
    ///    Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
    ///     Calendar</a>.</p>
    public let calendarNames: [String]?
    /// <p>The severity level to assign to the association.</p>
    public let complianceSeverity: AssociationComplianceSeverity?
    /// <p>The document version you want to associate with the target(s). Can be a specific version or
    ///    the default version.</p>
    public let documentVersion: String?
    /// <p>The instance ID.</p>
    ///          <note>
    ///             <p>
    ///                <code>InstanceId</code> has been deprecated. To specify an instance ID for an association,
    ///     use the <code>Targets</code> parameter. Requests that include the
    ///     parameter <code>InstanceID</code> with SSM documents that use schema version 2.0 or later will
    ///     fail. In addition, if you use the parameter <code>InstanceId</code>, you
    ///     cannot use the parameters <code>AssociationName</code>, <code>DocumentVersion</code>,
    ///      <code>MaxErrors</code>, <code>MaxConcurrency</code>, <code>OutputLocation</code>, or
    ///      <code>ScheduleExpression</code>. To use these parameters, you must use the <code>Targets</code>
    ///     parameter.</p>
    ///          </note>
    public let instanceId: String?
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    ///    specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    ///    value is 100%, which means all targets run the association at the same time.</p>
    ///          <p>If a new instance starts and attempts to run an association while Systems Manager is running
    ///    MaxConcurrency associations, the association is allowed to run. During the next association
    ///    interval, the new instance will process its association within the limit specified for
    ///    MaxConcurrency.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    ///    association on additional targets. You can specify either an absolute number of errors, for
    ///    example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    ///    the system stops sending requests when the fourth error is received. If you specify 0, then the
    ///    system stops sending requests after the first error is returned. If you run an association on 50
    ///    instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    ///    is received.</p>
    ///          <p>Executions that are already running an association when MaxErrors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    ///    You can specify Command or Automation documents.</p>
    ///          <p>You can specify AWS-predefined documents, documents you created, or a document that is
    ///    shared with you from another account.</p>
    ///          <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    ///    complete SSM document ARN, in the following format:</p>
    ///          <p>
    ///             <code>arn:<i>partition</i>:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    ///             </code>
    ///          </p>
    ///          <p>For example:</p>
    ///          <p>
    ///             <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    ///          </p>
    ///          <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    ///    specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    ///     <code>My-Document</code>.</p>
    public let name: String?
    /// <p>An S3 bucket where you want to store the output details of the request.</p>
    public let outputLocation: InstanceAssociationOutputLocation?
    /// <p>The parameters for the runtime configuration of the document.</p>
    public let parameters: [String:[String]]?
    /// <p>A cron expression when the association will be applied to the target(s).</p>
    public let scheduleExpression: String?
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    ///     <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    ///    execution to determine the compliance status. If the association execution runs successfully,
    ///    then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    ///    successfully, the association is <code>NON-COMPLIANT</code>.</p>
    ///          <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    ///    for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    ///    managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    ///          <p>By default, all associations use <code>AUTO</code> mode.</p>
    public let syncCompliance: AssociationSyncCompliance?
    /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
    ///    association. Use this action to create an association in multiple Regions and multiple
    ///    accounts.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The targets for the association. You can target instances by using tags, AWS Resource
    ///    Groups, all instances in an AWS account, or individual instance IDs. For more information about
    ///    choosing targets for an association, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html">Using targets and rate controls with State Manager associations</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let targets: [Target]?

    public init (
        applyOnlyAtCronInterval: Bool = false,
        associationName: String? = nil,
        automationTargetParameterName: String? = nil,
        calendarNames: [String]? = nil,
        complianceSeverity: AssociationComplianceSeverity? = nil,
        documentVersion: String? = nil,
        instanceId: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        outputLocation: InstanceAssociationOutputLocation? = nil,
        parameters: [String:[String]]? = nil,
        scheduleExpression: String? = nil,
        syncCompliance: AssociationSyncCompliance? = nil,
        targetLocations: [TargetLocation]? = nil,
        targets: [Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationName = associationName
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.instanceId = instanceId
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct CreateAssociationInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let instanceId: String?
    public let parameters: [String:[String]]?
    public let targets: [Target]?
    public let scheduleExpression: String?
    public let outputLocation: InstanceAssociationOutputLocation?
    public let associationName: String?
    public let automationTargetParameterName: String?
    public let maxErrors: String?
    public let maxConcurrency: String?
    public let complianceSeverity: AssociationComplianceSeverity?
    public let syncCompliance: AssociationSyncCompliance?
    public let applyOnlyAtCronInterval: Bool
    public let calendarNames: [String]?
    public let targetLocations: [TargetLocation]?
}

extension CreateAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationName = "AssociationName"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case instanceId = "InstanceId"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension CreateAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationAlreadyExists" : self = .associationAlreadyExists(try AssociationAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationLimitExceeded" : self = .associationLimitExceeded(try AssociationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssociationOutputError: Equatable {
    case associationAlreadyExists(AssociationAlreadyExists)
    case associationLimitExceeded(AssociationLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssociationOutputResponse(associationDescription: \(String(describing: associationDescription)))"}
}

extension CreateAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct CreateAssociationOutputResponse: Equatable {
    /// <p>Information about the association.</p>
    public let associationDescription: AssociationDescription?

    public init (
        associationDescription: AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct CreateAssociationOutputResponseBody: Equatable {
    public let associationDescription: AssociationDescription?
}

extension CreateAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct CreateDocumentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentOutputError>
}

extension CreateDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentInput(attachments: \(String(describing: attachments)), content: \(String(describing: content)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentType: \(String(describing: documentType)), name: \(String(describing: name)), requires: \(String(describing: requires)), tags: \(String(describing: tags)), targetType: \(String(describing: targetType)), versionName: \(String(describing: versionName)))"}
}

extension CreateDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct CreateDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDocumentInput>
    public typealias MOutput = OperationOutput<CreateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDocumentOutputError>
}

public struct CreateDocumentInput: Equatable {
    /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
    public let attachments: [AttachmentsSource]?
    /// <p>The content for the new SSM document in JSON or YAML format. We recommend storing the
    ///    contents for your new document in an external JSON or YAML file and referencing the file in a
    ///    command.</p>
    ///          <p>For examples, see the following topics in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
    ///       (AWS API)</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-cli.html">Create an SSM document
    ///       (AWS CLI)</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/create-ssm-document-api.html">Create an SSM document
    ///       (API)</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let content: String?
    /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
    ///    can differ for each version of the document. You can update this value at a later time using the
    ///     <a>UpdateDocument</a> action.</p>
    public let displayName: String?
    /// <p>Specify the document format for the request. The document format can be JSON, YAML, or TEXT.
    ///    JSON is the default format.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The type of document to create.</p>
    public let documentType: DocumentType?
    /// <p>A name for the Systems Manager document.</p>
    ///          <important>
    ///             <p>You can't use the following strings as document name prefixes. These are reserved by AWS
    ///     for use as document name prefixes:</p>
    ///             <ul>
    ///                <li>
    ///                   <p>
    ///                      <code>aws-</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>amazon</code>
    ///                   </p>
    ///                </li>
    ///                <li>
    ///                   <p>
    ///                      <code>amzn</code>
    ///                   </p>
    ///                </li>
    ///             </ul>
    ///          </important>
    public let name: String?
    /// <p>A list of SSM documents required by a document. This parameter is used exclusively by AWS
    ///    AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also
    ///    specify a required document for validation purposes. In this case, an
    ///     <code>ApplicationConfiguration</code> document requires an
    ///     <code>ApplicationConfigurationSchema</code> document for validation purposes. For more
    ///    information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig.html">AWS AppConfig</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let requires: [DocumentRequires]?
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    ///    different ways, such as by purpose, owner, or environment. For example, you might want to tag an
    ///    SSM document to identify the types of targets or the environment where it will run. In this case,
    ///    you could specify the following key name/value pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Environment,Value=Production</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>To add tags to an existing SSM document, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>Specify a target type to define the kinds of resources the document can run on. For example,
    ///    to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you
    ///    specify a value of '/' the document can run on all types of resources. If you don't specify a
    ///    value, the document can't run on any resources. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    ///     reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    public let targetType: String?
    /// <p>An optional field specifying the version of the artifact you are creating with the document.
    ///    For example, "Release 12, Update 6". This value is unique across all versions of a document, and
    ///    cannot be changed.</p>
    public let versionName: String?

    public init (
        attachments: [AttachmentsSource]? = nil,
        content: String? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentType: DocumentType? = nil,
        name: String? = nil,
        requires: [DocumentRequires]? = nil,
        tags: [Tag]? = nil,
        targetType: String? = nil,
        versionName: String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.name = name
        self.requires = requires
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct CreateDocumentInputBody: Equatable {
    public let content: String?
    public let requires: [DocumentRequires]?
    public let attachments: [AttachmentsSource]?
    public let name: String?
    public let displayName: String?
    public let versionName: String?
    public let documentType: DocumentType?
    public let documentFormat: DocumentFormat?
    public let targetType: String?
    public let tags: [Tag]?
}

extension CreateDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case name = "Name"
        case requires = "Requires"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let requiresContainer = try containerValues.decodeIfPresent([DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContainer = try containerValues.decodeIfPresent([AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DocumentAlreadyExists" : self = .documentAlreadyExists(try DocumentAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentOutputError: Equatable {
    case documentAlreadyExists(DocumentAlreadyExists)
    case documentLimitExceeded(DocumentLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDocumentOutputResponse(documentDescription: \(String(describing: documentDescription)))"}
}

extension CreateDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct CreateDocumentOutputResponse: Equatable {
    /// <p>Information about the Systems Manager document.</p>
    public let documentDescription: DocumentDescription?

    public init (
        documentDescription: DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct CreateDocumentOutputResponseBody: Equatable {
    public let documentDescription: DocumentDescription?
}

extension CreateDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

public struct CreateMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "CreateMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMaintenanceWindowOutputError>
}

extension CreateMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMaintenanceWindowInput(allowUnassociatedTargets: \(String(describing: allowUnassociatedTargets)), clientToken: \(String(describing: clientToken)), cutoff: \(String(describing: cutoff)), description: \(String(describing: description)), duration: \(String(describing: duration)), endDate: \(String(describing: endDate)), name: \(String(describing: name)), schedule: \(String(describing: schedule)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleTimezone: \(String(describing: scheduleTimezone)), startDate: \(String(describing: startDate)), tags: \(String(describing: tags)))"}
}

extension CreateMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<CreateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMaintenanceWindowOutputError>
}

public struct CreateMaintenanceWindowInput: Equatable {
    /// <p>Enables a maintenance window task to run on managed instances, even if you have not
    ///    registered those instances as targets. If enabled, then you must specify the unregistered
    ///    instances (by instance ID) when you register a task with the maintenance window.</p>
    ///          <p>If you don't enable this option, then you must specify previously-registered targets when
    ///    you register a task with the maintenance window.</p>
    public let allowUnassociatedTargets: Bool
    /// <p>User-provided idempotency token.</p>
    public var clientToken: String?
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    ///    tasks for execution.</p>
    public let cutoff: Int
    /// <p>An optional description for the maintenance window. We recommend specifying a description to
    ///    help you organize your maintenance windows. </p>
    public let description: String?
    /// <p>The duration of the maintenance window in hours.</p>
    public let duration: Int
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    ///    become inactive. EndDate allows you to set a date and time in the future when the maintenance
    ///    window will no longer run.</p>
    public let endDate: String?
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    public let schedule: String?
    /// <p>The number of days to wait after the date and time specified by a CRON expression before
    ///    running the maintenance window.</p>
    ///          <p>For example, the following cron expression schedules a maintenance window to run on the
    ///    third Tuesday of every month at 11:30 PM.</p>
    ///          <p>
    ///             <code>cron(30 23 ? * TUE#3 *)</code>
    ///          </p>
    ///          <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
    ///    later.</p>
    public let scheduleOffset: Int
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    ///    "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    ///     Zone Database</a> on the IANA website.</p>
    public let scheduleTimezone: String?
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    ///    become active. StartDate allows you to delay activation of the maintenance window until the
    ///    specified future date.</p>
    public let startDate: String?
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    ///    different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    ///    maintenance window to identify the type of tasks it will run, the types of targets, and the
    ///    environment it will run in. In this case, you could specify the following key name/value
    ///    pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=TaskType,Value=AgentUpdate</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Environment,Value=Production</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>To add tags to an existing maintenance window, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        allowUnassociatedTargets: Bool = false,
        clientToken: String? = nil,
        cutoff: Int = 0,
        description: String? = nil,
        duration: Int = 0,
        endDate: String? = nil,
        name: String? = nil,
        schedule: String? = nil,
        scheduleOffset: Int = 0,
        scheduleTimezone: String? = nil,
        startDate: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.clientToken = clientToken
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.tags = tags
    }
}

struct CreateMaintenanceWindowInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let startDate: String?
    public let endDate: String?
    public let schedule: String?
    public let scheduleTimezone: String?
    public let scheduleOffset: Int
    public let duration: Int
    public let cutoff: Int
    public let allowUnassociatedTargets: Bool
    public let clientToken: String?
    public let tags: [Tag]?
}

extension CreateMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case clientToken = "ClientToken"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMaintenanceWindowOutputError: Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMaintenanceWindowOutputResponse(windowId: \(String(describing: windowId)))"}
}

extension CreateMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct CreateMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the created maintenance window.</p>
    public let windowId: String?

    public init (
        windowId: String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct CreateMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
}

extension CreateMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

public struct CreateOpsItemInputBodyMiddleware: Middleware {
    public let id: String = "CreateOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsItemOutputError>
}

extension CreateOpsItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpsItemInput(actualEndTime: \(String(describing: actualEndTime)), actualStartTime: \(String(describing: actualStartTime)), category: \(String(describing: category)), description: \(String(describing: description)), notifications: \(String(describing: notifications)), operationalData: \(String(describing: operationalData)), opsItemType: \(String(describing: opsItemType)), plannedEndTime: \(String(describing: plannedEndTime)), plannedStartTime: \(String(describing: plannedStartTime)), priority: \(String(describing: priority)), relatedOpsItems: \(String(describing: relatedOpsItems)), severity: \(String(describing: severity)), source: \(String(describing: source)), tags: \(String(describing: tags)), title: \(String(describing: title)))"}
}

extension CreateOpsItemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct CreateOpsItemInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsItemInput>
    public typealias MOutput = OperationOutput<CreateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsItemOutputError>
}

public struct CreateOpsItemInput: Equatable {
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualEndTime: Date?
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualStartTime: Date?
    /// <p>Specify a category to assign to an OpsItem. </p>
    public let category: String?
    /// <p>Information about the OpsItem. </p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    ///    OpsItem is edited or changed.</p>
    public let notifications: [OpsItemNotification]?
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    ///    For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    ///    other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    ///    of 128 characters. The value has a maximum size of 20 KB.</p>
    ///          <important>
    ///             <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    ///     amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    ///          </important>
    ///          <p>You can choose to make the data searchable by other users in the account or you can restrict
    ///    search access. Searchable data means that all users with access to the OpsItem Overview page (as
    ///    provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    ///    specified data. Operational data that is not searchable is only viewable by users who have access
    ///    to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    ///          <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    ///    the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    ///    Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    ///     <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let operationalData: [String:OpsItemDataValue]?
    /// <p>The type of OpsItem to create. Currently, the only valid values are
    ///     <code>/aws/changerequest</code> and <code>/aws/issue</code>.</p>
    public let opsItemType: String?
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedEndTime: Date?
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedStartTime: Date?
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    public let priority: Int?
    /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
    ///    related OpsItems can include OpsItems with similar error messages, impacted resources, or
    ///    statuses for the impacted resource.</p>
    public let relatedOpsItems: [RelatedOpsItem]?
    /// <p>Specify a severity to assign to an OpsItem.</p>
    public let severity: String?
    /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager.</p>
    ///          <note>
    ///             <p>The source name can't contain the following strings: aws, amazon, and amzn. </p>
    ///          </note>
    public let source: String?
    /// <p>Optional metadata that you assign to a resource. You can restrict access to OpsItems by
    ///    using an inline IAM policy that specifies tags. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-getting-started.html#OpsCenter-getting-started-user-permissions">Getting started with OpsCenter</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          <p>Tags use a key-value pair. For example:</p>
    ///          <p>
    ///             <code>Key=Department,Value=Finance</code>
    ///          </p>
    ///          <note>
    ///             <p>To add tags to an existing OpsItem, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    public let title: String?

    public init (
        actualEndTime: Date? = nil,
        actualStartTime: Date? = nil,
        category: String? = nil,
        description: String? = nil,
        notifications: [OpsItemNotification]? = nil,
        operationalData: [String:OpsItemDataValue]? = nil,
        opsItemType: String? = nil,
        plannedEndTime: Date? = nil,
        plannedStartTime: Date? = nil,
        priority: Int? = nil,
        relatedOpsItems: [RelatedOpsItem]? = nil,
        severity: String? = nil,
        source: String? = nil,
        tags: [Tag]? = nil,
        title: String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.source = source
        self.tags = tags
        self.title = title
    }
}

struct CreateOpsItemInputBody: Equatable {
    public let description: String?
    public let opsItemType: String?
    public let operationalData: [String:OpsItemDataValue]?
    public let notifications: [OpsItemNotification]?
    public let priority: Int?
    public let relatedOpsItems: [RelatedOpsItem]?
    public let source: String?
    public let title: String?
    public let tags: [Tag]?
    public let category: String?
    public let severity: String?
    public let actualStartTime: Date?
    public let actualEndTime: Date?
    public let plannedStartTime: Date?
    public let plannedEndTime: Date?
}

extension CreateOpsItemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case tags = "Tags"
        case title = "Title"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([String: OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [String:OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [String:OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension CreateOpsItemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsItemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsItemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsItemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpsItemOutputResponse(opsItemId: \(String(describing: opsItemId)))"}
}

extension CreateOpsItemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.opsItemId = output.opsItemId
        } else {
            self.opsItemId = nil
        }
    }
}

public struct CreateOpsItemOutputResponse: Equatable {
    /// <p>The ID of the OpsItem.</p>
    public let opsItemId: String?

    public init (
        opsItemId: String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct CreateOpsItemOutputResponseBody: Equatable {
    public let opsItemId: String?
}

extension CreateOpsItemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

public struct CreateOpsMetadataInputBodyMiddleware: Middleware {
    public let id: String = "CreateOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsMetadataOutputError>
}

extension CreateOpsMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpsMetadataInput(metadata: \(String(describing: metadata)), resourceId: \(String(describing: resourceId)), tags: \(String(describing: tags)))"}
}

extension CreateOpsMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metadata)
            for (dictKey0, metadatamap0) in metadata {
                try metadataContainer.encode(metadatamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateOpsMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOpsMetadataInput>
    public typealias MOutput = OperationOutput<CreateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOpsMetadataOutputError>
}

public struct CreateOpsMetadataInput: Equatable {
    /// <p>Metadata for a new Application Manager application. </p>
    public let metadata: [String:MetadataValue]?
    /// <p>A resource ID for a new Application Manager application.</p>
    public let resourceId: String?
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    ///    an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by
    ///    purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to
    ///    identify an environment or target AWS Region. In this case, you could specify the following
    ///    key-value pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Environment,Value=Production</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Region,Value=us-east-2</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        metadata: [String:MetadataValue]? = nil,
        resourceId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.metadata = metadata
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct CreateOpsMetadataInputBody: Equatable {
    public let resourceId: String?
    public let metadata: [String:MetadataValue]?
    public let tags: [Tag]?
}

extension CreateOpsMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case resourceId = "ResourceId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String: MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [String:MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String:MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOpsMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOpsMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataAlreadyExistsException" : self = .opsMetadataAlreadyExistsException(try OpsMetadataAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataLimitExceededException" : self = .opsMetadataLimitExceededException(try OpsMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOpsMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataAlreadyExistsException(OpsMetadataAlreadyExistsException)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataLimitExceededException(OpsMetadataLimitExceededException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOpsMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOpsMetadataOutputResponse(opsMetadataArn: \(String(describing: opsMetadataArn)))"}
}

extension CreateOpsMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct CreateOpsMetadataOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object or blob created by the call.</p>
    public let opsMetadataArn: String?

    public init (
        opsMetadataArn: String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct CreateOpsMetadataOutputResponseBody: Equatable {
    public let opsMetadataArn: String?
}

extension CreateOpsMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

public struct CreatePatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "CreatePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePatchBaselineOutputError>
}

extension CreatePatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePatchBaselineInput(approvalRules: \(String(describing: approvalRules)), approvedPatches: \(String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(String(describing: approvedPatchesEnableNonSecurity)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), globalFilters: \(String(describing: globalFilters)), name: \(String(describing: name)), operatingSystem: \(String(describing: operatingSystem)), rejectedPatches: \(String(describing: rejectedPatches)), rejectedPatchesAction: \(String(describing: rejectedPatchesAction)), sources: \(String(describing: sources)), tags: \(String(describing: tags)))"}
}

extension CreatePatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePatchBaselineInput>
    public typealias MOutput = OperationOutput<CreatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePatchBaselineOutputError>
}

public struct CreatePatchBaselineInput: Equatable {
    /// <p>A set of rules used to include patches in the baseline.</p>
    public let approvalRules: PatchRuleGroup?
    /// <p>A list of explicitly approved patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let approvedPatches: [String]?
    /// <p>Defines the compliance level for approved patches. When an approved patch is reported as
    ///    missing, this value describes the severity of the compliance violation. The default value is
    ///    UNSPECIFIED.</p>
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    ///    applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    public let approvedPatchesEnableNonSecurity: Bool
    /// <p>User-provided idempotency token.</p>
    public var clientToken: String?
    /// <p>A description of the patch baseline.</p>
    public let description: String?
    /// <p>A set of global filters used to include patches in the baseline.</p>
    public let globalFilters: PatchFilterGroup?
    /// <p>The name of the patch baseline.</p>
    public let name: String?
    /// <p>Defines the operating system the patch baseline applies to. The Default value is
    ///    WINDOWS.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let rejectedPatches: [String]?
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
    ///    list.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
    ///      list is installed only if it is a dependency of another package. It is considered compliant
    ///      with the patch baseline, and its status is reported as <i>InstalledOther</i>.
    ///      This is the default action if no option is specified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
    ///      that include them as dependencies, are not installed under any circumstances. If a package was
    ///      installed before it was added to the Rejected patches list, it is considered non-compliant with
    ///      the patch baseline, and its status is reported as
    ///      <i>InstalledRejected</i>.</p>
    ///             </li>
    ///          </ul>
    public let rejectedPatchesAction: PatchAction?
    /// <p>Information about the patches to use to update the instances, including target operating
    ///    systems and source repositories. Applies to Linux instances only.</p>
    public let sources: [PatchSource]?
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    ///    different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    ///    patch baseline to identify the severity level of patches it specifies and the operating system
    ///    family it applies to. In this case, you could specify the following key name/value pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=PatchSeverity,Value=Critical</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?

    public init (
        approvalRules: PatchRuleGroup? = nil,
        approvedPatches: [String]? = nil,
        approvedPatchesComplianceLevel: PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Bool = false,
        clientToken: String? = nil,
        description: String? = nil,
        globalFilters: PatchFilterGroup? = nil,
        name: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        rejectedPatches: [String]? = nil,
        rejectedPatchesAction: PatchAction? = nil,
        sources: [PatchSource]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.clientToken = clientToken
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
        self.tags = tags
    }
}

struct CreatePatchBaselineInputBody: Equatable {
    public let operatingSystem: OperatingSystem?
    public let name: String?
    public let globalFilters: PatchFilterGroup?
    public let approvalRules: PatchRuleGroup?
    public let approvedPatches: [String]?
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Bool
    public let rejectedPatches: [String]?
    public let rejectedPatchesAction: PatchAction?
    public let description: String?
    public let sources: [PatchSource]?
    public let clientToken: String?
    public let tags: [Tag]?
}

extension CreatePatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case clientToken = "ClientToken"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePatchBaselineOutputError: Equatable {
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePatchBaselineOutputResponse(baselineId: \(String(describing: baselineId)))"}
}

extension CreatePatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct CreatePatchBaselineOutputResponse: Equatable {
    /// <p>The ID of the created patch baseline.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct CreatePatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
}

extension CreatePatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct CreateResourceDataSyncInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDataSyncOutputError>
}

extension CreateResourceDataSyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDataSyncInput(s3Destination: \(String(describing: s3Destination)), syncName: \(String(describing: syncName)), syncSource: \(String(describing: syncSource)), syncType: \(String(describing: syncType)))"}
}

extension CreateResourceDataSyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct CreateResourceDataSyncInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<CreateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceDataSyncOutputError>
}

public struct CreateResourceDataSyncInput: Equatable {
    /// <p>Amazon S3 configuration details for the sync. This parameter is required if the
    ///     <code>SyncType</code> value is SyncToDestination.</p>
    public let s3Destination: ResourceDataSyncS3Destination?
    /// <p>A name for the configuration.</p>
    public let syncName: String?
    /// <p>Specify information about the data sources to synchronize. This parameter is required if the
    ///     <code>SyncType</code> value is SyncFromSource.</p>
    public let syncSource: ResourceDataSyncSource?
    /// <p>Specify <code>SyncToDestination</code> to create a resource data sync that synchronizes data
    ///    to an S3 bucket for Inventory. If you specify <code>SyncToDestination</code>, you must provide a
    ///    value for <code>S3Destination</code>. Specify <code>SyncFromSource</code> to synchronize data
    ///    from a single account and multiple Regions, or multiple AWS accounts and Regions, as listed in
    ///    AWS Organizations for Explorer. If you specify <code>SyncFromSource</code>, you must provide a value for
    ///     <code>SyncSource</code>. The default value is <code>SyncToDestination</code>.</p>
    public let syncType: String?

    public init (
        s3Destination: ResourceDataSyncS3Destination? = nil,
        syncName: String? = nil,
        syncSource: ResourceDataSyncSource? = nil,
        syncType: String? = nil
    )
    {
        self.s3Destination = s3Destination
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct CreateResourceDataSyncInputBody: Equatable {
    public let syncName: String?
    public let s3Destination: ResourceDataSyncS3Destination?
    public let syncType: String?
    public let syncSource: ResourceDataSyncSource?
}

extension CreateResourceDataSyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Destination = "S3Destination"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension CreateResourceDataSyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceDataSyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncAlreadyExistsException" : self = .resourceDataSyncAlreadyExistsException(try ResourceDataSyncAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncCountExceededException" : self = .resourceDataSyncCountExceededException(try ResourceDataSyncCountExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfigurationException" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceDataSyncOutputError: Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncAlreadyExistsException(ResourceDataSyncAlreadyExistsException)
    case resourceDataSyncCountExceededException(ResourceDataSyncCountExceededException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceDataSyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceDataSyncOutputResponse()"}
}

extension CreateResourceDataSyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateResourceDataSyncOutputResponse: Equatable {

    public init() {}
}

struct CreateResourceDataSyncOutputResponseBody: Equatable {
}

extension CreateResourceDataSyncOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CustomSchemaCountLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomSchemaCountLimitExceededException(message: \(String(describing: message)))"}
}

extension CustomSchemaCountLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CustomSchemaCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the limit for custom schemas. Delete one or more custom schemas and try
///    again.</p>
public struct CustomSchemaCountLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CustomSchemaCountLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CustomSchemaCountLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteActivationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteActivationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivationOutputError>
}

extension DeleteActivationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActivationInput(activationId: \(String(describing: activationId)))"}
}

extension DeleteActivationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationId = "ActivationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
    }
}

public struct DeleteActivationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteActivationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteActivationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteActivationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteActivationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteActivationInput>
    public typealias MOutput = OperationOutput<DeleteActivationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteActivationOutputError>
}

public struct DeleteActivationInput: Equatable {
    /// <p>The ID of the activation that you want to delete.</p>
    public let activationId: String?

    public init (
        activationId: String? = nil
    )
    {
        self.activationId = activationId
    }
}

struct DeleteActivationInputBody: Equatable {
    public let activationId: String?
}

extension DeleteActivationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationId = "ActivationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationId)
        activationId = activationIdDecoded
    }
}

extension DeleteActivationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActivationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivation" : self = .invalidActivation(try InvalidActivation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActivationId" : self = .invalidActivationId(try InvalidActivationId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteActivationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidActivation(InvalidActivation)
    case invalidActivationId(InvalidActivationId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActivationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteActivationOutputResponse()"}
}

extension DeleteActivationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteActivationOutputResponse: Equatable {

    public init() {}
}

struct DeleteActivationOutputResponseBody: Equatable {
}

extension DeleteActivationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAssociationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssociationOutputError>
}

extension DeleteAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssociationInput(associationId: \(String(describing: associationId)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)))"}
}

extension DeleteAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssociationInput>
    public typealias MOutput = OperationOutput<DeleteAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssociationOutputError>
}

public struct DeleteAssociationInput: Equatable {
    /// <p>The association ID that you want to delete.</p>
    public let associationId: String?
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?

    public init (
        associationId: String? = nil,
        instanceId: String? = nil,
        name: String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.name = name
    }
}

struct DeleteAssociationInputBody: Equatable {
    public let name: String?
    public let instanceId: String?
    public let associationId: String?
}

extension DeleteAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DeleteAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssociationOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssociationOutputResponse()"}
}

extension DeleteAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssociationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssociationOutputResponseBody: Equatable {
}

extension DeleteAssociationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDocumentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentOutputError>
}

extension DeleteDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentInput(documentVersion: \(String(describing: documentVersion)), force: \(String(describing: force)), name: \(String(describing: name)), versionName: \(String(describing: versionName)))"}
}

extension DeleteDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct DeleteDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDocumentInput>
    public typealias MOutput = OperationOutput<DeleteDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDocumentOutputError>
}

public struct DeleteDocumentInput: Equatable {
    /// <p>The version of the document that you want to delete. If not provided, all versions of the
    ///    document are deleted.</p>
    public let documentVersion: String?
    /// <p>Some SSM document types require that you specify a <code>Force</code> flag before you can
    ///    delete the document. For example, you must specify a <code>Force</code> flag to delete a document
    ///    of type <code>ApplicationConfigurationSchema</code>. You can restrict access to the
    ///     <code>Force</code> flag in an AWS Identity and Access Management (IAM) policy.</p>
    public let force: Bool
    /// <p>The name of the document.</p>
    public let name: String?
    /// <p>The version name of the document that you want to delete. If not provided, all versions of
    ///    the document are deleted.</p>
    public let versionName: String?

    public init (
        documentVersion: String? = nil,
        force: Bool = false,
        name: String? = nil,
        versionName: String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.force = force
        self.name = name
        self.versionName = versionName
    }
}

struct DeleteDocumentInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let versionName: String?
    public let force: Bool
}

extension DeleteDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case force = "Force"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociatedInstances" : self = .associatedInstances(try AssociatedInstances(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentOutputError: Equatable {
    case associatedInstances(AssociatedInstances)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDocumentOutputResponse()"}
}

extension DeleteDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentOutputResponse: Equatable {

    public init() {}
}

struct DeleteDocumentOutputResponseBody: Equatable {
}

extension DeleteDocumentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInventoryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInventoryOutputError>
}

extension DeleteInventoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInventoryInput(clientToken: \(String(describing: clientToken)), dryRun: \(String(describing: dryRun)), schemaDeleteOption: \(String(describing: schemaDeleteOption)), typeName: \(String(describing: typeName)))"}
}

extension DeleteInventoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let schemaDeleteOption = schemaDeleteOption {
            try encodeContainer.encode(schemaDeleteOption.rawValue, forKey: .schemaDeleteOption)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct DeleteInventoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInventoryInput>
    public typealias MOutput = OperationOutput<DeleteInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInventoryOutputError>
}

public struct DeleteInventoryInput: Equatable {
    /// <p>User-provided idempotency token.</p>
    public var clientToken: String?
    /// <p>Use this option to view a summary of the deletion request without deleting any data or the
    ///    data type. This option is useful when you only want to understand what will be deleted. Once you
    ///    validate that the data to be deleted is what you intend to delete, you can run the same command
    ///    without specifying the <code>DryRun</code> option.</p>
    public let dryRun: Bool
    /// <p>Use the <code>SchemaDeleteOption</code> to delete a custom inventory type (schema). If you
    ///    don't choose this option, the system only deletes existing inventory data associated with the
    ///    custom inventory type. Choose one of the following options:</p>
    ///          <p>DisableSchema: If you choose this option, the system ignores all inventory data for the
    ///    specified version, and any earlier versions. To enable this schema again, you must call the
    ///     <code>PutInventory</code> action for a version greater than the disabled version.</p>
    ///          <p>DeleteSchema: This option deletes the specified custom type from the Inventory service. You
    ///    can recreate the schema later, if you want.</p>
    public let schemaDeleteOption: InventorySchemaDeleteOption?
    /// <p>The name of the custom inventory type for which you want to delete either all previously
    ///    collected data or the inventory type itself. </p>
    public let typeName: String?

    public init (
        clientToken: String? = nil,
        dryRun: Bool = false,
        schemaDeleteOption: InventorySchemaDeleteOption? = nil,
        typeName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.schemaDeleteOption = schemaDeleteOption
        self.typeName = typeName
    }
}

struct DeleteInventoryInputBody: Equatable {
    public let typeName: String?
    public let schemaDeleteOption: InventorySchemaDeleteOption?
    public let dryRun: Bool
    public let clientToken: String?
}

extension DeleteInventoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dryRun = "DryRun"
        case schemaDeleteOption = "SchemaDeleteOption"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaDeleteOptionDecoded = try containerValues.decodeIfPresent(InventorySchemaDeleteOption.self, forKey: .schemaDeleteOption)
        schemaDeleteOption = schemaDeleteOptionDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteInventoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInventoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeleteInventoryParametersException" : self = .invalidDeleteInventoryParametersException(try InvalidDeleteInventoryParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryRequestException" : self = .invalidInventoryRequestException(try InvalidInventoryRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOptionException" : self = .invalidOptionException(try InvalidOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInventoryOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDeleteInventoryParametersException(InvalidDeleteInventoryParametersException)
    case invalidInventoryRequestException(InvalidInventoryRequestException)
    case invalidOptionException(InvalidOptionException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInventoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInventoryOutputResponse(deletionId: \(String(describing: deletionId)), deletionSummary: \(String(describing: deletionSummary)), typeName: \(String(describing: typeName)))"}
}

extension DeleteInventoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInventoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionId = output.deletionId
            self.deletionSummary = output.deletionSummary
            self.typeName = output.typeName
        } else {
            self.deletionId = nil
            self.deletionSummary = nil
            self.typeName = nil
        }
    }
}

public struct DeleteInventoryOutputResponse: Equatable {
    /// <p>Every <code>DeleteInventory</code> action is assigned a unique ID. This option returns a
    ///    unique ID. You can use this ID to query the status of a delete operation. This option is useful
    ///    for ensuring that a delete operation has completed before you begin other actions. </p>
    public let deletionId: String?
    /// <p>A summary of the delete operation. For more information about this summary, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete-summary">Deleting custom inventory</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let deletionSummary: InventoryDeletionSummary?
    /// <p>The name of the inventory data type specified in the request.</p>
    public let typeName: String?

    public init (
        deletionId: String? = nil,
        deletionSummary: InventoryDeletionSummary? = nil,
        typeName: String? = nil
    )
    {
        self.deletionId = deletionId
        self.deletionSummary = deletionSummary
        self.typeName = typeName
    }
}

struct DeleteInventoryOutputResponseBody: Equatable {
    public let deletionId: String?
    public let typeName: String?
    public let deletionSummary: InventoryDeletionSummary?
}

extension DeleteInventoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionId = "DeletionId"
        case deletionSummary = "DeletionSummary"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
    }
}

public struct DeleteMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMaintenanceWindowOutputError>
}

extension DeleteMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMaintenanceWindowInput(windowId: \(String(describing: windowId)))"}
}

extension DeleteMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DeleteMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeleteMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMaintenanceWindowOutputError>
}

public struct DeleteMaintenanceWindowInput: Equatable {
    /// <p>The ID of the maintenance window to delete.</p>
    public let windowId: String?

    public init (
        windowId: String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
}

extension DeleteMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension DeleteMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMaintenanceWindowOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMaintenanceWindowOutputResponse(windowId: \(String(describing: windowId)))"}
}

extension DeleteMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowId = output.windowId
        } else {
            self.windowId = nil
        }
    }
}

public struct DeleteMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the deleted maintenance window.</p>
    public let windowId: String?

    public init (
        windowId: String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct DeleteMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
}

extension DeleteMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

public struct DeleteOpsMetadataInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpsMetadataOutputError>
}

extension DeleteOpsMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOpsMetadataInput(opsMetadataArn: \(String(describing: opsMetadataArn)))"}
}

extension DeleteOpsMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct DeleteOpsMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOpsMetadataInput>
    public typealias MOutput = OperationOutput<DeleteOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOpsMetadataOutputError>
}

public struct DeleteOpsMetadataInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.</p>
    public let opsMetadataArn: String?

    public init (
        opsMetadataArn: String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct DeleteOpsMetadataInputBody: Equatable {
    public let opsMetadataArn: String?
}

extension DeleteOpsMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

extension DeleteOpsMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOpsMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOpsMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOpsMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOpsMetadataOutputResponse()"}
}

extension DeleteOpsMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOpsMetadataOutputResponse: Equatable {

    public init() {}
}

struct DeleteOpsMetadataOutputResponseBody: Equatable {
}

extension DeleteOpsMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteParameterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterOutputError>
}

extension DeleteParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParameterInput(name: \(String(describing: name)))"}
}

extension DeleteParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteParameterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterInput>
    public typealias MOutput = OperationOutput<DeleteParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterOutputError>
}

public struct DeleteParameterInput: Equatable {
    /// <p>The name of the parameter to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteParameterInputBody: Equatable {
    public let name: String?
}

extension DeleteParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterOutputError: Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParameterOutputResponse()"}
}

extension DeleteParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteParameterOutputResponse: Equatable {

    public init() {}
}

struct DeleteParameterOutputResponseBody: Equatable {
}

extension DeleteParameterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteParametersInputBodyMiddleware: Middleware {
    public let id: String = "DeleteParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParametersOutputError>
}

extension DeleteParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParametersInput(names: \(String(describing: names)))"}
}

extension DeleteParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
    }
}

public struct DeleteParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParametersInput>
    public typealias MOutput = OperationOutput<DeleteParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParametersOutputError>
}

public struct DeleteParametersInput: Equatable {
    /// <p>The names of the parameters to delete.</p>
    public let names: [String]?

    public init (
        names: [String]? = nil
    )
    {
        self.names = names
    }
}

struct DeleteParametersInputBody: Equatable {
    public let names: [String]?
}

extension DeleteParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension DeleteParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParametersOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParametersOutputResponse(deletedParameters: \(String(describing: deletedParameters)), invalidParameters: \(String(describing: invalidParameters)))"}
}

extension DeleteParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletedParameters = output.deletedParameters
            self.invalidParameters = output.invalidParameters
        } else {
            self.deletedParameters = nil
            self.invalidParameters = nil
        }
    }
}

public struct DeleteParametersOutputResponse: Equatable {
    /// <p>The names of the deleted parameters.</p>
    public let deletedParameters: [String]?
    /// <p>The names of parameters that weren't deleted because the parameters are not valid.</p>
    public let invalidParameters: [String]?

    public init (
        deletedParameters: [String]? = nil,
        invalidParameters: [String]? = nil
    )
    {
        self.deletedParameters = deletedParameters
        self.invalidParameters = invalidParameters
    }
}

struct DeleteParametersOutputResponseBody: Equatable {
    public let deletedParameters: [String]?
    public let invalidParameters: [String]?
}

extension DeleteParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletedParameters = "DeletedParameters"
        case invalidParameters = "InvalidParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deletedParameters)
        var deletedParametersDecoded0:[String]? = nil
        if let deletedParametersContainer = deletedParametersContainer {
            deletedParametersDecoded0 = [String]()
            for string0 in deletedParametersContainer {
                if let string0 = string0 {
                    deletedParametersDecoded0?.append(string0)
                }
            }
        }
        deletedParameters = deletedParametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

public struct DeletePatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "DeletePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePatchBaselineOutputError>
}

extension DeletePatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePatchBaselineInput(baselineId: \(String(describing: baselineId)))"}
}

extension DeletePatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct DeletePatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePatchBaselineInput>
    public typealias MOutput = OperationOutput<DeletePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePatchBaselineOutputError>
}

public struct DeletePatchBaselineInput: Equatable {
    /// <p>The ID of the patch baseline to delete.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineInputBody: Equatable {
    public let baselineId: String?
}

extension DeletePatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension DeletePatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePatchBaselineOutputError: Equatable {
    case internalServerError(InternalServerError)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePatchBaselineOutputResponse(baselineId: \(String(describing: baselineId)))"}
}

extension DeletePatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct DeletePatchBaselineOutputResponse: Equatable {
    /// <p>The ID of the deleted patch baseline.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct DeletePatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
}

extension DeletePatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct DeleteResourceDataSyncInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceDataSyncOutputError>
}

extension DeleteResourceDataSyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceDataSyncInput(syncName: \(String(describing: syncName)), syncType: \(String(describing: syncType)))"}
}

extension DeleteResourceDataSyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct DeleteResourceDataSyncInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceDataSyncInput>
    public typealias MOutput = OperationOutput<DeleteResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceDataSyncOutputError>
}

public struct DeleteResourceDataSyncInput: Equatable {
    /// <p>The name of the configuration to delete.</p>
    public let syncName: String?
    /// <p>Specify the type of resource data sync to delete.</p>
    public let syncType: String?

    public init (
        syncName: String? = nil,
        syncType: String? = nil
    )
    {
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct DeleteResourceDataSyncInputBody: Equatable {
    public let syncName: String?
    public let syncType: String?
}

extension DeleteResourceDataSyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
    }
}

extension DeleteResourceDataSyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceDataSyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfigurationException" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFoundException" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceDataSyncOutputError: Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceDataSyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceDataSyncOutputResponse()"}
}

extension DeleteResourceDataSyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceDataSyncOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceDataSyncOutputResponseBody: Equatable {
}

extension DeleteResourceDataSyncOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterManagedInstanceInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterManagedInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterManagedInstanceOutputError>
}

extension DeregisterManagedInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterManagedInstanceInput(instanceId: \(String(describing: instanceId)))"}
}

extension DeregisterManagedInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct DeregisterManagedInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterManagedInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterManagedInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterManagedInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterManagedInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterManagedInstanceInput>
    public typealias MOutput = OperationOutput<DeregisterManagedInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterManagedInstanceOutputError>
}

public struct DeregisterManagedInstanceInput: Equatable {
    /// <p>The ID assigned to the managed instance when you registered it using the activation process.
    ///   </p>
    public let instanceId: String?

    public init (
        instanceId: String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterManagedInstanceInputBody: Equatable {
    public let instanceId: String?
}

extension DeregisterManagedInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterManagedInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterManagedInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterManagedInstanceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterManagedInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterManagedInstanceOutputResponse()"}
}

extension DeregisterManagedInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterManagedInstanceOutputResponse: Equatable {

    public init() {}
}

struct DeregisterManagedInstanceOutputResponseBody: Equatable {
}

extension DeregisterManagedInstanceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterPatchBaselineForPatchGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

extension DeregisterPatchBaselineForPatchGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterPatchBaselineForPatchGroupInput(baselineId: \(String(describing: baselineId)), patchGroup: \(String(describing: patchGroup)))"}
}

extension DeregisterPatchBaselineForPatchGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DeregisterPatchBaselineForPatchGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<DeregisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterPatchBaselineForPatchGroupOutputError>
}

public struct DeregisterPatchBaselineForPatchGroupInput: Equatable {
    /// <p>The ID of the patch baseline to deregister the patch group from.</p>
    public let baselineId: String?
    /// <p>The name of the patch group that should be deregistered from the patch baseline.</p>
    public let patchGroup: String?

    public init (
        baselineId: String? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupInputBody: Equatable {
    public let baselineId: String?
    public let patchGroup: String?
}

extension DeregisterPatchBaselineForPatchGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterPatchBaselineForPatchGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterPatchBaselineForPatchGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterPatchBaselineForPatchGroupOutputResponse(baselineId: \(String(describing: baselineId)), patchGroup: \(String(describing: patchGroup)))"}
}

extension DeregisterPatchBaselineForPatchGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct DeregisterPatchBaselineForPatchGroupOutputResponse: Equatable {
    /// <p>The ID of the patch baseline the patch group was deregistered from.</p>
    public let baselineId: String?
    /// <p>The name of the patch group deregistered from the patch baseline.</p>
    public let patchGroup: String?

    public init (
        baselineId: String? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct DeregisterPatchBaselineForPatchGroupOutputResponseBody: Equatable {
    public let baselineId: String?
    public let patchGroup: String?
}

extension DeregisterPatchBaselineForPatchGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

public struct DeregisterTargetFromMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterTargetFromMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

extension DeregisterTargetFromMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTargetFromMaintenanceWindowInput(safe: \(String(describing: safe)), windowId: \(String(describing: windowId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

extension DeregisterTargetFromMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if safe != false {
            try encodeContainer.encode(safe, forKey: .safe)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

public struct DeregisterTargetFromMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterTargetFromMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterTargetFromMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTargetFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetFromMaintenanceWindowOutputError>
}

public struct DeregisterTargetFromMaintenanceWindowInput: Equatable {
    /// <p>The system checks if the target is being referenced by a task. If the target is being
    ///    referenced, the system returns an error and does not deregister the target from the maintenance
    ///    window.</p>
    public let safe: Bool
    /// <p>The ID of the maintenance window the target should be removed from.</p>
    public let windowId: String?
    /// <p>The ID of the target definition to remove.</p>
    public let windowTargetId: String?

    public init (
        safe: Bool = false,
        windowId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.safe = safe
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
    public let windowTargetId: String?
    public let safe: Bool
}

extension DeregisterTargetFromMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case safe = "Safe"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let safeDecoded = try containerValues.decode(Bool.self, forKey: .safe)
        safe = safeDecoded
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTargetFromMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetInUseException" : self = .targetInUseException(try TargetInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTargetFromMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case targetInUseException(TargetInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetFromMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTargetFromMaintenanceWindowOutputResponse(windowId: \(String(describing: windowId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

extension DeregisterTargetFromMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterTargetFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct DeregisterTargetFromMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the maintenance window the target was removed from.</p>
    public let windowId: String?
    /// <p>The ID of the removed target definition.</p>
    public let windowTargetId: String?

    public init (
        windowId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct DeregisterTargetFromMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
    public let windowTargetId: String?
}

extension DeregisterTargetFromMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

public struct DeregisterTaskFromMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterTaskFromMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

extension DeregisterTaskFromMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTaskFromMaintenanceWindowInput(windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension DeregisterTaskFromMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct DeregisterTaskFromMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterTaskFromMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterTaskFromMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTaskFromMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<DeregisterTaskFromMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTaskFromMaintenanceWindowOutputError>
}

public struct DeregisterTaskFromMaintenanceWindowInput: Equatable {
    /// <p>The ID of the maintenance window the task should be removed from.</p>
    public let windowId: String?
    /// <p>The ID of the task to remove from the maintenance window.</p>
    public let windowTaskId: String?

    public init (
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
}

extension DeregisterTaskFromMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTaskFromMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTaskFromMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTaskFromMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTaskFromMaintenanceWindowOutputResponse(windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension DeregisterTaskFromMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterTaskFromMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct DeregisterTaskFromMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the maintenance window the task was removed from.</p>
    public let windowId: String?
    /// <p>The ID of the task removed from the maintenance window.</p>
    public let windowTaskId: String?

    public init (
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct DeregisterTaskFromMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
}

extension DeregisterTaskFromMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension DescribeActivationsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterKey = "FilterKey"
        case filterValues = "FilterValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterKey = filterKey {
            try encodeContainer.encode(filterKey.rawValue, forKey: .filterKey)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterValues)
            for stringlist0 in filterValues {
                try filterValuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterKeyDecoded = try containerValues.decodeIfPresent(DescribeActivationsFilterKeys.self, forKey: .filterKey)
        filterKey = filterKeyDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .filterValues)
        var filterValuesDecoded0:[String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [String]()
            for string0 in filterValuesContainer {
                if let string0 = string0 {
                    filterValuesDecoded0?.append(string0)
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension DescribeActivationsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivationsFilter(filterKey: \(String(describing: filterKey)), filterValues: \(String(describing: filterValues)))"}
}

/// <p>Filter for the DescribeActivation API.</p>
public struct DescribeActivationsFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let filterKey: DescribeActivationsFilterKeys?
    /// <p>The filter values.</p>
    public let filterValues: [String]?

    public init (
        filterKey: DescribeActivationsFilterKeys? = nil,
        filterValues: [String]? = nil
    )
    {
        self.filterKey = filterKey
        self.filterValues = filterValues
    }
}

public enum DescribeActivationsFilterKeys {
    case activationIds
    case defaultInstanceName
    case iamRole
    case sdkUnknown(String)
}

extension DescribeActivationsFilterKeys : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DescribeActivationsFilterKeys] {
        return [
            .activationIds,
            .defaultInstanceName,
            .iamRole,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activationIds: return "ActivationIds"
        case .defaultInstanceName: return "DefaultInstanceName"
        case .iamRole: return "IamRole"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DescribeActivationsFilterKeys(rawValue: rawValue) ?? DescribeActivationsFilterKeys.sdkUnknown(rawValue)
    }
}

public struct DescribeActivationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeActivationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivationsOutputError>
}

extension DescribeActivationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeActivationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for describeactivationsfilterlist0 in filters {
                try filtersContainer.encode(describeactivationsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeActivationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeActivationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeActivationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeActivationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeActivationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeActivationsInput>
    public typealias MOutput = OperationOutput<DescribeActivationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeActivationsOutputError>
}

public struct DescribeActivationsInput: Equatable {
    /// <p>A filter to view information about your activations.</p>
    public let filters: [DescribeActivationsFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        filters: [DescribeActivationsFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeActivationsInputBody: Equatable {
    public let filters: [DescribeActivationsFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeActivationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DescribeActivationsFilter?].self, forKey: .filters)
        var filtersDecoded0:[DescribeActivationsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DescribeActivationsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeActivationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeActivationsOutputResponse(activationList: \(String(describing: activationList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeActivationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeActivationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activationList = output.activationList
            self.nextToken = output.nextToken
        } else {
            self.activationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeActivationsOutputResponse: Equatable {
    /// <p>A list of activations for your AWS account.</p>
    public let activationList: [Activation]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results. </p>
    public let nextToken: String?

    public init (
        activationList: [Activation]? = nil,
        nextToken: String? = nil
    )
    {
        self.activationList = activationList
        self.nextToken = nextToken
    }
}

struct DescribeActivationsOutputResponseBody: Equatable {
    public let activationList: [Activation]?
    public let nextToken: String?
}

extension DescribeActivationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activationList = "ActivationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activationListContainer = try containerValues.decodeIfPresent([Activation?].self, forKey: .activationList)
        var activationListDecoded0:[Activation]? = nil
        if let activationListContainer = activationListContainer {
            activationListDecoded0 = [Activation]()
            for structure0 in activationListContainer {
                if let structure0 = structure0 {
                    activationListDecoded0?.append(structure0)
                }
            }
        }
        activationList = activationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationExecutionTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionTargetsOutputError>
}

extension DescribeAssociationExecutionTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationExecutionTargetsInput(associationId: \(String(describing: associationId)), executionId: \(String(describing: executionId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutiontargetsfilterlist0 in filters {
                try filtersContainer.encode(associationexecutiontargetsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAssociationExecutionTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionTargetsOutputError>
}

public struct DescribeAssociationExecutionTargetsInput: Equatable {
    /// <p>The association ID that includes the execution for which you want to view details.</p>
    public let associationId: String?
    /// <p>The execution ID for which you want to view details.</p>
    public let executionId: String?
    /// <p>Filters for the request. You can specify the following filters and values.</p>
    ///          <p>Status (EQUAL)</p>
    ///          <p>ResourceId (EQUAL)</p>
    ///          <p>ResourceType (EQUAL)</p>
    public let filters: [AssociationExecutionTargetsFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        associationId: String? = nil,
        executionId: String? = nil,
        filters: [AssociationExecutionTargetsFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.associationId = associationId
        self.executionId = executionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsInputBody: Equatable {
    public let associationId: String?
    public let executionId: String?
    public let filters: [AssociationExecutionTargetsFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAssociationExecutionTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case executionId = "ExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AssociationExecutionTargetsFilter?].self, forKey: .filters)
        var filtersDecoded0:[AssociationExecutionTargetsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AssociationExecutionTargetsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationExecutionDoesNotExist" : self = .associationExecutionDoesNotExist(try AssociationExecutionDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionTargetsOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationExecutionDoesNotExist(AssociationExecutionDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationExecutionTargetsOutputResponse(associationExecutionTargets: \(String(describing: associationExecutionTargets)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssociationExecutionTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationExecutionTargets = output.associationExecutionTargets
            self.nextToken = output.nextToken
        } else {
            self.associationExecutionTargets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionTargetsOutputResponse: Equatable {
    /// <p>Information about the execution.</p>
    public let associationExecutionTargets: [AssociationExecutionTarget]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        associationExecutionTargets: [AssociationExecutionTarget]? = nil,
        nextToken: String? = nil
    )
    {
        self.associationExecutionTargets = associationExecutionTargets
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionTargetsOutputResponseBody: Equatable {
    public let associationExecutionTargets: [AssociationExecutionTarget]?
    public let nextToken: String?
}

extension DescribeAssociationExecutionTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationExecutionTargets = "AssociationExecutionTargets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionTargetsContainer = try containerValues.decodeIfPresent([AssociationExecutionTarget?].self, forKey: .associationExecutionTargets)
        var associationExecutionTargetsDecoded0:[AssociationExecutionTarget]? = nil
        if let associationExecutionTargetsContainer = associationExecutionTargetsContainer {
            associationExecutionTargetsDecoded0 = [AssociationExecutionTarget]()
            for structure0 in associationExecutionTargetsContainer {
                if let structure0 = structure0 {
                    associationExecutionTargetsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutionTargets = associationExecutionTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionsOutputError>
}

extension DescribeAssociationExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationExecutionsInput(associationId: \(String(describing: associationId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for associationexecutionfilterlist0 in filters {
                try filtersContainer.encode(associationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAssociationExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssociationExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAssociationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationExecutionsOutputError>
}

public struct DescribeAssociationExecutionsInput: Equatable {
    /// <p>The association ID for which you want to view execution history details.</p>
    public let associationId: String?
    /// <p>Filters for the request. You can specify the following filters and values.</p>
    ///          <p>ExecutionId (EQUAL)</p>
    ///          <p>Status (EQUAL)</p>
    ///          <p>CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)</p>
    public let filters: [AssociationExecutionFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        associationId: String? = nil,
        filters: [AssociationExecutionFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.associationId = associationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsInputBody: Equatable {
    public let associationId: String?
    public let filters: [AssociationExecutionFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAssociationExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AssociationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[AssociationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AssociationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAssociationExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationExecutionsOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationExecutionsOutputResponse(associationExecutions: \(String(describing: associationExecutions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAssociationExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssociationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationExecutions = output.associationExecutions
            self.nextToken = output.nextToken
        } else {
            self.associationExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAssociationExecutionsOutputResponse: Equatable {
    /// <p>A list of the executions for the specified association ID.</p>
    public let associationExecutions: [AssociationExecution]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        associationExecutions: [AssociationExecution]? = nil,
        nextToken: String? = nil
    )
    {
        self.associationExecutions = associationExecutions
        self.nextToken = nextToken
    }
}

struct DescribeAssociationExecutionsOutputResponseBody: Equatable {
    public let associationExecutions: [AssociationExecution]?
    public let nextToken: String?
}

extension DescribeAssociationExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationExecutions = "AssociationExecutions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationExecutionsContainer = try containerValues.decodeIfPresent([AssociationExecution?].self, forKey: .associationExecutions)
        var associationExecutionsDecoded0:[AssociationExecution]? = nil
        if let associationExecutionsContainer = associationExecutionsContainer {
            associationExecutionsDecoded0 = [AssociationExecution]()
            for structure0 in associationExecutionsContainer {
                if let structure0 = structure0 {
                    associationExecutionsDecoded0?.append(structure0)
                }
            }
        }
        associationExecutions = associationExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAssociationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationOutputError>
}

extension DescribeAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationInput(associationId: \(String(describing: associationId)), associationVersion: \(String(describing: associationVersion)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)))"}
}

extension DescribeAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssociationInput>
    public typealias MOutput = OperationOutput<DescribeAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssociationOutputError>
}

public struct DescribeAssociationInput: Equatable {
    /// <p>The association ID for which you want information.</p>
    public let associationId: String?
    /// <p>Specify the association version to retrieve. To view the latest version, either specify
    ///     <code>$LATEST</code> for this parameter, or omit this parameter. To view a list of all
    ///    associations for an instance, use <a>ListAssociations</a>. To get a list of versions
    ///    for a specific association, use <a>ListAssociationVersions</a>. </p>
    public let associationVersion: String?
    /// <p>The instance ID.</p>
    public let instanceId: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?

    public init (
        associationId: String? = nil,
        associationVersion: String? = nil,
        instanceId: String? = nil,
        name: String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.instanceId = instanceId
        self.name = name
    }
}

struct DescribeAssociationInputBody: Equatable {
    public let name: String?
    public let instanceId: String?
    public let associationId: String?
    public let associationVersion: String?
}

extension DescribeAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension DescribeAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssociationOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssociationOutputResponse(associationDescription: \(String(describing: associationDescription)))"}
}

extension DescribeAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct DescribeAssociationOutputResponse: Equatable {
    /// <p>Information about the association.</p>
    public let associationDescription: AssociationDescription?

    public init (
        associationDescription: AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct DescribeAssociationOutputResponseBody: Equatable {
    public let associationDescription: AssociationDescription?
}

extension DescribeAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct DescribeAutomationExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAutomationExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationExecutionsOutputError>
}

extension DescribeAutomationExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutomationExecutionsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAutomationExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for automationexecutionfilterlist0 in filters {
                try filtersContainer.encode(automationexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAutomationExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAutomationExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAutomationExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationExecutionsOutputError>
}

public struct DescribeAutomationExecutionsInput: Equatable {
    /// <p>Filters used to limit the scope of executions that are requested.</p>
    public let filters: [AutomationExecutionFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [AutomationExecutionFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsInputBody: Equatable {
    public let filters: [AutomationExecutionFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAutomationExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AutomationExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[AutomationExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AutomationExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAutomationExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationExecutionsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutomationExecutionsOutputResponse(automationExecutionMetadataList: \(String(describing: automationExecutionMetadataList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAutomationExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAutomationExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automationExecutionMetadataList = output.automationExecutionMetadataList
            self.nextToken = output.nextToken
        } else {
            self.automationExecutionMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAutomationExecutionsOutputResponse: Equatable {
    /// <p>The list of details about each automation execution which has occurred which matches the
    ///    filter specification, if any.</p>
    public let automationExecutionMetadataList: [AutomationExecutionMetadata]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        automationExecutionMetadataList: [AutomationExecutionMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.automationExecutionMetadataList = automationExecutionMetadataList
        self.nextToken = nextToken
    }
}

struct DescribeAutomationExecutionsOutputResponseBody: Equatable {
    public let automationExecutionMetadataList: [AutomationExecutionMetadata]?
    public let nextToken: String?
}

extension DescribeAutomationExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionMetadataList = "AutomationExecutionMetadataList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionMetadataListContainer = try containerValues.decodeIfPresent([AutomationExecutionMetadata?].self, forKey: .automationExecutionMetadataList)
        var automationExecutionMetadataListDecoded0:[AutomationExecutionMetadata]? = nil
        if let automationExecutionMetadataListContainer = automationExecutionMetadataListContainer {
            automationExecutionMetadataListDecoded0 = [AutomationExecutionMetadata]()
            for structure0 in automationExecutionMetadataListContainer {
                if let structure0 = structure0 {
                    automationExecutionMetadataListDecoded0?.append(structure0)
                }
            }
        }
        automationExecutionMetadataList = automationExecutionMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAutomationStepExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAutomationStepExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationStepExecutionsOutputError>
}

extension DescribeAutomationStepExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutomationStepExecutionsInput(automationExecutionId: \(String(describing: automationExecutionId)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reverseOrder: \(String(describing: reverseOrder)))"}
}

extension DescribeAutomationStepExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for stepexecutionfilterlist0 in filters {
                try filtersContainer.encode(stepexecutionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if reverseOrder != false {
            try encodeContainer.encode(reverseOrder, forKey: .reverseOrder)
        }
    }
}

public struct DescribeAutomationStepExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAutomationStepExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAutomationStepExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAutomationStepExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAutomationStepExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAutomationStepExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeAutomationStepExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAutomationStepExecutionsOutputError>
}

public struct DescribeAutomationStepExecutionsInput: Equatable {
    /// <p>The Automation execution ID for which you want step execution descriptions.</p>
    public let automationExecutionId: String?
    /// <p>One or more filters to limit the number of step executions returned by the request.</p>
    public let filters: [StepExecutionFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>Indicates whether to list step executions in reverse order by start time. The default value
    ///    is 'false'.</p>
    public let reverseOrder: Bool

    public init (
        automationExecutionId: String? = nil,
        filters: [StepExecutionFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        reverseOrder: Bool = false
    )
    {
        self.automationExecutionId = automationExecutionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct DescribeAutomationStepExecutionsInputBody: Equatable {
    public let automationExecutionId: String?
    public let filters: [StepExecutionFilter]?
    public let nextToken: String?
    public let maxResults: Int
    public let reverseOrder: Bool
}

extension DescribeAutomationStepExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case reverseOrder = "ReverseOrder"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([StepExecutionFilter?].self, forKey: .filters)
        var filtersDecoded0:[StepExecutionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [StepExecutionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let reverseOrderDecoded = try containerValues.decode(Bool.self, forKey: .reverseOrder)
        reverseOrder = reverseOrderDecoded
    }
}

extension DescribeAutomationStepExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutomationStepExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFoundException" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutomationStepExecutionsOutputError: Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutomationStepExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAutomationStepExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), stepExecutions: \(String(describing: stepExecutions)))"}
}

extension DescribeAutomationStepExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAutomationStepExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.stepExecutions = output.stepExecutions
        } else {
            self.nextToken = nil
            self.stepExecutions = nil
        }
    }
}

public struct DescribeAutomationStepExecutionsOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>A list of details about the current state of all steps that make up an execution.</p>
    public let stepExecutions: [StepExecution]?

    public init (
        nextToken: String? = nil,
        stepExecutions: [StepExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.stepExecutions = stepExecutions
    }
}

struct DescribeAutomationStepExecutionsOutputResponseBody: Equatable {
    public let stepExecutions: [StepExecution]?
    public let nextToken: String?
}

extension DescribeAutomationStepExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case stepExecutions = "StepExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepExecutionsContainer = try containerValues.decodeIfPresent([StepExecution?].self, forKey: .stepExecutions)
        var stepExecutionsDecoded0:[StepExecution]? = nil
        if let stepExecutionsContainer = stepExecutionsContainer {
            stepExecutionsDecoded0 = [StepExecution]()
            for structure0 in stepExecutionsContainer {
                if let structure0 = structure0 {
                    stepExecutionsDecoded0?.append(structure0)
                }
            }
        }
        stepExecutions = stepExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeAvailablePatchesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAvailablePatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailablePatchesOutputError>
}

extension DescribeAvailablePatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailablePatchesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAvailablePatchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAvailablePatchesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAvailablePatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAvailablePatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAvailablePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAvailablePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAvailablePatchesInput>
    public typealias MOutput = OperationOutput<DescribeAvailablePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAvailablePatchesOutputError>
}

public struct DescribeAvailablePatchesInput: Equatable {
    /// <p>Filters used to scope down the returned patches.</p>
    public let filters: [PatchOrchestratorFilter]?
    /// <p>The maximum number of patches to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [PatchOrchestratorFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAvailablePatchesInputBody: Equatable {
    public let filters: [PatchOrchestratorFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeAvailablePatchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAvailablePatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAvailablePatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAvailablePatchesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAvailablePatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAvailablePatchesOutputResponse(nextToken: \(String(describing: nextToken)), patches: \(String(describing: patches)))"}
}

extension DescribeAvailablePatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAvailablePatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeAvailablePatchesOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>An array of patches. Each entry in the array is a patch structure.</p>
    public let patches: [Patch]?

    public init (
        nextToken: String? = nil,
        patches: [Patch]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeAvailablePatchesOutputResponseBody: Equatable {
    public let patches: [Patch]?
    public let nextToken: String?
}

extension DescribeAvailablePatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([Patch?].self, forKey: .patches)
        var patchesDecoded0:[Patch]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [Patch]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDocumentInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentOutputError>
}

extension DescribeDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentInput(documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)), versionName: \(String(describing: versionName)))"}
}

extension DescribeDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct DescribeDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentInput>
    public typealias MOutput = OperationOutput<DescribeDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentOutputError>
}

public struct DescribeDocumentInput: Equatable {
    /// <p>The document version for which you want information. Can be a specific version or the
    ///    default version.</p>
    public let documentVersion: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    ///    example, "Release 12, Update 6". This value is unique across all versions of a document, and
    ///    cannot be changed.</p>
    public let versionName: String?

    public init (
        documentVersion: String? = nil,
        name: String? = nil,
        versionName: String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct DescribeDocumentInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let versionName: String?
}

extension DescribeDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

extension DescribeDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentOutputResponse(document: \(String(describing: document)))"}
}

extension DescribeDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.document = output.document
        } else {
            self.document = nil
        }
    }
}

public struct DescribeDocumentOutputResponse: Equatable {
    /// <p>Information about the Systems Manager document.</p>
    public let document: DocumentDescription?

    public init (
        document: DocumentDescription? = nil
    )
    {
        self.document = document
    }
}

struct DescribeDocumentOutputResponseBody: Equatable {
    public let document: DocumentDescription?
}

extension DescribeDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(DocumentDescription.self, forKey: .document)
        document = documentDecoded
    }
}

public struct DescribeDocumentPermissionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDocumentPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentPermissionOutputError>
}

extension DescribeDocumentPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentPermissionInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), permissionType: \(String(describing: permissionType)))"}
}

extension DescribeDocumentPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

public struct DescribeDocumentPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDocumentPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDocumentPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDocumentPermissionInput>
    public typealias MOutput = OperationOutput<DescribeDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDocumentPermissionOutputError>
}

public struct DescribeDocumentPermissionInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The name of the document for which you are the owner.</p>
    public let name: String?
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The permission type for the document. The permission type can be
    ///    <i>Share</i>.</p>
    public let permissionType: DocumentPermissionType?

    public init (
        maxResults: Int = 0,
        name: String? = nil,
        nextToken: String? = nil,
        permissionType: DocumentPermissionType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionType = permissionType
    }
}

struct DescribeDocumentPermissionInputBody: Equatable {
    public let name: String?
    public let permissionType: DocumentPermissionType?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeDocumentPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case permissionType = "PermissionType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDocumentPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentPermissionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidNextToken(InvalidNextToken)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDocumentPermissionOutputResponse(accountIds: \(String(describing: accountIds)), accountSharingInfoList: \(String(describing: accountSharingInfoList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDocumentPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDocumentPermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountIds = output.accountIds
            self.accountSharingInfoList = output.accountSharingInfoList
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.accountSharingInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDocumentPermissionOutputResponse: Equatable {
    /// <p>The account IDs that have permission to use this document. The ID can be either an AWS
    ///    account or <i>All</i>.</p>
    public let accountIds: [String]?
    /// <p>A list of AWS accounts where the current document is shared and the version shared with each
    ///    account.</p>
    public let accountSharingInfoList: [AccountSharingInfo]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        accountIds: [String]? = nil,
        accountSharingInfoList: [AccountSharingInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.accountIds = accountIds
        self.accountSharingInfoList = accountSharingInfoList
        self.nextToken = nextToken
    }
}

struct DescribeDocumentPermissionOutputResponseBody: Equatable {
    public let accountIds: [String]?
    public let accountSharingInfoList: [AccountSharingInfo]?
    public let nextToken: String?
}

extension DescribeDocumentPermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "AccountIds"
        case accountSharingInfoList = "AccountSharingInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let accountSharingInfoListContainer = try containerValues.decodeIfPresent([AccountSharingInfo?].self, forKey: .accountSharingInfoList)
        var accountSharingInfoListDecoded0:[AccountSharingInfo]? = nil
        if let accountSharingInfoListContainer = accountSharingInfoListContainer {
            accountSharingInfoListDecoded0 = [AccountSharingInfo]()
            for structure0 in accountSharingInfoListContainer {
                if let structure0 = structure0 {
                    accountSharingInfoListDecoded0?.append(structure0)
                }
            }
        }
        accountSharingInfoList = accountSharingInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEffectiveInstanceAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEffectiveInstanceAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

extension DescribeEffectiveInstanceAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEffectiveInstanceAssociationsInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEffectiveInstanceAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEffectiveInstanceAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEffectiveInstanceAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectiveInstanceAssociationsInput>
    public typealias MOutput = OperationOutput<DescribeEffectiveInstanceAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectiveInstanceAssociationsOutputError>
}

public struct DescribeEffectiveInstanceAssociationsInput: Equatable {
    /// <p>The instance ID for which you want to view all associations.</p>
    public let instanceId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsInputBody: Equatable {
    public let instanceId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeEffectiveInstanceAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectiveInstanceAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectiveInstanceAssociationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectiveInstanceAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEffectiveInstanceAssociationsOutputResponse(associations: \(String(describing: associations)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEffectiveInstanceAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEffectiveInstanceAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsOutputResponse: Equatable {
    /// <p>The associations for the requested instance.</p>
    public let associations: [InstanceAssociation]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        associations: [InstanceAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct DescribeEffectiveInstanceAssociationsOutputResponseBody: Equatable {
    public let associations: [InstanceAssociation]?
    public let nextToken: String?
}

extension DescribeEffectiveInstanceAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([InstanceAssociation?].self, forKey: .associations)
        var associationsDecoded0:[InstanceAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [InstanceAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEffectivePatchesForPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

extension DescribeEffectivePatchesForPatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEffectivePatchesForPatchBaselineInput(baselineId: \(String(describing: baselineId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEffectivePatchesForPatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEffectivePatchesForPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEffectivePatchesForPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEffectivePatchesForPatchBaselineInput>
    public typealias MOutput = OperationOutput<DescribeEffectivePatchesForPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEffectivePatchesForPatchBaselineOutputError>
}

public struct DescribeEffectivePatchesForPatchBaselineInput: Equatable {
    /// <p>The ID of the patch baseline to retrieve the effective patches for.</p>
    public let baselineId: String?
    /// <p>The maximum number of patches to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        baselineId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.baselineId = baselineId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineInputBody: Equatable {
    public let baselineId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeEffectivePatchesForPatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEffectivePatchesForPatchBaselineOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEffectivePatchesForPatchBaselineOutputResponse(effectivePatches: \(String(describing: effectivePatches)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEffectivePatchesForPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.effectivePatches = output.effectivePatches
            self.nextToken = output.nextToken
        } else {
            self.effectivePatches = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineOutputResponse: Equatable {
    /// <p>An array of patches and patch status.</p>
    public let effectivePatches: [EffectivePatch]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        effectivePatches: [EffectivePatch]? = nil,
        nextToken: String? = nil
    )
    {
        self.effectivePatches = effectivePatches
        self.nextToken = nextToken
    }
}

struct DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Equatable {
    public let effectivePatches: [EffectivePatch]?
    public let nextToken: String?
}

extension DescribeEffectivePatchesForPatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effectivePatches = "EffectivePatches"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectivePatchesContainer = try containerValues.decodeIfPresent([EffectivePatch?].self, forKey: .effectivePatches)
        var effectivePatchesDecoded0:[EffectivePatch]? = nil
        if let effectivePatchesContainer = effectivePatchesContainer {
            effectivePatchesDecoded0 = [EffectivePatch]()
            for structure0 in effectivePatchesContainer {
                if let structure0 = structure0 {
                    effectivePatchesDecoded0?.append(structure0)
                }
            }
        }
        effectivePatches = effectivePatchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstanceAssociationsStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstanceAssociationsStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAssociationsStatusOutputError>
}

extension DescribeInstanceAssociationsStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAssociationsStatusInput(instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstanceAssociationsStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstanceAssociationsStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceAssociationsStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceAssociationsStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceAssociationsStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceAssociationsStatusInput>
    public typealias MOutput = OperationOutput<DescribeInstanceAssociationsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceAssociationsStatusOutputError>
}

public struct DescribeInstanceAssociationsStatusInput: Equatable {
    /// <p>The instance IDs for which you want association status information.</p>
    public let instanceId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusInputBody: Equatable {
    public let instanceId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeInstanceAssociationsStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceAssociationsStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceAssociationsStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceAssociationsStatusOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceAssociationsStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceAssociationsStatusOutputResponse(instanceAssociationStatusInfos: \(String(describing: instanceAssociationStatusInfos)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstanceAssociationsStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceAssociationsStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceAssociationStatusInfos = output.instanceAssociationStatusInfos
            self.nextToken = output.nextToken
        } else {
            self.instanceAssociationStatusInfos = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceAssociationsStatusOutputResponse: Equatable {
    /// <p>Status information about the association.</p>
    public let instanceAssociationStatusInfos: [InstanceAssociationStatusInfo]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        instanceAssociationStatusInfos: [InstanceAssociationStatusInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.instanceAssociationStatusInfos = instanceAssociationStatusInfos
        self.nextToken = nextToken
    }
}

struct DescribeInstanceAssociationsStatusOutputResponseBody: Equatable {
    public let instanceAssociationStatusInfos: [InstanceAssociationStatusInfo]?
    public let nextToken: String?
}

extension DescribeInstanceAssociationsStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceAssociationStatusInfos = "InstanceAssociationStatusInfos"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceAssociationStatusInfosContainer = try containerValues.decodeIfPresent([InstanceAssociationStatusInfo?].self, forKey: .instanceAssociationStatusInfos)
        var instanceAssociationStatusInfosDecoded0:[InstanceAssociationStatusInfo]? = nil
        if let instanceAssociationStatusInfosContainer = instanceAssociationStatusInfosContainer {
            instanceAssociationStatusInfosDecoded0 = [InstanceAssociationStatusInfo]()
            for structure0 in instanceAssociationStatusInfosContainer {
                if let structure0 = structure0 {
                    instanceAssociationStatusInfosDecoded0?.append(structure0)
                }
            }
        }
        instanceAssociationStatusInfos = instanceAssociationStatusInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstanceInformationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstanceInformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceInformationOutputError>
}

extension DescribeInstanceInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceInformationInput(filters: \(String(describing: filters)), instanceInformationFilterList: \(String(describing: instanceInformationFilterList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstanceInformationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instanceinformationstringfilterlist0 in filters {
                try filtersContainer.encode(instanceinformationstringfilterlist0)
            }
        }
        if let instanceInformationFilterList = instanceInformationFilterList {
            var instanceInformationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceInformationFilterList)
            for instanceinformationfilterlist0 in instanceInformationFilterList {
                try instanceInformationFilterListContainer.encode(instanceinformationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstanceInformationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstanceInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstanceInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstanceInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstanceInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstanceInformationInput>
    public typealias MOutput = OperationOutput<DescribeInstanceInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstanceInformationOutputError>
}

public struct DescribeInstanceInformationInput: Equatable {
    /// <p>One or more filters. Use a filter to return a more specific list of instances. You can
    ///    filter based on tags applied to EC2 instances. Use this <code>Filters</code> data type instead of
    ///     <code>InstanceInformationFilterList</code>, which is deprecated.</p>
    public let filters: [InstanceInformationStringFilter]?
    /// <p>This is a legacy method. We recommend that you don't use this method. Instead, use the
    ///     <code>Filters</code> data type. <code>Filters</code> enables you to return instance information
    ///    by filtering based on tags applied to managed instances.</p>
    ///          <note>
    ///             <p>Attempting to use <code>InstanceInformationFilterList</code> and <code>Filters</code> leads
    ///     to an exception error. </p>
    ///          </note>
    public let instanceInformationFilterList: [InstanceInformationFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results. </p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [InstanceInformationStringFilter]? = nil,
        instanceInformationFilterList: [InstanceInformationFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.instanceInformationFilterList = instanceInformationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationInputBody: Equatable {
    public let instanceInformationFilterList: [InstanceInformationFilter]?
    public let filters: [InstanceInformationStringFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeInstanceInformationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceInformationFilterList = "InstanceInformationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationFilterListContainer = try containerValues.decodeIfPresent([InstanceInformationFilter?].self, forKey: .instanceInformationFilterList)
        var instanceInformationFilterListDecoded0:[InstanceInformationFilter]? = nil
        if let instanceInformationFilterListContainer = instanceInformationFilterListContainer {
            instanceInformationFilterListDecoded0 = [InstanceInformationFilter]()
            for structure0 in instanceInformationFilterListContainer {
                if let structure0 = structure0 {
                    instanceInformationFilterListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationFilterList = instanceInformationFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([InstanceInformationStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[InstanceInformationStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InstanceInformationStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceInformationFilterValue" : self = .invalidInstanceInformationFilterValue(try InvalidInstanceInformationFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceInformationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInstanceInformationFilterValue(InvalidInstanceInformationFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstanceInformationOutputResponse(instanceInformationList: \(String(describing: instanceInformationList)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstanceInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstanceInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceInformationList = output.instanceInformationList
            self.nextToken = output.nextToken
        } else {
            self.instanceInformationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstanceInformationOutputResponse: Equatable {
    /// <p>The instance information list.</p>
    public let instanceInformationList: [InstanceInformation]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty. </p>
    public let nextToken: String?

    public init (
        instanceInformationList: [InstanceInformation]? = nil,
        nextToken: String? = nil
    )
    {
        self.instanceInformationList = instanceInformationList
        self.nextToken = nextToken
    }
}

struct DescribeInstanceInformationOutputResponseBody: Equatable {
    public let instanceInformationList: [InstanceInformation]?
    public let nextToken: String?
}

extension DescribeInstanceInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceInformationList = "InstanceInformationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceInformationListContainer = try containerValues.decodeIfPresent([InstanceInformation?].self, forKey: .instanceInformationList)
        var instanceInformationListDecoded0:[InstanceInformation]? = nil
        if let instanceInformationListContainer = instanceInformationListContainer {
            instanceInformationListDecoded0 = [InstanceInformation]()
            for structure0 in instanceInformationListContainer {
                if let structure0 = structure0 {
                    instanceInformationListDecoded0?.append(structure0)
                }
            }
        }
        instanceInformationList = instanceInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

extension DescribeInstancePatchStatesForPatchGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchStatesForPatchGroupInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), patchGroup: \(String(describing: patchGroup)))"}
}

extension DescribeInstancePatchStatesForPatchGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for instancepatchstatefilterlist0 in filters {
                try filtersContainer.encode(instancepatchstatefilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesForPatchGroupInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesForPatchGroupOutputError>
}

public struct DescribeInstancePatchStatesForPatchGroupInput: Equatable {
    /// <p>Each entry in the array is a structure containing:</p>
    ///          <p>Key (string between 1 and 200 characters)</p>
    ///          <p> Values (array containing a single string)</p>
    ///          <p> Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")</p>
    public let filters: [InstancePatchStateFilter]?
    /// <p>The maximum number of patches to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The name of the patch group for which the patch state information should be
    ///    retrieved.</p>
    public let patchGroup: String?

    public init (
        filters: [InstancePatchStateFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        patchGroup: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patchGroup = patchGroup
    }
}

struct DescribeInstancePatchStatesForPatchGroupInputBody: Equatable {
    public let patchGroup: String?
    public let filters: [InstancePatchStateFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeInstancePatchStatesForPatchGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let filtersContainer = try containerValues.decodeIfPresent([InstancePatchStateFilter?].self, forKey: .filters)
        var filtersDecoded0:[InstancePatchStateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InstancePatchStateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesForPatchGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchStatesForPatchGroupOutputResponse(instancePatchStates: \(String(describing: instancePatchStates)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstancePatchStatesForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupOutputResponse: Equatable {
    /// <p>The high-level patch state for the requested instances. </p>
    public let instancePatchStates: [InstancePatchState]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        instancePatchStates: [InstancePatchState]? = nil,
        nextToken: String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Equatable {
    public let instancePatchStates: [InstancePatchState]?
    public let nextToken: String?
}

extension DescribeInstancePatchStatesForPatchGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchStatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesOutputError>
}

extension DescribeInstancePatchStatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchStatesInput(instanceIds: \(String(describing: instanceIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstancePatchStatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchStatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchStatesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchStatesOutputError>
}

public struct DescribeInstancePatchStatesInput: Equatable {
    /// <p>The ID of the instance whose patch state information should be retrieved.</p>
    public let instanceIds: [String]?
    /// <p>The maximum number of instances to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        instanceIds: [String]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesInputBody: Equatable {
    public let instanceIds: [String]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeInstancePatchStatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceIds = "InstanceIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchStatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchStatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchStatesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchStatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchStatesOutputResponse(instancePatchStates: \(String(describing: instancePatchStates)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstancePatchStatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstancePatchStatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instancePatchStates = output.instancePatchStates
            self.nextToken = output.nextToken
        } else {
            self.instancePatchStates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInstancePatchStatesOutputResponse: Equatable {
    /// <p>The high-level patch state for the requested instances.</p>
    public let instancePatchStates: [InstancePatchState]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        instancePatchStates: [InstancePatchState]? = nil,
        nextToken: String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchStatesOutputResponseBody: Equatable {
    public let instancePatchStates: [InstancePatchState]?
    public let nextToken: String?
}

extension DescribeInstancePatchStatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instancePatchStates = "InstancePatchStates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePatchStatesContainer = try containerValues.decodeIfPresent([InstancePatchState?].self, forKey: .instancePatchStates)
        var instancePatchStatesDecoded0:[InstancePatchState]? = nil
        if let instancePatchStatesContainer = instancePatchStatesContainer {
            instancePatchStatesDecoded0 = [InstancePatchState]()
            for structure0 in instancePatchStatesContainer {
                if let structure0 = structure0 {
                    instancePatchStatesDecoded0?.append(structure0)
                }
            }
        }
        instancePatchStates = instancePatchStatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInstancePatchesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchesOutputError>
}

extension DescribeInstancePatchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchesInput(filters: \(String(describing: filters)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInstancePatchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInstancePatchesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInstancePatchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInstancePatchesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInstancePatchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInstancePatchesInput>
    public typealias MOutput = OperationOutput<DescribeInstancePatchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInstancePatchesOutputError>
}

public struct DescribeInstancePatchesInput: Equatable {
    /// <p>An array of structures. Each entry in the array is a structure containing a Key, Value
    ///    combination. Valid values for Key are <code>Classification</code> | <code>KBId</code> |
    ///     <code>Severity</code> | <code>State</code>.</p>
    public let filters: [PatchOrchestratorFilter]?
    /// <p>The ID of the instance whose patch state information should be retrieved.</p>
    public let instanceId: String?
    /// <p>The maximum number of patches to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [PatchOrchestratorFilter]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInstancePatchesInputBody: Equatable {
    public let instanceId: String?
    public let filters: [PatchOrchestratorFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeInstancePatchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInstancePatchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstancePatchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstancePatchesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstancePatchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInstancePatchesOutputResponse(nextToken: \(String(describing: nextToken)), patches: \(String(describing: patches)))"}
}

extension DescribeInstancePatchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInstancePatchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.patches = output.patches
        } else {
            self.nextToken = nil
            self.patches = nil
        }
    }
}

public struct DescribeInstancePatchesOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Each entry in the array is a structure containing:</p>
    ///          <p>Title (string)</p>
    ///          <p>KBId (string)</p>
    ///          <p>Classification (string)</p>
    ///          <p>Severity (string)</p>
    ///          <p>State (string, such as "INSTALLED" or "FAILED")</p>
    ///          <p>InstalledTime (DateTime)</p>
    ///          <p>InstalledBy (string)</p>
    public let patches: [PatchComplianceData]?

    public init (
        nextToken: String? = nil,
        patches: [PatchComplianceData]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

struct DescribeInstancePatchesOutputResponseBody: Equatable {
    public let patches: [PatchComplianceData]?
    public let nextToken: String?
}

extension DescribeInstancePatchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case patches = "Patches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchesContainer = try containerValues.decodeIfPresent([PatchComplianceData?].self, forKey: .patches)
        var patchesDecoded0:[PatchComplianceData]? = nil
        if let patchesContainer = patchesContainer {
            patchesDecoded0 = [PatchComplianceData]()
            for structure0 in patchesContainer {
                if let structure0 = structure0 {
                    patchesDecoded0?.append(structure0)
                }
            }
        }
        patches = patchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeInventoryDeletionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInventoryDeletionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInventoryDeletionsOutputError>
}

extension DescribeInventoryDeletionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInventoryDeletionsInput(deletionId: \(String(describing: deletionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInventoryDeletionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeInventoryDeletionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInventoryDeletionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInventoryDeletionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInventoryDeletionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInventoryDeletionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInventoryDeletionsInput>
    public typealias MOutput = OperationOutput<DescribeInventoryDeletionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInventoryDeletionsOutputError>
}

public struct DescribeInventoryDeletionsInput: Equatable {
    /// <p>Specify the delete inventory ID for which you want information. This ID was returned by the
    ///     <code>DeleteInventory</code> action.</p>
    public let deletionId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        deletionId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.deletionId = deletionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsInputBody: Equatable {
    public let deletionId: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension DescribeInventoryDeletionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionId = "DeletionId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeInventoryDeletionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInventoryDeletionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionIdException" : self = .invalidDeletionIdException(try InvalidDeletionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInventoryDeletionsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDeletionIdException(InvalidDeletionIdException)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInventoryDeletionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInventoryDeletionsOutputResponse(inventoryDeletions: \(String(describing: inventoryDeletions)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeInventoryDeletionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInventoryDeletionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inventoryDeletions = output.inventoryDeletions
            self.nextToken = output.nextToken
        } else {
            self.inventoryDeletions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeInventoryDeletionsOutputResponse: Equatable {
    /// <p>A list of status items for deleted inventory.</p>
    public let inventoryDeletions: [InventoryDeletionStatusItem]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        inventoryDeletions: [InventoryDeletionStatusItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.inventoryDeletions = inventoryDeletions
        self.nextToken = nextToken
    }
}

struct DescribeInventoryDeletionsOutputResponseBody: Equatable {
    public let inventoryDeletions: [InventoryDeletionStatusItem]?
    public let nextToken: String?
}

extension DescribeInventoryDeletionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inventoryDeletions = "InventoryDeletions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inventoryDeletionsContainer = try containerValues.decodeIfPresent([InventoryDeletionStatusItem?].self, forKey: .inventoryDeletions)
        var inventoryDeletionsDecoded0:[InventoryDeletionStatusItem]? = nil
        if let inventoryDeletionsContainer = inventoryDeletionsContainer {
            inventoryDeletionsDecoded0 = [InventoryDeletionStatusItem]()
            for structure0 in inventoryDeletionsContainer {
                if let structure0 = structure0 {
                    inventoryDeletionsDecoded0?.append(structure0)
                }
            }
        }
        inventoryDeletions = inventoryDeletionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionTaskInvocationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), taskId: \(String(describing: taskId)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTaskInvocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTaskInvocationsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTaskInvocationsOutputError>
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInput: Equatable {
    /// <p>Optional filters used to scope down the returned task invocations. The supported filter key
    ///    is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT,
    ///    CANCELLING, and CANCELLED.</p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the specific task in the maintenance window task that should be retrieved.</p>
    public let taskId: String?
    /// <p>The ID of the maintenance window execution the task is part of.</p>
    public let windowExecutionId: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        taskId: String? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Equatable {
    public let windowExecutionId: String?
    public let taskId: String?
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTaskInvocationsOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse(nextToken: \(String(describing: nextToken)), windowExecutionTaskInvocationIdentities: \(String(describing: windowExecutionTaskInvocationIdentities)))"}
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.windowExecutionTaskInvocationIdentities = output.windowExecutionTaskInvocationIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskInvocationIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the task invocation results per invocation.</p>
    public let windowExecutionTaskInvocationIdentities: [MaintenanceWindowExecutionTaskInvocationIdentity]?

    public init (
        nextToken: String? = nil,
        windowExecutionTaskInvocationIdentities: [MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Equatable {
    public let windowExecutionTaskInvocationIdentities: [MaintenanceWindowExecutionTaskInvocationIdentity]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskInvocationIdentities = "WindowExecutionTaskInvocationIdentities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskInvocationIdentitiesContainer = try containerValues.decodeIfPresent([MaintenanceWindowExecutionTaskInvocationIdentity?].self, forKey: .windowExecutionTaskInvocationIdentities)
        var windowExecutionTaskInvocationIdentitiesDecoded0:[MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
        if let windowExecutionTaskInvocationIdentitiesContainer = windowExecutionTaskInvocationIdentitiesContainer {
            windowExecutionTaskInvocationIdentitiesDecoded0 = [MaintenanceWindowExecutionTaskInvocationIdentity]()
            for structure0 in windowExecutionTaskInvocationIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskInvocationIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

extension DescribeMaintenanceWindowExecutionTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension DescribeMaintenanceWindowExecutionTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionTasksOutputError>
}

public struct DescribeMaintenanceWindowExecutionTasksInput: Equatable {
    /// <p>Optional filters used to scope down the returned tasks. The supported filter key is STATUS
    ///    with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and
    ///    CANCELLED. </p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the maintenance window execution whose task executions should be retrieved.</p>
    public let windowExecutionId: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowExecutionId = windowExecutionId
    }
}

struct DescribeMaintenanceWindowExecutionTasksInputBody: Equatable {
    public let windowExecutionId: String?
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionTasksOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionTasksOutputResponse(nextToken: \(String(describing: nextToken)), windowExecutionTaskIdentities: \(String(describing: windowExecutionTaskIdentities)))"}
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowExecutionTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.windowExecutionTaskIdentities = output.windowExecutionTaskIdentities
        } else {
            self.nextToken = nil
            self.windowExecutionTaskIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the task executions.</p>
    public let windowExecutionTaskIdentities: [MaintenanceWindowExecutionTaskIdentity]?

    public init (
        nextToken: String? = nil,
        windowExecutionTaskIdentities: [MaintenanceWindowExecutionTaskIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskIdentities = windowExecutionTaskIdentities
    }
}

struct DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Equatable {
    public let windowExecutionTaskIdentities: [MaintenanceWindowExecutionTaskIdentity]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case windowExecutionTaskIdentities = "WindowExecutionTaskIdentities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionTaskIdentitiesContainer = try containerValues.decodeIfPresent([MaintenanceWindowExecutionTaskIdentity?].self, forKey: .windowExecutionTaskIdentities)
        var windowExecutionTaskIdentitiesDecoded0:[MaintenanceWindowExecutionTaskIdentity]? = nil
        if let windowExecutionTaskIdentitiesContainer = windowExecutionTaskIdentitiesContainer {
            windowExecutionTaskIdentitiesDecoded0 = [MaintenanceWindowExecutionTaskIdentity]()
            for structure0 in windowExecutionTaskIdentitiesContainer {
                if let structure0 = structure0 {
                    windowExecutionTaskIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowExecutionTaskIdentities = windowExecutionTaskIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

extension DescribeMaintenanceWindowExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), windowId: \(String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowExecutionsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowExecutionsOutputError>
}

public struct DescribeMaintenanceWindowExecutionsInput: Equatable {
    /// <p>Each entry in the array is a structure containing:</p>
    ///          <p>Key (string, between 1 and 128 characters)</p>
    ///          <p>Values (array of strings, each string is between 1 and 256 characters)</p>
    ///          <p>The supported Keys are ExecutedBefore and ExecutedAfter with the value being a date/time
    ///    string such as 2016-11-04T05:00:00Z.</p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the maintenance window whose executions should be retrieved.</p>
    public let windowId: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        windowId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowExecutionsInputBody: Equatable {
    public let windowId: String?
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowExecutionsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), windowExecutions: \(String(describing: windowExecutions)))"}
}

extension DescribeMaintenanceWindowExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.windowExecutions = output.windowExecutions
        } else {
            self.nextToken = nil
            self.windowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the maintenance window executions.</p>
    public let windowExecutions: [MaintenanceWindowExecution]?

    public init (
        nextToken: String? = nil,
        windowExecutions: [MaintenanceWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutions = windowExecutions
    }
}

struct DescribeMaintenanceWindowExecutionsOutputResponseBody: Equatable {
    public let windowExecutions: [MaintenanceWindowExecution]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case windowExecutions = "WindowExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionsContainer = try containerValues.decodeIfPresent([MaintenanceWindowExecution?].self, forKey: .windowExecutions)
        var windowExecutionsDecoded0:[MaintenanceWindowExecution]? = nil
        if let windowExecutionsContainer = windowExecutionsContainer {
            windowExecutionsDecoded0 = [MaintenanceWindowExecution]()
            for structure0 in windowExecutionsContainer {
                if let structure0 = structure0 {
                    windowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        windowExecutions = windowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowScheduleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowScheduleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

extension DescribeMaintenanceWindowScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowScheduleInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)), targets: \(String(describing: targets)), windowId: \(String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowScheduleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowScheduleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowScheduleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowScheduleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowScheduleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowScheduleInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowScheduleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowScheduleOutputError>
}

public struct DescribeMaintenanceWindowScheduleInput: Equatable {
    /// <p>Filters used to limit the range of results. For example, you can limit maintenance window
    ///    executions to only those scheduled before or after a certain date and time.</p>
    public let filters: [PatchOrchestratorFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
    public let resourceType: MaintenanceWindowResourceType?
    /// <p>The instance ID or key/value pair to retrieve information about.</p>
    public let targets: [Target]?
    /// <p>The ID of the maintenance window to retrieve information about.</p>
    public let windowId: String?

    public init (
        filters: [PatchOrchestratorFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceType: MaintenanceWindowResourceType? = nil,
        targets: [Target]? = nil,
        windowId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowScheduleInputBody: Equatable {
    public let windowId: String?
    public let targets: [Target]?
    public let resourceType: MaintenanceWindowResourceType?
    public let filters: [PatchOrchestratorFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowScheduleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowScheduleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowScheduleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowScheduleOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowScheduleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowScheduleOutputResponse(nextToken: \(String(describing: nextToken)), scheduledWindowExecutions: \(String(describing: scheduledWindowExecutions)))"}
}

extension DescribeMaintenanceWindowScheduleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowScheduleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.scheduledWindowExecutions = output.scheduledWindowExecutions
        } else {
            self.nextToken = nil
            self.scheduledWindowExecutions = nil
        }
    }
}

public struct DescribeMaintenanceWindowScheduleOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    public let nextToken: String?
    /// <p>Information about maintenance window executions scheduled for the specified time
    ///    range.</p>
    public let scheduledWindowExecutions: [ScheduledWindowExecution]?

    public init (
        nextToken: String? = nil,
        scheduledWindowExecutions: [ScheduledWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledWindowExecutions = scheduledWindowExecutions
    }
}

struct DescribeMaintenanceWindowScheduleOutputResponseBody: Equatable {
    public let scheduledWindowExecutions: [ScheduledWindowExecution]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowScheduleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case scheduledWindowExecutions = "ScheduledWindowExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledWindowExecutionsContainer = try containerValues.decodeIfPresent([ScheduledWindowExecution?].self, forKey: .scheduledWindowExecutions)
        var scheduledWindowExecutionsDecoded0:[ScheduledWindowExecution]? = nil
        if let scheduledWindowExecutionsContainer = scheduledWindowExecutionsContainer {
            scheduledWindowExecutionsDecoded0 = [ScheduledWindowExecution]()
            for structure0 in scheduledWindowExecutionsContainer {
                if let structure0 = structure0 {
                    scheduledWindowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        scheduledWindowExecutions = scheduledWindowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

extension DescribeMaintenanceWindowTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowTargetsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), windowId: \(String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTargetsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTargetsOutputError>
}

public struct DescribeMaintenanceWindowTargetsInput: Equatable {
    /// <p>Optional filters that can be used to narrow down the scope of the returned window targets.
    ///    The supported filter keys are Type, WindowTargetId and OwnerInformation.</p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the maintenance window whose targets should be retrieved.</p>
    public let windowId: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        windowId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTargetsInputBody: Equatable {
    public let windowId: String?
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTargetsOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowTargetsOutputResponse(nextToken: \(String(describing: nextToken)), targets: \(String(describing: targets)))"}
}

extension DescribeMaintenanceWindowTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct DescribeMaintenanceWindowTargetsOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the targets in the maintenance window.</p>
    public let targets: [MaintenanceWindowTarget]?

    public init (
        nextToken: String? = nil,
        targets: [MaintenanceWindowTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowTargetsOutputResponseBody: Equatable {
    public let targets: [MaintenanceWindowTarget]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([MaintenanceWindowTarget?].self, forKey: .targets)
        var targetsDecoded0:[MaintenanceWindowTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [MaintenanceWindowTarget]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowTasksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTasksOutputError>
}

extension DescribeMaintenanceWindowTasksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowTasksInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), windowId: \(String(describing: windowId)))"}
}

extension DescribeMaintenanceWindowTasksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct DescribeMaintenanceWindowTasksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowTasksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowTasksInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowTasksOutputError>
}

public struct DescribeMaintenanceWindowTasksInput: Equatable {
    /// <p>Optional filters used to narrow down the scope of the returned tasks. The supported filter
    ///    keys are WindowTaskId, TaskArn, Priority, and TaskType.</p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the maintenance window whose tasks should be retrieved.</p>
    public let windowId: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        windowId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

struct DescribeMaintenanceWindowTasksInputBody: Equatable {
    public let windowId: String?
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowTasksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowTasksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowTasksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowTasksOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowTasksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowTasksOutputResponse(nextToken: \(String(describing: nextToken)), tasks: \(String(describing: tasks)))"}
}

extension DescribeMaintenanceWindowTasksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowTasksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeMaintenanceWindowTasksOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the tasks in the maintenance window.</p>
    public let tasks: [MaintenanceWindowTask]?

    public init (
        nextToken: String? = nil,
        tasks: [MaintenanceWindowTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeMaintenanceWindowTasksOutputResponseBody: Equatable {
    public let tasks: [MaintenanceWindowTask]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowTasksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tasks = "Tasks"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([MaintenanceWindowTask?].self, forKey: .tasks)
        var tasksDecoded0:[MaintenanceWindowTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [MaintenanceWindowTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowsForTargetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsForTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

extension DescribeMaintenanceWindowsForTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowsForTargetInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)), targets: \(String(describing: targets)))"}
}

extension DescribeMaintenanceWindowsForTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsForTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsForTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsForTargetInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsForTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsForTargetOutputError>
}

public struct DescribeMaintenanceWindowsForTargetInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
    public let resourceType: MaintenanceWindowResourceType?
    /// <p>The instance ID or key/value pair to retrieve information about.</p>
    public let targets: [Target]?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceType: MaintenanceWindowResourceType? = nil,
        targets: [Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
    }
}

struct DescribeMaintenanceWindowsForTargetInputBody: Equatable {
    public let targets: [Target]?
    public let resourceType: MaintenanceWindowResourceType?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowsForTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceType = "ResourceType"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsForTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsForTargetOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsForTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowsForTargetOutputResponse(nextToken: \(String(describing: nextToken)), windowIdentities: \(String(describing: windowIdentities)))"}
}

extension DescribeMaintenanceWindowsForTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowsForTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    public let nextToken: String?
    /// <p>Information about the maintenance window targets and tasks an instance is associated
    ///    with.</p>
    public let windowIdentities: [MaintenanceWindowIdentityForTarget]?

    public init (
        nextToken: String? = nil,
        windowIdentities: [MaintenanceWindowIdentityForTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsForTargetOutputResponseBody: Equatable {
    public let windowIdentities: [MaintenanceWindowIdentityForTarget]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowsForTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([MaintenanceWindowIdentityForTarget?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[MaintenanceWindowIdentityForTarget]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [MaintenanceWindowIdentityForTarget]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeMaintenanceWindowsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsOutputError>
}

extension DescribeMaintenanceWindowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeMaintenanceWindowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for maintenancewindowfilterlist0 in filters {
                try filtersContainer.encode(maintenancewindowfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeMaintenanceWindowsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMaintenanceWindowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMaintenanceWindowsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMaintenanceWindowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMaintenanceWindowsInput>
    public typealias MOutput = OperationOutput<DescribeMaintenanceWindowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMaintenanceWindowsOutputError>
}

public struct DescribeMaintenanceWindowsInput: Equatable {
    /// <p>Optional filters used to narrow down the scope of the returned maintenance windows.
    ///    Supported filter keys are <b>Name</b> and <b>Enabled</b>.</p>
    public let filters: [MaintenanceWindowFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [MaintenanceWindowFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeMaintenanceWindowsInputBody: Equatable {
    public let filters: [MaintenanceWindowFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeMaintenanceWindowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([MaintenanceWindowFilter?].self, forKey: .filters)
        var filtersDecoded0:[MaintenanceWindowFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [MaintenanceWindowFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMaintenanceWindowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMaintenanceWindowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMaintenanceWindowsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMaintenanceWindowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMaintenanceWindowsOutputResponse(nextToken: \(String(describing: nextToken)), windowIdentities: \(String(describing: windowIdentities)))"}
}

extension DescribeMaintenanceWindowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMaintenanceWindowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.windowIdentities = output.windowIdentities
        } else {
            self.nextToken = nil
            self.windowIdentities = nil
        }
    }
}

public struct DescribeMaintenanceWindowsOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Information about the maintenance windows.</p>
    public let windowIdentities: [MaintenanceWindowIdentity]?

    public init (
        nextToken: String? = nil,
        windowIdentities: [MaintenanceWindowIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

struct DescribeMaintenanceWindowsOutputResponseBody: Equatable {
    public let windowIdentities: [MaintenanceWindowIdentity]?
    public let nextToken: String?
}

extension DescribeMaintenanceWindowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case windowIdentities = "WindowIdentities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdentitiesContainer = try containerValues.decodeIfPresent([MaintenanceWindowIdentity?].self, forKey: .windowIdentities)
        var windowIdentitiesDecoded0:[MaintenanceWindowIdentity]? = nil
        if let windowIdentitiesContainer = windowIdentitiesContainer {
            windowIdentitiesDecoded0 = [MaintenanceWindowIdentity]()
            for structure0 in windowIdentitiesContainer {
                if let structure0 = structure0 {
                    windowIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        windowIdentities = windowIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeOpsItemsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOpsItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOpsItemsOutputError>
}

extension DescribeOpsItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOpsItemsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), opsItemFilters: \(String(describing: opsItemFilters)))"}
}

extension DescribeOpsItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemFilters = opsItemFilters {
            var opsItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .opsItemFilters)
            for opsitemfilters0 in opsItemFilters {
                try opsItemFiltersContainer.encode(opsitemfilters0)
            }
        }
    }
}

public struct DescribeOpsItemsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOpsItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOpsItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOpsItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOpsItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOpsItemsInput>
    public typealias MOutput = OperationOutput<DescribeOpsItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOpsItemsOutputError>
}

public struct DescribeOpsItemsInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?
    /// <p>One or more filters to limit the response.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key: CreatedTime</p>
    ///                <p>Operations: GreaterThan, LessThan</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: LastModifiedBy</p>
    ///                <p>Operations: Contains, Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: LastModifiedTime</p>
    ///                <p>Operations: GreaterThan, LessThan</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: Priority</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: Source</p>
    ///                <p>Operations: Contains, Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: Status</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: Title</p>
    ///                <p>Operations: Contains</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: OperationalData*</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: OperationalDataKey</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: OperationalDataValue</p>
    ///                <p>Operations: Equals, Contains</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: OpsItemId</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: ResourceId</p>
    ///                <p>Operations: Contains</p>
    ///             </li>
    ///             <li>
    ///                <p>Key: AutomationId</p>
    ///                <p>Operations: Equals</p>
    ///             </li>
    ///          </ul>
    ///          <p>*If you filter the response by using the OperationalData operator, specify a key-value pair
    ///    by using the following JSON format: {"key":"key_name","value":"a_value"}</p>
    public let opsItemFilters: [OpsItemFilter]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        opsItemFilters: [OpsItemFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemFilters = opsItemFilters
    }
}

struct DescribeOpsItemsInputBody: Equatable {
    public let opsItemFilters: [OpsItemFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeOpsItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemFilters = "OpsItemFilters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemFiltersContainer = try containerValues.decodeIfPresent([OpsItemFilter?].self, forKey: .opsItemFilters)
        var opsItemFiltersDecoded0:[OpsItemFilter]? = nil
        if let opsItemFiltersContainer = opsItemFiltersContainer {
            opsItemFiltersDecoded0 = [OpsItemFilter]()
            for structure0 in opsItemFiltersContainer {
                if let structure0 = structure0 {
                    opsItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        opsItemFilters = opsItemFiltersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOpsItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOpsItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOpsItemsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOpsItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOpsItemsOutputResponse(nextToken: \(String(describing: nextToken)), opsItemSummaries: \(String(describing: opsItemSummaries)))"}
}

extension DescribeOpsItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOpsItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.opsItemSummaries = output.opsItemSummaries
        } else {
            self.nextToken = nil
            self.opsItemSummaries = nil
        }
    }
}

public struct DescribeOpsItemsOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>A list of OpsItems.</p>
    public let opsItemSummaries: [OpsItemSummary]?

    public init (
        nextToken: String? = nil,
        opsItemSummaries: [OpsItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsItemSummaries = opsItemSummaries
    }
}

struct DescribeOpsItemsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let opsItemSummaries: [OpsItemSummary]?
}

extension DescribeOpsItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case opsItemSummaries = "OpsItemSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let opsItemSummariesContainer = try containerValues.decodeIfPresent([OpsItemSummary?].self, forKey: .opsItemSummaries)
        var opsItemSummariesDecoded0:[OpsItemSummary]? = nil
        if let opsItemSummariesContainer = opsItemSummariesContainer {
            opsItemSummariesDecoded0 = [OpsItemSummary]()
            for structure0 in opsItemSummariesContainer {
                if let structure0 = structure0 {
                    opsItemSummariesDecoded0?.append(structure0)
                }
            }
        }
        opsItemSummaries = opsItemSummariesDecoded0
    }
}

public struct DescribeParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

extension DescribeParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParametersInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), parameterFilters: \(String(describing: parameterFilters)))"}
}

extension DescribeParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for parametersfilterlist0 in filters {
                try filtersContainer.encode(parametersfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
    }
}

public struct DescribeParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInput: Equatable {
    /// <p>This data type is deprecated. Instead, use <code>ParameterFilters</code>.</p>
    public let filters: [ParametersFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>Filters to limit the request results.</p>
    public let parameterFilters: [ParameterStringFilter]?

    public init (
        filters: [ParametersFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        parameterFilters: [ParameterStringFilter]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
    }
}

struct DescribeParametersInputBody: Equatable {
    public let filters: [ParametersFilter]?
    public let parameterFilters: [ParameterStringFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ParametersFilter?].self, forKey: .filters)
        var filtersDecoded0:[ParametersFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ParametersFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let parameterFiltersContainer = try containerValues.decodeIfPresent([ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParametersOutputResponse(nextToken: \(String(describing: nextToken)), parameters: \(String(describing: parameters)))"}
}

extension DescribeParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items.</p>
    public let nextToken: String?
    /// <p>Parameters returned by the request.</p>
    public let parameters: [ParameterMetadata]?

    public init (
        nextToken: String? = nil,
        parameters: [ParameterMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Equatable {
    public let parameters: [ParameterMetadata]?
    public let nextToken: String?
}

extension DescribeParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([ParameterMetadata?].self, forKey: .parameters)
        var parametersDecoded0:[ParameterMetadata]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ParameterMetadata]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchBaselinesInputBodyMiddleware: Middleware {
    public let id: String = "DescribePatchBaselinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchBaselinesOutputError>
}

extension DescribePatchBaselinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchBaselinesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribePatchBaselinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribePatchBaselinesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePatchBaselinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePatchBaselinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchBaselinesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchBaselinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchBaselinesInput>
    public typealias MOutput = OperationOutput<DescribePatchBaselinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchBaselinesOutputError>
}

public struct DescribePatchBaselinesInput: Equatable {
    /// <p>Each element in the array is a structure containing: </p>
    ///          <p>Key: (string, "NAME_PREFIX" or "OWNER")</p>
    ///          <p>Value: (array of strings, exactly 1 entry, between 1 and 255 characters)</p>
    public let filters: [PatchOrchestratorFilter]?
    /// <p>The maximum number of patch baselines to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [PatchOrchestratorFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesInputBody: Equatable {
    public let filters: [PatchOrchestratorFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribePatchBaselinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchBaselinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchBaselinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchBaselinesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchBaselinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchBaselinesOutputResponse(baselineIdentities: \(String(describing: baselineIdentities)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribePatchBaselinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePatchBaselinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineIdentities = output.baselineIdentities
            self.nextToken = output.nextToken
        } else {
            self.baselineIdentities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchBaselinesOutputResponse: Equatable {
    /// <p>An array of PatchBaselineIdentity elements.</p>
    public let baselineIdentities: [PatchBaselineIdentity]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        baselineIdentities: [PatchBaselineIdentity]? = nil,
        nextToken: String? = nil
    )
    {
        self.baselineIdentities = baselineIdentities
        self.nextToken = nextToken
    }
}

struct DescribePatchBaselinesOutputResponseBody: Equatable {
    public let baselineIdentities: [PatchBaselineIdentity]?
    public let nextToken: String?
}

extension DescribePatchBaselinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineIdentities = "BaselineIdentities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdentitiesContainer = try containerValues.decodeIfPresent([PatchBaselineIdentity?].self, forKey: .baselineIdentities)
        var baselineIdentitiesDecoded0:[PatchBaselineIdentity]? = nil
        if let baselineIdentitiesContainer = baselineIdentitiesContainer {
            baselineIdentitiesDecoded0 = [PatchBaselineIdentity]()
            for structure0 in baselineIdentitiesContainer {
                if let structure0 = structure0 {
                    baselineIdentitiesDecoded0?.append(structure0)
                }
            }
        }
        baselineIdentities = baselineIdentitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchGroupStateInputBodyMiddleware: Middleware {
    public let id: String = "DescribePatchGroupStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupStateOutputError>
}

extension DescribePatchGroupStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchGroupStateInput(patchGroup: \(String(describing: patchGroup)))"}
}

extension DescribePatchGroupStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct DescribePatchGroupStateInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePatchGroupStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePatchGroupStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupStateInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupStateInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupStateOutputError>
}

public struct DescribePatchGroupStateInput: Equatable {
    /// <p>The name of the patch group whose patch snapshot should be retrieved.</p>
    public let patchGroup: String?

    public init (
        patchGroup: String? = nil
    )
    {
        self.patchGroup = patchGroup
    }
}

struct DescribePatchGroupStateInputBody: Equatable {
    public let patchGroup: String?
}

extension DescribePatchGroupStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension DescribePatchGroupStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupStateOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchGroupStateOutputResponse(instances: \(String(describing: instances)), instancesWithCriticalNonCompliantPatches: \(String(describing: instancesWithCriticalNonCompliantPatches)), instancesWithFailedPatches: \(String(describing: instancesWithFailedPatches)), instancesWithInstalledOtherPatches: \(String(describing: instancesWithInstalledOtherPatches)), instancesWithInstalledPatches: \(String(describing: instancesWithInstalledPatches)), instancesWithInstalledPendingRebootPatches: \(String(describing: instancesWithInstalledPendingRebootPatches)), instancesWithInstalledRejectedPatches: \(String(describing: instancesWithInstalledRejectedPatches)), instancesWithMissingPatches: \(String(describing: instancesWithMissingPatches)), instancesWithNotApplicablePatches: \(String(describing: instancesWithNotApplicablePatches)), instancesWithOtherNonCompliantPatches: \(String(describing: instancesWithOtherNonCompliantPatches)), instancesWithSecurityNonCompliantPatches: \(String(describing: instancesWithSecurityNonCompliantPatches)), instancesWithUnreportedNotApplicablePatches: \(String(describing: instancesWithUnreportedNotApplicablePatches)))"}
}

extension DescribePatchGroupStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePatchGroupStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instances = output.instances
            self.instancesWithCriticalNonCompliantPatches = output.instancesWithCriticalNonCompliantPatches
            self.instancesWithFailedPatches = output.instancesWithFailedPatches
            self.instancesWithInstalledOtherPatches = output.instancesWithInstalledOtherPatches
            self.instancesWithInstalledPatches = output.instancesWithInstalledPatches
            self.instancesWithInstalledPendingRebootPatches = output.instancesWithInstalledPendingRebootPatches
            self.instancesWithInstalledRejectedPatches = output.instancesWithInstalledRejectedPatches
            self.instancesWithMissingPatches = output.instancesWithMissingPatches
            self.instancesWithNotApplicablePatches = output.instancesWithNotApplicablePatches
            self.instancesWithOtherNonCompliantPatches = output.instancesWithOtherNonCompliantPatches
            self.instancesWithSecurityNonCompliantPatches = output.instancesWithSecurityNonCompliantPatches
            self.instancesWithUnreportedNotApplicablePatches = output.instancesWithUnreportedNotApplicablePatches
        } else {
            self.instances = 0
            self.instancesWithCriticalNonCompliantPatches = 0
            self.instancesWithFailedPatches = 0
            self.instancesWithInstalledOtherPatches = 0
            self.instancesWithInstalledPatches = 0
            self.instancesWithInstalledPendingRebootPatches = 0
            self.instancesWithInstalledRejectedPatches = 0
            self.instancesWithMissingPatches = 0
            self.instancesWithNotApplicablePatches = 0
            self.instancesWithOtherNonCompliantPatches = 0
            self.instancesWithSecurityNonCompliantPatches = 0
            self.instancesWithUnreportedNotApplicablePatches = 0
        }
    }
}

public struct DescribePatchGroupStateOutputResponse: Equatable {
    /// <p>The number of instances in the patch group.</p>
    public let instances: Int
    /// <p>The number of instances where patches that are specified as "Critical" for compliance
    ///    reporting in the patch baseline are not installed. These patches might be missing, have failed
    ///    installation, were rejected, or were installed but awaiting a required instance reboot. The
    ///    status of these instances is <code>NON_COMPLIANT</code>.</p>
    public let instancesWithCriticalNonCompliantPatches: Int
    /// <p>The number of instances with patches from the patch baseline that failed to install.</p>
    public let instancesWithFailedPatches: Int
    /// <p>The number of instances with patches installed that aren't defined in the patch
    ///    baseline.</p>
    public let instancesWithInstalledOtherPatches: Int
    /// <p>The number of instances with installed patches.</p>
    public let instancesWithInstalledPatches: Int
    /// <p>The number of instances with patches installed by Patch Manager that have not been rebooted
    ///    after the patch installation. The status of these instances is NON_COMPLIANT.</p>
    public let instancesWithInstalledPendingRebootPatches: Int
    /// <p>The number of instances with patches installed that are specified in a RejectedPatches list.
    ///    Patches with a status of <i>INSTALLED_REJECTED</i> were typically installed before
    ///    they were added to a RejectedPatches list.</p>
    ///          <note>
    ///             <p>If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of
    ///     InstancesWithInstalledRejectedPatches will always be 0 (zero).</p>
    ///          </note>
    public let instancesWithInstalledRejectedPatches: Int
    /// <p>The number of instances with missing patches from the patch baseline.</p>
    public let instancesWithMissingPatches: Int
    /// <p>The number of instances with patches that aren't applicable.</p>
    public let instancesWithNotApplicablePatches: Int
    /// <p>The number of instances with patches installed that are specified as other than "Critical"
    ///    or "Security" but are not compliant with the patch baseline. The status of these instances is
    ///    NON_COMPLIANT.</p>
    public let instancesWithOtherNonCompliantPatches: Int
    /// <p>The number of instances where patches that are specified as "Security" in a patch advisory
    ///    are not installed. These patches might be missing, have failed installation, were rejected, or
    ///    were installed but awaiting a required instance reboot. The status of these instances is
    ///     <code>NON_COMPLIANT</code>.</p>
    public let instancesWithSecurityNonCompliantPatches: Int
    /// <p>The number of instances with <code>NotApplicable</code> patches beyond the supported limit,
    ///    which are not reported by name to Systems Manager Inventory.</p>
    public let instancesWithUnreportedNotApplicablePatches: Int

    public init (
        instances: Int = 0,
        instancesWithCriticalNonCompliantPatches: Int = 0,
        instancesWithFailedPatches: Int = 0,
        instancesWithInstalledOtherPatches: Int = 0,
        instancesWithInstalledPatches: Int = 0,
        instancesWithInstalledPendingRebootPatches: Int = 0,
        instancesWithInstalledRejectedPatches: Int = 0,
        instancesWithMissingPatches: Int = 0,
        instancesWithNotApplicablePatches: Int = 0,
        instancesWithOtherNonCompliantPatches: Int = 0,
        instancesWithSecurityNonCompliantPatches: Int = 0,
        instancesWithUnreportedNotApplicablePatches: Int = 0
    )
    {
        self.instances = instances
        self.instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatches
        self.instancesWithFailedPatches = instancesWithFailedPatches
        self.instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatches
        self.instancesWithInstalledPatches = instancesWithInstalledPatches
        self.instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatches
        self.instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatches
        self.instancesWithMissingPatches = instancesWithMissingPatches
        self.instancesWithNotApplicablePatches = instancesWithNotApplicablePatches
        self.instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatches
        self.instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatches
        self.instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatches
    }
}

struct DescribePatchGroupStateOutputResponseBody: Equatable {
    public let instances: Int
    public let instancesWithInstalledPatches: Int
    public let instancesWithInstalledOtherPatches: Int
    public let instancesWithInstalledPendingRebootPatches: Int
    public let instancesWithInstalledRejectedPatches: Int
    public let instancesWithMissingPatches: Int
    public let instancesWithFailedPatches: Int
    public let instancesWithNotApplicablePatches: Int
    public let instancesWithUnreportedNotApplicablePatches: Int
    public let instancesWithCriticalNonCompliantPatches: Int
    public let instancesWithSecurityNonCompliantPatches: Int
    public let instancesWithOtherNonCompliantPatches: Int
}

extension DescribePatchGroupStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instances = "Instances"
        case instancesWithCriticalNonCompliantPatches = "InstancesWithCriticalNonCompliantPatches"
        case instancesWithFailedPatches = "InstancesWithFailedPatches"
        case instancesWithInstalledOtherPatches = "InstancesWithInstalledOtherPatches"
        case instancesWithInstalledPatches = "InstancesWithInstalledPatches"
        case instancesWithInstalledPendingRebootPatches = "InstancesWithInstalledPendingRebootPatches"
        case instancesWithInstalledRejectedPatches = "InstancesWithInstalledRejectedPatches"
        case instancesWithMissingPatches = "InstancesWithMissingPatches"
        case instancesWithNotApplicablePatches = "InstancesWithNotApplicablePatches"
        case instancesWithOtherNonCompliantPatches = "InstancesWithOtherNonCompliantPatches"
        case instancesWithSecurityNonCompliantPatches = "InstancesWithSecurityNonCompliantPatches"
        case instancesWithUnreportedNotApplicablePatches = "InstancesWithUnreportedNotApplicablePatches"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesDecoded = try containerValues.decode(Int.self, forKey: .instances)
        instances = instancesDecoded
        let instancesWithInstalledPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithInstalledPatches)
        instancesWithInstalledPatches = instancesWithInstalledPatchesDecoded
        let instancesWithInstalledOtherPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithInstalledOtherPatches)
        instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatchesDecoded
        let instancesWithInstalledPendingRebootPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithInstalledPendingRebootPatches)
        instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatchesDecoded
        let instancesWithInstalledRejectedPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithInstalledRejectedPatches)
        instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatchesDecoded
        let instancesWithMissingPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithMissingPatches)
        instancesWithMissingPatches = instancesWithMissingPatchesDecoded
        let instancesWithFailedPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithFailedPatches)
        instancesWithFailedPatches = instancesWithFailedPatchesDecoded
        let instancesWithNotApplicablePatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithNotApplicablePatches)
        instancesWithNotApplicablePatches = instancesWithNotApplicablePatchesDecoded
        let instancesWithUnreportedNotApplicablePatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithUnreportedNotApplicablePatches)
        instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatchesDecoded
        let instancesWithCriticalNonCompliantPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithCriticalNonCompliantPatches)
        instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatchesDecoded
        let instancesWithSecurityNonCompliantPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithSecurityNonCompliantPatches)
        instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatchesDecoded
        let instancesWithOtherNonCompliantPatchesDecoded = try containerValues.decode(Int.self, forKey: .instancesWithOtherNonCompliantPatches)
        instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatchesDecoded
    }
}

public struct DescribePatchGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePatchGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupsOutputError>
}

extension DescribePatchGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchGroupsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribePatchGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for patchorchestratorfilterlist0 in filters {
                try filtersContainer.encode(patchorchestratorfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribePatchGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePatchGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePatchGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchGroupsInput>
    public typealias MOutput = OperationOutput<DescribePatchGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchGroupsOutputError>
}

public struct DescribePatchGroupsInput: Equatable {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    ///          <p>For <code>DescribePatchGroups</code>,valid filter keys include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>NAME_PREFIX</code>: The name of the patch group. Wildcards (*) are accepted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATING_SYSTEM</code>: The supported operating system type to return results for.
    ///      For valid operating system values, see <a>GetDefaultPatchBaselineRequest$OperatingSystem</a> in <a>CreatePatchBaseline</a>.</p>
    ///                <p>Examples:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>--filters Key=NAME_PREFIX,Values=MyPatchGroup*</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>--filters Key=OPERATING_SYSTEM,Values=AMAZON_LINUX_2</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let filters: [PatchOrchestratorFilter]?
    /// <p>The maximum number of patch groups to return (per page).</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        filters: [PatchOrchestratorFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsInputBody: Equatable {
    public let maxResults: Int
    public let filters: [PatchOrchestratorFilter]?
    public let nextToken: String?
}

extension DescribePatchGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([PatchOrchestratorFilter?].self, forKey: .filters)
        var filtersDecoded0:[PatchOrchestratorFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PatchOrchestratorFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchGroupsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchGroupsOutputResponse(mappings: \(String(describing: mappings)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribePatchGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePatchGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mappings = output.mappings
            self.nextToken = output.nextToken
        } else {
            self.mappings = nil
            self.nextToken = nil
        }
    }
}

public struct DescribePatchGroupsOutputResponse: Equatable {
    /// <p>Each entry in the array contains:</p>
    ///          <p>PatchGroup: string (between 1 and 256 characters, Regex:
    ///    ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)</p>
    ///          <p>PatchBaselineIdentity: A PatchBaselineIdentity element. </p>
    public let mappings: [PatchGroupPatchBaselineMapping]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        mappings: [PatchGroupPatchBaselineMapping]? = nil,
        nextToken: String? = nil
    )
    {
        self.mappings = mappings
        self.nextToken = nextToken
    }
}

struct DescribePatchGroupsOutputResponseBody: Equatable {
    public let mappings: [PatchGroupPatchBaselineMapping]?
    public let nextToken: String?
}

extension DescribePatchGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mappings = "Mappings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappingsContainer = try containerValues.decodeIfPresent([PatchGroupPatchBaselineMapping?].self, forKey: .mappings)
        var mappingsDecoded0:[PatchGroupPatchBaselineMapping]? = nil
        if let mappingsContainer = mappingsContainer {
            mappingsDecoded0 = [PatchGroupPatchBaselineMapping]()
            for structure0 in mappingsContainer {
                if let structure0 = structure0 {
                    mappingsDecoded0?.append(structure0)
                }
            }
        }
        mappings = mappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribePatchPropertiesInputBodyMiddleware: Middleware {
    public let id: String = "DescribePatchPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchPropertiesOutputError>
}

extension DescribePatchPropertiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchPropertiesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), operatingSystem: \(String(describing: operatingSystem)), patchSet: \(String(describing: patchSet)), property: \(String(describing: property)))"}
}

extension DescribePatchPropertiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchSet = patchSet {
            try encodeContainer.encode(patchSet.rawValue, forKey: .patchSet)
        }
        if let property = property {
            try encodeContainer.encode(property.rawValue, forKey: .property)
        }
    }
}

public struct DescribePatchPropertiesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePatchPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePatchPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePatchPropertiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePatchPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePatchPropertiesInput>
    public typealias MOutput = OperationOutput<DescribePatchPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePatchPropertiesOutputError>
}

public struct DescribePatchPropertiesInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The operating system type for which to list patches.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>Indicates whether to list patches for the Windows operating system or for Microsoft
    ///    applications. Not applicable for the Linux or macOS operating systems.</p>
    public let patchSet: PatchSet?
    /// <p>The patch property for which you want to view patch details. </p>
    public let property: PatchProperty?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        patchSet: PatchSet? = nil,
        property: PatchProperty? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystem = operatingSystem
        self.patchSet = patchSet
        self.property = property
    }
}

struct DescribePatchPropertiesInputBody: Equatable {
    public let operatingSystem: OperatingSystem?
    public let property: PatchProperty?
    public let patchSet: PatchSet?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribePatchPropertiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case operatingSystem = "OperatingSystem"
        case patchSet = "PatchSet"
        case property = "Property"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(PatchProperty.self, forKey: .property)
        property = propertyDecoded
        let patchSetDecoded = try containerValues.decodeIfPresent(PatchSet.self, forKey: .patchSet)
        patchSet = patchSetDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePatchPropertiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePatchPropertiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePatchPropertiesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePatchPropertiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePatchPropertiesOutputResponse(nextToken: \(String(describing: nextToken)), properties: \(String(describing: properties)))"}
}

extension DescribePatchPropertiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePatchPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.properties = output.properties
        } else {
            self.nextToken = nil
            self.properties = nil
        }
    }
}

public struct DescribePatchPropertiesOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. (You use this token in the next call.)</p>
    public let nextToken: String?
    /// <p>A list of the properties for patches matching the filter request parameters.</p>
    public let properties: [[String:String]]?

    public init (
        nextToken: String? = nil,
        properties: [[String:String]]? = nil
    )
    {
        self.nextToken = nextToken
        self.properties = properties
    }
}

struct DescribePatchPropertiesOutputResponseBody: Equatable {
    public let properties: [[String:String]]?
    public let nextToken: String?
}

extension DescribePatchPropertiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case properties = "Properties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .properties)
        var propertiesDecoded0:[[String:String]]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [[String:String]]()
            for map0 in propertiesContainer {
                var propertiesContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    propertiesContainerDecoded0 = [String: String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            propertiesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let propertiesContainerDecoded0 = propertiesContainerDecoded0 {
                    propertiesDecoded0?.append(propertiesContainerDecoded0)
                }
            }
        }
        properties = propertiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeSessionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

extension DescribeSessionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSessionsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), state: \(String(describing: state)))"}
}

extension DescribeSessionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for sessionfilterlist0 in filters {
                try filtersContainer.encode(sessionfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct DescribeSessionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSessionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSessionsInput>
    public typealias MOutput = OperationOutput<DescribeSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSessionsOutputError>
}

public struct DescribeSessionsInput: Equatable {
    /// <p>One or more filters to limit the type of sessions returned by the request.</p>
    public let filters: [SessionFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The session status to retrieve a list of sessions for. For example, "Active".</p>
    public let state: SessionState?

    public init (
        filters: [SessionFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        state: SessionState? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct DescribeSessionsInputBody: Equatable {
    public let state: SessionState?
    public let maxResults: Int
    public let nextToken: String?
    public let filters: [SessionFilter]?
}

extension DescribeSessionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(SessionState.self, forKey: .state)
        state = stateDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SessionFilter?].self, forKey: .filters)
        var filtersDecoded0:[SessionFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SessionFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeSessionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSessionsOutputResponse(nextToken: \(String(describing: nextToken)), sessions: \(String(describing: sessions)))"}
}

extension DescribeSessionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>A list of sessions meeting the request parameters.</p>
    public let sessions: [Session]?

    public init (
        nextToken: String? = nil,
        sessions: [Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Equatable {
    public let sessions: [Session]?
    public let nextToken: String?
}

extension DescribeSessionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([Session?].self, forKey: .sessions)
        var sessionsDecoded0:[Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateOpsItemRelatedItemInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateOpsItemRelatedItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateOpsItemRelatedItemOutputError>
}

extension DisassociateOpsItemRelatedItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateOpsItemRelatedItemInput(associationId: \(String(describing: associationId)), opsItemId: \(String(describing: opsItemId)))"}
}

extension DisassociateOpsItemRelatedItemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct DisassociateOpsItemRelatedItemInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateOpsItemRelatedItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateOpsItemRelatedItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateOpsItemRelatedItemInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateOpsItemRelatedItemInput>
    public typealias MOutput = OperationOutput<DisassociateOpsItemRelatedItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateOpsItemRelatedItemOutputError>
}

public struct DisassociateOpsItemRelatedItemInput: Equatable {
    /// <p>The ID of the association for which you want to delete an association between the OpsItem
    ///    and a related resource.</p>
    public let associationId: String?
    /// <p>The ID of the OpsItem for which you want to delete an association between the OpsItem and a
    ///    related resource.</p>
    public let opsItemId: String?

    public init (
        associationId: String? = nil,
        opsItemId: String? = nil
    )
    {
        self.associationId = associationId
        self.opsItemId = opsItemId
    }
}

struct DisassociateOpsItemRelatedItemInputBody: Equatable {
    public let opsItemId: String?
    public let associationId: String?
}

extension DisassociateOpsItemRelatedItemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
    }
}

extension DisassociateOpsItemRelatedItemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateOpsItemRelatedItemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemRelatedItemAssociationNotFoundException" : self = .opsItemRelatedItemAssociationNotFoundException(try OpsItemRelatedItemAssociationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateOpsItemRelatedItemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case opsItemRelatedItemAssociationNotFoundException(OpsItemRelatedItemAssociationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateOpsItemRelatedItemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateOpsItemRelatedItemOutputResponse()"}
}

extension DisassociateOpsItemRelatedItemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateOpsItemRelatedItemOutputResponse: Equatable {

    public init() {}
}

struct DisassociateOpsItemRelatedItemOutputResponseBody: Equatable {
}

extension DisassociateOpsItemRelatedItemOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DocumentAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentAlreadyExists(message: \(String(describing: message)))"}
}

extension DocumentAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified document already exists.</p>
public struct DocumentAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentAlreadyExistsBody: Equatable {
    public let message: String?
}

extension DocumentAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocumentDefaultVersionDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultVersion = "DefaultVersion"
        case defaultVersionName = "DefaultVersionName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let defaultVersionName = defaultVersionName {
            try encodeContainer.encode(defaultVersionName, forKey: .defaultVersionName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let defaultVersionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersionName)
        defaultVersionName = defaultVersionNameDecoded
    }
}

extension DocumentDefaultVersionDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentDefaultVersionDescription(defaultVersion: \(String(describing: defaultVersion)), defaultVersionName: \(String(describing: defaultVersionName)), name: \(String(describing: name)))"}
}

/// <p>A default version of a document.</p>
public struct DocumentDefaultVersionDescription: Equatable {
    /// <p>The default version of the document.</p>
    public let defaultVersion: String?
    /// <p>The default version of the artifact associated with the document.</p>
    public let defaultVersionName: String?
    /// <p>The name of the document.</p>
    public let name: String?

    public init (
        defaultVersion: String? = nil,
        defaultVersionName: String? = nil,
        name: String? = nil
    )
    {
        self.defaultVersion = defaultVersion
        self.defaultVersionName = defaultVersionName
        self.name = name
    }
}

extension DocumentDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvedVersion = "ApprovedVersion"
        case attachmentsInformation = "AttachmentsInformation"
        case author = "Author"
        case createdDate = "CreatedDate"
        case defaultVersion = "DefaultVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case hash = "Hash"
        case hashType = "HashType"
        case latestVersion = "LatestVersion"
        case name = "Name"
        case owner = "Owner"
        case parameters = "Parameters"
        case pendingReviewVersion = "PendingReviewVersion"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewInformation = "ReviewInformation"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case sha1 = "Sha1"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvedVersion = approvedVersion {
            try encodeContainer.encode(approvedVersion, forKey: .approvedVersion)
        }
        if let attachmentsInformation = attachmentsInformation {
            var attachmentsInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentsInformation)
            for attachmentinformationlist0 in attachmentsInformation {
                try attachmentsInformationContainer.encode(attachmentinformationlist0)
            }
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let hash = hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let hashType = hashType {
            try encodeContainer.encode(hashType.rawValue, forKey: .hashType)
        }
        if let latestVersion = latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for documentparameterlist0 in parameters {
                try parametersContainer.encode(documentparameterlist0)
            }
        }
        if let pendingReviewVersion = pendingReviewVersion {
            try encodeContainer.encode(pendingReviewVersion, forKey: .pendingReviewVersion)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewInformation = reviewInformation {
            var reviewInformationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewInformation)
            for reviewinformationlist0 in reviewInformation {
                try reviewInformationContainer.encode(reviewinformationlist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sha1 = sha1 {
            try encodeContainer.encode(sha1, forKey: .sha1)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sha1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .sha1)
        sha1 = sha1Decoded
        let hashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hash)
        hash = hashDecoded
        let hashTypeDecoded = try containerValues.decodeIfPresent(DocumentHashType.self, forKey: .hashType)
        hashType = hashTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([DocumentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[DocumentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [DocumentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let platformTypesContainer = try containerValues.decodeIfPresent([PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentTypeDecoded = try containerValues.decodeIfPresent(DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let attachmentsInformationContainer = try containerValues.decodeIfPresent([AttachmentInformation?].self, forKey: .attachmentsInformation)
        var attachmentsInformationDecoded0:[AttachmentInformation]? = nil
        if let attachmentsInformationContainer = attachmentsInformationContainer {
            attachmentsInformationDecoded0 = [AttachmentInformation]()
            for structure0 in attachmentsInformationContainer {
                if let structure0 = structure0 {
                    attachmentsInformationDecoded0?.append(structure0)
                }
            }
        }
        attachmentsInformation = attachmentsInformationDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let reviewInformationContainer = try containerValues.decodeIfPresent([ReviewInformation?].self, forKey: .reviewInformation)
        var reviewInformationDecoded0:[ReviewInformation]? = nil
        if let reviewInformationContainer = reviewInformationContainer {
            reviewInformationDecoded0 = [ReviewInformation]()
            for structure0 in reviewInformationContainer {
                if let structure0 = structure0 {
                    reviewInformationDecoded0?.append(structure0)
                }
            }
        }
        reviewInformation = reviewInformationDecoded0
        let approvedVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvedVersion)
        approvedVersion = approvedVersionDecoded
        let pendingReviewVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pendingReviewVersion)
        pendingReviewVersion = pendingReviewVersionDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension DocumentDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentDescription(approvedVersion: \(String(describing: approvedVersion)), attachmentsInformation: \(String(describing: attachmentsInformation)), author: \(String(describing: author)), createdDate: \(String(describing: createdDate)), defaultVersion: \(String(describing: defaultVersion)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentType: \(String(describing: documentType)), documentVersion: \(String(describing: documentVersion)), hash: \(String(describing: hash)), hashType: \(String(describing: hashType)), latestVersion: \(String(describing: latestVersion)), name: \(String(describing: name)), owner: \(String(describing: owner)), parameters: \(String(describing: parameters)), pendingReviewVersion: \(String(describing: pendingReviewVersion)), platformTypes: \(String(describing: platformTypes)), requires: \(String(describing: requires)), reviewInformation: \(String(describing: reviewInformation)), reviewStatus: \(String(describing: reviewStatus)), schemaVersion: \(String(describing: schemaVersion)), sha1: \(String(describing: sha1)), status: \(String(describing: status)), statusInformation: \(String(describing: statusInformation)), tags: \(String(describing: tags)), targetType: \(String(describing: targetType)), versionName: \(String(describing: versionName)))"}
}

/// <p>Describes a Systems Manager document. </p>
public struct DocumentDescription: Equatable {
    /// <p>The version of the document currently approved for use in the organization.</p>
    public let approvedVersion: String?
    /// <p>Details about the document attachments, including names, locations, sizes, and so on.</p>
    public let attachmentsInformation: [AttachmentInformation]?
    /// <p>The user in your organization who created the document.</p>
    public let author: String?
    /// <p>The date when the document was created.</p>
    public let createdDate: Date?
    /// <p>The default version.</p>
    public let defaultVersion: String?
    /// <p>A description of the document. </p>
    public let description: String?
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    ///    document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    public let displayName: String?
    /// <p>The document format, either JSON or YAML.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The type of document.</p>
    public let documentType: DocumentType?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
    ///          <note>
    ///             <p>Sha1 hashes have been deprecated.</p>
    ///          </note>
    public let hash: String?
    /// <p>The hash type of the document. Valid values include <code>Sha256</code> or
    ///    <code>Sha1</code>.</p>
    ///          <note>
    ///             <p>Sha1 hashes have been deprecated.</p>
    ///          </note>
    public let hashType: DocumentHashType?
    /// <p>The latest version of the document.</p>
    public let latestVersion: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>The AWS user account that created the document.</p>
    public let owner: String?
    /// <p>A description of the parameters for a document.</p>
    public let parameters: [DocumentParameter]?
    /// <p>The version of the document that is currently under review.</p>
    public let pendingReviewVersion: String?
    /// <p>The list of OS platforms compatible with this Systems Manager document. </p>
    public let platformTypes: [PlatformType]?
    /// <p>A list of SSM documents required by a document. For example, an
    ///     <code>ApplicationConfiguration</code> document requires an
    ///     <code>ApplicationConfigurationSchema</code> document.</p>
    public let requires: [DocumentRequires]?
    /// <p>Details about the review of a document.</p>
    public let reviewInformation: [ReviewInformation]?
    /// <p>The current status of the review.</p>
    public let reviewStatus: ReviewStatus?
    /// <p>The schema version.</p>
    public let schemaVersion: String?
    /// <p>The SHA1 hash of the document, which you can use for verification.</p>
    public let sha1: String?
    /// <p>The status of the Systems Manager document.</p>
    public let status: DocumentStatus?
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    ///     <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    ///    "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    public let statusInformation: String?
    /// <p>The tags, or metadata, that have been applied to the document.</p>
    public let tags: [Tag]?
    /// <p>The target type which defines the kinds of resources the document can run on. For example,
    ///    /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    ///     reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    public let targetType: String?
    /// <p>The version of the artifact associated with the document.</p>
    public let versionName: String?

    public init (
        approvedVersion: String? = nil,
        attachmentsInformation: [AttachmentInformation]? = nil,
        author: String? = nil,
        createdDate: Date? = nil,
        defaultVersion: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentType: DocumentType? = nil,
        documentVersion: String? = nil,
        hash: String? = nil,
        hashType: DocumentHashType? = nil,
        latestVersion: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        parameters: [DocumentParameter]? = nil,
        pendingReviewVersion: String? = nil,
        platformTypes: [PlatformType]? = nil,
        requires: [DocumentRequires]? = nil,
        reviewInformation: [ReviewInformation]? = nil,
        reviewStatus: ReviewStatus? = nil,
        schemaVersion: String? = nil,
        sha1: String? = nil,
        status: DocumentStatus? = nil,
        statusInformation: String? = nil,
        tags: [Tag]? = nil,
        targetType: String? = nil,
        versionName: String? = nil
    )
    {
        self.approvedVersion = approvedVersion
        self.attachmentsInformation = attachmentsInformation
        self.author = author
        self.createdDate = createdDate
        self.defaultVersion = defaultVersion
        self.description = description
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.hash = hash
        self.hashType = hashType
        self.latestVersion = latestVersion
        self.name = name
        self.owner = owner
        self.parameters = parameters
        self.pendingReviewVersion = pendingReviewVersion
        self.platformTypes = platformTypes
        self.requires = requires
        self.reviewInformation = reviewInformation
        self.reviewStatus = reviewStatus
        self.schemaVersion = schemaVersion
        self.sha1 = sha1
        self.status = status
        self.statusInformation = statusInformation
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

extension DocumentFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(DocumentFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DocumentFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This data type is deprecated. Instead, use <a>DocumentKeyValuesFilter</a>.</p>
public struct DocumentFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: DocumentFilterKey?
    /// <p>The value of the filter.</p>
    public let value: String?

    public init (
        key: DocumentFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum DocumentFilterKey {
    case documenttype
    case name
    case owner
    case platformtypes
    case sdkUnknown(String)
}

extension DocumentFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentFilterKey] {
        return [
            .documenttype,
            .name,
            .owner,
            .platformtypes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .documenttype: return "DocumentType"
        case .name: return "Name"
        case .owner: return "Owner"
        case .platformtypes: return "PlatformTypes"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentFilterKey(rawValue: rawValue) ?? DocumentFilterKey.sdkUnknown(rawValue)
    }
}

public enum DocumentFormat {
    case json
    case text
    case yaml
    case sdkUnknown(String)
}

extension DocumentFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentFormat] {
        return [
            .json,
            .text,
            .yaml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .text: return "TEXT"
        case .yaml: return "YAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentFormat(rawValue: rawValue) ?? DocumentFormat.sdkUnknown(rawValue)
    }
}

public enum DocumentHashType {
    case sha1
    case sha256
    case sdkUnknown(String)
}

extension DocumentHashType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentHashType] {
        return [
            .sha1,
            .sha256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sha1: return "Sha1"
        case .sha256: return "Sha256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentHashType(rawValue: rawValue) ?? DocumentHashType.sdkUnknown(rawValue)
    }
}

extension DocumentIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case author = "Author"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case owner = "Owner"
        case platformTypes = "PlatformTypes"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case schemaVersion = "SchemaVersion"
        case tags = "Tags"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentType = documentType {
            try encodeContainer.encode(documentType.rawValue, forKey: .documentType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platformTypes = platformTypes {
            var platformTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformTypes)
            for platformtypelist0 in platformTypes {
                try platformTypesContainer.encode(platformtypelist0.rawValue)
            }
        }
        if let requires = requires {
            var requiresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requires)
            for documentrequireslist0 in requires {
                try requiresContainer.encode(documentrequireslist0)
            }
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let platformTypesContainer = try containerValues.decodeIfPresent([PlatformType?].self, forKey: .platformTypes)
        var platformTypesDecoded0:[PlatformType]? = nil
        if let platformTypesContainer = platformTypesContainer {
            platformTypesDecoded0 = [PlatformType]()
            for string0 in platformTypesContainer {
                if let string0 = string0 {
                    platformTypesDecoded0?.append(string0)
                }
            }
        }
        platformTypes = platformTypesDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let requiresContainer = try containerValues.decodeIfPresent([DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
    }
}

extension DocumentIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentIdentifier(author: \(String(describing: author)), createdDate: \(String(describing: createdDate)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentType: \(String(describing: documentType)), documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)), owner: \(String(describing: owner)), platformTypes: \(String(describing: platformTypes)), requires: \(String(describing: requires)), reviewStatus: \(String(describing: reviewStatus)), schemaVersion: \(String(describing: schemaVersion)), tags: \(String(describing: tags)), targetType: \(String(describing: targetType)), versionName: \(String(describing: versionName)))"}
}

/// <p>Describes the name of a Systems Manager document.</p>
public struct DocumentIdentifier: Equatable {
    /// <p>The user in your organization who created the document.</p>
    public let author: String?
    /// <p>The date the Systems Manager document was created.</p>
    public let createdDate: Date?
    /// <p>An optional field where you can specify a friendly name for the Systems Manager document. This value
    ///    can differ for each version of the document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    public let displayName: String?
    /// <p>The document format, either JSON or YAML.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The document type.</p>
    public let documentType: DocumentType?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>The AWS user account that created the document.</p>
    public let owner: String?
    /// <p>The operating system platform. </p>
    public let platformTypes: [PlatformType]?
    /// <p>A list of SSM documents required by a document. For example, an
    ///     <code>ApplicationConfiguration</code> document requires an
    ///     <code>ApplicationConfigurationSchema</code> document.</p>
    public let requires: [DocumentRequires]?
    /// <p>The current status of a document review.</p>
    public let reviewStatus: ReviewStatus?
    /// <p>The schema version.</p>
    public let schemaVersion: String?
    /// <p>The tags, or metadata, that have been applied to the document.</p>
    public let tags: [Tag]?
    /// <p>The target type which defines the kinds of resources the document can run on. For example,
    ///    /AWS::EC2::Instance. For a list of valid resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
    ///     reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
    public let targetType: String?
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    ///    example, "Release 12, Update 6". This value is unique across all versions of a document, and
    ///    cannot be changed.</p>
    public let versionName: String?

    public init (
        author: String? = nil,
        createdDate: Date? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentType: DocumentType? = nil,
        documentVersion: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        platformTypes: [PlatformType]? = nil,
        requires: [DocumentRequires]? = nil,
        reviewStatus: ReviewStatus? = nil,
        schemaVersion: String? = nil,
        tags: [Tag]? = nil,
        targetType: String? = nil,
        versionName: String? = nil
    )
    {
        self.author = author
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.name = name
        self.owner = owner
        self.platformTypes = platformTypes
        self.requires = requires
        self.reviewStatus = reviewStatus
        self.schemaVersion = schemaVersion
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

extension DocumentKeyValuesFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for documentkeyvaluesfiltervalues0 in values {
                try valuesContainer.encode(documentkeyvaluesfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DocumentKeyValuesFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentKeyValuesFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>One or more filters. Use a filter to return a more specific list of documents.</p>
///          <p>For keys, you can specify one or more tags that have been applied to a document. </p>
///          <p>You can also use AWS-provided keys, some of which have specific allowed values. These keys
///    and their associated values are as follows:</p>
///          <dl>
///             <dt>DocumentType</dt>
///             <dd>
///                <ul>
///                   <li>
///                      <p>ApplicationConfiguration</p>
///                   </li>
///                   <li>
///                      <p>ApplicationConfigurationSchema</p>
///                   </li>
///                   <li>
///                      <p>Automation</p>
///                   </li>
///                   <li>
///                      <p>ChangeCalendar</p>
///                   </li>
///                   <li>
///                      <p>Command</p>
///                   </li>
///                   <li>
///                      <p>DeploymentStrategy</p>
///                   </li>
///                   <li>
///                      <p>Package</p>
///                   </li>
///                   <li>
///                      <p>Policy</p>
///                   </li>
///                   <li>
///                      <p>Session</p>
///                   </li>
///                </ul>
///             </dd>
///             <dt>Owner</dt>
///             <dd>
///                <p>Note that only one <code>Owner</code> can be specified in a request. For example:
///        <code>Key=Owner,Values=Self</code>.</p>
///                <ul>
///                   <li>
///                      <p>Amazon</p>
///                   </li>
///                   <li>
///                      <p>Private</p>
///                   </li>
///                   <li>
///                      <p>Public</p>
///                   </li>
///                   <li>
///                      <p>Self</p>
///                   </li>
///                   <li>
///                      <p>ThirdParty</p>
///                   </li>
///                </ul>
///             </dd>
///             <dt>PlatformTypes</dt>
///             <dd>
///                <ul>
///                   <li>
///                      <p>Linux</p>
///                   </li>
///                   <li>
///                      <p>Windows</p>
///                   </li>
///                </ul>
///             </dd>
///          </dl>
///          <p>
///             <code>Name</code> is another AWS-provided key. If you use <code>Name</code> as a key, you
///    can use a name prefix to return a list of documents. For example, in the AWS CLI, to return a
///    list of all documents that begin with <code>Te</code>, run the following command:</p>
///          <p>
///             <code>aws ssm list-documents --filters Key=Name,Values=Te</code>
///          </p>
///          <p>You can also use the <code>TargetType</code> AWS-provided key. For a list of valid resource
///    type values that can be used with this key, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS resource and property types
///     reference</a> in the <i>AWS CloudFormation User Guide</i>.</p>
///          <p>If you specify more than two keys, only documents that are identified by all the tags are
///    returned in the results. If you specify more than two values for a key, documents that are
///    identified by any of the values are returned in the results.</p>
///          <p>To specify a custom key and value pair, use the format
///     <code>Key=tag:tagName,Values=valueName</code>.</p>
///          <p>For example, if you created a key called region and are using the AWS CLI to call the
///     <code>list-documents</code> command: </p>
///          <p>
///             <code>aws ssm list-documents --filters Key=tag:region,Values=east,west
///     Key=Owner,Values=Self</code>
///          </p>
public struct DocumentKeyValuesFilter: Equatable {
    /// <p>The name of the filter key.</p>
    public let key: String?
    /// <p>The value for the filter key.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension DocumentLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentLimitExceeded(message: \(String(describing: message)))"}
}

extension DocumentLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can have at most 500 active Systems Manager documents.</p>
public struct DocumentLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentLimitExceededBody: Equatable {
    public let message: String?
}

extension DocumentLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DocumentMetadataEnum {
    case documentreviews
    case sdkUnknown(String)
}

extension DocumentMetadataEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentMetadataEnum] {
        return [
            .documentreviews,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .documentreviews: return "DocumentReviews"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentMetadataEnum(rawValue: rawValue) ?? DocumentMetadataEnum.sdkUnknown(rawValue)
    }
}

extension DocumentMetadataResponseInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reviewerResponse = "ReviewerResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewerResponse = reviewerResponse {
            var reviewerResponseContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewerResponse)
            for documentreviewerresponselist0 in reviewerResponse {
                try reviewerResponseContainer.encode(documentreviewerresponselist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewerResponseContainer = try containerValues.decodeIfPresent([DocumentReviewerResponseSource?].self, forKey: .reviewerResponse)
        var reviewerResponseDecoded0:[DocumentReviewerResponseSource]? = nil
        if let reviewerResponseContainer = reviewerResponseContainer {
            reviewerResponseDecoded0 = [DocumentReviewerResponseSource]()
            for structure0 in reviewerResponseContainer {
                if let structure0 = structure0 {
                    reviewerResponseDecoded0?.append(structure0)
                }
            }
        }
        reviewerResponse = reviewerResponseDecoded0
    }
}

extension DocumentMetadataResponseInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentMetadataResponseInfo(reviewerResponse: \(String(describing: reviewerResponse)))"}
}

/// <p>Details about the response to a document review request.</p>
public struct DocumentMetadataResponseInfo: Equatable {
    /// <p>Details about a reviewer's response to a document review request.</p>
    public let reviewerResponse: [DocumentReviewerResponseSource]?

    public init (
        reviewerResponse: [DocumentReviewerResponseSource]? = nil
    )
    {
        self.reviewerResponse = reviewerResponse
    }
}

extension DocumentParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DocumentParameterType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension DocumentParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentParameter(defaultValue: \(String(describing: defaultValue)), description: \(String(describing: description)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Parameters specified in a System Manager document that run on the server when the command is
///    run. </p>
public struct DocumentParameter: Equatable {
    /// <p>If specified, the default values for the parameters. Parameters without a default value are
    ///    required. Parameters with a default value are optional.</p>
    public let defaultValue: String?
    /// <p>A description of what the parameter does, how to use it, the default value, and whether or
    ///    not the parameter is optional.</p>
    public let description: String?
    /// <p>The name of the parameter.</p>
    public let name: String?
    /// <p>The type of parameter. The type can be either String or StringList.</p>
    public let type: DocumentParameterType?

    public init (
        defaultValue: String? = nil,
        description: String? = nil,
        name: String? = nil,
        type: DocumentParameterType? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.type = type
    }
}

public enum DocumentParameterType {
    case string
    case stringlist
    case sdkUnknown(String)
}

extension DocumentParameterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentParameterType] {
        return [
            .string,
            .stringlist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .string: return "String"
        case .stringlist: return "StringList"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentParameterType(rawValue: rawValue) ?? DocumentParameterType.sdkUnknown(rawValue)
    }
}

extension DocumentPermissionLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentPermissionLimit(message: \(String(describing: message)))"}
}

extension DocumentPermissionLimit: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentPermissionLimitBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document cannot be shared with more AWS user accounts. You can share a document with a
///    maximum of 20 accounts. You can publicly share up to five documents. If you need to increase this
///    limit, contact AWS Support.</p>
public struct DocumentPermissionLimit: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentPermissionLimitBody: Equatable {
    public let message: String?
}

extension DocumentPermissionLimitBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum DocumentPermissionType {
    case share
    case sdkUnknown(String)
}

extension DocumentPermissionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentPermissionType] {
        return [
            .share,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .share: return "Share"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentPermissionType(rawValue: rawValue) ?? DocumentPermissionType.sdkUnknown(rawValue)
    }
}

extension DocumentRequires: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DocumentRequires: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentRequires(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>An SSM document required by the current document.</p>
public struct DocumentRequires: Equatable {
    /// <p>The name of the required SSM document. The name can be an Amazon Resource Name (ARN).</p>
    public let name: String?
    /// <p>The document version required by the current document.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

public enum DocumentReviewAction {
    case approve
    case reject
    case sendforreview
    case updatereview
    case sdkUnknown(String)
}

extension DocumentReviewAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentReviewAction] {
        return [
            .approve,
            .reject,
            .sendforreview,
            .updatereview,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approve: return "Approve"
        case .reject: return "Reject"
        case .sendforreview: return "SendForReview"
        case .updatereview: return "UpdateReview"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentReviewAction(rawValue: rawValue) ?? DocumentReviewAction.sdkUnknown(rawValue)
    }
}

extension DocumentReviewCommentSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DocumentReviewCommentType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension DocumentReviewCommentSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentReviewCommentSource(content: \(String(describing: content)), type: \(String(describing: type)))"}
}

/// <p>Information about comments added to a document review request.</p>
public struct DocumentReviewCommentSource: Equatable {
    /// <p>The content of a comment entered by a user who requests a review of a new document version,
    ///    or who reviews the new version.</p>
    public let content: String?
    /// <p>The type of information added to a review request. Currently, only the value
    ///     <code>Comment</code> is supported.</p>
    public let type: DocumentReviewCommentType?

    public init (
        content: String? = nil,
        type: DocumentReviewCommentType? = nil
    )
    {
        self.content = content
        self.type = type
    }
}

public enum DocumentReviewCommentType {
    case comment
    case sdkUnknown(String)
}

extension DocumentReviewCommentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentReviewCommentType] {
        return [
            .comment,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .comment: return "Comment"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentReviewCommentType(rawValue: rawValue) ?? DocumentReviewCommentType.sdkUnknown(rawValue)
    }
}

extension DocumentReviewerResponseSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case createTime = "CreateTime"
        case reviewStatus = "ReviewStatus"
        case reviewer = "Reviewer"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
        let commentContainer = try containerValues.decodeIfPresent([DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
        let reviewerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension DocumentReviewerResponseSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentReviewerResponseSource(comment: \(String(describing: comment)), createTime: \(String(describing: createTime)), reviewStatus: \(String(describing: reviewStatus)), reviewer: \(String(describing: reviewer)), updatedTime: \(String(describing: updatedTime)))"}
}

/// <p>Information about a reviewer's response to a document review request.</p>
public struct DocumentReviewerResponseSource: Equatable {
    /// <p>The comment entered by a reviewer as part of their document review response.</p>
    public let comment: [DocumentReviewCommentSource]?
    /// <p>The date and time that a reviewer entered a response to a document review request.</p>
    public let createTime: Date?
    /// <p>The current review status of a new custom SSM document created by a member of your
    ///    organization, or of the latest version of an existing SSM document.</p>
    ///          <p>Only one version of a document can be in the APPROVED state at a time. When a new version is
    ///    approved, the status of the previous version changes to REJECTED.</p>
    ///          <p>Only one version of a document can be in review, or PENDING, at a time.</p>
    public let reviewStatus: ReviewStatus?
    /// <p>The user in your organization assigned to review a document request.</p>
    public let reviewer: String?
    /// <p>The date and time that a reviewer last updated a response to a document review
    ///    request.</p>
    public let updatedTime: Date?

    public init (
        comment: [DocumentReviewCommentSource]? = nil,
        createTime: Date? = nil,
        reviewStatus: ReviewStatus? = nil,
        reviewer: String? = nil,
        updatedTime: Date? = nil
    )
    {
        self.comment = comment
        self.createTime = createTime
        self.reviewStatus = reviewStatus
        self.reviewer = reviewer
        self.updatedTime = updatedTime
    }
}

extension DocumentReviews: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case comment = "Comment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let comment = comment {
            var commentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comment)
            for documentreviewcommentlist0 in comment {
                try commentContainer.encode(documentreviewcommentlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DocumentReviewAction.self, forKey: .action)
        action = actionDecoded
        let commentContainer = try containerValues.decodeIfPresent([DocumentReviewCommentSource?].self, forKey: .comment)
        var commentDecoded0:[DocumentReviewCommentSource]? = nil
        if let commentContainer = commentContainer {
            commentDecoded0 = [DocumentReviewCommentSource]()
            for structure0 in commentContainer {
                if let structure0 = structure0 {
                    commentDecoded0?.append(structure0)
                }
            }
        }
        comment = commentDecoded0
    }
}

extension DocumentReviews: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentReviews(action: \(String(describing: action)), comment: \(String(describing: comment)))"}
}

/// <p>Information about a document approval review.</p>
public struct DocumentReviews: Equatable {
    /// <p>The action to take on a document approval review request.</p>
    public let action: DocumentReviewAction?
    /// <p>A comment entered by a user in your organization about the document review request.</p>
    public let comment: [DocumentReviewCommentSource]?

    public init (
        action: DocumentReviewAction? = nil,
        comment: [DocumentReviewCommentSource]? = nil
    )
    {
        self.action = action
        self.comment = comment
    }
}

/// <p>The status of a document.</p>
public enum DocumentStatus {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension DocumentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .creating: return "Creating"
        case .deleting: return "Deleting"
        case .failed: return "Failed"
        case .updating: return "Updating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentStatus(rawValue: rawValue) ?? DocumentStatus.sdkUnknown(rawValue)
    }
}

public enum DocumentType {
    case applicationconfiguration
    case applicationconfigurationschema
    case automation
    case changecalendar
    case changetemplate
    case command
    case deploymentstrategy
    case package
    case policy
    case problemanalysis
    case problemanalysistemplate
    case session
    case sdkUnknown(String)
}

extension DocumentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DocumentType] {
        return [
            .applicationconfiguration,
            .applicationconfigurationschema,
            .automation,
            .changecalendar,
            .changetemplate,
            .command,
            .deploymentstrategy,
            .package,
            .policy,
            .problemanalysis,
            .problemanalysistemplate,
            .session,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applicationconfiguration: return "ApplicationConfiguration"
        case .applicationconfigurationschema: return "ApplicationConfigurationSchema"
        case .automation: return "Automation"
        case .changecalendar: return "ChangeCalendar"
        case .changetemplate: return "Automation.ChangeTemplate"
        case .command: return "Command"
        case .deploymentstrategy: return "DeploymentStrategy"
        case .package: return "Package"
        case .policy: return "Policy"
        case .problemanalysis: return "ProblemAnalysis"
        case .problemanalysistemplate: return "ProblemAnalysisTemplate"
        case .session: return "Session"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DocumentType(rawValue: rawValue) ?? DocumentType.sdkUnknown(rawValue)
    }
}

extension DocumentVersionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case isDefaultVersion = "IsDefaultVersion"
        case name = "Name"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reviewStatus = reviewStatus {
            try encodeContainer.encode(reviewStatus.rawValue, forKey: .reviewStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusInformation = statusInformation {
            try encodeContainer.encode(statusInformation, forKey: .statusInformation)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let isDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .isDefaultVersion)
        isDefaultVersion = isDefaultVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let reviewStatusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

extension DocumentVersionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentVersionInfo(createdDate: \(String(describing: createdDate)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentVersion: \(String(describing: documentVersion)), isDefaultVersion: \(String(describing: isDefaultVersion)), name: \(String(describing: name)), reviewStatus: \(String(describing: reviewStatus)), status: \(String(describing: status)), statusInformation: \(String(describing: statusInformation)), versionName: \(String(describing: versionName)))"}
}

/// <p>Version information about the document.</p>
public struct DocumentVersionInfo: Equatable {
    /// <p>The date the document was created.</p>
    public let createdDate: Date?
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    ///    document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    public let displayName: String?
    /// <p>The document format, either JSON or YAML.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>An identifier for the default version of the document.</p>
    public let isDefaultVersion: Bool
    /// <p>The document name.</p>
    public let name: String?
    /// <p>The current status of the approval review for the latest version of the document.</p>
    public let reviewStatus: ReviewStatus?
    /// <p>The status of the Systems Manager document, such as <code>Creating</code>, <code>Active</code>,
    ///     <code>Failed</code>, and <code>Deleting</code>.</p>
    public let status: DocumentStatus?
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    ///     <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    ///    "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    public let statusInformation: String?
    /// <p>The version of the artifact associated with the document. For example, "Release 12, Update
    ///    6". This value is unique across all versions of a document, and cannot be changed.</p>
    public let versionName: String?

    public init (
        createdDate: Date? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentVersion: String? = nil,
        isDefaultVersion: Bool = false,
        name: String? = nil,
        reviewStatus: ReviewStatus? = nil,
        status: DocumentStatus? = nil,
        statusInformation: String? = nil,
        versionName: String? = nil
    )
    {
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.isDefaultVersion = isDefaultVersion
        self.name = name
        self.reviewStatus = reviewStatus
        self.status = status
        self.statusInformation = statusInformation
        self.versionName = versionName
    }
}

extension DocumentVersionLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DocumentVersionLimitExceeded(message: \(String(describing: message)))"}
}

extension DocumentVersionLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DocumentVersionLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document has too many versions. Delete one or more document versions and try
///    again.</p>
public struct DocumentVersionLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentVersionLimitExceededBody: Equatable {
    public let message: String?
}

extension DocumentVersionLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DoesNotExistException(message: \(String(describing: message)))"}
}

extension DoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error returned when the ID specified for a resource, such as a maintenance window or Patch
///    baseline, doesn't exist.</p>
///          <p>For information about resource quotas in Systems Manager, see <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm">Systems Manager service quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct DoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension DoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateDocumentContent(message: \(String(describing: message)))"}
}

extension DuplicateDocumentContent: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateDocumentContentBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content of the association document matches another document. Change the content of the
///    document and try again.</p>
public struct DuplicateDocumentContent: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentContentBody: Equatable {
    public let message: String?
}

extension DuplicateDocumentContentBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateDocumentVersionName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateDocumentVersionName(message: \(String(describing: message)))"}
}

extension DuplicateDocumentVersionName: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DuplicateDocumentVersionNameBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The version name has already been used in this document. Specify a different version name,
///    and then try again.</p>
public struct DuplicateDocumentVersionName: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateDocumentVersionNameBody: Equatable {
    public let message: String?
}

extension DuplicateDocumentVersionNameBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateInstanceId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateInstanceId()"}
}

extension DuplicateInstanceId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot specify an instance ID in more than one association.</p>
public struct DuplicateInstanceId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension EffectivePatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patch = "Patch"
        case patchStatus = "PatchStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patch = patch {
            try encodeContainer.encode(patch, forKey: .patch)
        }
        if let patchStatus = patchStatus {
            try encodeContainer.encode(patchStatus, forKey: .patchStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchDecoded = try containerValues.decodeIfPresent(Patch.self, forKey: .patch)
        patch = patchDecoded
        let patchStatusDecoded = try containerValues.decodeIfPresent(PatchStatus.self, forKey: .patchStatus)
        patchStatus = patchStatusDecoded
    }
}

extension EffectivePatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EffectivePatch(patch: \(String(describing: patch)), patchStatus: \(String(describing: patchStatus)))"}
}

/// <p>The EffectivePatch structure defines metadata about a patch along with the approval state of
///    the patch in a particular patch baseline. The approval state includes information about whether
///    the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly
///    rejected and the date the patch was or will be approved.</p>
public struct EffectivePatch: Equatable {
    /// <p>Provides metadata for a patch, including information such as the KB ID, severity,
    ///    classification and a URL for where more information can be obtained about the patch.</p>
    public let patch: Patch?
    /// <p>The status of the patch in a patch baseline. This includes information about whether the
    ///    patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly
    ///    rejected and the date the patch was or will be approved.</p>
    public let patchStatus: PatchStatus?

    public init (
        patch: Patch? = nil,
        patchStatus: PatchStatus? = nil
    )
    {
        self.patch = patch
        self.patchStatus = patchStatus
    }
}

public enum ExecutionMode {
    case auto
    case interactive
    case sdkUnknown(String)
}

extension ExecutionMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutionMode] {
        return [
            .auto,
            .interactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "Auto"
        case .interactive: return "Interactive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutionMode(rawValue: rawValue) ?? ExecutionMode.sdkUnknown(rawValue)
    }
}

extension FailedCreateAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entry = "Entry"
        case fault = "Fault"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let fault = fault {
            try encodeContainer.encode(fault.rawValue, forKey: .fault)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(CreateAssociationBatchRequestEntry.self, forKey: .entry)
        entry = entryDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let faultDecoded = try containerValues.decodeIfPresent(Fault.self, forKey: .fault)
        fault = faultDecoded
    }
}

extension FailedCreateAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedCreateAssociation(entry: \(String(describing: entry)), fault: \(String(describing: fault)), message: \(String(describing: message)))"}
}

/// <p>Describes a failed association.</p>
public struct FailedCreateAssociation: Equatable {
    /// <p>The association.</p>
    public let entry: CreateAssociationBatchRequestEntry?
    /// <p>The source of the failure.</p>
    public let fault: Fault?
    /// <p>A description of the failure.</p>
    public let message: String?

    public init (
        entry: CreateAssociationBatchRequestEntry? = nil,
        fault: Fault? = nil,
        message: String? = nil
    )
    {
        self.entry = entry
        self.fault = fault
        self.message = message
    }
}

extension FailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case failureStage = "FailureStage"
        case failureType = "FailureType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            var detailsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .details)
            for (dictKey0, automationparametermap0) in details {
                try detailsContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let failureStage = failureStage {
            try encodeContainer.encode(failureStage, forKey: .failureStage)
        }
        if let failureType = failureType {
            try encodeContainer.encode(failureType, forKey: .failureType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureStageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureStage)
        failureStage = failureStageDecoded
        let failureTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureType)
        failureType = failureTypeDecoded
        let detailsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .details)
        var detailsDecoded0: [String:[String]]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in detailsContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                detailsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        details = detailsDecoded0
    }
}

extension FailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailureDetails(details: \(String(describing: details)), failureStage: \(String(describing: failureStage)), failureType: \(String(describing: failureType)))"}
}

/// <p>Information about an Automation failure.</p>
public struct FailureDetails: Equatable {
    /// <p>Detailed information about the Automation step failure.</p>
    public let details: [String:[String]]?
    /// <p>The stage of the Automation execution when the failure occurred. The stages include the
    ///    following: InputValidation, PreVerification, Invocation, PostVerification.</p>
    public let failureStage: String?
    /// <p>The type of Automation failure. Failure types include the following: Action, Permission,
    ///    Throttling, Verification, Internal.</p>
    public let failureType: String?

    public init (
        details: [String:[String]]? = nil,
        failureStage: String? = nil,
        failureType: String? = nil
    )
    {
        self.details = details
        self.failureStage = failureStage
        self.failureType = failureType
    }
}

public enum Fault {
    case client
    case server
    case unknown
    case sdkUnknown(String)
}

extension Fault : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Fault] {
        return [
            .client,
            .server,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .client: return "Client"
        case .server: return "Server"
        case .unknown: return "Unknown"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Fault(rawValue: rawValue) ?? Fault.sdkUnknown(rawValue)
    }
}

extension FeatureNotAvailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FeatureNotAvailableException(message: \(String(describing: message)))"}
}

extension FeatureNotAvailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FeatureNotAvailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You attempted to register a LAMBDA or STEP_FUNCTIONS task in a region where the
///    corresponding service is not available. </p>
public struct FeatureNotAvailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FeatureNotAvailableExceptionBody: Equatable {
    public let message: String?
}

extension FeatureNotAvailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetAutomationExecutionInputBodyMiddleware: Middleware {
    public let id: String = "GetAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutomationExecutionOutputError>
}

extension GetAutomationExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAutomationExecutionInput(automationExecutionId: \(String(describing: automationExecutionId)))"}
}

extension GetAutomationExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
    }
}

public struct GetAutomationExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "GetAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAutomationExecutionInput>
    public typealias MOutput = OperationOutput<GetAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAutomationExecutionOutputError>
}

public struct GetAutomationExecutionInput: Equatable {
    /// <p>The unique identifier for an existing automation execution to examine. The execution ID is
    ///    returned by StartAutomationExecution when the execution of an Automation document is
    ///    initiated.</p>
    public let automationExecutionId: String?

    public init (
        automationExecutionId: String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct GetAutomationExecutionInputBody: Equatable {
    public let automationExecutionId: String?
}

extension GetAutomationExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

extension GetAutomationExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAutomationExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFoundException" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAutomationExecutionOutputError: Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAutomationExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAutomationExecutionOutputResponse(automationExecution: \(String(describing: automationExecution)))"}
}

extension GetAutomationExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automationExecution = output.automationExecution
        } else {
            self.automationExecution = nil
        }
    }
}

public struct GetAutomationExecutionOutputResponse: Equatable {
    /// <p>Detailed information about the current state of an automation execution.</p>
    public let automationExecution: AutomationExecution?

    public init (
        automationExecution: AutomationExecution? = nil
    )
    {
        self.automationExecution = automationExecution
    }
}

struct GetAutomationExecutionOutputResponseBody: Equatable {
    public let automationExecution: AutomationExecution?
}

extension GetAutomationExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecution = "AutomationExecution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionDecoded = try containerValues.decodeIfPresent(AutomationExecution.self, forKey: .automationExecution)
        automationExecution = automationExecutionDecoded
    }
}

public struct GetCalendarStateInputBodyMiddleware: Middleware {
    public let id: String = "GetCalendarStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCalendarStateOutputError>
}

extension GetCalendarStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCalendarStateInput(atTime: \(String(describing: atTime)), calendarNames: \(String(describing: calendarNames)))"}
}

extension GetCalendarStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atTime = atTime {
            try encodeContainer.encode(atTime, forKey: .atTime)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
    }
}

public struct GetCalendarStateInputHeadersMiddleware: Middleware {
    public let id: String = "GetCalendarStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCalendarStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCalendarStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCalendarStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCalendarStateInput>
    public typealias MOutput = OperationOutput<GetCalendarStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCalendarStateOutputError>
}

public struct GetCalendarStateInput: Equatable {
    /// <p>(Optional) The specific time for which you want to get calendar state information, in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format. If you do not add
    ///     <code>AtTime</code>, the current time is assumed.</p>
    public let atTime: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager documents that represent the calendar
    ///    entries for which you want to get the state.</p>
    public let calendarNames: [String]?

    public init (
        atTime: String? = nil,
        calendarNames: [String]? = nil
    )
    {
        self.atTime = atTime
        self.calendarNames = calendarNames
    }
}

struct GetCalendarStateInputBody: Equatable {
    public let calendarNames: [String]?
    public let atTime: String?
}

extension GetCalendarStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case atTime = "AtTime"
        case calendarNames = "CalendarNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let atTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .atTime)
        atTime = atTimeDecoded
    }
}

extension GetCalendarStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCalendarStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentType" : self = .invalidDocumentType(try InvalidDocumentType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCalendarException" : self = .unsupportedCalendarException(try UnsupportedCalendarException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCalendarStateOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentType(InvalidDocumentType)
    case unsupportedCalendarException(UnsupportedCalendarException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCalendarStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCalendarStateOutputResponse(atTime: \(String(describing: atTime)), nextTransitionTime: \(String(describing: nextTransitionTime)), state: \(String(describing: state)))"}
}

extension GetCalendarStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCalendarStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.atTime = output.atTime
            self.nextTransitionTime = output.nextTransitionTime
            self.state = output.state
        } else {
            self.atTime = nil
            self.nextTransitionTime = nil
            self.state = nil
        }
    }
}

public struct GetCalendarStateOutputResponse: Equatable {
    /// <p>The time, as an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> string,
    ///    that you specified in your command. If you did not specify a time, <code>GetCalendarState</code>
    ///    uses the current time.</p>
    public let atTime: String?
    /// <p>The time, as an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> string,
    ///    that the calendar state will change. If the current calendar state is <code>OPEN</code>,
    ///     <code>NextTransitionTime</code> indicates when the calendar state changes to
    ///    <code>CLOSED</code>, and vice-versa.</p>
    public let nextTransitionTime: String?
    /// <p>The state of the calendar. An <code>OPEN</code> calendar indicates that actions are allowed
    ///    to proceed, and a <code>CLOSED</code> calendar indicates that actions are not allowed to
    ///    proceed.</p>
    public let state: CalendarState?

    public init (
        atTime: String? = nil,
        nextTransitionTime: String? = nil,
        state: CalendarState? = nil
    )
    {
        self.atTime = atTime
        self.nextTransitionTime = nextTransitionTime
        self.state = state
    }
}

struct GetCalendarStateOutputResponseBody: Equatable {
    public let state: CalendarState?
    public let atTime: String?
    public let nextTransitionTime: String?
}

extension GetCalendarStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case atTime = "AtTime"
        case nextTransitionTime = "NextTransitionTime"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(CalendarState.self, forKey: .state)
        state = stateDecoded
        let atTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .atTime)
        atTime = atTimeDecoded
        let nextTransitionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextTransitionTime)
        nextTransitionTime = nextTransitionTimeDecoded
    }
}

public struct GetCommandInvocationInputBodyMiddleware: Middleware {
    public let id: String = "GetCommandInvocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommandInvocationOutputError>
}

extension GetCommandInvocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommandInvocationInput(commandId: \(String(describing: commandId)), instanceId: \(String(describing: instanceId)), pluginName: \(String(describing: pluginName)))"}
}

extension GetCommandInvocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let pluginName = pluginName {
            try encodeContainer.encode(pluginName, forKey: .pluginName)
        }
    }
}

public struct GetCommandInvocationInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommandInvocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommandInvocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommandInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommandInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommandInvocationInput>
    public typealias MOutput = OperationOutput<GetCommandInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommandInvocationOutputError>
}

public struct GetCommandInvocationInput: Equatable {
    /// <p>(Required) The parent command ID of the invocation plugin.</p>
    public let commandId: String?
    /// <p>(Required) The ID of the managed instance targeted by the command. A managed instance can be
    ///    an Amazon Elastic Compute Cloud (Amazon EC2) instance or an instance in your hybrid environment that is configured for
    ///    AWS Systems Manager.</p>
    public let instanceId: String?
    /// <p>The name of the plugin for which you want detailed results. If the document contains only
    ///    one plugin, you can omit the name and details for that plugin. If the document contains more than
    ///    one plugin, you must specify the name of the plugin for which you want to view details.</p>
    ///          <p>Plugin names are also referred to as <i>step names</i> in Systems Manager documents. For
    ///    example, <code>aws:RunShellScript</code> is a plugin.</p>
    ///          <p>To find the <code>PluginName</code>, check the document content and find the name of the
    ///    plugin. Alternatively, use <a>ListCommandInvocations</a> with the
    ///     <code>CommandId</code> and <code>Details</code> parameters. The <code>PluginName</code> is the
    ///     <code>Name</code> attribute of the <code>CommandPlugin</code> object in the
    ///     <code>CommandPlugins</code> list.</p>
    public let pluginName: String?

    public init (
        commandId: String? = nil,
        instanceId: String? = nil,
        pluginName: String? = nil
    )
    {
        self.commandId = commandId
        self.instanceId = instanceId
        self.pluginName = pluginName
    }
}

struct GetCommandInvocationInputBody: Equatable {
    public let commandId: String?
    public let instanceId: String?
    public let pluginName: String?
}

extension GetCommandInvocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
    }
}

extension GetCommandInvocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommandInvocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPluginName" : self = .invalidPluginName(try InvalidPluginName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvocationDoesNotExist" : self = .invocationDoesNotExist(try InvocationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommandInvocationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidInstanceId(InvalidInstanceId)
    case invalidPluginName(InvalidPluginName)
    case invocationDoesNotExist(InvocationDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommandInvocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommandInvocationOutputResponse(cloudWatchOutputConfig: \(String(describing: cloudWatchOutputConfig)), commandId: \(String(describing: commandId)), comment: \(String(describing: comment)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), executionElapsedTime: \(String(describing: executionElapsedTime)), executionEndDateTime: \(String(describing: executionEndDateTime)), executionStartDateTime: \(String(describing: executionStartDateTime)), instanceId: \(String(describing: instanceId)), pluginName: \(String(describing: pluginName)), responseCode: \(String(describing: responseCode)), standardErrorContent: \(String(describing: standardErrorContent)), standardErrorUrl: \(String(describing: standardErrorUrl)), standardOutputContent: \(String(describing: standardOutputContent)), standardOutputUrl: \(String(describing: standardOutputUrl)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)))"}
}

extension GetCommandInvocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommandInvocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudWatchOutputConfig = output.cloudWatchOutputConfig
            self.commandId = output.commandId
            self.comment = output.comment
            self.documentName = output.documentName
            self.documentVersion = output.documentVersion
            self.executionElapsedTime = output.executionElapsedTime
            self.executionEndDateTime = output.executionEndDateTime
            self.executionStartDateTime = output.executionStartDateTime
            self.instanceId = output.instanceId
            self.pluginName = output.pluginName
            self.responseCode = output.responseCode
            self.standardErrorContent = output.standardErrorContent
            self.standardErrorUrl = output.standardErrorUrl
            self.standardOutputContent = output.standardOutputContent
            self.standardOutputUrl = output.standardOutputUrl
            self.status = output.status
            self.statusDetails = output.statusDetails
        } else {
            self.cloudWatchOutputConfig = nil
            self.commandId = nil
            self.comment = nil
            self.documentName = nil
            self.documentVersion = nil
            self.executionElapsedTime = nil
            self.executionEndDateTime = nil
            self.executionStartDateTime = nil
            self.instanceId = nil
            self.pluginName = nil
            self.responseCode = 0
            self.standardErrorContent = nil
            self.standardErrorUrl = nil
            self.standardOutputContent = nil
            self.standardOutputUrl = nil
            self.status = nil
            self.statusDetails = nil
        }
    }
}

public struct GetCommandInvocationOutputResponse: Equatable {
    /// <p>CloudWatch Logs information where Systems Manager sent the command output.</p>
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
    /// <p>The parent command ID of the invocation plugin.</p>
    public let commandId: String?
    /// <p>The comment text for the command.</p>
    public let comment: String?
    /// <p>The name of the document that was run. For example, <code>AWS-RunShellScript</code>.</p>
    public let documentName: String?
    /// <p>The SSM document version used in the request.</p>
    public let documentVersion: String?
    /// <p>Duration since <code>ExecutionStartDateTime</code>.</p>
    public let executionElapsedTime: String?
    /// <p>The date and time the plugin finished running. Date and time are written in ISO 8601 format.
    ///    For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses
    ///    the <code>InvokedAfter</code> filter.</p>
    ///          <p>
    ///             <code>aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z</code>
    ///          </p>
    ///          <p>If the plugin has not started to run, the string is empty.</p>
    public let executionEndDateTime: String?
    /// <p>The date and time the plugin started running. Date and time are written in ISO 8601 format.
    ///    For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses
    ///    the <code>InvokedBefore</code> filter.</p>
    ///          <p>
    ///             <code>aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z</code>
    ///          </p>
    ///          <p>If the plugin has not started to run, the string is empty.</p>
    public let executionStartDateTime: String?
    /// <p>The ID of the managed instance targeted by the command. A managed instance can be an EC2
    ///    instance or an instance in your hybrid environment that is configured for Systems Manager.</p>
    public let instanceId: String?
    /// <p>The name of the plugin, or <i>step name</i>, for which details are reported.
    ///    For example, <code>aws:RunShellScript</code> is a plugin.</p>
    public let pluginName: String?
    /// <p>The error level response code for the plugin script. If the response code is
    ///    <code>-1</code>, then the command has not started running on the instance, or it was not received
    ///    by the instance.</p>
    public let responseCode: Int
    /// <p>The first 8,000 characters written by the plugin to <code>stderr</code>. If the command has
    ///    not finished running, then this string is empty.</p>
    public let standardErrorContent: String?
    /// <p>The URL for the complete text written by the plugin to <code>stderr</code>. If the command
    ///    has not finished running, then this string is empty.</p>
    public let standardErrorUrl: String?
    /// <p>The first 24,000 characters written by the plugin to <code>stdout</code>. If the command has
    ///    not finished running, if <code>ExecutionStatus</code> is neither Succeeded nor Failed, then this
    ///    string is empty.</p>
    public let standardOutputContent: String?
    /// <p>The URL for the complete text written by the plugin to <code>stdout</code> in Amazon Simple Storage Service
    ///    (Amazon S3). If an S3 bucket was not specified, then this string is empty.</p>
    public let standardOutputUrl: String?
    /// <p>The status of this invocation plugin. This status can be different than
    ///     <code>StatusDetails</code>.</p>
    public let status: CommandInvocationStatus?
    /// <p>A detailed status of the command execution for an invocation. <code>StatusDetails</code>
    ///    includes more information than <code>Status</code> because it includes states resulting from
    ///    error and concurrency control parameters. <code>StatusDetails</code> can show different results
    ///    than <code>Status</code>. For more information about these statuses, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding
    ///     command statuses</a> in the <i>AWS Systems Manager User Guide</i>.
    ///     <code>StatusDetails</code> can be one of the following values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Pending: The command has not been sent to the instance.</p>
    ///             </li>
    ///             <li>
    ///                <p>In Progress: The command has been sent to the instance but has not reached a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Delayed: The system attempted to send the command to the target, but the target was not
    ///      available. The instance might not be available because of network issues, because the instance
    ///      was stopped, or for similar reasons. The system will try to send the command again.</p>
    ///             </li>
    ///             <li>
    ///                <p>Success: The command or plugin ran successfully. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Delivery Timed Out: The command was not delivered to the instance before the delivery
    ///      timeout expired. Delivery timeouts do not count against the parent command's
    ///       <code>MaxErrors</code> limit, but they do contribute to whether the parent command status is
    ///      Success or Incomplete. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Execution Timed Out: The command started to run on the instance, but the execution was not
    ///      complete before the timeout expired. Execution timeouts count against the
    ///       <code>MaxErrors</code> limit of the parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Failed: The command wasn't run successfully on the instance. For a plugin, this indicates
    ///      that the result code was not zero. For a command invocation, this indicates that the result
    ///      code for one or more plugins was not zero. Invocation failures count against the
    ///       <code>MaxErrors</code> limit of the parent command. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Canceled: The command was terminated before it was completed. This is a terminal
    ///      state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Undeliverable: The command can't be delivered to the instance. The instance might not
    ///      exist or might not be responding. Undeliverable invocations don't count against the parent
    ///      command's <code>MaxErrors</code> limit and don't contribute to whether the parent command
    ///      status is Success or Incomplete. This is a terminal state.</p>
    ///             </li>
    ///             <li>
    ///                <p>Terminated: The parent command exceeded its <code>MaxErrors</code> limit and subsequent
    ///      command invocations were canceled by the system. This is a terminal state.</p>
    ///             </li>
    ///          </ul>
    public let statusDetails: String?

    public init (
        cloudWatchOutputConfig: CloudWatchOutputConfig? = nil,
        commandId: String? = nil,
        comment: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        executionElapsedTime: String? = nil,
        executionEndDateTime: String? = nil,
        executionStartDateTime: String? = nil,
        instanceId: String? = nil,
        pluginName: String? = nil,
        responseCode: Int = 0,
        standardErrorContent: String? = nil,
        standardErrorUrl: String? = nil,
        standardOutputContent: String? = nil,
        standardOutputUrl: String? = nil,
        status: CommandInvocationStatus? = nil,
        statusDetails: String? = nil
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.comment = comment
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executionElapsedTime = executionElapsedTime
        self.executionEndDateTime = executionEndDateTime
        self.executionStartDateTime = executionStartDateTime
        self.instanceId = instanceId
        self.pluginName = pluginName
        self.responseCode = responseCode
        self.standardErrorContent = standardErrorContent
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputContent = standardOutputContent
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
    }
}

struct GetCommandInvocationOutputResponseBody: Equatable {
    public let commandId: String?
    public let instanceId: String?
    public let comment: String?
    public let documentName: String?
    public let documentVersion: String?
    public let pluginName: String?
    public let responseCode: Int
    public let executionStartDateTime: String?
    public let executionElapsedTime: String?
    public let executionEndDateTime: String?
    public let status: CommandInvocationStatus?
    public let statusDetails: String?
    public let standardOutputContent: String?
    public let standardOutputUrl: String?
    public let standardErrorContent: String?
    public let standardErrorUrl: String?
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
}

extension GetCommandInvocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case commandId = "CommandId"
        case comment = "Comment"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case executionElapsedTime = "ExecutionElapsedTime"
        case executionEndDateTime = "ExecutionEndDateTime"
        case executionStartDateTime = "ExecutionStartDateTime"
        case instanceId = "InstanceId"
        case pluginName = "PluginName"
        case responseCode = "ResponseCode"
        case standardErrorContent = "StandardErrorContent"
        case standardErrorUrl = "StandardErrorUrl"
        case standardOutputContent = "StandardOutputContent"
        case standardOutputUrl = "StandardOutputUrl"
        case status = "Status"
        case statusDetails = "StatusDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
        let responseCodeDecoded = try containerValues.decode(Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let executionStartDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionStartDateTime)
        executionStartDateTime = executionStartDateTimeDecoded
        let executionElapsedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionElapsedTime)
        executionElapsedTime = executionElapsedTimeDecoded
        let executionEndDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionEndDateTime)
        executionEndDateTime = executionEndDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CommandInvocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let standardOutputContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardOutputContent)
        standardOutputContent = standardOutputContentDecoded
        let standardOutputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardOutputUrl)
        standardOutputUrl = standardOutputUrlDecoded
        let standardErrorContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardErrorContent)
        standardErrorContent = standardErrorContentDecoded
        let standardErrorUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .standardErrorUrl)
        standardErrorUrl = standardErrorUrlDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

public struct GetConnectionStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetConnectionStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionStatusOutputError>
}

extension GetConnectionStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionStatusInput(target: \(String(describing: target)))"}
}

extension GetConnectionStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct GetConnectionStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectionStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectionStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionStatusInput>
    public typealias MOutput = OperationOutput<GetConnectionStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionStatusOutputError>
}

public struct GetConnectionStatusInput: Equatable {
    /// <p>The ID of the instance.</p>
    public let target: String?

    public init (
        target: String? = nil
    )
    {
        self.target = target
    }
}

struct GetConnectionStatusInputBody: Equatable {
    public let target: String?
}

extension GetConnectionStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GetConnectionStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionStatusOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionStatusOutputResponse(status: \(String(describing: status)), target: \(String(describing: target)))"}
}

extension GetConnectionStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectionStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
            self.target = output.target
        } else {
            self.status = nil
            self.target = nil
        }
    }
}

public struct GetConnectionStatusOutputResponse: Equatable {
    /// <p>The status of the connection to the instance. For example, 'Connected' or 'Not
    ///    Connected'.</p>
    public let status: ConnectionStatus?
    /// <p>The ID of the instance to check connection status. </p>
    public let target: String?

    public init (
        status: ConnectionStatus? = nil,
        target: String? = nil
    )
    {
        self.status = status
        self.target = target
    }
}

struct GetConnectionStatusOutputResponseBody: Equatable {
    public let target: String?
    public let status: ConnectionStatus?
}

extension GetConnectionStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct GetDefaultPatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "GetDefaultPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultPatchBaselineOutputError>
}

extension GetDefaultPatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDefaultPatchBaselineInput(operatingSystem: \(String(describing: operatingSystem)))"}
}

extension GetDefaultPatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }
}

public struct GetDefaultPatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "GetDefaultPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDefaultPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultPatchBaselineOutputError>
}

public struct GetDefaultPatchBaselineInput: Equatable {
    /// <p>Returns the default patch baseline for the specified operating system.</p>
    public let operatingSystem: OperatingSystem?

    public init (
        operatingSystem: OperatingSystem? = nil
    )
    {
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineInputBody: Equatable {
    public let operatingSystem: OperatingSystem?
}

extension GetDefaultPatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetDefaultPatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultPatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDefaultPatchBaselineOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultPatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDefaultPatchBaselineOutputResponse(baselineId: \(String(describing: baselineId)), operatingSystem: \(String(describing: operatingSystem)))"}
}

extension GetDefaultPatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
        }
    }
}

public struct GetDefaultPatchBaselineOutputResponse: Equatable {
    /// <p>The ID of the default patch baseline.</p>
    public let baselineId: String?
    /// <p>The operating system for the returned patch baseline. </p>
    public let operatingSystem: OperatingSystem?

    public init (
        baselineId: String? = nil,
        operatingSystem: OperatingSystem? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
    }
}

struct GetDefaultPatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
    public let operatingSystem: OperatingSystem?
}

extension GetDefaultPatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

public struct GetDeployablePatchSnapshotForInstanceInputBodyMiddleware: Middleware {
    public let id: String = "GetDeployablePatchSnapshotForInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

extension GetDeployablePatchSnapshotForInstanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeployablePatchSnapshotForInstanceInput(baselineOverride: \(String(describing: baselineOverride)), instanceId: \(String(describing: instanceId)), snapshotId: \(String(describing: snapshotId)))"}
}

extension GetDeployablePatchSnapshotForInstanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineOverride = baselineOverride {
            try encodeContainer.encode(baselineOverride, forKey: .baselineOverride)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeployablePatchSnapshotForInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeployablePatchSnapshotForInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeployablePatchSnapshotForInstanceInput>
    public typealias MOutput = OperationOutput<GetDeployablePatchSnapshotForInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeployablePatchSnapshotForInstanceOutputError>
}

public struct GetDeployablePatchSnapshotForInstanceInput: Equatable {
    /// <p>Defines the basic information about a patch baseline override.</p>
    public let baselineOverride: BaselineOverride?
    /// <p>The ID of the instance for which the appropriate patch snapshot should be retrieved.</p>
    public let instanceId: String?
    /// <p>The user-defined snapshot ID.</p>
    public let snapshotId: String?

    public init (
        baselineOverride: BaselineOverride? = nil,
        instanceId: String? = nil,
        snapshotId: String? = nil
    )
    {
        self.baselineOverride = baselineOverride
        self.instanceId = instanceId
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceInputBody: Equatable {
    public let instanceId: String?
    public let snapshotId: String?
    public let baselineOverride: BaselineOverride?
}

extension GetDeployablePatchSnapshotForInstanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineOverride = "BaselineOverride"
        case instanceId = "InstanceId"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let baselineOverrideDecoded = try containerValues.decodeIfPresent(BaselineOverride.self, forKey: .baselineOverride)
        baselineOverride = baselineOverrideDecoded
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeployablePatchSnapshotForInstanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedFeatureRequiredException" : self = .unsupportedFeatureRequiredException(try UnsupportedFeatureRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperatingSystem" : self = .unsupportedOperatingSystem(try UnsupportedOperatingSystem(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeployablePatchSnapshotForInstanceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unsupportedFeatureRequiredException(UnsupportedFeatureRequiredException)
    case unsupportedOperatingSystem(UnsupportedOperatingSystem)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeployablePatchSnapshotForInstanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeployablePatchSnapshotForInstanceOutputResponse(instanceId: \(String(describing: instanceId)), product: \(String(describing: product)), snapshotDownloadUrl: \(String(describing: snapshotDownloadUrl)), snapshotId: \(String(describing: snapshotId)))"}
}

extension GetDeployablePatchSnapshotForInstanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeployablePatchSnapshotForInstanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.instanceId = output.instanceId
            self.product = output.product
            self.snapshotDownloadUrl = output.snapshotDownloadUrl
            self.snapshotId = output.snapshotId
        } else {
            self.instanceId = nil
            self.product = nil
            self.snapshotDownloadUrl = nil
            self.snapshotId = nil
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceOutputResponse: Equatable {
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>Returns the specific operating system (for example Windows Server 2012 or Amazon Linux
    ///    2015.09) on the instance for the specified patch snapshot.</p>
    public let product: String?
    /// <p>A pre-signed Amazon S3 URL that can be used to download the patch snapshot.</p>
    public let snapshotDownloadUrl: String?
    /// <p>The user-defined snapshot ID.</p>
    public let snapshotId: String?

    public init (
        instanceId: String? = nil,
        product: String? = nil,
        snapshotDownloadUrl: String? = nil,
        snapshotId: String? = nil
    )
    {
        self.instanceId = instanceId
        self.product = product
        self.snapshotDownloadUrl = snapshotDownloadUrl
        self.snapshotId = snapshotId
    }
}

struct GetDeployablePatchSnapshotForInstanceOutputResponseBody: Equatable {
    public let instanceId: String?
    public let snapshotId: String?
    public let snapshotDownloadUrl: String?
    public let product: String?
}

extension GetDeployablePatchSnapshotForInstanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case product = "Product"
        case snapshotDownloadUrl = "SnapshotDownloadUrl"
        case snapshotId = "SnapshotId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let snapshotDownloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotDownloadUrl)
        snapshotDownloadUrl = snapshotDownloadUrlDecoded
        let productDecoded = try containerValues.decodeIfPresent(String.self, forKey: .product)
        product = productDecoded
    }
}

public struct GetDocumentInputBodyMiddleware: Middleware {
    public let id: String = "GetDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentInput>
    public typealias MOutput = OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentOutputError>
}

extension GetDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentInput(documentFormat: \(String(describing: documentFormat)), documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)), versionName: \(String(describing: versionName)))"}
}

extension GetDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct GetDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentInput>
    public typealias MOutput = OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentOutputError>
}

public struct GetDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDocumentInput>
    public typealias MOutput = OperationOutput<GetDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDocumentOutputError>
}

public struct GetDocumentInput: Equatable {
    /// <p>Returns the document in the specified format. The document format can be either JSON or
    ///    YAML. JSON is the default format.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The document version for which you want information.</p>
    public let documentVersion: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>An optional field specifying the version of the artifact associated with the document. For
    ///    example, "Release 12, Update 6". This value is unique across all versions of a document and can't
    ///    be changed.</p>
    public let versionName: String?

    public init (
        documentFormat: DocumentFormat? = nil,
        documentVersion: String? = nil,
        name: String? = nil,
        versionName: String? = nil
    )
    {
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

struct GetDocumentInputBody: Equatable {
    public let name: String?
    public let versionName: String?
    public let documentVersion: String?
    public let documentFormat: DocumentFormat?
}

extension GetDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
    }
}

extension GetDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDocumentOutputResponse(attachmentsContent: \(String(describing: attachmentsContent)), content: \(String(describing: content)), createdDate: \(String(describing: createdDate)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentType: \(String(describing: documentType)), documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)), requires: \(String(describing: requires)), reviewStatus: \(String(describing: reviewStatus)), status: \(String(describing: status)), statusInformation: \(String(describing: statusInformation)), versionName: \(String(describing: versionName)))"}
}

extension GetDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attachmentsContent = output.attachmentsContent
            self.content = output.content
            self.createdDate = output.createdDate
            self.displayName = output.displayName
            self.documentFormat = output.documentFormat
            self.documentType = output.documentType
            self.documentVersion = output.documentVersion
            self.name = output.name
            self.requires = output.requires
            self.reviewStatus = output.reviewStatus
            self.status = output.status
            self.statusInformation = output.statusInformation
            self.versionName = output.versionName
        } else {
            self.attachmentsContent = nil
            self.content = nil
            self.createdDate = nil
            self.displayName = nil
            self.documentFormat = nil
            self.documentType = nil
            self.documentVersion = nil
            self.name = nil
            self.requires = nil
            self.reviewStatus = nil
            self.status = nil
            self.statusInformation = nil
            self.versionName = nil
        }
    }
}

public struct GetDocumentOutputResponse: Equatable {
    /// <p>A description of the document attachments, including names, locations, sizes, and so
    ///    on.</p>
    public let attachmentsContent: [AttachmentContent]?
    /// <p>The contents of the Systems Manager document.</p>
    public let content: String?
    /// <p>The date the Systems Manager document was created.</p>
    public let createdDate: Date?
    /// <p>The friendly name of the Systems Manager document. This value can differ for each version of the
    ///    document. If you want to update this value, see <a>UpdateDocument</a>.</p>
    public let displayName: String?
    /// <p>The document format, either JSON or YAML.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The document type.</p>
    public let documentType: DocumentType?
    /// <p>The document version.</p>
    public let documentVersion: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?
    /// <p>A list of SSM documents required by a document. For example, an
    ///     <code>ApplicationConfiguration</code> document requires an
    ///     <code>ApplicationConfigurationSchema</code> document.</p>
    public let requires: [DocumentRequires]?
    /// <p>The current review status of a new custom Systems Manager document (SSM document) created by a member
    ///    of your organization, or of the latest version of an existing SSM document.</p>
    ///          <p>Only one version of an SSM document can be in the APPROVED state at a time. When a new
    ///    version is approved, the status of the previous version changes to REJECTED.</p>
    ///          <p>Only one version of an SSM document can be in review, or PENDING, at a time.</p>
    public let reviewStatus: ReviewStatus?
    /// <p>The status of the Systems Manager document, such as <code>Creating</code>, <code>Active</code>,
    ///     <code>Updating</code>, <code>Failed</code>, and <code>Deleting</code>.</p>
    public let status: DocumentStatus?
    /// <p>A message returned by AWS Systems Manager that explains the <code>Status</code> value. For example, a
    ///     <code>Failed</code> status might be explained by the <code>StatusInformation</code> message,
    ///    "The specified S3 bucket does not exist. Verify that the URL of the S3 bucket is correct."</p>
    public let statusInformation: String?
    /// <p>The version of the artifact associated with the document. For example, "Release 12, Update
    ///    6". This value is unique across all versions of a document, and cannot be changed.</p>
    public let versionName: String?

    public init (
        attachmentsContent: [AttachmentContent]? = nil,
        content: String? = nil,
        createdDate: Date? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentType: DocumentType? = nil,
        documentVersion: String? = nil,
        name: String? = nil,
        requires: [DocumentRequires]? = nil,
        reviewStatus: ReviewStatus? = nil,
        status: DocumentStatus? = nil,
        statusInformation: String? = nil,
        versionName: String? = nil
    )
    {
        self.attachmentsContent = attachmentsContent
        self.content = content
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.name = name
        self.requires = requires
        self.reviewStatus = reviewStatus
        self.status = status
        self.statusInformation = statusInformation
        self.versionName = versionName
    }
}

struct GetDocumentOutputResponseBody: Equatable {
    public let name: String?
    public let createdDate: Date?
    public let displayName: String?
    public let versionName: String?
    public let documentVersion: String?
    public let status: DocumentStatus?
    public let statusInformation: String?
    public let content: String?
    public let documentType: DocumentType?
    public let documentFormat: DocumentFormat?
    public let requires: [DocumentRequires]?
    public let attachmentsContent: [AttachmentContent]?
    public let reviewStatus: ReviewStatus?
}

extension GetDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentsContent = "AttachmentsContent"
        case content = "Content"
        case createdDate = "CreatedDate"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentType = "DocumentType"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case requires = "Requires"
        case reviewStatus = "ReviewStatus"
        case status = "Status"
        case statusInformation = "StatusInformation"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocumentStatus.self, forKey: .status)
        status = statusDecoded
        let statusInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusInformation)
        statusInformation = statusInformationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(DocumentType.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let requiresContainer = try containerValues.decodeIfPresent([DocumentRequires?].self, forKey: .requires)
        var requiresDecoded0:[DocumentRequires]? = nil
        if let requiresContainer = requiresContainer {
            requiresDecoded0 = [DocumentRequires]()
            for structure0 in requiresContainer {
                if let structure0 = structure0 {
                    requiresDecoded0?.append(structure0)
                }
            }
        }
        requires = requiresDecoded0
        let attachmentsContentContainer = try containerValues.decodeIfPresent([AttachmentContent?].self, forKey: .attachmentsContent)
        var attachmentsContentDecoded0:[AttachmentContent]? = nil
        if let attachmentsContentContainer = attachmentsContentContainer {
            attachmentsContentDecoded0 = [AttachmentContent]()
            for structure0 in attachmentsContentContainer {
                if let structure0 = structure0 {
                    attachmentsContentDecoded0?.append(structure0)
                }
            }
        }
        attachmentsContent = attachmentsContentDecoded0
        let reviewStatusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .reviewStatus)
        reviewStatus = reviewStatusDecoded
    }
}

public struct GetInventoryInputBodyMiddleware: Middleware {
    public let id: String = "GetInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventoryInput>
    public typealias MOutput = OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventoryOutputError>
}

extension GetInventoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInventoryInput(aggregators: \(String(describing: aggregators)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resultAttributes: \(String(describing: resultAttributes)))"}
}

extension GetInventoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for resultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(resultattributelist0)
            }
        }
    }
}

public struct GetInventoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventoryInput>
    public typealias MOutput = OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventoryOutputError>
}

public struct GetInventoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventoryInput>
    public typealias MOutput = OperationOutput<GetInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventoryOutputError>
}

public struct GetInventoryInput: Equatable {
    /// <p>Returns counts of inventory types based on one or more expressions. For example, if you
    ///    aggregate by using an expression that uses the <code>AWS:InstanceInformation.PlatformType</code>
    ///    type, you can see a count of how many Windows and Linux instances exist in your inventoried
    ///    fleet.</p>
    public let aggregators: [InventoryAggregator]?
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    public let filters: [InventoryFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The list of inventory item types to return.</p>
    public let resultAttributes: [ResultAttribute]?

    public init (
        aggregators: [InventoryAggregator]? = nil,
        filters: [InventoryFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        resultAttributes: [ResultAttribute]? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
    }
}

struct GetInventoryInputBody: Equatable {
    public let filters: [InventoryFilter]?
    public let aggregators: [InventoryAggregator]?
    public let resultAttributes: [ResultAttribute]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetInventoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([ResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[ResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [ResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetInventoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregatorException" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryGroupException" : self = .invalidInventoryGroupException(try InvalidInventoryGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResultAttributeException" : self = .invalidResultAttributeException(try InvalidResultAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventoryOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidInventoryGroupException(InvalidInventoryGroupException)
    case invalidNextToken(InvalidNextToken)
    case invalidResultAttributeException(InvalidResultAttributeException)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInventoryOutputResponse(entities: \(String(describing: entities)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInventoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInventoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetInventoryOutputResponse: Equatable {
    /// <p>Collection of inventory entities such as a collection of instance inventory. </p>
    public let entities: [InventoryResultEntity]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        entities: [InventoryResultEntity]? = nil,
        nextToken: String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetInventoryOutputResponseBody: Equatable {
    public let entities: [InventoryResultEntity]?
    public let nextToken: String?
}

extension GetInventoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([InventoryResultEntity?].self, forKey: .entities)
        var entitiesDecoded0:[InventoryResultEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [InventoryResultEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetInventorySchemaInputBodyMiddleware: Middleware {
    public let id: String = "GetInventorySchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventorySchemaOutputError>
}

extension GetInventorySchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInventorySchemaInput(aggregator: \(String(describing: aggregator)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), subType: \(String(describing: subType)), typeName: \(String(describing: typeName)))"}
}

extension GetInventorySchemaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if aggregator != false {
            try encodeContainer.encode(aggregator, forKey: .aggregator)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if subType != false {
            try encodeContainer.encode(subType, forKey: .subType)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct GetInventorySchemaInputHeadersMiddleware: Middleware {
    public let id: String = "GetInventorySchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInventorySchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInventorySchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInventorySchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInventorySchemaInput>
    public typealias MOutput = OperationOutput<GetInventorySchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInventorySchemaOutputError>
}

public struct GetInventorySchemaInput: Equatable {
    /// <p>Returns inventory schemas that support aggregation. For example, this call returns the
    ///     <code>AWS:InstanceInformation</code> type, because it supports aggregation based on the
    ///     <code>PlatformName</code>, <code>PlatformType</code>, and <code>PlatformVersion</code>
    ///    attributes.</p>
    public let aggregator: Bool
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>Returns the sub-type schema for a specified inventory type.</p>
    public let subType: Bool
    /// <p>The type of inventory item to return.</p>
    public let typeName: String?

    public init (
        aggregator: Bool = false,
        maxResults: Int = 0,
        nextToken: String? = nil,
        subType: Bool = false,
        typeName: String? = nil
    )
    {
        self.aggregator = aggregator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subType = subType
        self.typeName = typeName
    }
}

struct GetInventorySchemaInputBody: Equatable {
    public let typeName: String?
    public let nextToken: String?
    public let maxResults: Int
    public let aggregator: Bool
    public let subType: Bool
}

extension GetInventorySchemaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregator = "Aggregator"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subType = "SubType"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aggregatorDecoded = try containerValues.decode(Bool.self, forKey: .aggregator)
        aggregator = aggregatorDecoded
        let subTypeDecoded = try containerValues.decode(Bool.self, forKey: .subType)
        subType = subTypeDecoded
    }
}

extension GetInventorySchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInventorySchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInventorySchemaOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInventorySchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInventorySchemaOutputResponse(nextToken: \(String(describing: nextToken)), schemas: \(String(describing: schemas)))"}
}

extension GetInventorySchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInventorySchemaOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct GetInventorySchemaOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>Inventory schemas returned by the request.</p>
    public let schemas: [InventoryItemSchema]?

    public init (
        nextToken: String? = nil,
        schemas: [InventoryItemSchema]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct GetInventorySchemaOutputResponseBody: Equatable {
    public let schemas: [InventoryItemSchema]?
    public let nextToken: String?
}

extension GetInventorySchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case schemas = "Schemas"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([InventoryItemSchema?].self, forKey: .schemas)
        var schemasDecoded0:[InventoryItemSchema]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [InventoryItemSchema]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMaintenanceWindowExecutionInputBodyMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionOutputError>
}

extension GetMaintenanceWindowExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionInput(windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionOutputError>
}

public struct GetMaintenanceWindowExecutionInput: Equatable {
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    public let windowExecutionId: String?

    public init (
        windowExecutionId: String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionInputBody: Equatable {
    public let windowExecutionId: String?
}

extension GetMaintenanceWindowExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
    }
}

extension GetMaintenanceWindowExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionOutputResponse(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), taskIds: \(String(describing: taskIds)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMaintenanceWindowExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskIds = output.taskIds
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskIds = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionOutputResponse: Equatable {
    /// <p>The time the maintenance window finished running.</p>
    public let endTime: Date?
    /// <p>The time the maintenance window started running.</p>
    public let startTime: Date?
    /// <p>The status of the maintenance window execution.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    public let statusDetails: String?
    /// <p>The ID of the task executions from the maintenance window execution.</p>
    public let taskIds: [String]?
    /// <p>The ID of the maintenance window execution.</p>
    public let windowExecutionId: String?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        taskIds: [String]? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskIds = taskIds
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionOutputResponseBody: Equatable {
    public let windowExecutionId: String?
    public let taskIds: [String]?
    public let status: MaintenanceWindowExecutionStatus?
    public let statusDetails: String?
    public let startTime: Date?
    public let endTime: Date?
}

extension GetMaintenanceWindowExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskIds = "TaskIds"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct GetMaintenanceWindowExecutionTaskInputBodyMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

extension GetMaintenanceWindowExecutionTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionTaskInput(taskId: \(String(describing: taskId)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInput: Equatable {
    /// <p>The ID of the specific task execution in the maintenance window task that should be
    ///    retrieved.</p>
    public let taskId: String?
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    public let windowExecutionId: String?

    public init (
        taskId: String? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInputBody: Equatable {
    public let windowExecutionId: String?
    public let taskId: String?
}

extension GetMaintenanceWindowExecutionTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputBodyMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInvocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionTaskInvocationInput(invocationId: \(String(describing: invocationId)), taskId: \(String(describing: taskId)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskInvocationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputHeadersMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInvocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowExecutionTaskInvocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowExecutionTaskInvocationInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowExecutionTaskInvocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowExecutionTaskInvocationOutputError>
}

public struct GetMaintenanceWindowExecutionTaskInvocationInput: Equatable {
    /// <p>The invocation ID to retrieve.</p>
    public let invocationId: String?
    /// <p>The ID of the specific task in the maintenance window task that should be retrieved. </p>
    public let taskId: String?
    /// <p>The ID of the maintenance window execution for which the task is a part.</p>
    public let windowExecutionId: String?

    public init (
        invocationId: String? = nil,
        taskId: String? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.invocationId = invocationId
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationInputBody: Equatable {
    public let windowExecutionId: String?
    public let taskId: String?
    public let invocationId: String?
}

extension GetMaintenanceWindowExecutionTaskInvocationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invocationId = "InvocationId"
        case taskId = "TaskId"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskInvocationOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionTaskInvocationOutputResponse(endTime: \(String(describing: endTime)), executionId: \(String(describing: executionId)), invocationId: \(String(describing: invocationId)), ownerInformation: \(String(describing: ownerInformation)), parameters: \(String(describing: parameters)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), taskExecutionId: \(String(describing: taskExecutionId)), taskType: \(String(describing: taskType)), windowExecutionId: \(String(describing: windowExecutionId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.executionId = output.executionId
            self.invocationId = output.invocationId
            self.ownerInformation = output.ownerInformation
            self.parameters = output.parameters
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskExecutionId = output.taskExecutionId
            self.taskType = output.taskType
            self.windowExecutionId = output.windowExecutionId
            self.windowTargetId = output.windowTargetId
        } else {
            self.endTime = nil
            self.executionId = nil
            self.invocationId = nil
            self.ownerInformation = nil
            self.parameters = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskExecutionId = nil
            self.taskType = nil
            self.windowExecutionId = nil
            self.windowTargetId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationOutputResponse: Equatable {
    /// <p>The time that the task finished running on the target.</p>
    public let endTime: Date?
    /// <p>The execution ID.</p>
    public let executionId: String?
    /// <p>The invocation ID.</p>
    public let invocationId: String?
    /// <p>User-provided value to be included in any CloudWatch events raised while running tasks for
    ///    these targets in this maintenance window. </p>
    public let ownerInformation: String?
    /// <p>The parameters used at the time that the task ran.</p>
    public let parameters: String?
    /// <p>The time that the task started running on the target.</p>
    public let startTime: Date?
    /// <p>The task status for an invocation.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the status. Details are only available for certain status
    ///    values.</p>
    public let statusDetails: String?
    /// <p>The task execution ID.</p>
    public let taskExecutionId: String?
    /// <p>Retrieves the task type for a maintenance window. Task types include the following: LAMBDA,
    ///    STEP_FUNCTIONS, AUTOMATION, RUN_COMMAND.</p>
    public let taskType: MaintenanceWindowTaskType?
    /// <p>The maintenance window execution ID.</p>
    public let windowExecutionId: String?
    /// <p>The maintenance window target ID.</p>
    public let windowTargetId: String?

    public init (
        endTime: Date? = nil,
        executionId: String? = nil,
        invocationId: String? = nil,
        ownerInformation: String? = nil,
        parameters: String? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        taskExecutionId: String? = nil,
        taskType: MaintenanceWindowTaskType? = nil,
        windowExecutionId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.endTime = endTime
        self.executionId = executionId
        self.invocationId = invocationId
        self.ownerInformation = ownerInformation
        self.parameters = parameters
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
        self.windowTargetId = windowTargetId
    }
}

struct GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Equatable {
    public let windowExecutionId: String?
    public let taskExecutionId: String?
    public let invocationId: String?
    public let executionId: String?
    public let taskType: MaintenanceWindowTaskType?
    public let parameters: String?
    public let status: MaintenanceWindowExecutionStatus?
    public let statusDetails: String?
    public let startTime: Date?
    public let endTime: Date?
    public let ownerInformation: String?
    public let windowTargetId: String?
}

extension GetMaintenanceWindowExecutionTaskInvocationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowExecutionTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowExecutionTaskOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowExecutionTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowExecutionTaskOutputResponse(endTime: \(String(describing: endTime)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), priority: \(String(describing: priority)), serviceRole: \(String(describing: serviceRole)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), taskArn: \(String(describing: taskArn)), taskExecutionId: \(String(describing: taskExecutionId)), taskParameters: \(String(describing: taskParameters)), type: \(String(describing: type)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

extension GetMaintenanceWindowExecutionTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMaintenanceWindowExecutionTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.priority = output.priority
            self.serviceRole = output.serviceRole
            self.startTime = output.startTime
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.taskArn = output.taskArn
            self.taskExecutionId = output.taskExecutionId
            self.taskParameters = output.taskParameters
            self.type = output.type
            self.windowExecutionId = output.windowExecutionId
        } else {
            self.endTime = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.priority = 0
            self.serviceRole = nil
            self.startTime = nil
            self.status = nil
            self.statusDetails = nil
            self.taskArn = nil
            self.taskExecutionId = nil
            self.taskParameters = nil
            self.type = nil
            self.windowExecutionId = nil
        }
    }
}

public struct GetMaintenanceWindowExecutionTaskOutputResponse: Equatable {
    /// <p>The time the task execution completed.</p>
    public let endTime: Date?
    /// <p>The defined maximum number of task executions that could be run in parallel.</p>
    public let maxConcurrency: String?
    /// <p>The defined maximum number of task execution errors allowed before scheduling of the task
    ///    execution would have been stopped.</p>
    public let maxErrors: String?
    /// <p>The priority of the task.</p>
    public let priority: Int
    /// <p>The role that was assumed when running the task.</p>
    public let serviceRole: String?
    /// <p>The time the task execution started.</p>
    public let startTime: Date?
    /// <p>The status of the task.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    public let statusDetails: String?
    /// <p>The ARN of the task that ran.</p>
    public let taskArn: String?
    /// <p>The ID of the specific task execution in the maintenance window task that was
    ///    retrieved.</p>
    public let taskExecutionId: String?
    /// <p>The parameters passed to the task when it was run.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    ///          <p>The map has the following format:</p>
    ///          <p>Key: string, between 1 and 255 characters</p>
    ///          <p>Value: an array of strings, each string is between 1 and 255 characters</p>
    public let taskParameters: [[String:MaintenanceWindowTaskParameterValueExpression]]?
    /// <p>The type of task that was run.</p>
    public let type: MaintenanceWindowTaskType?
    /// <p>The ID of the maintenance window execution that includes the task.</p>
    public let windowExecutionId: String?

    public init (
        endTime: Date? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        priority: Int = 0,
        serviceRole: String? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        taskArn: String? = nil,
        taskExecutionId: String? = nil,
        taskParameters: [[String:MaintenanceWindowTaskParameterValueExpression]]? = nil,
        type: MaintenanceWindowTaskType? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.endTime = endTime
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.priority = priority
        self.serviceRole = serviceRole
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskArn = taskArn
        self.taskExecutionId = taskExecutionId
        self.taskParameters = taskParameters
        self.type = type
        self.windowExecutionId = windowExecutionId
    }
}

struct GetMaintenanceWindowExecutionTaskOutputResponseBody: Equatable {
    public let windowExecutionId: String?
    public let taskExecutionId: String?
    public let taskArn: String?
    public let serviceRole: String?
    public let type: MaintenanceWindowTaskType?
    public let taskParameters: [[String:MaintenanceWindowTaskParameterValueExpression]]?
    public let priority: Int
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let status: MaintenanceWindowExecutionStatus?
    public let statusDetails: String?
    public let startTime: Date?
    public let endTime: Date?
}

extension GetMaintenanceWindowExecutionTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case priority = "Priority"
        case serviceRole = "ServiceRole"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowExecutionId = "WindowExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([[String: MaintenanceWindowTaskParameterValueExpression?]?].self, forKey: .taskParameters)
        var taskParametersDecoded0:[[String:MaintenanceWindowTaskParameterValueExpression]]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [[String:MaintenanceWindowTaskParameterValueExpression]]()
            for map0 in taskParametersContainer {
                var taskParametersContainerDecoded0: [String: MaintenanceWindowTaskParameterValueExpression]? = nil
                if let map0 = map0 {
                    taskParametersContainerDecoded0 = [String: MaintenanceWindowTaskParameterValueExpression]()
                    for (key1, maintenancewindowtaskparametervalueexpression1) in map0 {
                        if let maintenancewindowtaskparametervalueexpression1 = maintenancewindowtaskparametervalueexpression1 {
                            taskParametersContainerDecoded0?[key1] = maintenancewindowtaskparametervalueexpression1
                        }
                    }
                }
                if let taskParametersContainerDecoded0 = taskParametersContainerDecoded0 {
                    taskParametersDecoded0?.append(taskParametersContainerDecoded0)
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct GetMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowOutputError>
}

extension GetMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowInput(windowId: \(String(describing: windowId)))"}
}

extension GetMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct GetMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowOutputError>
}

public struct GetMaintenanceWindowInput: Equatable {
    /// <p>The ID of the maintenance window for which you want to retrieve information.</p>
    public let windowId: String?

    public init (
        windowId: String? = nil
    )
    {
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
}

extension GetMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
    }
}

extension GetMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowOutputResponse(allowUnassociatedTargets: \(String(describing: allowUnassociatedTargets)), createdDate: \(String(describing: createdDate)), cutoff: \(String(describing: cutoff)), description: \(String(describing: description)), duration: \(String(describing: duration)), enabled: \(String(describing: enabled)), endDate: \(String(describing: endDate)), modifiedDate: \(String(describing: modifiedDate)), name: \(String(describing: name)), nextExecutionTime: \(String(describing: nextExecutionTime)), schedule: \(String(describing: schedule)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleTimezone: \(String(describing: scheduleTimezone)), startDate: \(String(describing: startDate)), windowId: \(String(describing: windowId)))"}
}

extension GetMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.createdDate = output.createdDate
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.nextExecutionTime = output.nextExecutionTime
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.createdDate = nil
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.modifiedDate = nil
            self.name = nil
            self.nextExecutionTime = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct GetMaintenanceWindowOutputResponse: Equatable {
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    ///    for those targets.</p>
    public let allowUnassociatedTargets: Bool
    /// <p>The date the maintenance window was created.</p>
    public let createdDate: Date?
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    ///    tasks for execution.</p>
    public let cutoff: Int
    /// <p>The description of the maintenance window.</p>
    public let description: String?
    /// <p>The duration of the maintenance window in hours.</p>
    public let duration: Int
    /// <p>Indicates whether the maintenance window is enabled.</p>
    public let enabled: Bool
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become inactive. The maintenance window will not run after this specified time.</p>
    public let endDate: String?
    /// <p>The date the maintenance window was last modified.</p>
    public let modifiedDate: Date?
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>The next time the maintenance window will actually run, taking into account any specified
    ///    times for the maintenance window to become active or inactive.</p>
    public let nextExecutionTime: String?
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    public let schedule: String?
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    ///    date and time.</p>
    public let scheduleOffset: Int
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    ///    "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    ///     Zone Database</a> on the IANA website.</p>
    public let scheduleTimezone: String?
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become active. The maintenance window will not run before this specified time.</p>
    public let startDate: String?
    /// <p>The ID of the created maintenance window.</p>
    public let windowId: String?

    public init (
        allowUnassociatedTargets: Bool = false,
        createdDate: Date? = nil,
        cutoff: Int = 0,
        description: String? = nil,
        duration: Int = 0,
        enabled: Bool = false,
        endDate: String? = nil,
        modifiedDate: Date? = nil,
        name: String? = nil,
        nextExecutionTime: String? = nil,
        schedule: String? = nil,
        scheduleOffset: Int = 0,
        scheduleTimezone: String? = nil,
        startDate: String? = nil,
        windowId: String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.createdDate = createdDate
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.modifiedDate = modifiedDate
        self.name = name
        self.nextExecutionTime = nextExecutionTime
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct GetMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
    public let name: String?
    public let description: String?
    public let startDate: String?
    public let endDate: String?
    public let schedule: String?
    public let scheduleTimezone: String?
    public let scheduleOffset: Int
    public let nextExecutionTime: String?
    public let duration: Int
    public let cutoff: Int
    public let allowUnassociatedTargets: Bool
    public let enabled: Bool
    public let createdDate: Date?
    public let modifiedDate: Date?
}

extension GetMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case createdDate = "CreatedDate"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
    }
}

public struct GetMaintenanceWindowTaskInputBodyMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowTaskOutputError>
}

extension GetMaintenanceWindowTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowTaskInput(windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension GetMaintenanceWindowTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct GetMaintenanceWindowTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMaintenanceWindowTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<GetMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMaintenanceWindowTaskOutputError>
}

public struct GetMaintenanceWindowTaskInput: Equatable {
    /// <p>The maintenance window ID that includes the task to retrieve.</p>
    public let windowId: String?
    /// <p>The maintenance window task ID to retrieve.</p>
    public let windowTaskId: String?

    public init (
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskInputBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
}

extension GetMaintenanceWindowTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension GetMaintenanceWindowTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMaintenanceWindowTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMaintenanceWindowTaskOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMaintenanceWindowTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMaintenanceWindowTaskOutputResponse(description: \(String(describing: description)), loggingInfo: \(String(describing: loggingInfo)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), priority: \(String(describing: priority)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), taskArn: \(String(describing: taskArn)), taskInvocationParameters: \(String(describing: taskInvocationParameters)), taskParameters: \(String(describing: taskParameters)), taskType: \(String(describing: taskType)), windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension GetMaintenanceWindowTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.taskType = output.taskType
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.taskType = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct GetMaintenanceWindowTaskOutputResponse: Equatable {
    /// <p>The retrieved task description.</p>
    public let description: String?
    /// <p>The location in Amazon S3 where the task results are logged.</p>
    ///          <note>
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let loggingInfo: LoggingInfo?
    /// <p>The maximum number of targets allowed to run this task in parallel.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    ///     in the response to this command. This value does not affect the running of your task and can be
    ///     ignored.</p>
    ///          </note>
    public let maxConcurrency: String?
    /// <p>The maximum number of errors allowed before the task stops being scheduled.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    ///     in the response to this command. This value does not affect the running of your task and can be
    ///     ignored.</p>
    ///          </note>
    public let maxErrors: String?
    /// <p>The retrieved task name.</p>
    public let name: String?
    /// <p>The priority of the task when it runs. The lower the number, the higher the priority. Tasks
    ///    that have the same priority are scheduled in parallel.</p>
    public let priority: Int
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    ///    maintenance window Run Command tasks.</p>
    public let serviceRoleArn: String?
    /// <p>The targets where the task should run.</p>
    public let targets: [Target]?
    /// <p>The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types,
    ///    the TaskArn is the Systems Manager Document name/ARN. For LAMBDA tasks, the value is the function name/ARN.
    ///    For STEP_FUNCTIONS tasks, the value is the state machine ARN.</p>
    public let taskArn: String?
    /// <p>The parameters to pass to the task when it runs.</p>
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    /// <p>The parameters to pass to the task when it runs.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    /// <p>The type of task to run.</p>
    public let taskType: MaintenanceWindowTaskType?
    /// <p>The retrieved maintenance window ID.</p>
    public let windowId: String?
    /// <p>The retrieved maintenance window task ID.</p>
    public let windowTaskId: String?

    public init (
        description: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        priority: Int = 0,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        taskArn: String? = nil,
        taskInvocationParameters: MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: MaintenanceWindowTaskType? = nil,
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct GetMaintenanceWindowTaskOutputResponseBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
    public let targets: [Target]?
    public let taskArn: String?
    public let serviceRoleArn: String?
    public let taskType: MaintenanceWindowTaskType?
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    public let priority: Int
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let loggingInfo: LoggingInfo?
    public let name: String?
    public let description: String?
}

extension GetMaintenanceWindowTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([String: MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [String:MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [String:MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct GetOpsItemInputBodyMiddleware: Middleware {
    public let id: String = "GetOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsItemOutputError>
}

extension GetOpsItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsItemInput(opsItemId: \(String(describing: opsItemId)))"}
}

extension GetOpsItemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct GetOpsItemInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsItemInput>
    public typealias MOutput = OperationOutput<GetOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsItemOutputError>
}

public struct GetOpsItemInput: Equatable {
    /// <p>The ID of the OpsItem that you want to get.</p>
    public let opsItemId: String?

    public init (
        opsItemId: String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

struct GetOpsItemInputBody: Equatable {
    public let opsItemId: String?
}

extension GetOpsItemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension GetOpsItemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsItemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsItemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsItemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsItemOutputResponse(opsItem: \(String(describing: opsItem)))"}
}

extension GetOpsItemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpsItemOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.opsItem = output.opsItem
        } else {
            self.opsItem = nil
        }
    }
}

public struct GetOpsItemOutputResponse: Equatable {
    /// <p>The OpsItem.</p>
    public let opsItem: OpsItem?

    public init (
        opsItem: OpsItem? = nil
    )
    {
        self.opsItem = opsItem
    }
}

struct GetOpsItemOutputResponseBody: Equatable {
    public let opsItem: OpsItem?
}

extension GetOpsItemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsItem = "OpsItem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemDecoded = try containerValues.decodeIfPresent(OpsItem.self, forKey: .opsItem)
        opsItem = opsItemDecoded
    }
}

public struct GetOpsMetadataInputBodyMiddleware: Middleware {
    public let id: String = "GetOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsMetadataOutputError>
}

extension GetOpsMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsMetadataInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), opsMetadataArn: \(String(describing: opsMetadataArn)))"}
}

extension GetOpsMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct GetOpsMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsMetadataInput>
    public typealias MOutput = OperationOutput<GetOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsMetadataOutputError>
}

public struct GetOpsMetadataInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of an OpsMetadata Object to view.</p>
    public let opsMetadataArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        opsMetadataArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsMetadataArn = opsMetadataArn
    }
}

struct GetOpsMetadataInputBody: Equatable {
    public let opsMetadataArn: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension GetOpsMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetOpsMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsMetadataOutputResponse(metadata: \(String(describing: metadata)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)))"}
}

extension GetOpsMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.nextToken = output.nextToken
            self.resourceId = output.resourceId
        } else {
            self.metadata = nil
            self.nextToken = nil
            self.resourceId = nil
        }
    }
}

public struct GetOpsMetadataOutputResponse: Equatable {
    /// <p>OpsMetadata for an Application Manager application.</p>
    public let metadata: [String:MetadataValue]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>The resource ID of the Application Manager application.</p>
    public let resourceId: String?

    public init (
        metadata: [String:MetadataValue]? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil
    )
    {
        self.metadata = metadata
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct GetOpsMetadataOutputResponseBody: Equatable {
    public let resourceId: String?
    public let metadata: [String:MetadataValue]?
    public let nextToken: String?
}

extension GetOpsMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case nextToken = "NextToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String: MetadataValue?].self, forKey: .metadata)
        var metadataDecoded0: [String:MetadataValue]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String:MetadataValue]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetOpsSummaryInputBodyMiddleware: Middleware {
    public let id: String = "GetOpsSummaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsSummaryOutputError>
}

extension GetOpsSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsSummaryInput(aggregators: \(String(describing: aggregators)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resultAttributes: \(String(describing: resultAttributes)), syncName: \(String(describing: syncName)))"}
}

extension GetOpsSummaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resultAttributes = resultAttributes {
            var resultAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultAttributes)
            for opsresultattributelist0 in resultAttributes {
                try resultAttributesContainer.encode(opsresultattributelist0)
            }
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
    }
}

public struct GetOpsSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpsSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpsSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpsSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpsSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpsSummaryInput>
    public typealias MOutput = OperationOutput<GetOpsSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpsSummaryOutputError>
}

public struct GetOpsSummaryInput: Equatable {
    /// <p>Optional aggregators that return counts of OpsItems based on one or more expressions.</p>
    public let aggregators: [OpsAggregator]?
    /// <p>Optional filters used to scope down the returned OpsItems. </p>
    public let filters: [OpsFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?
    /// <p>The OpsItem data type to return.</p>
    public let resultAttributes: [OpsResultAttribute]?
    /// <p>Specify the name of a resource data sync to get.</p>
    public let syncName: String?

    public init (
        aggregators: [OpsAggregator]? = nil,
        filters: [OpsFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        resultAttributes: [OpsResultAttribute]? = nil,
        syncName: String? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
        self.syncName = syncName
    }
}

struct GetOpsSummaryInputBody: Equatable {
    public let syncName: String?
    public let filters: [OpsFilter]?
    public let aggregators: [OpsAggregator]?
    public let resultAttributes: [OpsResultAttribute]?
    public let nextToken: String?
    public let maxResults: Int
}

extension GetOpsSummaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregators = "Aggregators"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resultAttributes = "ResultAttributes"
        case syncName = "SyncName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let resultAttributesContainer = try containerValues.decodeIfPresent([OpsResultAttribute?].self, forKey: .resultAttributes)
        var resultAttributesDecoded0:[OpsResultAttribute]? = nil
        if let resultAttributesContainer = resultAttributesContainer {
            resultAttributesDecoded0 = [OpsResultAttribute]()
            for structure0 in resultAttributesContainer {
                if let structure0 = structure0 {
                    resultAttributesDecoded0?.append(structure0)
                }
            }
        }
        resultAttributes = resultAttributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOpsSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpsSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAggregatorException" : self = .invalidAggregatorException(try InvalidAggregatorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFoundException" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpsSummaryOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidAggregatorException(InvalidAggregatorException)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpsSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpsSummaryOutputResponse(entities: \(String(describing: entities)), nextToken: \(String(describing: nextToken)))"}
}

extension GetOpsSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpsSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct GetOpsSummaryOutputResponse: Equatable {
    /// <p>The list of aggregated and filtered OpsItems.</p>
    public let entities: [OpsEntity]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        entities: [OpsEntity]? = nil,
        nextToken: String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct GetOpsSummaryOutputResponseBody: Equatable {
    public let entities: [OpsEntity]?
    public let nextToken: String?
}

extension GetOpsSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entities = "Entities"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([OpsEntity?].self, forKey: .entities)
        var entitiesDecoded0:[OpsEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [OpsEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParameterHistoryInputBodyMiddleware: Middleware {
    public let id: String = "GetParameterHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterHistoryOutputError>
}

extension GetParameterHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParameterHistoryInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)), withDecryption: \(String(describing: withDecryption)))"}
}

extension GetParameterHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParameterHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetParameterHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParameterHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterHistoryInput>
    public typealias MOutput = OperationOutput<GetParameterHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterHistoryOutputError>
}

public struct GetParameterHistoryInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The name of the parameter for which you want to review history.</p>
    public let name: String?
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
    ///    StringList parameter types.</p>
    public let withDecryption: Bool

    public init (
        maxResults: Int = 0,
        name: String? = nil,
        nextToken: String? = nil,
        withDecryption: Bool = false
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.withDecryption = withDecryption
    }
}

struct GetParameterHistoryInputBody: Equatable {
    public let name: String?
    public let withDecryption: Bool
    public let maxResults: Int
    public let nextToken: String?
}

extension GetParameterHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParameterHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterHistoryOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case parameterNotFound(ParameterNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParameterHistoryOutputResponse(nextToken: \(String(describing: nextToken)), parameters: \(String(describing: parameters)))"}
}

extension GetParameterHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParameterHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParameterHistoryOutputResponse: Equatable {
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>A list of parameters returned by the request.</p>
    public let parameters: [ParameterHistory]?

    public init (
        nextToken: String? = nil,
        parameters: [ParameterHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParameterHistoryOutputResponseBody: Equatable {
    public let parameters: [ParameterHistory]?
    public let nextToken: String?
}

extension GetParameterHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([ParameterHistory?].self, forKey: .parameters)
        var parametersDecoded0:[ParameterHistory]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ParameterHistory]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParameterInputBodyMiddleware: Middleware {
    public let id: String = "GetParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterInput>
    public typealias MOutput = OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterOutputError>
}

extension GetParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParameterInput(name: \(String(describing: name)), withDecryption: \(String(describing: withDecryption)))"}
}

extension GetParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParameterInputHeadersMiddleware: Middleware {
    public let id: String = "GetParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterInput>
    public typealias MOutput = OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterOutputError>
}

public struct GetParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParameterInput>
    public typealias MOutput = OperationOutput<GetParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParameterOutputError>
}

public struct GetParameterInput: Equatable {
    /// <p>The name of the parameter you want to query.</p>
    public let name: String?
    /// <p>Return decrypted values for secure string parameters. This flag is ignored for String and
    ///    StringList parameter types.</p>
    public let withDecryption: Bool

    public init (
        name: String? = nil,
        withDecryption: Bool = false
    )
    {
        self.name = name
        self.withDecryption = withDecryption
    }
}

struct GetParameterInputBody: Equatable {
    public let name: String?
    public let withDecryption: Bool
}

extension GetParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let withDecryptionDecoded = try containerValues.decode(Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParameterOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParameterOutputResponse(parameter: \(String(describing: parameter)))"}
}

extension GetParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParameterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameter = output.parameter
        } else {
            self.parameter = nil
        }
    }
}

public struct GetParameterOutputResponse: Equatable {
    /// <p>Information about a parameter.</p>
    public let parameter: Parameter?

    public init (
        parameter: Parameter? = nil
    )
    {
        self.parameter = parameter
    }
}

struct GetParameterOutputResponseBody: Equatable {
    public let parameter: Parameter?
}

extension GetParameterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameter = "Parameter"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterDecoded = try containerValues.decodeIfPresent(Parameter.self, forKey: .parameter)
        parameter = parameterDecoded
    }
}

public struct GetParametersByPathInputBodyMiddleware: Middleware {
    public let id: String = "GetParametersByPathInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersByPathOutputError>
}

extension GetParametersByPathInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersByPathInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), parameterFilters: \(String(describing: parameterFilters)), path: \(String(describing: path)), recursive: \(String(describing: recursive)), withDecryption: \(String(describing: withDecryption)))"}
}

extension GetParametersByPathInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterFilters = parameterFilters {
            var parameterFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterFilters)
            for parameterstringfilterlist0 in parameterFilters {
                try parameterFiltersContainer.encode(parameterstringfilterlist0)
            }
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if recursive != false {
            try encodeContainer.encode(recursive, forKey: .recursive)
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParametersByPathInputHeadersMiddleware: Middleware {
    public let id: String = "GetParametersByPathInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParametersByPathInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersByPathInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersByPathOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersByPathInput>
    public typealias MOutput = OperationOutput<GetParametersByPathOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersByPathOutputError>
}

public struct GetParametersByPathInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?
    /// <p>Filters to limit the request results.</p>
    ///          <note>
    ///             <p>For <code>GetParametersByPath</code>, the following filter <code>Key</code> names are
    ///     supported: <code>Type</code>, <code>KeyId</code>, <code>Label</code>, and
    ///     <code>DataType</code>.</p>
    ///             <p>The following <code>Key</code> values are not supported for
    ///      <code>GetParametersByPath</code>: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
    ///      <code>Tier</code>.</p>
    ///          </note>
    public let parameterFilters: [ParameterStringFilter]?
    /// <p>The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierachy is
    ///    the parameter name except the last part of the parameter. For the API call to succeeed, the last
    ///    part of the parameter name cannot be in the path. A parameter name hierarchy can have a maximum
    ///    of 15 levels. Here is an example of a hierarchy: <code>/Finance/Prod/IAD/WinServ2016/license33
    ///    </code>
    ///          </p>
    public let path: String?
    /// <p>Retrieve all parameters within a hierarchy.</p>
    ///          <important>
    ///             <p>If a user has access to a path, then the user can access all levels of that path. For
    ///     example, if a user has permission to access path <code>/a</code>, then the user can also access
    ///      <code>/a/b</code>. Even if a user has explicitly been denied access in IAM for parameter
    ///      <code>/a/b</code>, they can still call the GetParametersByPath API action recursively for
    ///      <code>/a</code> and view <code>/a/b</code>.</p>
    ///          </important>
    public let recursive: Bool
    /// <p>Retrieve all parameters in a hierarchy with their value decrypted.</p>
    public let withDecryption: Bool

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        parameterFilters: [ParameterStringFilter]? = nil,
        path: String? = nil,
        recursive: Bool = false,
        withDecryption: Bool = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
        self.path = path
        self.recursive = recursive
        self.withDecryption = withDecryption
    }
}

struct GetParametersByPathInputBody: Equatable {
    public let path: String?
    public let recursive: Bool
    public let parameterFilters: [ParameterStringFilter]?
    public let withDecryption: Bool
    public let maxResults: Int
    public let nextToken: String?
}

extension GetParametersByPathInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterFilters = "ParameterFilters"
        case path = "Path"
        case recursive = "Recursive"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let recursiveDecoded = try containerValues.decode(Bool.self, forKey: .recursive)
        recursive = recursiveDecoded
        let parameterFiltersContainer = try containerValues.decodeIfPresent([ParameterStringFilter?].self, forKey: .parameterFilters)
        var parameterFiltersDecoded0:[ParameterStringFilter]? = nil
        if let parameterFiltersContainer = parameterFiltersContainer {
            parameterFiltersDecoded0 = [ParameterStringFilter]()
            for structure0 in parameterFiltersContainer {
                if let structure0 = structure0 {
                    parameterFiltersDecoded0?.append(structure0)
                }
            }
        }
        parameterFilters = parameterFiltersDecoded0
        let withDecryptionDecoded = try containerValues.decode(Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetParametersByPathOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersByPathOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterOption" : self = .invalidFilterOption(try InvalidFilterOption(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterValue" : self = .invalidFilterValue(try InvalidFilterValue(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersByPathOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidFilterOption(InvalidFilterOption)
    case invalidFilterValue(InvalidFilterValue)
    case invalidKeyId(InvalidKeyId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersByPathOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersByPathOutputResponse(nextToken: \(String(describing: nextToken)), parameters: \(String(describing: parameters)))"}
}

extension GetParametersByPathOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParametersByPathOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersByPathOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>A list of parameters found in the specified hierarchy.</p>
    public let parameters: [Parameter]?

    public init (
        nextToken: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct GetParametersByPathOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let nextToken: String?
}

extension GetParametersByPathOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetParametersInputBodyMiddleware: Middleware {
    public let id: String = "GetParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersInput>
    public typealias MOutput = OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersOutputError>
}

extension GetParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersInput(names: \(String(describing: names)), withDecryption: \(String(describing: withDecryption)))"}
}

extension GetParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for parameternamelist0 in names {
                try namesContainer.encode(parameternamelist0)
            }
        }
        if withDecryption != false {
            try encodeContainer.encode(withDecryption, forKey: .withDecryption)
        }
    }
}

public struct GetParametersInputHeadersMiddleware: Middleware {
    public let id: String = "GetParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersInput>
    public typealias MOutput = OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersOutputError>
}

public struct GetParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetParametersInput>
    public typealias MOutput = OperationOutput<GetParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetParametersOutputError>
}

public struct GetParametersInput: Equatable {
    /// <p>Names of the parameters for which you want to query information.</p>
    public let names: [String]?
    /// <p>Return decrypted secure string value. Return decrypted values for secure string parameters.
    ///    This flag is ignored for String and StringList parameter types.</p>
    public let withDecryption: Bool

    public init (
        names: [String]? = nil,
        withDecryption: Bool = false
    )
    {
        self.names = names
        self.withDecryption = withDecryption
    }
}

struct GetParametersInputBody: Equatable {
    public let names: [String]?
    public let withDecryption: Bool
}

extension GetParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case names = "Names"
        case withDecryption = "WithDecryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let withDecryptionDecoded = try containerValues.decode(Bool.self, forKey: .withDecryption)
        withDecryption = withDecryptionDecoded
    }
}

extension GetParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParametersOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidKeyId(InvalidKeyId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetParametersOutputResponse(invalidParameters: \(String(describing: invalidParameters)), parameters: \(String(describing: parameters)))"}
}

extension GetParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidParameters = output.invalidParameters
            self.parameters = output.parameters
        } else {
            self.invalidParameters = nil
            self.parameters = nil
        }
    }
}

public struct GetParametersOutputResponse: Equatable {
    /// <p>A list of parameters that are not formatted correctly or do not run during an
    ///    execution.</p>
    public let invalidParameters: [String]?
    /// <p>A list of details for a parameter.</p>
    public let parameters: [Parameter]?

    public init (
        invalidParameters: [String]? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.invalidParameters = invalidParameters
        self.parameters = parameters
    }
}

struct GetParametersOutputResponseBody: Equatable {
    public let parameters: [Parameter]?
    public let invalidParameters: [String]?
}

extension GetParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidParameters = "InvalidParameters"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersContainer = try containerValues.decodeIfPresent([Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let invalidParametersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidParameters)
        var invalidParametersDecoded0:[String]? = nil
        if let invalidParametersContainer = invalidParametersContainer {
            invalidParametersDecoded0 = [String]()
            for string0 in invalidParametersContainer {
                if let string0 = string0 {
                    invalidParametersDecoded0?.append(string0)
                }
            }
        }
        invalidParameters = invalidParametersDecoded0
    }
}

public struct GetPatchBaselineForPatchGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineForPatchGroupOutputError>
}

extension GetPatchBaselineForPatchGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPatchBaselineForPatchGroupInput(operatingSystem: \(String(describing: operatingSystem)), patchGroup: \(String(describing: patchGroup)))"}
}

extension GetPatchBaselineForPatchGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct GetPatchBaselineForPatchGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineForPatchGroupOutputError>
}

public struct GetPatchBaselineForPatchGroupInput: Equatable {
    /// <p>Returns he operating system rule specified for patch groups using the patch baseline.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>The name of the patch group whose patch baseline should be retrieved.</p>
    public let patchGroup: String?

    public init (
        operatingSystem: OperatingSystem? = nil,
        patchGroup: String? = nil
    )
    {
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupInputBody: Equatable {
    public let patchGroup: String?
    public let operatingSystem: OperatingSystem?
}

extension GetPatchBaselineForPatchGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension GetPatchBaselineForPatchGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineForPatchGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineForPatchGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineForPatchGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPatchBaselineForPatchGroupOutputResponse(baselineId: \(String(describing: baselineId)), operatingSystem: \(String(describing: operatingSystem)), patchGroup: \(String(describing: patchGroup)))"}
}

extension GetPatchBaselineForPatchGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
            self.operatingSystem = output.operatingSystem
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.operatingSystem = nil
            self.patchGroup = nil
        }
    }
}

public struct GetPatchBaselineForPatchGroupOutputResponse: Equatable {
    /// <p>The ID of the patch baseline that should be used for the patch group.</p>
    public let baselineId: String?
    /// <p>The operating system rule specified for patch groups using the patch baseline.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>The name of the patch group.</p>
    public let patchGroup: String?

    public init (
        baselineId: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

struct GetPatchBaselineForPatchGroupOutputResponseBody: Equatable {
    public let baselineId: String?
    public let patchGroup: String?
    public let operatingSystem: OperatingSystem?
}

extension GetPatchBaselineForPatchGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case operatingSystem = "OperatingSystem"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

public struct GetPatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "GetPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineOutputError>
}

extension GetPatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPatchBaselineInput(baselineId: \(String(describing: baselineId)))"}
}

extension GetPatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct GetPatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "GetPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPatchBaselineInput>
    public typealias MOutput = OperationOutput<GetPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPatchBaselineOutputError>
}

public struct GetPatchBaselineInput: Equatable {
    /// <p>The ID of the patch baseline to retrieve.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct GetPatchBaselineInputBody: Equatable {
    public let baselineId: String?
}

extension GetPatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension GetPatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPatchBaselineOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPatchBaselineOutputResponse(approvalRules: \(String(describing: approvalRules)), approvedPatches: \(String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(String(describing: baselineId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), globalFilters: \(String(describing: globalFilters)), modifiedDate: \(String(describing: modifiedDate)), name: \(String(describing: name)), operatingSystem: \(String(describing: operatingSystem)), patchGroups: \(String(describing: patchGroups)), rejectedPatches: \(String(describing: rejectedPatches)), rejectedPatchesAction: \(String(describing: rejectedPatchesAction)), sources: \(String(describing: sources)))"}
}

extension GetPatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.patchGroups = output.patchGroups
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.patchGroups = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct GetPatchBaselineOutputResponse: Equatable {
    /// <p>A set of rules used to include patches in the baseline.</p>
    public let approvalRules: PatchRuleGroup?
    /// <p>A list of explicitly approved patches for the baseline.</p>
    public let approvedPatches: [String]?
    /// <p>Returns the specified compliance severity level for approved patches in the patch
    ///    baseline.</p>
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    ///    applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    public let approvedPatchesEnableNonSecurity: Bool
    /// <p>The ID of the retrieved patch baseline.</p>
    public let baselineId: String?
    /// <p>The date the patch baseline was created.</p>
    public let createdDate: Date?
    /// <p>A description of the patch baseline.</p>
    public let description: String?
    /// <p>A set of global filters used to exclude patches from the baseline.</p>
    public let globalFilters: PatchFilterGroup?
    /// <p>The date the patch baseline was last modified.</p>
    public let modifiedDate: Date?
    /// <p>The name of the patch baseline.</p>
    public let name: String?
    /// <p>Returns the operating system specified for the patch baseline.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>Patch groups included in the patch baseline.</p>
    public let patchGroups: [String]?
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    public let rejectedPatches: [String]?
    /// <p>The action specified to take on patches included in the RejectedPatches list. A patch can be
    ///    allowed only if it is a dependency of another package, or blocked entirely along with packages
    ///    that include it as a dependency.</p>
    public let rejectedPatchesAction: PatchAction?
    /// <p>Information about the patches to use to update the instances, including target operating
    ///    systems and source repositories. Applies to Linux instances only.</p>
    public let sources: [PatchSource]?

    public init (
        approvalRules: PatchRuleGroup? = nil,
        approvedPatches: [String]? = nil,
        approvedPatchesComplianceLevel: PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Bool = false,
        baselineId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        globalFilters: PatchFilterGroup? = nil,
        modifiedDate: Date? = nil,
        name: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        patchGroups: [String]? = nil,
        rejectedPatches: [String]? = nil,
        rejectedPatchesAction: PatchAction? = nil,
        sources: [PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.patchGroups = patchGroups
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct GetPatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
    public let name: String?
    public let operatingSystem: OperatingSystem?
    public let globalFilters: PatchFilterGroup?
    public let approvalRules: PatchRuleGroup?
    public let approvedPatches: [String]?
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Bool
    public let rejectedPatches: [String]?
    public let rejectedPatchesAction: PatchAction?
    public let patchGroups: [String]?
    public let createdDate: Date?
    public let modifiedDate: Date?
    public let description: String?
    public let sources: [PatchSource]?
}

extension GetPatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case patchGroups = "PatchGroups"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let patchGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .patchGroups)
        var patchGroupsDecoded0:[String]? = nil
        if let patchGroupsContainer = patchGroupsContainer {
            patchGroupsDecoded0 = [String]()
            for string0 in patchGroupsContainer {
                if let string0 = string0 {
                    patchGroupsDecoded0?.append(string0)
                }
            }
        }
        patchGroups = patchGroupsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public struct GetServiceSettingInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceSettingOutputError>
}

extension GetServiceSettingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceSettingInput(settingId: \(String(describing: settingId)))"}
}

extension GetServiceSettingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

public struct GetServiceSettingInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceSettingOutputError>
}

public struct GetServiceSettingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceSettingInput>
    public typealias MOutput = OperationOutput<GetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceSettingOutputError>
}

/// <p>The request body of the GetServiceSetting API action.</p>
public struct GetServiceSettingInput: Equatable {
    /// <p>The ID of the service setting to get. The setting ID can be one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-destination</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-group-name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/documents/console/public-sharing-permission</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/default-parameter-tier</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/high-throughput-enabled</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/managed-instance/activation-tier</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let settingId: String?

    public init (
        settingId: String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct GetServiceSettingInputBody: Equatable {
    public let settingId: String?
}

extension GetServiceSettingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension GetServiceSettingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceSettingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceSettingOutputError: Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceSettingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceSettingOutputResponse(serviceSetting: \(String(describing: serviceSetting)))"}
}

extension GetServiceSettingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// <p>The query result body of the GetServiceSetting API action.</p>
public struct GetServiceSettingOutputResponse: Equatable {
    /// <p>The query result of the current service setting.</p>
    public let serviceSetting: ServiceSetting?

    public init (
        serviceSetting: ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct GetServiceSettingOutputResponseBody: Equatable {
    public let serviceSetting: ServiceSetting?
}

extension GetServiceSettingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension HierarchyLevelLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyLevelLimitExceededException(message: \(String(describing: message)))"}
}

extension HierarchyLevelLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: HierarchyLevelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A hierarchy can have a maximum of 15 levels. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and
///     constraints for parameter names</a> in the <i>AWS Systems Manager User Guide</i>. </p>
public struct HierarchyLevelLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A hierarchy can have a maximum of 15 levels. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and
    ///     constraints for parameter names</a> in the <i>AWS Systems Manager User Guide</i>. </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyLevelLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension HierarchyLevelLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HierarchyTypeMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HierarchyTypeMismatchException(message: \(String(describing: message)))"}
}

extension HierarchyTypeMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: HierarchyTypeMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Parameter Store does not support changing a parameter type in a hierarchy. For example, you
///    can't change a parameter from a <code>String</code> type to a <code>SecureString</code> type. You
///    must create a new, unique parameter.</p>
public struct HierarchyTypeMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Parameter Store does not support changing a parameter type in a hierarchy. For example, you
    ///    can't change a parameter from a <code>String</code> type to a <code>SecureString</code> type. You
    ///    must create a new, unique parameter.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HierarchyTypeMismatchExceptionBody: Equatable {
    public let message: String?
}

extension HierarchyTypeMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IdempotentParameterMismatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatch(message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatch: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error returned when an idempotent operation is retried and the parameters don't match the
///    original call to the API with the same idempotency token. </p>
public struct IdempotentParameterMismatch: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchBody: Equatable {
    public let message: String?
}

extension IdempotentParameterMismatchBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatiblePolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatiblePolicyException(message: \(String(describing: message)))"}
}

extension IncompatiblePolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatiblePolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is a conflict in the policies specified for this parameter. You can't, for example,
///    specify two Expiration policies for a parameter. Review your policies, and try again.</p>
public struct IncompatiblePolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatiblePolicyExceptionBody: Equatable {
    public let message: String?
}

extension IncompatiblePolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceAggregatedAssociationOverview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detailedStatus = "DetailedStatus"
        case instanceAssociationStatusAggregatedCount = "InstanceAssociationStatusAggregatedCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount {
            var instanceAssociationStatusAggregatedCountContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .instanceAssociationStatusAggregatedCount)
            for (dictKey0, instanceassociationstatusaggregatedcount0) in instanceAssociationStatusAggregatedCount {
                try instanceAssociationStatusAggregatedCountContainer.encode(instanceassociationstatusaggregatedcount0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let instanceAssociationStatusAggregatedCountContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .instanceAssociationStatusAggregatedCount)
        var instanceAssociationStatusAggregatedCountDecoded0: [String:Int]? = nil
        if let instanceAssociationStatusAggregatedCountContainer = instanceAssociationStatusAggregatedCountContainer {
            instanceAssociationStatusAggregatedCountDecoded0 = [String:Int]()
            for (key0, instancecount0) in instanceAssociationStatusAggregatedCountContainer {
                if let instancecount0 = instancecount0 {
                    instanceAssociationStatusAggregatedCountDecoded0?[key0] = instancecount0
                }
            }
        }
        instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCountDecoded0
    }
}

extension InstanceAggregatedAssociationOverview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAggregatedAssociationOverview(detailedStatus: \(String(describing: detailedStatus)), instanceAssociationStatusAggregatedCount: \(String(describing: instanceAssociationStatusAggregatedCount)))"}
}

/// <p>Status information about the aggregated associations.</p>
public struct InstanceAggregatedAssociationOverview: Equatable {
    /// <p>Detailed status information about the aggregated associations.</p>
    public let detailedStatus: String?
    /// <p>The number of associations for the instance(s).</p>
    public let instanceAssociationStatusAggregatedCount: [String:Int]?

    public init (
        detailedStatus: String? = nil,
        instanceAssociationStatusAggregatedCount: [String:Int]? = nil
    )
    {
        self.detailedStatus = detailedStatus
        self.instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount
    }
}

extension InstanceAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationVersion = "AssociationVersion"
        case content = "Content"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
    }
}

extension InstanceAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAssociation(associationId: \(String(describing: associationId)), associationVersion: \(String(describing: associationVersion)), content: \(String(describing: content)), instanceId: \(String(describing: instanceId)))"}
}

/// <p>One or more association documents on the instance. </p>
public struct InstanceAssociation: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>Version information for the association on the instance.</p>
    public let associationVersion: String?
    /// <p>The content of the association document for the instance(s).</p>
    public let content: String?
    /// <p>The instance ID.</p>
    public let instanceId: String?

    public init (
        associationId: String? = nil,
        associationVersion: String? = nil,
        content: String? = nil,
        instanceId: String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.content = content
        self.instanceId = instanceId
    }
}

extension InstanceAssociationOutputLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3OutputLocation.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension InstanceAssociationOutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAssociationOutputLocation(s3Location: \(String(describing: s3Location)))"}
}

/// <p>An S3 bucket where you want to store the results of this request.</p>
///          <p>For the minimal permissions required to enable Amazon S3 output for an association, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-state-assoc.html">Creating
///     associations</a> in the <i>Systems Manager User Guide</i>. </p>
public struct InstanceAssociationOutputLocation: Equatable {
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    public let s3Location: S3OutputLocation?

    public init (
        s3Location: S3OutputLocation? = nil
    )
    {
        self.s3Location = s3Location
    }
}

extension InstanceAssociationOutputUrl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(S3OutputUrl.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
    }
}

extension InstanceAssociationOutputUrl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAssociationOutputUrl(s3OutputUrl: \(String(describing: s3OutputUrl)))"}
}

/// <p>The URL of S3 bucket where you want to store the results of this request.</p>
public struct InstanceAssociationOutputUrl: Equatable {
    /// <p>The URL of S3 bucket where you want to store the results of this request.</p>
    public let s3OutputUrl: S3OutputUrl?

    public init (
        s3OutputUrl: S3OutputUrl? = nil
    )
    {
        self.s3OutputUrl = s3OutputUrl
    }
}

extension InstanceAssociationStatusInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case detailedStatus = "DetailedStatus"
        case documentVersion = "DocumentVersion"
        case errorCode = "ErrorCode"
        case executionDate = "ExecutionDate"
        case executionSummary = "ExecutionSummary"
        case instanceId = "InstanceId"
        case name = "Name"
        case outputUrl = "OutputUrl"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let detailedStatus = detailedStatus {
            try encodeContainer.encode(detailedStatus, forKey: .detailedStatus)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let executionDate = executionDate {
            try encodeContainer.encode(executionDate.timeIntervalSince1970, forKey: .executionDate)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let executionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionDate)
        executionDate = executionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let detailedStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailedStatus)
        detailedStatus = detailedStatusDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
    }
}

extension InstanceAssociationStatusInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceAssociationStatusInfo(associationId: \(String(describing: associationId)), associationName: \(String(describing: associationName)), associationVersion: \(String(describing: associationVersion)), detailedStatus: \(String(describing: detailedStatus)), documentVersion: \(String(describing: documentVersion)), errorCode: \(String(describing: errorCode)), executionDate: \(String(describing: executionDate)), executionSummary: \(String(describing: executionSummary)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)), outputUrl: \(String(describing: outputUrl)), status: \(String(describing: status)))"}
}

/// <p>Status information about the instance association.</p>
public struct InstanceAssociationStatusInfo: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>The name of the association applied to the instance.</p>
    public let associationName: String?
    /// <p>The version of the association applied to the instance.</p>
    public let associationVersion: String?
    /// <p>Detailed status information about the instance association.</p>
    public let detailedStatus: String?
    /// <p>The association document versions.</p>
    public let documentVersion: String?
    /// <p>An error code returned by the request to create the association.</p>
    public let errorCode: String?
    /// <p>The date the instance association ran. </p>
    public let executionDate: Date?
    /// <p>Summary information about association execution.</p>
    public let executionSummary: String?
    /// <p>The instance ID where the association was created.</p>
    public let instanceId: String?
    /// <p>The name of the association.</p>
    public let name: String?
    /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
    public let outputUrl: InstanceAssociationOutputUrl?
    /// <p>Status information about the instance association.</p>
    public let status: String?

    public init (
        associationId: String? = nil,
        associationName: String? = nil,
        associationVersion: String? = nil,
        detailedStatus: String? = nil,
        documentVersion: String? = nil,
        errorCode: String? = nil,
        executionDate: Date? = nil,
        executionSummary: String? = nil,
        instanceId: String? = nil,
        name: String? = nil,
        outputUrl: InstanceAssociationOutputUrl? = nil,
        status: String? = nil
    )
    {
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.detailedStatus = detailedStatus
        self.documentVersion = documentVersion
        self.errorCode = errorCode
        self.executionDate = executionDate
        self.executionSummary = executionSummary
        self.instanceId = instanceId
        self.name = name
        self.outputUrl = outputUrl
        self.status = status
    }
}

extension InstanceInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activationId = "ActivationId"
        case agentVersion = "AgentVersion"
        case associationOverview = "AssociationOverview"
        case associationStatus = "AssociationStatus"
        case computerName = "ComputerName"
        case iPAddress = "IPAddress"
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
        case isLatestVersion = "IsLatestVersion"
        case lastAssociationExecutionDate = "LastAssociationExecutionDate"
        case lastPingDateTime = "LastPingDateTime"
        case lastSuccessfulAssociationExecutionDate = "LastSuccessfulAssociationExecutionDate"
        case name = "Name"
        case pingStatus = "PingStatus"
        case platformName = "PlatformName"
        case platformType = "PlatformType"
        case platformVersion = "PlatformVersion"
        case registrationDate = "RegistrationDate"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationId = activationId {
            try encodeContainer.encode(activationId, forKey: .activationId)
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let associationOverview = associationOverview {
            try encodeContainer.encode(associationOverview, forKey: .associationOverview)
        }
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let computerName = computerName {
            try encodeContainer.encode(computerName, forKey: .computerName)
        }
        if let iPAddress = iPAddress {
            try encodeContainer.encode(iPAddress, forKey: .iPAddress)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if isLatestVersion != false {
            try encodeContainer.encode(isLatestVersion, forKey: .isLatestVersion)
        }
        if let lastAssociationExecutionDate = lastAssociationExecutionDate {
            try encodeContainer.encode(lastAssociationExecutionDate.timeIntervalSince1970, forKey: .lastAssociationExecutionDate)
        }
        if let lastPingDateTime = lastPingDateTime {
            try encodeContainer.encode(lastPingDateTime.timeIntervalSince1970, forKey: .lastPingDateTime)
        }
        if let lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate {
            try encodeContainer.encode(lastSuccessfulAssociationExecutionDate.timeIntervalSince1970, forKey: .lastSuccessfulAssociationExecutionDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pingStatus = pingStatus {
            try encodeContainer.encode(pingStatus.rawValue, forKey: .pingStatus)
        }
        if let platformName = platformName {
            try encodeContainer.encode(platformName, forKey: .platformName)
        }
        if let platformType = platformType {
            try encodeContainer.encode(platformType.rawValue, forKey: .platformType)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let registrationDate = registrationDate {
            try encodeContainer.encode(registrationDate.timeIntervalSince1970, forKey: .registrationDate)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let pingStatusDecoded = try containerValues.decodeIfPresent(PingStatus.self, forKey: .pingStatus)
        pingStatus = pingStatusDecoded
        let lastPingDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastPingDateTime)
        lastPingDateTime = lastPingDateTimeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let isLatestVersionDecoded = try containerValues.decode(Bool.self, forKey: .isLatestVersion)
        isLatestVersion = isLatestVersionDecoded
        let platformTypeDecoded = try containerValues.decodeIfPresent(PlatformType.self, forKey: .platformType)
        platformType = platformTypeDecoded
        let platformNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformName)
        platformName = platformNameDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let activationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activationId)
        activationId = activationIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let registrationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .registrationDate)
        registrationDate = registrationDateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let iPAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPAddress)
        iPAddress = iPAddressDecoded
        let computerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computerName)
        computerName = computerNameDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let lastAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAssociationExecutionDate)
        lastAssociationExecutionDate = lastAssociationExecutionDateDecoded
        let lastSuccessfulAssociationExecutionDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulAssociationExecutionDate)
        lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDateDecoded
        let associationOverviewDecoded = try containerValues.decodeIfPresent(InstanceAggregatedAssociationOverview.self, forKey: .associationOverview)
        associationOverview = associationOverviewDecoded
    }
}

extension InstanceInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceInformation(activationId: \(String(describing: activationId)), agentVersion: \(String(describing: agentVersion)), associationOverview: \(String(describing: associationOverview)), associationStatus: \(String(describing: associationStatus)), computerName: \(String(describing: computerName)), iPAddress: \(String(describing: iPAddress)), iamRole: \(String(describing: iamRole)), instanceId: \(String(describing: instanceId)), isLatestVersion: \(String(describing: isLatestVersion)), lastAssociationExecutionDate: \(String(describing: lastAssociationExecutionDate)), lastPingDateTime: \(String(describing: lastPingDateTime)), lastSuccessfulAssociationExecutionDate: \(String(describing: lastSuccessfulAssociationExecutionDate)), name: \(String(describing: name)), pingStatus: \(String(describing: pingStatus)), platformName: \(String(describing: platformName)), platformType: \(String(describing: platformType)), platformVersion: \(String(describing: platformVersion)), registrationDate: \(String(describing: registrationDate)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Describes a filter for a specific list of instances. </p>
public struct InstanceInformation: Equatable {
    /// <p>The activation ID created by Systems Manager when the server or VM was registered.</p>
    public let activationId: String?
    /// <p>The version of SSM Agent running on your Linux instance. </p>
    public let agentVersion: String?
    /// <p>Information about the association.</p>
    public let associationOverview: InstanceAggregatedAssociationOverview?
    /// <p>The status of the association.</p>
    public let associationStatus: String?
    /// <p>The fully qualified host name of the managed instance.</p>
    public let computerName: String?
    /// <p>The IP address of the managed instance.</p>
    public let iPAddress: String?
    /// <p>The Amazon Identity and Access Management (IAM) role assigned to the on-premises Systems Manager
    ///    managed instance. This call does not return the IAM role for EC2 instances. To retrieve the IAM
    ///    role for an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> action. For information,
    ///    see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
    ///    <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
    public let iamRole: String?
    /// <p>The instance ID. </p>
    public let instanceId: String?
    /// <p>Indicates whether the latest version of SSM Agent is running on your Linux Managed Instance.
    ///    This field does not indicate whether or not the latest version is installed on Windows managed
    ///    instances, because some older versions of Windows Server use the EC2Config service to process SSM
    ///    requests.</p>
    public let isLatestVersion: Bool
    /// <p>The date the association was last run.</p>
    public let lastAssociationExecutionDate: Date?
    /// <p>The date and time when the agent last pinged the Systems Manager service. </p>
    public let lastPingDateTime: Date?
    /// <p>The last date the association was successfully run.</p>
    public let lastSuccessfulAssociationExecutionDate: Date?
    /// <p>The name assigned to an on-premises server or virtual machine (VM) when it is activated as a
    ///    Systems Manager managed instance. The name is specified as the <code>DefaultInstanceName</code> property
    ///    using the <a>CreateActivation</a> command. It is applied to the managed instance by
    ///    specifying the Activation Code and Activation ID when you install SSM Agent on the instance, as
    ///    explained in <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html">Install SSM Agent for a
    ///     hybrid environment (Linux)</a> and <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html">Install SSM Agent for a hybrid environment
    ///     (Windows)</a>. To retrieve the Name tag of an EC2 instance, use the Amazon EC2
    ///    <code>DescribeInstances</code> action. For information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> in the
    ///    <i>Amazon EC2 API Reference</i> or <a href="https://docs.aws.amazon.com/cli/latest/ec2/describe-instances.html">describe-instances</a> in the <i>AWS CLI Command Reference</i>.</p>
    public let name: String?
    /// <p>Connection status of SSM Agent. </p>
    ///          <note>
    ///             <p>The status <code>Inactive</code> has been deprecated and is no longer in use.</p>
    ///          </note>
    public let pingStatus: PingStatus?
    /// <p>The name of the operating system platform running on your instance. </p>
    public let platformName: String?
    /// <p>The operating system platform type. </p>
    public let platformType: PlatformType?
    /// <p>The version of the OS platform running on your instance. </p>
    public let platformVersion: String?
    /// <p>The date the server or VM was registered with AWS as a managed instance.</p>
    public let registrationDate: Date?
    /// <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
    public let resourceType: ResourceType?

    public init (
        activationId: String? = nil,
        agentVersion: String? = nil,
        associationOverview: InstanceAggregatedAssociationOverview? = nil,
        associationStatus: String? = nil,
        computerName: String? = nil,
        iPAddress: String? = nil,
        iamRole: String? = nil,
        instanceId: String? = nil,
        isLatestVersion: Bool = false,
        lastAssociationExecutionDate: Date? = nil,
        lastPingDateTime: Date? = nil,
        lastSuccessfulAssociationExecutionDate: Date? = nil,
        name: String? = nil,
        pingStatus: PingStatus? = nil,
        platformName: String? = nil,
        platformType: PlatformType? = nil,
        platformVersion: String? = nil,
        registrationDate: Date? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.activationId = activationId
        self.agentVersion = agentVersion
        self.associationOverview = associationOverview
        self.associationStatus = associationStatus
        self.computerName = computerName
        self.iPAddress = iPAddress
        self.iamRole = iamRole
        self.instanceId = instanceId
        self.isLatestVersion = isLatestVersion
        self.lastAssociationExecutionDate = lastAssociationExecutionDate
        self.lastPingDateTime = lastPingDateTime
        self.lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate
        self.name = name
        self.pingStatus = pingStatus
        self.platformName = platformName
        self.platformType = platformType
        self.platformVersion = platformVersion
        self.registrationDate = registrationDate
        self.resourceType = resourceType
    }
}

extension InstanceInformationFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case valueSet
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let valueSet = valueSet {
            var valueSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueSet)
            for instanceinformationfiltervalueset0 in valueSet {
                try valueSetContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(InstanceInformationFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueSetContainer = try containerValues.decodeIfPresent([String?].self, forKey: .valueSet)
        var valueSetDecoded0:[String]? = nil
        if let valueSetContainer = valueSetContainer {
            valueSetDecoded0 = [String]()
            for string0 in valueSetContainer {
                if let string0 = string0 {
                    valueSetDecoded0?.append(string0)
                }
            }
        }
        valueSet = valueSetDecoded0
    }
}

extension InstanceInformationFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceInformationFilter(key: \(String(describing: key)), valueSet: \(String(describing: valueSet)))"}
}

/// <p>Describes a filter for a specific list of instances. You can filter instances information by
///    using tags. You specify tags by using a key-value mapping.</p>
///          <p>Use this action instead of the <a>DescribeInstanceInformationRequest$InstanceInformationFilterList</a> method. The
///     <code>InstanceInformationFilterList</code> method is a legacy method and does not support tags.
///   </p>
public struct InstanceInformationFilter: Equatable {
    /// <p>The name of the filter. </p>
    public let key: InstanceInformationFilterKey?
    /// <p>The filter values.</p>
    public let valueSet: [String]?

    public init (
        key: InstanceInformationFilterKey? = nil,
        valueSet: [String]? = nil
    )
    {
        self.key = key
        self.valueSet = valueSet
    }
}

public enum InstanceInformationFilterKey {
    case activationIds
    case agentVersion
    case associationStatus
    case iamRole
    case instanceIds
    case pingStatus
    case platformTypes
    case resourceType
    case sdkUnknown(String)
}

extension InstanceInformationFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstanceInformationFilterKey] {
        return [
            .activationIds,
            .agentVersion,
            .associationStatus,
            .iamRole,
            .instanceIds,
            .pingStatus,
            .platformTypes,
            .resourceType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activationIds: return "ActivationIds"
        case .agentVersion: return "AgentVersion"
        case .associationStatus: return "AssociationStatus"
        case .iamRole: return "IamRole"
        case .instanceIds: return "InstanceIds"
        case .pingStatus: return "PingStatus"
        case .platformTypes: return "PlatformTypes"
        case .resourceType: return "ResourceType"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstanceInformationFilterKey(rawValue: rawValue) ?? InstanceInformationFilterKey.sdkUnknown(rawValue)
    }
}

extension InstanceInformationStringFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instanceinformationfiltervalueset0 in values {
                try valuesContainer.encode(instanceinformationfiltervalueset0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension InstanceInformationStringFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceInformationStringFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>The filters to describe or get information about your managed instances.</p>
public struct InstanceInformationStringFilter: Equatable {
    /// <p>The filter key name to describe your instances. For example:</p>
    ///          <p>"InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag
    ///    Key"</p>
    ///          <important>
    ///             <p>
    ///                <code>Tag key</code> is not a valid filter. You must specify either <code>tag-key</code> or
    ///      <code>tag:keyname</code> and a string. Here are some valid examples: tag-key, tag:123, tag:al!,
    ///     tag:Windows. Here are some <i>invalid</i> examples: tag-keys, Tag Key, tag:,
    ///     tagKey, abc:keyname.</p>
    ///          </important>
    public let key: String?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension InstancePatchState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case criticalNonCompliantCount = "CriticalNonCompliantCount"
        case failedCount = "FailedCount"
        case installOverrideList = "InstallOverrideList"
        case installedCount = "InstalledCount"
        case installedOtherCount = "InstalledOtherCount"
        case installedPendingRebootCount = "InstalledPendingRebootCount"
        case installedRejectedCount = "InstalledRejectedCount"
        case instanceId = "InstanceId"
        case lastNoRebootInstallOperationTime = "LastNoRebootInstallOperationTime"
        case missingCount = "MissingCount"
        case notApplicableCount = "NotApplicableCount"
        case operation = "Operation"
        case operationEndTime = "OperationEndTime"
        case operationStartTime = "OperationStartTime"
        case otherNonCompliantCount = "OtherNonCompliantCount"
        case ownerInformation = "OwnerInformation"
        case patchGroup = "PatchGroup"
        case rebootOption = "RebootOption"
        case securityNonCompliantCount = "SecurityNonCompliantCount"
        case snapshotId = "SnapshotId"
        case unreportedNotApplicableCount = "UnreportedNotApplicableCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if criticalNonCompliantCount != 0 {
            try encodeContainer.encode(criticalNonCompliantCount, forKey: .criticalNonCompliantCount)
        }
        if failedCount != 0 {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let installOverrideList = installOverrideList {
            try encodeContainer.encode(installOverrideList, forKey: .installOverrideList)
        }
        if installedCount != 0 {
            try encodeContainer.encode(installedCount, forKey: .installedCount)
        }
        if installedOtherCount != 0 {
            try encodeContainer.encode(installedOtherCount, forKey: .installedOtherCount)
        }
        if installedPendingRebootCount != 0 {
            try encodeContainer.encode(installedPendingRebootCount, forKey: .installedPendingRebootCount)
        }
        if installedRejectedCount != 0 {
            try encodeContainer.encode(installedRejectedCount, forKey: .installedRejectedCount)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime {
            try encodeContainer.encode(lastNoRebootInstallOperationTime.timeIntervalSince1970, forKey: .lastNoRebootInstallOperationTime)
        }
        if missingCount != 0 {
            try encodeContainer.encode(missingCount, forKey: .missingCount)
        }
        if notApplicableCount != 0 {
            try encodeContainer.encode(notApplicableCount, forKey: .notApplicableCount)
        }
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let operationEndTime = operationEndTime {
            try encodeContainer.encode(operationEndTime.timeIntervalSince1970, forKey: .operationEndTime)
        }
        if let operationStartTime = operationStartTime {
            try encodeContainer.encode(operationStartTime.timeIntervalSince1970, forKey: .operationStartTime)
        }
        if otherNonCompliantCount != 0 {
            try encodeContainer.encode(otherNonCompliantCount, forKey: .otherNonCompliantCount)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
        if let rebootOption = rebootOption {
            try encodeContainer.encode(rebootOption.rawValue, forKey: .rebootOption)
        }
        if securityNonCompliantCount != 0 {
            try encodeContainer.encode(securityNonCompliantCount, forKey: .securityNonCompliantCount)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if unreportedNotApplicableCount != 0 {
            try encodeContainer.encode(unreportedNotApplicableCount, forKey: .unreportedNotApplicableCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let installOverrideListDecoded = try containerValues.decodeIfPresent(String.self, forKey: .installOverrideList)
        installOverrideList = installOverrideListDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let installedCountDecoded = try containerValues.decode(Int.self, forKey: .installedCount)
        installedCount = installedCountDecoded
        let installedOtherCountDecoded = try containerValues.decode(Int.self, forKey: .installedOtherCount)
        installedOtherCount = installedOtherCountDecoded
        let installedPendingRebootCountDecoded = try containerValues.decode(Int.self, forKey: .installedPendingRebootCount)
        installedPendingRebootCount = installedPendingRebootCountDecoded
        let installedRejectedCountDecoded = try containerValues.decode(Int.self, forKey: .installedRejectedCount)
        installedRejectedCount = installedRejectedCountDecoded
        let missingCountDecoded = try containerValues.decode(Int.self, forKey: .missingCount)
        missingCount = missingCountDecoded
        let failedCountDecoded = try containerValues.decode(Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let unreportedNotApplicableCountDecoded = try containerValues.decode(Int.self, forKey: .unreportedNotApplicableCount)
        unreportedNotApplicableCount = unreportedNotApplicableCountDecoded
        let notApplicableCountDecoded = try containerValues.decode(Int.self, forKey: .notApplicableCount)
        notApplicableCount = notApplicableCountDecoded
        let operationStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .operationStartTime)
        operationStartTime = operationStartTimeDecoded
        let operationEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .operationEndTime)
        operationEndTime = operationEndTimeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(PatchOperationType.self, forKey: .operation)
        operation = operationDecoded
        let lastNoRebootInstallOperationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastNoRebootInstallOperationTime)
        lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTimeDecoded
        let rebootOptionDecoded = try containerValues.decodeIfPresent(RebootOption.self, forKey: .rebootOption)
        rebootOption = rebootOptionDecoded
        let criticalNonCompliantCountDecoded = try containerValues.decode(Int.self, forKey: .criticalNonCompliantCount)
        criticalNonCompliantCount = criticalNonCompliantCountDecoded
        let securityNonCompliantCountDecoded = try containerValues.decode(Int.self, forKey: .securityNonCompliantCount)
        securityNonCompliantCount = securityNonCompliantCountDecoded
        let otherNonCompliantCountDecoded = try containerValues.decode(Int.self, forKey: .otherNonCompliantCount)
        otherNonCompliantCount = otherNonCompliantCountDecoded
    }
}

extension InstancePatchState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstancePatchState(baselineId: \(String(describing: baselineId)), criticalNonCompliantCount: \(String(describing: criticalNonCompliantCount)), failedCount: \(String(describing: failedCount)), installOverrideList: \(String(describing: installOverrideList)), installedCount: \(String(describing: installedCount)), installedOtherCount: \(String(describing: installedOtherCount)), installedPendingRebootCount: \(String(describing: installedPendingRebootCount)), installedRejectedCount: \(String(describing: installedRejectedCount)), instanceId: \(String(describing: instanceId)), lastNoRebootInstallOperationTime: \(String(describing: lastNoRebootInstallOperationTime)), missingCount: \(String(describing: missingCount)), notApplicableCount: \(String(describing: notApplicableCount)), operation: \(String(describing: operation)), operationEndTime: \(String(describing: operationEndTime)), operationStartTime: \(String(describing: operationStartTime)), otherNonCompliantCount: \(String(describing: otherNonCompliantCount)), ownerInformation: \(String(describing: ownerInformation)), patchGroup: \(String(describing: patchGroup)), rebootOption: \(String(describing: rebootOption)), securityNonCompliantCount: \(String(describing: securityNonCompliantCount)), snapshotId: \(String(describing: snapshotId)), unreportedNotApplicableCount: \(String(describing: unreportedNotApplicableCount)))"}
}

/// <p>Defines the high-level patch compliance state for a managed instance, providing information
///    about the number of installed, missing, not applicable, and failed patches along with metadata
///    about the operation when this information was gathered for the instance.</p>
public struct InstancePatchState: Equatable {
    /// <p>The ID of the patch baseline used to patch the instance.</p>
    public let baselineId: String?
    /// <p>The number of instances where patches that are specified as "Critical" for compliance
    ///    reporting in the patch baseline are not installed. These patches might be missing, have failed
    ///    installation, were rejected, or were installed but awaiting a required instance reboot. The
    ///    status of these instances is <code>NON_COMPLIANT</code>.</p>
    public let criticalNonCompliantCount: Int
    /// <p>The number of patches from the patch baseline that were attempted to be installed during the
    ///    last patching operation, but failed to install.</p>
    public let failedCount: Int
    /// <p>An https URL or an Amazon S3 path-style URL to a list of patches to be installed. This patch
    ///    installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM
    ///    document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch
    ///    baseline.</p>
    ///          <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the
    ///     SSM document AWS-RunPatchBaseline</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let installOverrideList: String?
    /// <p>The number of patches from the patch baseline that are installed on the instance.</p>
    public let installedCount: Int
    /// <p>The number of patches not specified in the patch baseline that are installed on the
    ///    instance.</p>
    public let installedOtherCount: Int
    /// <p>The number of patches installed by Patch Manager since the last time the instance was
    ///    rebooted.</p>
    public let installedPendingRebootCount: Int
    /// <p>The number of patches installed on an instance that are specified in a
    ///     <code>RejectedPatches</code> list. Patches with a status of
    ///     <i>InstalledRejected</i> were typically installed before they were added to a
    ///     <code>RejectedPatches</code> list.</p>
    ///          <note>
    ///             <p>If <code>ALLOW_AS_DEPENDENCY</code> is the specified option for
    ///      <code>RejectedPatchesAction</code>, the value of <code>InstalledRejectedCount</code> will
    ///     always be <code>0</code> (zero).</p>
    ///          </note>
    public let installedRejectedCount: Int
    /// <p>The ID of the managed instance the high-level patch compliance information was collected
    ///    for.</p>
    public let instanceId: String?
    /// <p>The time of the last attempt to patch the instance with <code>NoReboot</code> specified as
    ///    the reboot option.</p>
    public let lastNoRebootInstallOperationTime: Date?
    /// <p>The number of patches from the patch baseline that are applicable for the instance but
    ///    aren't currently installed.</p>
    public let missingCount: Int
    /// <p>The number of patches from the patch baseline that aren't applicable for the instance and
    ///    therefore aren't installed on the instance. This number may be truncated if the list of patch
    ///    names is very large. The number of patches beyond this limit are reported in
    ///     <code>UnreportedNotApplicableCount</code>.</p>
    public let notApplicableCount: Int
    /// <p>The type of patching operation that was performed: <code>SCAN</code> (assess patch
    ///    compliance state) or <code>INSTALL</code> (install missing patches).</p>
    public let operation: PatchOperationType?
    /// <p>The time the most recent patching operation completed on the instance.</p>
    public let operationEndTime: Date?
    /// <p>The time the most recent patching operation was started on the instance.</p>
    public let operationStartTime: Date?
    /// <p>The number of instances with patches installed that are specified as other than "Critical"
    ///    or "Security" but are not compliant with the patch baseline. The status of these instances is
    ///    NON_COMPLIANT.</p>
    public let otherNonCompliantCount: Int
    /// <p>Placeholder information. This field will always be empty in the current release of the
    ///    service.</p>
    public let ownerInformation: String?
    /// <p>The name of the patch group the managed instance belongs to.</p>
    public let patchGroup: String?
    /// <p>Indicates the reboot option specified in the patch baseline.</p>
    ///          <note>
    ///             <p>Reboot options apply to <code>Install</code> operations only. Reboots are not attempted for
    ///     Patch Manager <code>Scan</code> operations.</p>
    ///          </note>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>RebootIfNeeded</b>: Patch Manager tries to reboot the
    ///      instance if it installed any patches, or if any patches are detected with a status of
    ///       <code>InstalledPendingReboot</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NoReboot</b>: Patch Manager attempts to install missing
    ///      packages without trying to reboot the system. Patches installed with this option are assigned a
    ///      status of <code>InstalledPendingReboot</code>. These patches might not be in effect until a
    ///      reboot is performed.</p>
    ///             </li>
    ///          </ul>
    public let rebootOption: RebootOption?
    /// <p>The number of instances where patches that are specified as "Security" in a patch advisory
    ///    are not installed. These patches might be missing, have failed installation, were rejected, or
    ///    were installed but awaiting a required instance reboot. The status of these instances is
    ///     <code>NON_COMPLIANT</code>.</p>
    public let securityNonCompliantCount: Int
    /// <p>The ID of the patch baseline snapshot used during the patching operation when this
    ///    compliance data was collected.</p>
    public let snapshotId: String?
    /// <p>The number of patches beyond the supported limit of <code>NotApplicableCount</code> that are
    ///    not reported by name to Systems Manager Inventory.</p>
    public let unreportedNotApplicableCount: Int

    public init (
        baselineId: String? = nil,
        criticalNonCompliantCount: Int = 0,
        failedCount: Int = 0,
        installOverrideList: String? = nil,
        installedCount: Int = 0,
        installedOtherCount: Int = 0,
        installedPendingRebootCount: Int = 0,
        installedRejectedCount: Int = 0,
        instanceId: String? = nil,
        lastNoRebootInstallOperationTime: Date? = nil,
        missingCount: Int = 0,
        notApplicableCount: Int = 0,
        operation: PatchOperationType? = nil,
        operationEndTime: Date? = nil,
        operationStartTime: Date? = nil,
        otherNonCompliantCount: Int = 0,
        ownerInformation: String? = nil,
        patchGroup: String? = nil,
        rebootOption: RebootOption? = nil,
        securityNonCompliantCount: Int = 0,
        snapshotId: String? = nil,
        unreportedNotApplicableCount: Int = 0
    )
    {
        self.baselineId = baselineId
        self.criticalNonCompliantCount = criticalNonCompliantCount
        self.failedCount = failedCount
        self.installOverrideList = installOverrideList
        self.installedCount = installedCount
        self.installedOtherCount = installedOtherCount
        self.installedPendingRebootCount = installedPendingRebootCount
        self.installedRejectedCount = installedRejectedCount
        self.instanceId = instanceId
        self.lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime
        self.missingCount = missingCount
        self.notApplicableCount = notApplicableCount
        self.operation = operation
        self.operationEndTime = operationEndTime
        self.operationStartTime = operationStartTime
        self.otherNonCompliantCount = otherNonCompliantCount
        self.ownerInformation = ownerInformation
        self.patchGroup = patchGroup
        self.rebootOption = rebootOption
        self.securityNonCompliantCount = securityNonCompliantCount
        self.snapshotId = snapshotId
        self.unreportedNotApplicableCount = unreportedNotApplicableCount
    }
}

extension InstancePatchStateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for instancepatchstatefiltervalues0 in values {
                try valuesContainer.encode(instancepatchstatefiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(InstancePatchStateOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension InstancePatchStateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstancePatchStateFilter(key: \(String(describing: key)), type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>Defines a filter used in <a>DescribeInstancePatchStatesForPatchGroup</a> used to
///    scope down the information returned by the API.</p>
public struct InstancePatchStateFilter: Equatable {
    /// <p>The key for the filter. Supported values are FailedCount, InstalledCount,
    ///    InstalledOtherCount, MissingCount and NotApplicableCount.</p>
    public let key: String?
    /// <p>The type of comparison that should be performed for the value: Equal, NotEqual, LessThan or
    ///    GreaterThan.</p>
    public let type: InstancePatchStateOperatorType?
    /// <p>The value for the filter, must be an integer greater than or equal to 0.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        type: InstancePatchStateOperatorType? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.type = type
        self.values = values
    }
}

public enum InstancePatchStateOperatorType {
    case equal
    case greaterThan
    case lessThan
    case notEqual
    case sdkUnknown(String)
}

extension InstancePatchStateOperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InstancePatchStateOperatorType] {
        return [
            .equal,
            .greaterThan,
            .lessThan,
            .notEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "Equal"
        case .greaterThan: return "GreaterThan"
        case .lessThan: return "LessThan"
        case .notEqual: return "NotEqual"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InstancePatchStateOperatorType(rawValue: rawValue) ?? InstancePatchStateOperatorType.sdkUnknown(rawValue)
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred on the server side.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidActivation(message: \(String(describing: message)))"}
}

extension InvalidActivation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidActivationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The activation is not valid. The activation might have been deleted, or the ActivationId and
///    the ActivationCode do not match.</p>
public struct InvalidActivation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationBody: Equatable {
    public let message: String?
}

extension InvalidActivationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActivationId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidActivationId(message: \(String(describing: message)))"}
}

extension InvalidActivationId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidActivationIdBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The activation ID is not valid. Verify the you entered the correct ActivationId or
///    ActivationCode and try again.</p>
public struct InvalidActivationId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActivationIdBody: Equatable {
    public let message: String?
}

extension InvalidActivationIdBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAggregatorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAggregatorException(message: \(String(describing: message)))"}
}

extension InvalidAggregatorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAggregatorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified aggregator is not valid for inventory groups. Verify that the aggregator uses
///    a valid inventory type such as <code>AWS:Application</code> or
///     <code>AWS:InstanceInformation</code>.</p>
public struct InvalidAggregatorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAggregatorExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAggregatorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAllowedPatternException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAllowedPatternException(message: \(String(describing: message)))"}
}

extension InvalidAllowedPatternException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAllowedPatternExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request does not meet the regular expression requirement.</p>
public struct InvalidAllowedPatternException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The request does not meet the regular expression requirement.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAllowedPatternExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAllowedPatternExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAssociation(message: \(String(describing: message)))"}
}

extension InvalidAssociation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAssociationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The association is not valid or does not exist. </p>
public struct InvalidAssociation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationBody: Equatable {
    public let message: String?
}

extension InvalidAssociationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAssociationVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAssociationVersion(message: \(String(describing: message)))"}
}

extension InvalidAssociationVersion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAssociationVersionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The version you specified is not valid. Use ListAssociationVersions to view all versions of
///    an association according to the association ID. Or, use the <code>$LATEST</code> parameter to
///    view the latest version of the association.</p>
public struct InvalidAssociationVersion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAssociationVersionBody: Equatable {
    public let message: String?
}

extension InvalidAssociationVersionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationExecutionParametersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAutomationExecutionParametersException(message: \(String(describing: message)))"}
}

extension InvalidAutomationExecutionParametersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAutomationExecutionParametersExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied parameters for invoking the specified Automation document are incorrect. For
///    example, they may not match the set of parameters permitted for the specified Automation
///    document.</p>
public struct InvalidAutomationExecutionParametersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationExecutionParametersExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAutomationExecutionParametersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationSignalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAutomationSignalException(message: \(String(describing: message)))"}
}

extension InvalidAutomationSignalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAutomationSignalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The signal is not valid for the current Automation execution.</p>
public struct InvalidAutomationSignalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationSignalExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAutomationSignalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAutomationStatusUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAutomationStatusUpdateException(message: \(String(describing: message)))"}
}

extension InvalidAutomationStatusUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAutomationStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified update status operation is not valid.</p>
public struct InvalidAutomationStatusUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAutomationStatusUpdateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAutomationStatusUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommandId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCommandId()"}
}

extension InvalidCommandId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified command ID is not valid. Verify the ID and try again.</p>
public struct InvalidCommandId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidDeleteInventoryParametersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeleteInventoryParametersException(message: \(String(describing: message)))"}
}

extension InvalidDeleteInventoryParametersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeleteInventoryParametersExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the parameters specified for the delete operation is not valid. Verify all
///    parameters and try again.</p>
public struct InvalidDeleteInventoryParametersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeleteInventoryParametersExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeleteInventoryParametersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeletionIdException(message: \(String(describing: message)))"}
}

extension InvalidDeletionIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeletionIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The ID specified for the delete operation does not exist or is not valid. Verify the ID and
///    try again.</p>
public struct InvalidDeletionIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeletionIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeletionIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocument(message: \(String(describing: message)))"}
}

extension InvalidDocument: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified document does not exist.</p>
public struct InvalidDocument: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The document does not exist or the document is not available to the user. This exception can
    ///    be issued by CreateAssociation, CreateAssociationBatch, DeleteAssociation, DeleteDocument,
    ///    DescribeAssociation, DescribeDocument, GetDocument, SendCommand, or UpdateAssociationStatus.
    ///   </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentBody: Equatable {
    public let message: String?
}

extension InvalidDocumentBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocumentContent(message: \(String(describing: message)))"}
}

extension InvalidDocumentContent: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentContentBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content for the document is not valid.</p>
public struct InvalidDocumentContent: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A description of the validation error.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentContentBody: Equatable {
    public let message: String?
}

extension InvalidDocumentContentBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocumentOperation(message: \(String(describing: message)))"}
}

extension InvalidDocumentOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentOperationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You attempted to delete a document while it is still shared. You must stop sharing the
///    document before you can delete it.</p>
public struct InvalidDocumentOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentOperationBody: Equatable {
    public let message: String?
}

extension InvalidDocumentOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentSchemaVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocumentSchemaVersion(message: \(String(describing: message)))"}
}

extension InvalidDocumentSchemaVersion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentSchemaVersionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The version of the document schema is not supported.</p>
public struct InvalidDocumentSchemaVersion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentSchemaVersionBody: Equatable {
    public let message: String?
}

extension InvalidDocumentSchemaVersionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocumentType(message: \(String(describing: message)))"}
}

extension InvalidDocumentType: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentTypeBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document type is not valid. Valid document types are described in the
///     <code>DocumentType</code> property.</p>
public struct InvalidDocumentType: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentTypeBody: Equatable {
    public let message: String?
}

extension InvalidDocumentTypeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDocumentVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDocumentVersion(message: \(String(describing: message)))"}
}

extension InvalidDocumentVersion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDocumentVersionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document version is not valid or does not exist.</p>
public struct InvalidDocumentVersion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDocumentVersionBody: Equatable {
    public let message: String?
}

extension InvalidDocumentVersionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilter(message: \(String(describing: message)))"}
}

extension InvalidFilter: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilterBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter name is not valid. Verify the you entered the correct name and try again.</p>
public struct InvalidFilter: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterBody: Equatable {
    public let message: String?
}

extension InvalidFilterBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilterKey()"}
}

extension InvalidFilterKey: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified key is not valid.</p>
public struct InvalidFilterKey: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidFilterOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilterOption(message: \(String(describing: message)))"}
}

extension InvalidFilterOption: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilterOptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified filter option is not valid. Valid options are Equals and BeginsWith. For Path
///    filter, valid options are Recursive and OneLevel.</p>
public struct InvalidFilterOption: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The specified filter option is not valid. Valid options are Equals and BeginsWith. For Path
    ///    filter, valid options are Recursive and OneLevel.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterOptionBody: Equatable {
    public let message: String?
}

extension InvalidFilterOptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilterValue(message: \(String(describing: message)))"}
}

extension InvalidFilterValue: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilterValueBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter value is not valid. Verify the value and try again.</p>
public struct InvalidFilterValue: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterValueBody: Equatable {
    public let message: String?
}

extension InvalidFilterValueBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInstanceId(message: \(String(describing: message)))"}
}

extension InvalidInstanceId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInstanceIdBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The following problems can cause this exception:</p>
///          <p>You do not have permission to access the instance.</p>
///          <p>SSM Agent is not running. Verify that SSM Agent is running.</p>
///          <p>SSM Agent is not registered with the SSM endpoint. Try reinstalling SSM Agent.</p>
///          <p>The instance is not in valid state. Valid states are: Running, Pending, Stopped, Stopping.
///    Invalid states are: Shutting-down and Terminated.</p>
public struct InvalidInstanceId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceIdBody: Equatable {
    public let message: String?
}

extension InvalidInstanceIdBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInstanceInformationFilterValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInstanceInformationFilterValue(message: \(String(describing: message)))"}
}

extension InvalidInstanceInformationFilterValue: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInstanceInformationFilterValueBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified filter value is not valid.</p>
public struct InvalidInstanceInformationFilterValue: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInstanceInformationFilterValueBody: Equatable {
    public let message: String?
}

extension InvalidInstanceInformationFilterValueBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryGroupException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInventoryGroupException(message: \(String(describing: message)))"}
}

extension InvalidInventoryGroupException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInventoryGroupExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified inventory group is not valid.</p>
public struct InvalidInventoryGroupException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryGroupExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInventoryGroupExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryItemContextException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInventoryItemContextException(message: \(String(describing: message)))"}
}

extension InvalidInventoryItemContextException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified invalid keys or values in the <code>Context</code> attribute for
///     <code>InventoryItem</code>. Verify the keys and values, and try again.</p>
public struct InvalidInventoryItemContextException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryItemContextExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInventoryItemContextExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInventoryRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInventoryRequestException(message: \(String(describing: message)))"}
}

extension InvalidInventoryRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInventoryRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidInventoryRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInventoryRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInventoryRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidItemContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidItemContentException(message: \(String(describing: message)), typeName: \(String(describing: typeName)))"}
}

extension InvalidItemContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidItemContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more content items is not valid.</p>
public struct InvalidItemContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var typeName: String?

    public init (
        message: String? = nil,
        typeName: String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct InvalidItemContentExceptionBody: Equatable {
    public let typeName: String?
    public let message: String?
}

extension InvalidItemContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKeyId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidKeyId(message: \(String(describing: message)))"}
}

extension InvalidKeyId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidKeyIdBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The query key ID is not valid.</p>
public struct InvalidKeyId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKeyIdBody: Equatable {
    public let message: String?
}

extension InvalidKeyIdBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextToken: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextToken(message: \(String(describing: message)))"}
}

extension InvalidNextToken: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified token is not valid.</p>
public struct InvalidNextToken: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNotificationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNotificationConfig(message: \(String(describing: message)))"}
}

extension InvalidNotificationConfig: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNotificationConfigBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more configuration items is not valid. Verify that a valid Amazon Resource Name (ARN)
///    was provided for an Amazon SNS topic.</p>
public struct InvalidNotificationConfig: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNotificationConfigBody: Equatable {
    public let message: String?
}

extension InvalidNotificationConfigBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOptionException(message: \(String(describing: message)))"}
}

extension InvalidOptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The delete inventory option specified is not valid. Verify the option and try again.</p>
public struct InvalidOptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOutputFolder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOutputFolder()"}
}

extension InvalidOutputFolder: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The S3 bucket does not exist.</p>
public struct InvalidOutputFolder: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidOutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOutputLocation()"}
}

extension InvalidOutputLocation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The output location is not valid or does not exist.</p>
public struct InvalidOutputLocation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameters(message: \(String(describing: message)))"}
}

extension InvalidParameters: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParametersBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You must specify values for all required parameters in the Systems Manager document. You can only
///    supply values to parameters defined in the Systems Manager document.</p>
public struct InvalidParameters: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParametersBody: Equatable {
    public let message: String?
}

extension InvalidParametersBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPermissionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPermissionType(message: \(String(describing: message)))"}
}

extension InvalidPermissionType: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPermissionTypeBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The permission type is not supported. <i>Share</i> is the only supported
///    permission type.</p>
public struct InvalidPermissionType: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPermissionTypeBody: Equatable {
    public let message: String?
}

extension InvalidPermissionTypeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPluginName: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPluginName()"}
}

extension InvalidPluginName: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The plugin name is not valid.</p>
public struct InvalidPluginName: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidPolicyAttributeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyAttributeException(message: \(String(describing: message)))"}
}

extension InvalidPolicyAttributeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPolicyAttributeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A policy attribute or its value is invalid. </p>
public struct InvalidPolicyAttributeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyAttributeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPolicyAttributeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPolicyTypeException(message: \(String(describing: message)))"}
}

extension InvalidPolicyTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPolicyTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The policy type is not supported. Parameter Store supports the following policy types:
///    Expiration, ExpirationNotification, and NoChangeNotification.</p>
public struct InvalidPolicyTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPolicyTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPolicyTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceId()"}
}

extension InvalidResourceId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource ID is not valid. Verify that you entered the correct ID and try again.</p>
public struct InvalidResourceId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidResourceType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceType()"}
}

extension InvalidResourceType: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource type is not valid. For example, if you are attempting to tag an instance, the
///    instance must be a registered, managed instance.</p>
public struct InvalidResourceType: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension InvalidResultAttributeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResultAttributeException(message: \(String(describing: message)))"}
}

extension InvalidResultAttributeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResultAttributeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified inventory item result attribute is not valid.</p>
public struct InvalidResultAttributeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResultAttributeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResultAttributeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRole: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRole(message: \(String(describing: message)))"}
}

extension InvalidRole: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRoleBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The role name can't contain invalid characters. Also verify that you specified an IAM role
///    for notifications that includes the required trust policy. For information about configuring the
///    IAM role for Run Command notifications, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/rc-sns-notifications.html">Configuring Amazon SNS
///     Notifications for Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
public struct InvalidRole: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleBody: Equatable {
    public let message: String?
}

extension InvalidRoleBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSchedule(message: \(String(describing: message)))"}
}

extension InvalidSchedule: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidScheduleBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The schedule is invalid. Verify your cron or rate expression and try again.</p>
public struct InvalidSchedule: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidScheduleBody: Equatable {
    public let message: String?
}

extension InvalidScheduleBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTarget(message: \(String(describing: message)))"}
}

extension InvalidTarget: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTargetBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The target is not valid or does not exist. It might not be configured for Systems Manager or you might
///    not have permission to perform the operation.</p>
public struct InvalidTarget: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetBody: Equatable {
    public let message: String?
}

extension InvalidTargetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTypeNameException(message: \(String(describing: message)))"}
}

extension InvalidTypeNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTypeNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter type name is not valid.</p>
public struct InvalidTypeNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTypeNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidUpdate(message: \(String(describing: message)))"}
}

extension InvalidUpdate: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidUpdateBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The update is not valid.</p>
public struct InvalidUpdate: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUpdateBody: Equatable {
    public let message: String?
}

extension InvalidUpdateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InventoryAggregator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregators = "Aggregators"
        case expression = "Expression"
        case groups = "Groups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for inventoryaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(inventoryaggregatorlist0)
            }
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for inventorygrouplist0 in groups {
                try groupsContainer.encode(inventorygrouplist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let aggregatorsContainer = try containerValues.decodeIfPresent([InventoryAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[InventoryAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [InventoryAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([InventoryGroup?].self, forKey: .groups)
        var groupsDecoded0:[InventoryGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [InventoryGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension InventoryAggregator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryAggregator(aggregators: \(String(describing: aggregators)), expression: \(String(describing: expression)), groups: \(String(describing: groups)))"}
}

/// <p>Specifies the inventory type and attribute for the aggregation execution.</p>
public struct InventoryAggregator: Equatable {
    /// <p>Nested aggregators to further refine aggregation for an inventory type.</p>
    public let aggregators: [InventoryAggregator]?
    /// <p>The inventory type and attribute name for aggregation.</p>
    public let expression: String?
    /// <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups
    ///    return a count of resources that match and don't match the specified criteria.</p>
    public let groups: [InventoryGroup]?

    public init (
        aggregators: [InventoryAggregator]? = nil,
        expression: String? = nil,
        groups: [InventoryGroup]? = nil
    )
    {
        self.aggregators = aggregators
        self.expression = expression
        self.groups = groups
    }
}

public enum InventoryAttributeDataType {
    case number
    case string
    case sdkUnknown(String)
}

extension InventoryAttributeDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryAttributeDataType] {
        return [
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .number: return "number"
        case .string: return "string"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryAttributeDataType(rawValue: rawValue) ?? InventoryAttributeDataType.sdkUnknown(rawValue)
    }
}

public enum InventoryDeletionStatus {
    case complete
    case inProgress
    case sdkUnknown(String)
}

extension InventoryDeletionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryDeletionStatus] {
        return [
            .complete,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "Complete"
        case .inProgress: return "InProgress"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryDeletionStatus(rawValue: rawValue) ?? InventoryDeletionStatus.sdkUnknown(rawValue)
    }
}

extension InventoryDeletionStatusItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deletionId = "DeletionId"
        case deletionStartTime = "DeletionStartTime"
        case deletionSummary = "DeletionSummary"
        case lastStatus = "LastStatus"
        case lastStatusMessage = "LastStatusMessage"
        case lastStatusUpdateTime = "LastStatusUpdateTime"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionId = deletionId {
            try encodeContainer.encode(deletionId, forKey: .deletionId)
        }
        if let deletionStartTime = deletionStartTime {
            try encodeContainer.encode(deletionStartTime.timeIntervalSince1970, forKey: .deletionStartTime)
        }
        if let deletionSummary = deletionSummary {
            try encodeContainer.encode(deletionSummary, forKey: .deletionSummary)
        }
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastStatusMessage = lastStatusMessage {
            try encodeContainer.encode(lastStatusMessage, forKey: .lastStatusMessage)
        }
        if let lastStatusUpdateTime = lastStatusUpdateTime {
            try encodeContainer.encode(lastStatusUpdateTime.timeIntervalSince1970, forKey: .lastStatusUpdateTime)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionId)
        deletionId = deletionIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let deletionStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deletionStartTime)
        deletionStartTime = deletionStartTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(InventoryDeletionStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let lastStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastStatusMessage)
        lastStatusMessage = lastStatusMessageDecoded
        let deletionSummaryDecoded = try containerValues.decodeIfPresent(InventoryDeletionSummary.self, forKey: .deletionSummary)
        deletionSummary = deletionSummaryDecoded
        let lastStatusUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusUpdateTime)
        lastStatusUpdateTime = lastStatusUpdateTimeDecoded
    }
}

extension InventoryDeletionStatusItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryDeletionStatusItem(deletionId: \(String(describing: deletionId)), deletionStartTime: \(String(describing: deletionStartTime)), deletionSummary: \(String(describing: deletionSummary)), lastStatus: \(String(describing: lastStatus)), lastStatusMessage: \(String(describing: lastStatusMessage)), lastStatusUpdateTime: \(String(describing: lastStatusUpdateTime)), typeName: \(String(describing: typeName)))"}
}

/// <p>Status information returned by the <code>DeleteInventory</code> action.</p>
public struct InventoryDeletionStatusItem: Equatable {
    /// <p>The deletion ID returned by the <code>DeleteInventory</code> action.</p>
    public let deletionId: String?
    /// <p>The UTC timestamp when the delete operation started.</p>
    public let deletionStartTime: Date?
    /// <p>Information about the delete operation. For more information about this summary, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-custom.html#sysman-inventory-delete">Understanding the delete inventory summary</a> in the
    ///    <i>AWS Systems Manager User Guide</i>.</p>
    public let deletionSummary: InventoryDeletionSummary?
    /// <p>The status of the operation. Possible values are InProgress and Complete.</p>
    public let lastStatus: InventoryDeletionStatus?
    /// <p>Information about the status.</p>
    public let lastStatusMessage: String?
    /// <p>The UTC timestamp of when the last status report.</p>
    public let lastStatusUpdateTime: Date?
    /// <p>The name of the inventory data type.</p>
    public let typeName: String?

    public init (
        deletionId: String? = nil,
        deletionStartTime: Date? = nil,
        deletionSummary: InventoryDeletionSummary? = nil,
        lastStatus: InventoryDeletionStatus? = nil,
        lastStatusMessage: String? = nil,
        lastStatusUpdateTime: Date? = nil,
        typeName: String? = nil
    )
    {
        self.deletionId = deletionId
        self.deletionStartTime = deletionStartTime
        self.deletionSummary = deletionSummary
        self.lastStatus = lastStatus
        self.lastStatusMessage = lastStatusMessage
        self.lastStatusUpdateTime = lastStatusUpdateTime
        self.typeName = typeName
    }
}

extension InventoryDeletionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case remainingCount = "RemainingCount"
        case summaryItems = "SummaryItems"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let summaryItems = summaryItems {
            var summaryItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .summaryItems)
            for inventorydeletionsummaryitems0 in summaryItems {
                try summaryItemsContainer.encode(inventorydeletionsummaryitems0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decode(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let remainingCountDecoded = try containerValues.decode(Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
        let summaryItemsContainer = try containerValues.decodeIfPresent([InventoryDeletionSummaryItem?].self, forKey: .summaryItems)
        var summaryItemsDecoded0:[InventoryDeletionSummaryItem]? = nil
        if let summaryItemsContainer = summaryItemsContainer {
            summaryItemsDecoded0 = [InventoryDeletionSummaryItem]()
            for structure0 in summaryItemsContainer {
                if let structure0 = structure0 {
                    summaryItemsDecoded0?.append(structure0)
                }
            }
        }
        summaryItems = summaryItemsDecoded0
    }
}

extension InventoryDeletionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryDeletionSummary(remainingCount: \(String(describing: remainingCount)), summaryItems: \(String(describing: summaryItems)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Information about the delete operation.</p>
public struct InventoryDeletionSummary: Equatable {
    /// <p>Remaining number of items to delete.</p>
    public let remainingCount: Int
    /// <p>A list of counts and versions for deleted items.</p>
    public let summaryItems: [InventoryDeletionSummaryItem]?
    /// <p>The total number of items to delete. This count does not change during the delete
    ///    operation.</p>
    public let totalCount: Int

    public init (
        remainingCount: Int = 0,
        summaryItems: [InventoryDeletionSummaryItem]? = nil,
        totalCount: Int = 0
    )
    {
        self.remainingCount = remainingCount
        self.summaryItems = summaryItems
        self.totalCount = totalCount
    }
}

extension InventoryDeletionSummaryItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case remainingCount = "RemainingCount"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if remainingCount != 0 {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let remainingCountDecoded = try containerValues.decode(Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
    }
}

extension InventoryDeletionSummaryItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryDeletionSummaryItem(count: \(String(describing: count)), remainingCount: \(String(describing: remainingCount)), version: \(String(describing: version)))"}
}

/// <p>Either a count, remaining count, or a version number in a delete inventory summary.</p>
public struct InventoryDeletionSummaryItem: Equatable {
    /// <p>A count of the number of deleted items.</p>
    public let count: Int
    /// <p>The remaining number of items to delete.</p>
    public let remainingCount: Int
    /// <p>The inventory type version.</p>
    public let version: String?

    public init (
        count: Int = 0,
        remainingCount: Int = 0,
        version: String? = nil
    )
    {
        self.count = count
        self.remainingCount = remainingCount
        self.version = version
    }
}

extension InventoryFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for inventoryfiltervaluelist0 in values {
                try valuesContainer.encode(inventoryfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(InventoryQueryOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension InventoryFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryFilter(key: \(String(describing: key)), type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
public struct InventoryFilter: Equatable {
    /// <p>The name of the filter key.</p>
    public let key: String?
    /// <p>The type of filter.</p>
    ///          <note>
    ///             <p>The <code>Exists</code> filter must be used with aggregators. For more information, see
    ///      <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-aggregate.html">Aggregating inventory
    ///      data</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          </note>
    public let type: InventoryQueryOperatorType?
    /// <p>Inventory filter values. Example: inventory filter where instance IDs are specified as
    ///    values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal
    ///   </p>
    public let values: [String]?

    public init (
        key: String? = nil,
        type: InventoryQueryOperatorType? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.type = type
        self.values = values
    }
}

extension InventoryGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension InventoryGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryGroup(filters: \(String(describing: filters)), name: \(String(describing: name)))"}
}

/// <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups
///    return a count of resources that match and don't match the specified criteria.</p>
public struct InventoryGroup: Equatable {
    /// <p>Filters define the criteria for the group. The <code>matchingCount</code> field displays the
    ///    number of resources that match the criteria. The <code>notMatchingCount</code> field displays the
    ///    number of resources that don't match the criteria. </p>
    public let filters: [InventoryFilter]?
    /// <p>The name of the group.</p>
    public let name: String?

    public init (
        filters: [InventoryFilter]? = nil,
        name: String? = nil
    )
    {
        self.filters = filters
        self.name = name
    }
}

extension InventoryItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case context = "Context"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, inventoryitemcontentcontext0) in context {
                try contextContainer.encode(inventoryitemcontentcontext0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .content)
        var contentDecoded0:[[String:String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[String:String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [String: String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
    }
}

extension InventoryItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryItem(captureTime: \(String(describing: captureTime)), content: \(String(describing: content)), contentHash: \(String(describing: contentHash)), context: \(String(describing: context)), schemaVersion: \(String(describing: schemaVersion)), typeName: \(String(describing: typeName)))"}
}

/// <p>Information collected from managed instances based on your inventory policy document</p>
public struct InventoryItem: Equatable {
    /// <p>The time the inventory information was collected.</p>
    public let captureTime: String?
    /// <p>The inventory data of the inventory type.</p>
    public let content: [[String:String]]?
    /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
    ///    to update inventory information. The PutInventory API does not update the inventory item type
    ///    contents if the MD5 hash has not changed since last update. </p>
    public let contentHash: String?
    /// <p>A map of associated properties for a specified inventory type. For example, with this
    ///    attribute, you can specify the <code>ExecutionId</code>, <code>ExecutionType</code>,
    ///     <code>ComplianceType</code> properties of the <code>AWS:ComplianceItem</code> type.</p>
    public let context: [String:String]?
    /// <p>The schema version for the inventory item.</p>
    public let schemaVersion: String?
    /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
    ///    inventory type names will start with Custom. Default inventory item types include the following:
    ///    AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
    ///    AWS:WindowsUpdate.</p>
    public let typeName: String?

    public init (
        captureTime: String? = nil,
        content: [[String:String]]? = nil,
        contentHash: String? = nil,
        context: [String:String]? = nil,
        schemaVersion: String? = nil,
        typeName: String? = nil
    )
    {
        self.captureTime = captureTime
        self.content = content
        self.contentHash = contentHash
        self.context = context
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

extension InventoryItemAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType = "DataType"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(InventoryAttributeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension InventoryItemAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryItemAttribute(dataType: \(String(describing: dataType)), name: \(String(describing: name)))"}
}

/// <p>Attributes are the entries within the inventory item content. It contains name and
///    value.</p>
public struct InventoryItemAttribute: Equatable {
    /// <p>The data type of the inventory item attribute. </p>
    public let dataType: InventoryAttributeDataType?
    /// <p>Name of the inventory item attribute.</p>
    public let name: String?

    public init (
        dataType: InventoryAttributeDataType? = nil,
        name: String? = nil
    )
    {
        self.dataType = dataType
        self.name = name
    }
}

extension InventoryItemSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case displayName = "DisplayName"
        case typeName = "TypeName"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for inventoryitemattributelist0 in attributes {
                try attributesContainer.encode(inventoryitemattributelist0)
            }
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([InventoryItemAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[InventoryItemAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [InventoryItemAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension InventoryItemSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryItemSchema(attributes: \(String(describing: attributes)), displayName: \(String(describing: displayName)), typeName: \(String(describing: typeName)), version: \(String(describing: version)))"}
}

/// <p>The inventory item schema definition. Users can use this to compose inventory query
///    filters.</p>
public struct InventoryItemSchema: Equatable {
    /// <p>The schema attributes for inventory. This contains data type and attribute name.</p>
    public let attributes: [InventoryItemAttribute]?
    /// <p>The alias name of the inventory type. The alias name is used for display purposes.</p>
    public let displayName: String?
    /// <p>The name of the inventory type. Default inventory item type names start with AWS. Custom
    ///    inventory type names will start with Custom. Default inventory item types include the following:
    ///    AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and
    ///    AWS:WindowsUpdate.</p>
    public let typeName: String?
    /// <p>The schema version for the inventory item.</p>
    public let version: String?

    public init (
        attributes: [InventoryItemAttribute]? = nil,
        displayName: String? = nil,
        typeName: String? = nil,
        version: String? = nil
    )
    {
        self.attributes = attributes
        self.displayName = displayName
        self.typeName = typeName
        self.version = version
    }
}

public enum InventoryQueryOperatorType {
    case beginWith
    case equal
    case exists
    case greaterThan
    case lessThan
    case notEqual
    case sdkUnknown(String)
}

extension InventoryQueryOperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventoryQueryOperatorType] {
        return [
            .beginWith,
            .equal,
            .exists,
            .greaterThan,
            .lessThan,
            .notEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginWith: return "BeginWith"
        case .equal: return "Equal"
        case .exists: return "Exists"
        case .greaterThan: return "GreaterThan"
        case .lessThan: return "LessThan"
        case .notEqual: return "NotEqual"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventoryQueryOperatorType(rawValue: rawValue) ?? InventoryQueryOperatorType.sdkUnknown(rawValue)
    }
}

extension InventoryResultEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, inventoryresultitemmap0) in data {
                try dataContainer.encode(inventoryresultitemmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: InventoryResultItem?].self, forKey: .data)
        var dataDecoded0: [String:InventoryResultItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:InventoryResultItem]()
            for (key0, inventoryresultitem0) in dataContainer {
                if let inventoryresultitem0 = inventoryresultitem0 {
                    dataDecoded0?[key0] = inventoryresultitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension InventoryResultEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryResultEntity(data: \(String(describing: data)), id: \(String(describing: id)))"}
}

/// <p>Inventory query results.</p>
public struct InventoryResultEntity: Equatable {
    /// <p>The data section in the inventory result entity JSON.</p>
    public let data: [String:InventoryResultItem]?
    /// <p>ID of the inventory result entity. For example, for managed instance inventory the result
    ///    will be the managed instance ID. For EC2 instance inventory, the result will be the instance ID.
    ///   </p>
    public let id: String?

    public init (
        data: [String:InventoryResultItem]? = nil,
        id: String? = nil
    )
    {
        self.data = data
        self.id = id
    }
}

extension InventoryResultItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
        case contentHash = "ContentHash"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for inventoryitementrylist0 in content {
                var inventoryitementrylist0Container = contentContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, inventoryitementry1) in inventoryitementrylist0 {
                    try inventoryitementrylist0Container.encode(inventoryitementry1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
        if let contentHash = contentHash {
            try encodeContainer.encode(contentHash, forKey: .contentHash)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentHash)
        contentHash = contentHashDecoded
        let contentContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .content)
        var contentDecoded0:[[String:String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[String:String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [String: String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension InventoryResultItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryResultItem(captureTime: \(String(describing: captureTime)), content: \(String(describing: content)), contentHash: \(String(describing: contentHash)), schemaVersion: \(String(describing: schemaVersion)), typeName: \(String(describing: typeName)))"}
}

/// <p>The inventory result item.</p>
public struct InventoryResultItem: Equatable {
    /// <p>The time inventory item data was captured.</p>
    public let captureTime: String?
    /// <p>Contains all the inventory data of the item type. Results include attribute names and
    ///    values. </p>
    public let content: [[String:String]]?
    /// <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether
    ///    to update inventory information. The PutInventory API does not update the inventory item type
    ///    contents if the MD5 hash has not changed since last update. </p>
    public let contentHash: String?
    /// <p>The schema version for the inventory result item/</p>
    public let schemaVersion: String?
    /// <p>The name of the inventory result item type.</p>
    public let typeName: String?

    public init (
        captureTime: String? = nil,
        content: [[String:String]]? = nil,
        contentHash: String? = nil,
        schemaVersion: String? = nil,
        typeName: String? = nil
    )
    {
        self.captureTime = captureTime
        self.content = content
        self.contentHash = contentHash
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

public enum InventorySchemaDeleteOption {
    case deleteSchema
    case disableSchema
    case sdkUnknown(String)
}

extension InventorySchemaDeleteOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InventorySchemaDeleteOption] {
        return [
            .deleteSchema,
            .disableSchema,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleteSchema: return "DeleteSchema"
        case .disableSchema: return "DisableSchema"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InventorySchemaDeleteOption(rawValue: rawValue) ?? InventorySchemaDeleteOption.sdkUnknown(rawValue)
    }
}

extension InvocationDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvocationDoesNotExist()"}
}

extension InvocationDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The command ID and instance ID you specified did not match any invocations. Verify the
///    command ID and the instance ID and try again. </p>
public struct InvocationDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension ItemContentMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ItemContentMismatchException(message: \(String(describing: message)), typeName: \(String(describing: typeName)))"}
}

extension ItemContentMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ItemContentMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The inventory item has invalid content. </p>
public struct ItemContentMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var typeName: String?

    public init (
        message: String? = nil,
        typeName: String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemContentMismatchExceptionBody: Equatable {
    public let typeName: String?
    public let message: String?
}

extension ItemContentMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ItemSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ItemSizeLimitExceededException(message: \(String(describing: message)), typeName: \(String(describing: typeName)))"}
}

extension ItemSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ItemSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The inventory item size has exceeded the size limit.</p>
public struct ItemSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var typeName: String?

    public init (
        message: String? = nil,
        typeName: String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct ItemSizeLimitExceededExceptionBody: Equatable {
    public let typeName: String?
    public let message: String?
}

extension ItemSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct LabelParameterVersionInputBodyMiddleware: Middleware {
    public let id: String = "LabelParameterVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LabelParameterVersionOutputError>
}

extension LabelParameterVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelParameterVersionInput(labels: \(String(describing: labels)), name: \(String(describing: name)), parameterVersion: \(String(describing: parameterVersion)))"}
}

extension LabelParameterVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

public struct LabelParameterVersionInputHeadersMiddleware: Middleware {
    public let id: String = "LabelParameterVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "LabelParameterVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<LabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LabelParameterVersionInput>
    public typealias MOutput = OperationOutput<LabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LabelParameterVersionOutputError>
}

public struct LabelParameterVersionInput: Equatable {
    /// <p>One or more labels to attach to the specified parameter version.</p>
    public let labels: [String]?
    /// <p>The parameter name on which you want to attach one or more labels.</p>
    public let name: String?
    /// <p>The specific version of the parameter on which you want to attach one or more labels. If no
    ///    version is specified, the system attaches the label to the latest version.</p>
    public let parameterVersion: Int

    public init (
        labels: [String]? = nil,
        name: String? = nil,
        parameterVersion: Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionInputBody: Equatable {
    public let name: String?
    public let parameterVersion: Int
    public let labels: [String]?
}

extension LabelParameterVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension LabelParameterVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LabelParameterVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionLabelLimitExceeded" : self = .parameterVersionLabelLimitExceeded(try ParameterVersionLabelLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LabelParameterVersionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionLabelLimitExceeded(ParameterVersionLabelLimitExceeded)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension LabelParameterVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelParameterVersionOutputResponse(invalidLabels: \(String(describing: invalidLabels)), parameterVersion: \(String(describing: parameterVersion)))"}
}

extension LabelParameterVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidLabels = output.invalidLabels
            self.parameterVersion = output.parameterVersion
        } else {
            self.invalidLabels = nil
            self.parameterVersion = 0
        }
    }
}

public struct LabelParameterVersionOutputResponse: Equatable {
    /// <p>The label does not meet the requirements. For information about parameter label
    ///    requirements, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html">Labeling parameters</a>
    ///    in the <i>AWS Systems Manager User Guide</i>.</p>
    public let invalidLabels: [String]?
    /// <p>The version of the parameter that has been labeled.</p>
    public let parameterVersion: Int

    public init (
        invalidLabels: [String]? = nil,
        parameterVersion: Int = 0
    )
    {
        self.invalidLabels = invalidLabels
        self.parameterVersion = parameterVersion
    }
}

struct LabelParameterVersionOutputResponseBody: Equatable {
    public let invalidLabels: [String]?
    public let parameterVersion: Int
}

extension LabelParameterVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidLabels = "InvalidLabels"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidLabelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
        let parameterVersionDecoded = try containerValues.decode(Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
    }
}

public enum LastResourceDataSyncStatus {
    case failed
    case inprogress
    case successful
    case sdkUnknown(String)
}

extension LastResourceDataSyncStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LastResourceDataSyncStatus] {
        return [
            .failed,
            .inprogress,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .successful: return "Successful"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LastResourceDataSyncStatus(rawValue: rawValue) ?? LastResourceDataSyncStatus.sdkUnknown(rawValue)
    }
}

public struct ListAssociationVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociationVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationVersionsOutputError>
}

extension ListAssociationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationVersionsInput(associationId: \(String(describing: associationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationVersionsInput>
    public typealias MOutput = OperationOutput<ListAssociationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationVersionsOutputError>
}

public struct ListAssociationVersionsInput: Equatable {
    /// <p>The association ID for which you want to view all versions.</p>
    public let associationId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        associationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.associationId = associationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsInputBody: Equatable {
    public let associationId: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListAssociationVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationVersionsOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationVersionsOutputResponse(associationVersions: \(String(describing: associationVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationVersions = output.associationVersions
            self.nextToken = output.nextToken
        } else {
            self.associationVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationVersionsOutputResponse: Equatable {
    /// <p>Information about all versions of the association for the specified association ID.</p>
    public let associationVersions: [AssociationVersionInfo]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        associationVersions: [AssociationVersionInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.associationVersions = associationVersions
        self.nextToken = nextToken
    }
}

struct ListAssociationVersionsOutputResponseBody: Equatable {
    public let associationVersions: [AssociationVersionInfo]?
    public let nextToken: String?
}

extension ListAssociationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationVersions = "AssociationVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationVersionsContainer = try containerValues.decodeIfPresent([AssociationVersionInfo?].self, forKey: .associationVersions)
        var associationVersionsDecoded0:[AssociationVersionInfo]? = nil
        if let associationVersionsContainer = associationVersionsContainer {
            associationVersionsDecoded0 = [AssociationVersionInfo]()
            for structure0 in associationVersionsContainer {
                if let structure0 = structure0 {
                    associationVersionsDecoded0?.append(structure0)
                }
            }
        }
        associationVersions = associationVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssociationsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsOutputError>
}

extension ListAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationsInput(associationFilterList: \(String(describing: associationFilterList)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationFilterList = associationFilterList {
            var associationFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationFilterList)
            for associationfilterlist0 in associationFilterList {
                try associationFilterListContainer.encode(associationfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociationsInput>
    public typealias MOutput = OperationOutput<ListAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociationsOutputError>
}

public struct ListAssociationsInput: Equatable {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    ///          <note>
    ///             <p>Filtering associations using the <code>InstanceID</code> attribute only returns legacy
    ///     associations created using the <code>InstanceID</code> attribute. Associations targeting the
    ///     instance that are part of the Target Attributes <code>ResourceGroup</code> or <code>Tags</code>
    ///     are not returned.</p>
    ///          </note>
    public let associationFilterList: [AssociationFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        associationFilterList: [AssociationFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.associationFilterList = associationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssociationsInputBody: Equatable {
    public let associationFilterList: [AssociationFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListAssociationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationFilterList = "AssociationFilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationFilterListContainer = try containerValues.decodeIfPresent([AssociationFilter?].self, forKey: .associationFilterList)
        var associationFilterListDecoded0:[AssociationFilter]? = nil
        if let associationFilterListContainer = associationFilterListContainer {
            associationFilterListDecoded0 = [AssociationFilter]()
            for structure0 in associationFilterListContainer {
                if let structure0 = structure0 {
                    associationFilterListDecoded0?.append(structure0)
                }
            }
        }
        associationFilterList = associationFilterListDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociationsOutputResponse(associations: \(String(describing: associations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associations = output.associations
            self.nextToken = output.nextToken
        } else {
            self.associations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociationsOutputResponse: Equatable {
    /// <p>The associations.</p>
    public let associations: [Association]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        associations: [Association]? = nil,
        nextToken: String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

struct ListAssociationsOutputResponseBody: Equatable {
    public let associations: [Association]?
    public let nextToken: String?
}

extension ListAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associations = "Associations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationsContainer = try containerValues.decodeIfPresent([Association?].self, forKey: .associations)
        var associationsDecoded0:[Association]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [Association]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCommandInvocationsInputBodyMiddleware: Middleware {
    public let id: String = "ListCommandInvocationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandInvocationsOutputError>
}

extension ListCommandInvocationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCommandInvocationsInput(commandId: \(String(describing: commandId)), details: \(String(describing: details)), filters: \(String(describing: filters)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCommandInvocationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if details != false {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCommandInvocationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCommandInvocationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCommandInvocationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandInvocationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandInvocationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandInvocationsInput>
    public typealias MOutput = OperationOutput<ListCommandInvocationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandInvocationsOutputError>
}

public struct ListCommandInvocationsInput: Equatable {
    /// <p>(Optional) The invocations for a specific command ID.</p>
    public let commandId: String?
    /// <p>(Optional) If set this returns the response of the command executions and any command
    ///    output. The default value is 'false'. </p>
    public let details: Bool
    /// <p>(Optional) One or more filters. Use a filter to return a more specific list of
    ///    results.</p>
    public let filters: [CommandFilter]?
    /// <p>(Optional) The command execution details for a specific instance ID.</p>
    public let instanceId: String?
    /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
    ///    token that you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    ///    previous call.)</p>
    public let nextToken: String?

    public init (
        commandId: String? = nil,
        details: Bool = false,
        filters: [CommandFilter]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.commandId = commandId
        self.details = details
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsInputBody: Equatable {
    public let commandId: String?
    public let instanceId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let filters: [CommandFilter]?
    public let details: Bool
}

extension ListCommandInvocationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case details = "Details"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let detailsDecoded = try containerValues.decode(Bool.self, forKey: .details)
        details = detailsDecoded
    }
}

extension ListCommandInvocationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandInvocationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandInvocationsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandInvocationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCommandInvocationsOutputResponse(commandInvocations: \(String(describing: commandInvocations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCommandInvocationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCommandInvocationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commandInvocations = output.commandInvocations
            self.nextToken = output.nextToken
        } else {
            self.commandInvocations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandInvocationsOutputResponse: Equatable {
    /// <p>(Optional) A list of all invocations. </p>
    public let commandInvocations: [CommandInvocation]?
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    ///    previous call.)</p>
    public let nextToken: String?

    public init (
        commandInvocations: [CommandInvocation]? = nil,
        nextToken: String? = nil
    )
    {
        self.commandInvocations = commandInvocations
        self.nextToken = nextToken
    }
}

struct ListCommandInvocationsOutputResponseBody: Equatable {
    public let commandInvocations: [CommandInvocation]?
    public let nextToken: String?
}

extension ListCommandInvocationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandInvocations = "CommandInvocations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandInvocationsContainer = try containerValues.decodeIfPresent([CommandInvocation?].self, forKey: .commandInvocations)
        var commandInvocationsDecoded0:[CommandInvocation]? = nil
        if let commandInvocationsContainer = commandInvocationsContainer {
            commandInvocationsDecoded0 = [CommandInvocation]()
            for structure0 in commandInvocationsContainer {
                if let structure0 = structure0 {
                    commandInvocationsDecoded0?.append(structure0)
                }
            }
        }
        commandInvocations = commandInvocationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCommandsInputBodyMiddleware: Middleware {
    public let id: String = "ListCommandsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandsInput>
    public typealias MOutput = OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandsOutputError>
}

extension ListCommandsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCommandsInput(commandId: \(String(describing: commandId)), filters: \(String(describing: filters)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCommandsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandId = commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for commandfilterlist0 in filters {
                try filtersContainer.encode(commandfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCommandsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCommandsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandsInput>
    public typealias MOutput = OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandsOutputError>
}

public struct ListCommandsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCommandsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCommandsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCommandsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCommandsInput>
    public typealias MOutput = OperationOutput<ListCommandsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCommandsOutputError>
}

public struct ListCommandsInput: Equatable {
    /// <p>(Optional) If provided, lists only the specified command.</p>
    public let commandId: String?
    /// <p>(Optional) One or more filters. Use a filter to return a more specific list of results.
    ///   </p>
    public let filters: [CommandFilter]?
    /// <p>(Optional) Lists commands issued against this instance ID.</p>
    ///          <note>
    ///             <p>You can't specify an instance ID in the same command that you specify <code>Status</code> =
    ///      <code>Pending</code>. This is because the command has not reached the instance yet.</p>
    ///          </note>
    public let instanceId: String?
    /// <p>(Optional) The maximum number of items to return for this call. The call also returns a
    ///    token that you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    ///    previous call.)</p>
    public let nextToken: String?

    public init (
        commandId: String? = nil,
        filters: [CommandFilter]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.commandId = commandId
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommandsInputBody: Equatable {
    public let commandId: String?
    public let instanceId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let filters: [CommandFilter]?
}

extension ListCommandsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commandId = "CommandId"
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CommandFilter?].self, forKey: .filters)
        var filtersDecoded0:[CommandFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CommandFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListCommandsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCommandsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommandId" : self = .invalidCommandId(try InvalidCommandId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCommandsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidCommandId(InvalidCommandId)
    case invalidFilterKey(InvalidFilterKey)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCommandsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCommandsOutputResponse(commands: \(String(describing: commands)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCommandsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCommandsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commands = output.commands
            self.nextToken = output.nextToken
        } else {
            self.commands = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommandsOutputResponse: Equatable {
    /// <p>(Optional) The list of commands requested by the user. </p>
    public let commands: [Command]?
    /// <p>(Optional) The token for the next set of items to return. (You received this token from a
    ///    previous call.)</p>
    public let nextToken: String?

    public init (
        commands: [Command]? = nil,
        nextToken: String? = nil
    )
    {
        self.commands = commands
        self.nextToken = nextToken
    }
}

struct ListCommandsOutputResponseBody: Equatable {
    public let commands: [Command]?
    public let nextToken: String?
}

extension ListCommandsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commands = "Commands"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([Command?].self, forKey: .commands)
        var commandsDecoded0:[Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComplianceItemsInputBodyMiddleware: Middleware {
    public let id: String = "ListComplianceItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceItemsOutputError>
}

extension ListComplianceItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceItemsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceIds: \(String(describing: resourceIds)), resourceTypes: \(String(describing: resourceTypes)))"}
}

extension ListComplianceItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for complianceresourceidlist0 in resourceIds {
                try resourceIdsContainer.encode(complianceresourceidlist0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for complianceresourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(complianceresourcetypelist0)
            }
        }
    }
}

public struct ListComplianceItemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComplianceItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComplianceItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceItemsInput>
    public typealias MOutput = OperationOutput<ListComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceItemsOutputError>
}

public struct ListComplianceItemsInput: Equatable {
    /// <p>One or more compliance filters. Use a filter to return a more specific list of
    ///    results.</p>
    public let filters: [ComplianceStringFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?
    /// <p>The ID for the resources from which to get compliance information. Currently, you can only
    ///    specify one resource ID.</p>
    public let resourceIds: [String]?
    /// <p>The type of resource from which to get compliance information. Currently, the only supported
    ///    resource type is <code>ManagedInstance</code>.</p>
    public let resourceTypes: [String]?

    public init (
        filters: [ComplianceStringFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceIds: [String]? = nil,
        resourceTypes: [String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceTypes = resourceTypes
    }
}

struct ListComplianceItemsInputBody: Equatable {
    public let filters: [ComplianceStringFilter]?
    public let resourceIds: [String]?
    public let resourceTypes: [String]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListComplianceItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceIds = "ResourceIds"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceItemsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceItemsOutputResponse(complianceItems: \(String(describing: complianceItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComplianceItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListComplianceItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceItems = output.complianceItems
            self.nextToken = output.nextToken
        } else {
            self.complianceItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceItemsOutputResponse: Equatable {
    /// <p>A list of compliance information for the specified resource ID. </p>
    public let complianceItems: [ComplianceItem]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        complianceItems: [ComplianceItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.complianceItems = complianceItems
        self.nextToken = nextToken
    }
}

struct ListComplianceItemsOutputResponseBody: Equatable {
    public let complianceItems: [ComplianceItem]?
    public let nextToken: String?
}

extension ListComplianceItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceItems = "ComplianceItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceItemsContainer = try containerValues.decodeIfPresent([ComplianceItem?].self, forKey: .complianceItems)
        var complianceItemsDecoded0:[ComplianceItem]? = nil
        if let complianceItemsContainer = complianceItemsContainer {
            complianceItemsDecoded0 = [ComplianceItem]()
            for structure0 in complianceItemsContainer {
                if let structure0 = structure0 {
                    complianceItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceItems = complianceItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComplianceSummariesInputBodyMiddleware: Middleware {
    public let id: String = "ListComplianceSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceSummariesOutputError>
}

extension ListComplianceSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceSummariesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComplianceSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListComplianceSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "ListComplianceSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComplianceSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComplianceSummariesOutputError>
}

public struct ListComplianceSummariesInput: Equatable {
    /// <p>One or more compliance or inventory filters. Use a filter to return a more specific list of
    ///    results.</p>
    public let filters: [ComplianceStringFilter]?
    /// <p>The maximum number of items to return for this call. Currently, you can specify null or 50.
    ///    The call also returns a token that you can specify in a subsequent call to get the next set of
    ///    results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        filters: [ComplianceStringFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesInputBody: Equatable {
    public let filters: [ComplianceStringFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListComplianceSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListComplianceSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComplianceSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComplianceSummariesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComplianceSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComplianceSummariesOutputResponse(complianceSummaryItems: \(String(describing: complianceSummaryItems)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComplianceSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.complianceSummaryItems = output.complianceSummaryItems
            self.nextToken = output.nextToken
        } else {
            self.complianceSummaryItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListComplianceSummariesOutputResponse: Equatable {
    /// <p>A list of compliant and non-compliant summary counts based on compliance types. For example,
    ///    this call returns State Manager associations, patches, or custom compliance types according to
    ///    the filter criteria that you specified.</p>
    public let complianceSummaryItems: [ComplianceSummaryItem]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?

    public init (
        complianceSummaryItems: [ComplianceSummaryItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.complianceSummaryItems = complianceSummaryItems
        self.nextToken = nextToken
    }
}

struct ListComplianceSummariesOutputResponseBody: Equatable {
    public let complianceSummaryItems: [ComplianceSummaryItem]?
    public let nextToken: String?
}

extension ListComplianceSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceSummaryItems = "ComplianceSummaryItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryItemsContainer = try containerValues.decodeIfPresent([ComplianceSummaryItem?].self, forKey: .complianceSummaryItems)
        var complianceSummaryItemsDecoded0:[ComplianceSummaryItem]? = nil
        if let complianceSummaryItemsContainer = complianceSummaryItemsContainer {
            complianceSummaryItemsDecoded0 = [ComplianceSummaryItem]()
            for structure0 in complianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    complianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        complianceSummaryItems = complianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentMetadataHistoryInputBodyMiddleware: Middleware {
    public let id: String = "ListDocumentMetadataHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentMetadataHistoryOutputError>
}

extension ListDocumentMetadataHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentMetadataHistoryInput(documentVersion: \(String(describing: documentVersion)), maxResults: \(String(describing: maxResults)), metadata: \(String(describing: metadata)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentMetadataHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata.rawValue, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentMetadataHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListDocumentMetadataHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDocumentMetadataHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentMetadataHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentMetadataHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentMetadataHistoryInput>
    public typealias MOutput = OperationOutput<ListDocumentMetadataHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentMetadataHistoryOutputError>
}

public struct ListDocumentMetadataHistoryInput: Equatable {
    /// <p>The version of the document.</p>
    public let documentVersion: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The type of data for which details are being requested. Currently, the only supported value
    ///    is <code>DocumentReviews</code>.</p>
    public let metadata: DocumentMetadataEnum?
    /// <p>The name of the document.</p>
    public let name: String?
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        documentVersion: String? = nil,
        maxResults: Int = 0,
        metadata: DocumentMetadataEnum? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.maxResults = maxResults
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let metadata: DocumentMetadataEnum?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListDocumentMetadataHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case maxResults = "MaxResults"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(DocumentMetadataEnum.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDocumentMetadataHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentMetadataHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentMetadataHistoryOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentMetadataHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentMetadataHistoryOutputResponse(author: \(String(describing: author)), documentVersion: \(String(describing: documentVersion)), metadata: \(String(describing: metadata)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentMetadataHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDocumentMetadataHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.author = output.author
            self.documentVersion = output.documentVersion
            self.metadata = output.metadata
            self.name = output.name
            self.nextToken = output.nextToken
        } else {
            self.author = nil
            self.documentVersion = nil
            self.metadata = nil
            self.name = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentMetadataHistoryOutputResponse: Equatable {
    /// <p>The user ID of the person in the organization who requested the document review.</p>
    public let author: String?
    /// <p>The version of the document.</p>
    public let documentVersion: String?
    /// <p>Information about the response to the document approval request.</p>
    public let metadata: DocumentMetadataResponseInfo?
    /// <p>The name of the document.</p>
    public let name: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let nextToken: String?

    public init (
        author: String? = nil,
        documentVersion: String? = nil,
        metadata: DocumentMetadataResponseInfo? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.author = author
        self.documentVersion = documentVersion
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentMetadataHistoryOutputResponseBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let author: String?
    public let metadata: DocumentMetadataResponseInfo?
    public let nextToken: String?
}

extension ListDocumentMetadataHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case author = "Author"
        case documentVersion = "DocumentVersion"
        case metadata = "Metadata"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(DocumentMetadataResponseInfo.self, forKey: .metadata)
        metadata = metadataDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListDocumentVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentVersionsOutputError>
}

extension ListDocumentVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentVersionsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDocumentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDocumentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentVersionsInput>
    public typealias MOutput = OperationOutput<ListDocumentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentVersionsOutputError>
}

public struct ListDocumentVersionsInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The name of the document. You can specify an Amazon Resource Name (ARN).</p>
    public let name: String?
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsInputBody: Equatable {
    public let name: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListDocumentVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentVersionsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentVersionsOutputResponse(documentVersions: \(String(describing: documentVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDocumentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentVersions = output.documentVersions
            self.nextToken = output.nextToken
        } else {
            self.documentVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentVersionsOutputResponse: Equatable {
    /// <p>The document versions.</p>
    public let documentVersions: [DocumentVersionInfo]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        documentVersions: [DocumentVersionInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.nextToken = nextToken
    }
}

struct ListDocumentVersionsOutputResponseBody: Equatable {
    public let documentVersions: [DocumentVersionInfo]?
    public let nextToken: String?
}

extension ListDocumentVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersions = "DocumentVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([DocumentVersionInfo?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[DocumentVersionInfo]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [DocumentVersionInfo]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDocumentsInputBodyMiddleware: Middleware {
    public let id: String = "ListDocumentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentsOutputError>
}

extension ListDocumentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentsInput(documentFilterList: \(String(describing: documentFilterList)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentFilterList = documentFilterList {
            var documentFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .documentFilterList)
            for documentfilterlist0 in documentFilterList {
                try documentFilterListContainer.encode(documentfilterlist0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for documentkeyvaluesfilterlist0 in filters {
                try filtersContainer.encode(documentkeyvaluesfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDocumentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDocumentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDocumentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDocumentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDocumentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDocumentsInput>
    public typealias MOutput = OperationOutput<ListDocumentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDocumentsOutputError>
}

public struct ListDocumentsInput: Equatable {
    /// <p>This data type is deprecated. Instead, use <code>Filters</code>.</p>
    public let documentFilterList: [DocumentFilter]?
    /// <p>One or more <code>DocumentKeyValuesFilter</code> objects. Use a filter to return a more
    ///    specific list of results. For keys, you can specify one or more key-value pair tags that have
    ///    been applied to a document. Other valid keys include <code>Owner</code>, <code>Name</code>,
    ///     <code>PlatformTypes</code>, <code>DocumentType</code>, and <code>TargetType</code>. For example,
    ///    to return documents you own use <code>Key=Owner,Values=Self</code>. To specify a custom key-value
    ///    pair, use the format <code>Key=tag:tagName,Values=valueName</code>.</p>
    ///          <note>
    ///             <p>This API action only supports filtering documents by using a single tag key and one or more
    ///     tag values. For example: <code>Key=tag:tagName,Values=valueName1,valueName2</code>
    ///             </p>
    ///          </note>
    public let filters: [DocumentKeyValuesFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?

    public init (
        documentFilterList: [DocumentFilter]? = nil,
        filters: [DocumentKeyValuesFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.documentFilterList = documentFilterList
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDocumentsInputBody: Equatable {
    public let documentFilterList: [DocumentFilter]?
    public let filters: [DocumentKeyValuesFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListDocumentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentFilterList = "DocumentFilterList"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentFilterListContainer = try containerValues.decodeIfPresent([DocumentFilter?].self, forKey: .documentFilterList)
        var documentFilterListDecoded0:[DocumentFilter]? = nil
        if let documentFilterListContainer = documentFilterListContainer {
            documentFilterListDecoded0 = [DocumentFilter]()
            for structure0 in documentFilterListContainer {
                if let structure0 = structure0 {
                    documentFilterListDecoded0?.append(structure0)
                }
            }
        }
        documentFilterList = documentFilterListDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([DocumentKeyValuesFilter?].self, forKey: .filters)
        var filtersDecoded0:[DocumentKeyValuesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DocumentKeyValuesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDocumentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDocumentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterKey" : self = .invalidFilterKey(try InvalidFilterKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDocumentsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilterKey(InvalidFilterKey)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDocumentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDocumentsOutputResponse(documentIdentifiers: \(String(describing: documentIdentifiers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDocumentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDocumentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentIdentifiers = output.documentIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.documentIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListDocumentsOutputResponse: Equatable {
    /// <p>The names of the Systems Manager documents.</p>
    public let documentIdentifiers: [DocumentIdentifier]?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?

    public init (
        documentIdentifiers: [DocumentIdentifier]? = nil,
        nextToken: String? = nil
    )
    {
        self.documentIdentifiers = documentIdentifiers
        self.nextToken = nextToken
    }
}

struct ListDocumentsOutputResponseBody: Equatable {
    public let documentIdentifiers: [DocumentIdentifier]?
    public let nextToken: String?
}

extension ListDocumentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentIdentifiers = "DocumentIdentifiers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentIdentifiersContainer = try containerValues.decodeIfPresent([DocumentIdentifier?].self, forKey: .documentIdentifiers)
        var documentIdentifiersDecoded0:[DocumentIdentifier]? = nil
        if let documentIdentifiersContainer = documentIdentifiersContainer {
            documentIdentifiersDecoded0 = [DocumentIdentifier]()
            for structure0 in documentIdentifiersContainer {
                if let structure0 = structure0 {
                    documentIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        documentIdentifiers = documentIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInventoryEntriesInputBodyMiddleware: Middleware {
    public let id: String = "ListInventoryEntriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInventoryEntriesOutputError>
}

extension ListInventoryEntriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInventoryEntriesInput(filters: \(String(describing: filters)), instanceId: \(String(describing: instanceId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), typeName: \(String(describing: typeName)))"}
}

extension ListInventoryEntriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for inventoryfilterlist0 in filters {
                try filtersContainer.encode(inventoryfilterlist0)
            }
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }
}

public struct ListInventoryEntriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListInventoryEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInventoryEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInventoryEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInventoryEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInventoryEntriesInput>
    public typealias MOutput = OperationOutput<ListInventoryEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInventoryEntriesOutputError>
}

public struct ListInventoryEntriesInput: Equatable {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    public let filters: [InventoryFilter]?
    /// <p>The instance ID for which you want inventory information.</p>
    public let instanceId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The type of inventory item for which you want information.</p>
    public let typeName: String?

    public init (
        filters: [InventoryFilter]? = nil,
        instanceId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        typeName: String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListInventoryEntriesInputBody: Equatable {
    public let instanceId: String?
    public let typeName: String?
    public let filters: [InventoryFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListInventoryEntriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case instanceId = "InstanceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([InventoryFilter?].self, forKey: .filters)
        var filtersDecoded0:[InventoryFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [InventoryFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInventoryEntriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInventoryEntriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInventoryEntriesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNextToken(InvalidNextToken)
    case invalidTypeNameException(InvalidTypeNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInventoryEntriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInventoryEntriesOutputResponse(captureTime: \(String(describing: captureTime)), entries: \(String(describing: entries)), instanceId: \(String(describing: instanceId)), nextToken: \(String(describing: nextToken)), schemaVersion: \(String(describing: schemaVersion)), typeName: \(String(describing: typeName)))"}
}

extension ListInventoryEntriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInventoryEntriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.captureTime = output.captureTime
            self.entries = output.entries
            self.instanceId = output.instanceId
            self.nextToken = output.nextToken
            self.schemaVersion = output.schemaVersion
            self.typeName = output.typeName
        } else {
            self.captureTime = nil
            self.entries = nil
            self.instanceId = nil
            self.nextToken = nil
            self.schemaVersion = nil
            self.typeName = nil
        }
    }
}

public struct ListInventoryEntriesOutputResponse: Equatable {
    /// <p>The time that inventory information was collected for the instance(s).</p>
    public let captureTime: String?
    /// <p>A list of inventory items on the instance(s).</p>
    public let entries: [[String:String]]?
    /// <p>The instance ID targeted by the request to query inventory information.</p>
    public let instanceId: String?
    /// <p>The token to use when requesting the next set of items. If there are no additional items to
    ///    return, the string is empty.</p>
    public let nextToken: String?
    /// <p>The inventory schema version used by the instance(s).</p>
    public let schemaVersion: String?
    /// <p>The type of inventory item returned by the request.</p>
    public let typeName: String?

    public init (
        captureTime: String? = nil,
        entries: [[String:String]]? = nil,
        instanceId: String? = nil,
        nextToken: String? = nil,
        schemaVersion: String? = nil,
        typeName: String? = nil
    )
    {
        self.captureTime = captureTime
        self.entries = entries
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

struct ListInventoryEntriesOutputResponseBody: Equatable {
    public let typeName: String?
    public let instanceId: String?
    public let schemaVersion: String?
    public let captureTime: String?
    public let entries: [[String:String]]?
    public let nextToken: String?
}

extension ListInventoryEntriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case captureTime = "CaptureTime"
        case entries = "Entries"
        case instanceId = "InstanceId"
        case nextToken = "NextToken"
        case schemaVersion = "SchemaVersion"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let captureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let entriesContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .entries)
        var entriesDecoded0:[[String:String]]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [[String:String]]()
            for map0 in entriesContainer {
                var entriesContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    entriesContainerDecoded0 = [String: String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            entriesContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let entriesContainerDecoded0 = entriesContainerDecoded0 {
                    entriesDecoded0?.append(entriesContainerDecoded0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOpsItemEventsInputBodyMiddleware: Middleware {
    public let id: String = "ListOpsItemEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemEventsOutputError>
}

extension ListOpsItemEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsItemEventsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOpsItemEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemeventfilters0 in filters {
                try filtersContainer.encode(opsitemeventfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOpsItemEventsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOpsItemEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOpsItemEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemEventsInput>
    public typealias MOutput = OperationOutput<ListOpsItemEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemEventsOutputError>
}

public struct ListOpsItemEventsInput: Equatable {
    /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
    public let filters: [OpsItemEventFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results. </p>
    public let maxResults: Int?
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        filters: [OpsItemEventFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsItemEventsInputBody: Equatable {
    public let filters: [OpsItemEventFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListOpsItemEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([OpsItemEventFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpsItemEventFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpsItemEventFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemEventsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsItemEventsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListOpsItemEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOpsItemEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemEventsOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results. </p>
    public let nextToken: String?
    /// <p>A list of event information for the specified OpsItems.</p>
    public let summaries: [OpsItemEventSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [OpsItemEventSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemEventsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let summaries: [OpsItemEventSummary]?
}

extension ListOpsItemEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([OpsItemEventSummary?].self, forKey: .summaries)
        var summariesDecoded0:[OpsItemEventSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [OpsItemEventSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct ListOpsItemRelatedItemsInputBodyMiddleware: Middleware {
    public let id: String = "ListOpsItemRelatedItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemRelatedItemsOutputError>
}

extension ListOpsItemRelatedItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsItemRelatedItemsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), opsItemId: \(String(describing: opsItemId)))"}
}

extension ListOpsItemRelatedItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsitemrelateditemsfilters0 in filters {
                try filtersContainer.encode(opsitemrelateditemsfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }
}

public struct ListOpsItemRelatedItemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOpsItemRelatedItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOpsItemRelatedItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsItemRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsItemRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsItemRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListOpsItemRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsItemRelatedItemsOutputError>
}

public struct ListOpsItemRelatedItemsInput: Equatable {
    /// <p>One or more OpsItem filters. Use a filter to return a more specific list of results. </p>
    public let filters: [OpsItemRelatedItemsFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of items to return. (You received this token from a previous
    ///    call.)</p>
    public let nextToken: String?
    /// <p>The ID of the OpsItem for which you want to list all related-item resources.</p>
    public let opsItemId: String?

    public init (
        filters: [OpsItemRelatedItemsFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        opsItemId: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemId = opsItemId
    }
}

struct ListOpsItemRelatedItemsInputBody: Equatable {
    public let opsItemId: String?
    public let filters: [OpsItemRelatedItemsFilter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListOpsItemRelatedItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([OpsItemRelatedItemsFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpsItemRelatedItemsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpsItemRelatedItemsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsItemRelatedItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsItemRelatedItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsItemRelatedItemsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsItemRelatedItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsItemRelatedItemsOutputResponse(nextToken: \(String(describing: nextToken)), summaries: \(String(describing: summaries)))"}
}

extension ListOpsItemRelatedItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOpsItemRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListOpsItemRelatedItemsOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>A list of related-item resources for the specified OpsItem.</p>
    public let summaries: [OpsItemRelatedItemSummary]?

    public init (
        nextToken: String? = nil,
        summaries: [OpsItemRelatedItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListOpsItemRelatedItemsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let summaries: [OpsItemRelatedItemSummary]?
}

extension ListOpsItemRelatedItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case summaries = "Summaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let summariesContainer = try containerValues.decodeIfPresent([OpsItemRelatedItemSummary?].self, forKey: .summaries)
        var summariesDecoded0:[OpsItemRelatedItemSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [OpsItemRelatedItemSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct ListOpsMetadataInputBodyMiddleware: Middleware {
    public let id: String = "ListOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsMetadataOutputError>
}

extension ListOpsMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsMetadataInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOpsMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsmetadatafilterlist0 in filters {
                try filtersContainer.encode(opsmetadatafilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOpsMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "ListOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOpsMetadataInput>
    public typealias MOutput = OperationOutput<ListOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOpsMetadataOutputError>
}

public struct ListOpsMetadataInput: Equatable {
    /// <p>One or more filters to limit the number of OpsMetadata objects returned by the call.</p>
    public let filters: [OpsMetadataFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        filters: [OpsMetadataFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOpsMetadataInputBody: Equatable {
    public let filters: [OpsMetadataFilter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListOpsMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([OpsMetadataFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpsMetadataFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpsMetadataFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOpsMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOpsMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOpsMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOpsMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOpsMetadataOutputResponse(nextToken: \(String(describing: nextToken)), opsMetadataList: \(String(describing: opsMetadataList)))"}
}

extension ListOpsMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.opsMetadataList = output.opsMetadataList
        } else {
            self.nextToken = nil
            self.opsMetadataList = nil
        }
    }
}

public struct ListOpsMetadataOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>Returns a list of OpsMetadata objects.</p>
    public let opsMetadataList: [OpsMetadata]?

    public init (
        nextToken: String? = nil,
        opsMetadataList: [OpsMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsMetadataList = opsMetadataList
    }
}

struct ListOpsMetadataOutputResponseBody: Equatable {
    public let opsMetadataList: [OpsMetadata]?
    public let nextToken: String?
}

extension ListOpsMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case opsMetadataList = "OpsMetadataList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataListContainer = try containerValues.decodeIfPresent([OpsMetadata?].self, forKey: .opsMetadataList)
        var opsMetadataListDecoded0:[OpsMetadata]? = nil
        if let opsMetadataListContainer = opsMetadataListContainer {
            opsMetadataListDecoded0 = [OpsMetadata]()
            for structure0 in opsMetadataListContainer {
                if let structure0 = structure0 {
                    opsMetadataListDecoded0?.append(structure0)
                }
            }
        }
        opsMetadataList = opsMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceComplianceSummariesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceComplianceSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceComplianceSummariesOutputError>
}

extension ListResourceComplianceSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceComplianceSummariesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceComplianceSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for compliancestringfilterlist0 in filters {
                try filtersContainer.encode(compliancestringfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceComplianceSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceComplianceSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceComplianceSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceComplianceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceComplianceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceComplianceSummariesInput>
    public typealias MOutput = OperationOutput<ListResourceComplianceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceComplianceSummariesOutputError>
}

public struct ListResourceComplianceSummariesInput: Equatable {
    /// <p>One or more filters. Use a filter to return a more specific list of results.</p>
    public let filters: [ComplianceStringFilter]?
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        filters: [ComplianceStringFilter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceComplianceSummariesInputBody: Equatable {
    public let filters: [ComplianceStringFilter]?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListResourceComplianceSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ComplianceStringFilter?].self, forKey: .filters)
        var filtersDecoded0:[ComplianceStringFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ComplianceStringFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceComplianceSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceComplianceSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilter" : self = .invalidFilter(try InvalidFilter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceComplianceSummariesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidFilter(InvalidFilter)
    case invalidNextToken(InvalidNextToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceComplianceSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceComplianceSummariesOutputResponse(nextToken: \(String(describing: nextToken)), resourceComplianceSummaryItems: \(String(describing: resourceComplianceSummaryItems)))"}
}

extension ListResourceComplianceSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceComplianceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceComplianceSummaryItems = output.resourceComplianceSummaryItems
        } else {
            self.nextToken = nil
            self.resourceComplianceSummaryItems = nil
        }
    }
}

public struct ListResourceComplianceSummariesOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>A summary count for specified or targeted managed instances. Summary count includes
    ///    information about compliant and non-compliant State Manager associations, patch status, or custom
    ///    items according to the filter criteria that you specify. </p>
    public let resourceComplianceSummaryItems: [ResourceComplianceSummaryItem]?

    public init (
        nextToken: String? = nil,
        resourceComplianceSummaryItems: [ResourceComplianceSummaryItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceComplianceSummaryItems = resourceComplianceSummaryItems
    }
}

struct ListResourceComplianceSummariesOutputResponseBody: Equatable {
    public let resourceComplianceSummaryItems: [ResourceComplianceSummaryItem]?
    public let nextToken: String?
}

extension ListResourceComplianceSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceComplianceSummaryItems = "ResourceComplianceSummaryItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceComplianceSummaryItemsContainer = try containerValues.decodeIfPresent([ResourceComplianceSummaryItem?].self, forKey: .resourceComplianceSummaryItems)
        var resourceComplianceSummaryItemsDecoded0:[ResourceComplianceSummaryItem]? = nil
        if let resourceComplianceSummaryItemsContainer = resourceComplianceSummaryItemsContainer {
            resourceComplianceSummaryItemsDecoded0 = [ResourceComplianceSummaryItem]()
            for structure0 in resourceComplianceSummaryItemsContainer {
                if let structure0 = structure0 {
                    resourceComplianceSummaryItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceComplianceSummaryItems = resourceComplianceSummaryItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceDataSyncInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDataSyncOutputError>
}

extension ListResourceDataSyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDataSyncInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), syncType: \(String(describing: syncType)))"}
}

extension ListResourceDataSyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct ListResourceDataSyncInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDataSyncInput>
    public typealias MOutput = OperationOutput<ListResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDataSyncOutputError>
}

public struct ListResourceDataSyncInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that you
    ///    can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?
    /// <p>View a list of resource data syncs according to the sync type. Specify
    ///     <code>SyncToDestination</code> to view resource data syncs that synchronize data to an Amazon S3
    ///    bucket. Specify <code>SyncFromSource</code> to view resource data syncs from AWS Organizations or from
    ///    multiple AWS Regions.</p>
    public let syncType: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        syncType: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncType = syncType
    }
}

struct ListResourceDataSyncInputBody: Equatable {
    public let syncType: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListResourceDataSyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case syncType = "SyncType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDataSyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDataSyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextToken(try InvalidNextToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfigurationException" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDataSyncOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidNextToken(InvalidNextToken)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDataSyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDataSyncOutputResponse(nextToken: \(String(describing: nextToken)), resourceDataSyncItems: \(String(describing: resourceDataSyncItems)))"}
}

extension ListResourceDataSyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceDataSyncOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceDataSyncItems = output.resourceDataSyncItems
        } else {
            self.nextToken = nil
            self.resourceDataSyncItems = nil
        }
    }
}

public struct ListResourceDataSyncOutputResponse: Equatable {
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///    results.</p>
    public let nextToken: String?
    /// <p>A list of your current Resource Data Sync configurations and their statuses.</p>
    public let resourceDataSyncItems: [ResourceDataSyncItem]?

    public init (
        nextToken: String? = nil,
        resourceDataSyncItems: [ResourceDataSyncItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceDataSyncItems = resourceDataSyncItems
    }
}

struct ListResourceDataSyncOutputResponseBody: Equatable {
    public let resourceDataSyncItems: [ResourceDataSyncItem]?
    public let nextToken: String?
}

extension ListResourceDataSyncOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceDataSyncItems = "ResourceDataSyncItems"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDataSyncItemsContainer = try containerValues.decodeIfPresent([ResourceDataSyncItem?].self, forKey: .resourceDataSyncItems)
        var resourceDataSyncItemsDecoded0:[ResourceDataSyncItem]? = nil
        if let resourceDataSyncItemsContainer = resourceDataSyncItemsContainer {
            resourceDataSyncItemsDecoded0 = [ResourceDataSyncItem]()
            for structure0 in resourceDataSyncItemsContainer {
                if let structure0 = structure0 {
                    resourceDataSyncItemsDecoded0?.append(structure0)
                }
            }
        }
        resourceDataSyncItems = resourceDataSyncItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The resource ID for which you want to see a list of tags.</p>
    public let resourceId: String?
    /// <p>Returns a list of tags for a specific resource type.</p>
    public let resourceType: ResourceTypeForTagging?

    public init (
        resourceId: String? = nil,
        resourceType: ResourceTypeForTagging? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceType: ResourceTypeForTagging?
    public let resourceId: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension LoggingInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case s3Region = "S3Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let s3Region = s3Region {
            try encodeContainer.encode(s3Region, forKey: .s3Region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
    }
}

extension LoggingInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingInfo(s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), s3Region: \(String(describing: s3Region)))"}
}

/// <p>Information about an S3 bucket to write instance-level logs to.</p>
///          <note>
///             <p>
///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
///       For information about how Systems Manager handles these options for the supported maintenance
///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///          </note>
public struct LoggingInfo: Equatable {
    /// <p>The name of an S3 bucket where execution logs are stored .</p>
    public let s3BucketName: String?
    /// <p>(Optional) The S3 bucket subfolder. </p>
    public let s3KeyPrefix: String?
    /// <p>The Region where the S3 bucket is located.</p>
    public let s3Region: String?

    public init (
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        s3Region: String? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.s3Region = s3Region
    }
}

extension MaintenanceWindowAutomationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension MaintenanceWindowAutomationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowAutomationParameters(documentVersion: \(String(describing: documentVersion)), parameters: \(String(describing: parameters)))"}
}

/// <p>The parameters for an AUTOMATION task type.</p>
public struct MaintenanceWindowAutomationParameters: Equatable {
    /// <p>The version of an Automation document to use during task execution.</p>
    public let documentVersion: String?
    /// <p>The parameters for the AUTOMATION task.</p>
    ///          <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
    ///          <note>
    ///
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///             <p>For AUTOMATION task types, Systems Manager ignores any values specified for these parameters.</p>
    ///          </note>
    public let parameters: [String:[String]]?

    public init (
        documentVersion: String? = nil,
        parameters: [String:[String]]? = nil
    )
    {
        self.documentVersion = documentVersion
        self.parameters = parameters
    }
}

extension MaintenanceWindowExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case windowExecutionId = "WindowExecutionId"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension MaintenanceWindowExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowExecution(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), windowExecutionId: \(String(describing: windowExecutionId)), windowId: \(String(describing: windowId)))"}
}

/// <p>Describes the information about an execution of a maintenance window. </p>
public struct MaintenanceWindowExecution: Equatable {
    /// <p>The time the execution finished.</p>
    public let endTime: Date?
    /// <p>The time the execution started.</p>
    public let startTime: Date?
    /// <p>The status of the execution.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the Status. Only available for certain status values.</p>
    public let statusDetails: String?
    /// <p>The ID of the maintenance window execution.</p>
    public let windowExecutionId: String?
    /// <p>The ID of the maintenance window.</p>
    public let windowId: String?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        windowExecutionId: String? = nil,
        windowId: String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.windowExecutionId = windowExecutionId
        self.windowId = windowId
    }
}

public enum MaintenanceWindowExecutionStatus {
    case cancelled
    case cancelling
    case failed
    case inprogress
    case pending
    case skippedoverlapping
    case success
    case timedout
    case sdkUnknown(String)
}

extension MaintenanceWindowExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MaintenanceWindowExecutionStatus] {
        return [
            .cancelled,
            .cancelling,
            .failed,
            .inprogress,
            .pending,
            .skippedoverlapping,
            .success,
            .timedout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .failed: return "FAILED"
        case .inprogress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .skippedoverlapping: return "SKIPPED_OVERLAPPING"
        case .success: return "SUCCESS"
        case .timedout: return "TIMED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MaintenanceWindowExecutionStatus(rawValue: rawValue) ?? MaintenanceWindowExecutionStatus.sdkUnknown(rawValue)
    }
}

extension MaintenanceWindowExecutionTaskIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskArn = "TaskArn"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
    }
}

extension MaintenanceWindowExecutionTaskIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowExecutionTaskIdentity(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), taskArn: \(String(describing: taskArn)), taskExecutionId: \(String(describing: taskExecutionId)), taskType: \(String(describing: taskType)), windowExecutionId: \(String(describing: windowExecutionId)))"}
}

/// <p>Information about a task execution performed as part of a maintenance window
///    execution.</p>
public struct MaintenanceWindowExecutionTaskIdentity: Equatable {
    /// <p>The time the task execution finished.</p>
    public let endTime: Date?
    /// <p>The time the task execution started.</p>
    public let startTime: Date?
    /// <p>The status of the task execution.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the status of the task execution. Only available for certain status
    ///    values.</p>
    public let statusDetails: String?
    /// <p>The ARN of the task that ran.</p>
    public let taskArn: String?
    /// <p>The ID of the specific task execution in the maintenance window execution.</p>
    public let taskExecutionId: String?
    /// <p>The type of task that ran.</p>
    public let taskType: MaintenanceWindowTaskType?
    /// <p>The ID of the maintenance window execution that ran the task.</p>
    public let windowExecutionId: String?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        taskArn: String? = nil,
        taskExecutionId: String? = nil,
        taskType: MaintenanceWindowTaskType? = nil,
        windowExecutionId: String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskArn = taskArn
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
    }
}

extension MaintenanceWindowExecutionTaskInvocationIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case executionId = "ExecutionId"
        case invocationId = "InvocationId"
        case ownerInformation = "OwnerInformation"
        case parameters = "Parameters"
        case startTime = "StartTime"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case taskExecutionId = "TaskExecutionId"
        case taskType = "TaskType"
        case windowExecutionId = "WindowExecutionId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let executionId = executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let invocationId = invocationId {
            try encodeContainer.encode(invocationId, forKey: .invocationId)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetails = statusDetails {
            try encodeContainer.encode(statusDetails, forKey: .statusDetails)
        }
        if let taskExecutionId = taskExecutionId {
            try encodeContainer.encode(taskExecutionId, forKey: .taskExecutionId)
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowExecutionId = windowExecutionId {
            try encodeContainer.encode(windowExecutionId, forKey: .windowExecutionId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowExecutionId)
        windowExecutionId = windowExecutionIdDecoded
        let taskExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskExecutionId)
        taskExecutionId = taskExecutionIdDecoded
        let invocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationId)
        invocationId = invocationIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameters)
        parameters = parametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MaintenanceWindowExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

extension MaintenanceWindowExecutionTaskInvocationIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowExecutionTaskInvocationIdentity(endTime: \(String(describing: endTime)), executionId: \(String(describing: executionId)), invocationId: \(String(describing: invocationId)), ownerInformation: \(String(describing: ownerInformation)), parameters: \(String(describing: parameters)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusDetails: \(String(describing: statusDetails)), taskExecutionId: \(String(describing: taskExecutionId)), taskType: \(String(describing: taskType)), windowExecutionId: \(String(describing: windowExecutionId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

/// <p>Describes the information about a task invocation for a particular target as part of a task
///    execution performed as part of a maintenance window execution.</p>
public struct MaintenanceWindowExecutionTaskInvocationIdentity: Equatable {
    /// <p>The time the invocation finished.</p>
    public let endTime: Date?
    /// <p>The ID of the action performed in the service that actually handled the task invocation. If
    ///    the task type is RUN_COMMAND, this value is the command ID.</p>
    public let executionId: String?
    /// <p>The ID of the task invocation.</p>
    public let invocationId: String?
    /// <p>User-provided value that was specified when the target was registered with the maintenance
    ///    window. This was also included in any CloudWatch events raised during the task invocation.</p>
    public let ownerInformation: String?
    /// <p>The parameters that were provided for the invocation when it was run.</p>
    public let parameters: String?
    /// <p>The time the invocation started.</p>
    public let startTime: Date?
    /// <p>The status of the task invocation.</p>
    public let status: MaintenanceWindowExecutionStatus?
    /// <p>The details explaining the status of the task invocation. Only available for certain Status
    ///    values. </p>
    public let statusDetails: String?
    /// <p>The ID of the specific task execution in the maintenance window execution.</p>
    public let taskExecutionId: String?
    /// <p>The task type.</p>
    public let taskType: MaintenanceWindowTaskType?
    /// <p>The ID of the maintenance window execution that ran the task.</p>
    public let windowExecutionId: String?
    /// <p>The ID of the target definition in this maintenance window the invocation was performed
    ///    for.</p>
    public let windowTargetId: String?

    public init (
        endTime: Date? = nil,
        executionId: String? = nil,
        invocationId: String? = nil,
        ownerInformation: String? = nil,
        parameters: String? = nil,
        startTime: Date? = nil,
        status: MaintenanceWindowExecutionStatus? = nil,
        statusDetails: String? = nil,
        taskExecutionId: String? = nil,
        taskType: MaintenanceWindowTaskType? = nil,
        windowExecutionId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.endTime = endTime
        self.executionId = executionId
        self.invocationId = invocationId
        self.ownerInformation = ownerInformation
        self.parameters = parameters
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
        self.windowTargetId = windowTargetId
    }
}

extension MaintenanceWindowFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowfiltervalues0 in values {
                try valuesContainer.encode(maintenancewindowfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MaintenanceWindowFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Filter used in the request. Supported filter keys are Name and Enabled.</p>
public struct MaintenanceWindowFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: String?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension MaintenanceWindowIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case nextExecutionTime = "NextExecutionTime"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextExecutionTime = nextExecutionTime {
            try encodeContainer.encode(nextExecutionTime, forKey: .nextExecutionTime)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let nextExecutionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextExecutionTime)
        nextExecutionTime = nextExecutionTimeDecoded
    }
}

extension MaintenanceWindowIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowIdentity(cutoff: \(String(describing: cutoff)), description: \(String(describing: description)), duration: \(String(describing: duration)), enabled: \(String(describing: enabled)), endDate: \(String(describing: endDate)), name: \(String(describing: name)), nextExecutionTime: \(String(describing: nextExecutionTime)), schedule: \(String(describing: schedule)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleTimezone: \(String(describing: scheduleTimezone)), startDate: \(String(describing: startDate)), windowId: \(String(describing: windowId)))"}
}

/// <p>Information about the maintenance window.</p>
public struct MaintenanceWindowIdentity: Equatable {
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    ///    tasks for execution.</p>
    public let cutoff: Int
    /// <p>A description of the maintenance window.</p>
    public let description: String?
    /// <p>The duration of the maintenance window in hours.</p>
    public let duration: Int
    /// <p>Indicates whether the maintenance window is enabled.</p>
    public let enabled: Bool
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become inactive.</p>
    public let endDate: String?
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>The next time the maintenance window will actually run, taking into account any specified
    ///    times for the maintenance window to become active or inactive.</p>
    public let nextExecutionTime: String?
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    public let schedule: String?
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    ///    date and time.</p>
    public let scheduleOffset: Int
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format.</p>
    public let scheduleTimezone: String?
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become active.</p>
    public let startDate: String?
    /// <p>The ID of the maintenance window.</p>
    public let windowId: String?

    public init (
        cutoff: Int = 0,
        description: String? = nil,
        duration: Int = 0,
        enabled: Bool = false,
        endDate: String? = nil,
        name: String? = nil,
        nextExecutionTime: String? = nil,
        schedule: String? = nil,
        scheduleOffset: Int = 0,
        scheduleTimezone: String? = nil,
        startDate: String? = nil,
        windowId: String? = nil
    )
    {
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.nextExecutionTime = nextExecutionTime
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

extension MaintenanceWindowIdentityForTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MaintenanceWindowIdentityForTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowIdentityForTarget(name: \(String(describing: name)), windowId: \(String(describing: windowId)))"}
}

/// <p>The maintenance window to which the specified target belongs.</p>
public struct MaintenanceWindowIdentityForTarget: Equatable {
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>The ID of the maintenance window.</p>
    public let windowId: String?

    public init (
        name: String? = nil,
        windowId: String? = nil
    )
    {
        self.name = name
        self.windowId = windowId
    }
}

extension MaintenanceWindowLambdaParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientContext = "ClientContext"
        case payload = "Payload"
        case qualifier = "Qualifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientContext = clientContext {
            try encodeContainer.encode(clientContext, forKey: .clientContext)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let qualifier = qualifier {
            try encodeContainer.encode(qualifier, forKey: .qualifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientContextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientContext)
        clientContext = clientContextDecoded
        let qualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualifier)
        qualifier = qualifierDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension MaintenanceWindowLambdaParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowLambdaParameters(clientContext: \(String(describing: clientContext)), payload: \(String(describing: payload)), qualifier: \(String(describing: qualifier)))"}
}

/// <p>The parameters for a LAMBDA task type.</p>
///          <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
///          <note>
///
///             <p>
///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
///       For information about how Systems Manager handles these options for the supported maintenance
///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///
///             <p>
///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
///       about how Systems Manager handles these options for the supported maintenance window task
///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///             <p>For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and
///     LoggingInfo.</p>
///          </note>
public struct MaintenanceWindowLambdaParameters: Equatable {
    /// <p>Pass client-specific information to the Lambda function that you are invoking. You can then
    ///    process the client information in your Lambda function as you choose through the context
    ///    variable.</p>
    public let clientContext: String?
    /// <p>JSON to provide to your Lambda function as input.</p>
    public let payload: Data?
    /// <p>(Optional) Specify a Lambda function version or alias name. If you specify a function
    ///    version, the action uses the qualified function ARN to invoke a specific Lambda function. If you
    ///    specify an alias name, the action uses the alias ARN to invoke the Lambda function version to
    ///    which the alias points.</p>
    public let qualifier: String?

    public init (
        clientContext: String? = nil,
        payload: Data? = nil,
        qualifier: String? = nil
    )
    {
        self.clientContext = clientContext
        self.payload = payload
        self.qualifier = qualifier
    }
}

public enum MaintenanceWindowResourceType {
    case instance
    case resourcegroup
    case sdkUnknown(String)
}

extension MaintenanceWindowResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MaintenanceWindowResourceType] {
        return [
            .instance,
            .resourcegroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instance: return "INSTANCE"
        case .resourcegroup: return "RESOURCE_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MaintenanceWindowResourceType(rawValue: rawValue) ?? MaintenanceWindowResourceType.sdkUnknown(rawValue)
    }
}

extension MaintenanceWindowRunCommandParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentVersion = "DocumentVersion"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
    }
}

extension MaintenanceWindowRunCommandParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowRunCommandParameters(cloudWatchOutputConfig: \(String(describing: cloudWatchOutputConfig)), comment: \(String(describing: comment)), documentHash: \(String(describing: documentHash)), documentHashType: \(String(describing: documentHashType)), documentVersion: \(String(describing: documentVersion)), notificationConfig: \(String(describing: notificationConfig)), outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), parameters: \(String(describing: parameters)), serviceRoleArn: \(String(describing: serviceRoleArn)), timeoutSeconds: \(String(describing: timeoutSeconds)))"}
}

/// <p>The parameters for a RUN_COMMAND task type.</p>
///          <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
///          <note>
///
///             <p>
///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
///       For information about how Systems Manager handles these options for the supported maintenance
///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///
///             <p>
///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
///       about how Systems Manager handles these options for the supported maintenance window task
///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///             <p>For Run Command tasks, Systems Manager uses specified values for <code>TaskParameters</code> and
///      <code>LoggingInfo</code> only if no values are specified for
///      <code>TaskInvocationParameters</code>. </p>
///          </note>
public struct MaintenanceWindowRunCommandParameters: Equatable {
    /// <p>Configuration options for sending command output to CloudWatch Logs.</p>
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
    /// <p>Information about the commands to run.</p>
    public let comment: String?
    /// <p>The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes
    ///    have been deprecated.</p>
    public let documentHash: String?
    /// <p>SHA-256 or SHA-1. SHA-1 hashes have been deprecated.</p>
    public let documentHashType: DocumentHashType?
    /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
    ///    specific version number. If you run commands by using the AWS CLI, then you must escape the first
    ///    two options by using a backslash. If you specify a version number, then you don't need to use the
    ///    backslash. For example:</p>
    ///          <p>--document-version "\$DEFAULT"</p>
    ///          <p>--document-version "\$LATEST"</p>
    ///          <p>--document-version "3"</p>
    public let documentVersion: String?
    /// <p>Configurations for sending notifications about command status changes on a per-instance
    ///    basis.</p>
    public let notificationConfig: NotificationConfig?
    /// <p>The name of the S3 bucket.</p>
    public let outputS3BucketName: String?
    /// <p>The S3 bucket subfolder.</p>
    public let outputS3KeyPrefix: String?
    /// <p>The parameters for the RUN_COMMAND task execution.</p>
    public let parameters: [String:[String]]?
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    ///    maintenance window Run Command tasks.</p>
    public let serviceRoleArn: String?
    /// <p>If this time is reached and the command has not already started running, it doesn't
    ///    run.</p>
    public let timeoutSeconds: Int

    public init (
        cloudWatchOutputConfig: CloudWatchOutputConfig? = nil,
        comment: String? = nil,
        documentHash: String? = nil,
        documentHashType: DocumentHashType? = nil,
        documentVersion: String? = nil,
        notificationConfig: NotificationConfig? = nil,
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        parameters: [String:[String]]? = nil,
        serviceRoleArn: String? = nil,
        timeoutSeconds: Int = 0
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.comment = comment
        self.documentHash = documentHash
        self.documentHashType = documentHashType
        self.documentVersion = documentVersion
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.parameters = parameters
        self.serviceRoleArn = serviceRoleArn
        self.timeoutSeconds = timeoutSeconds
    }
}

extension MaintenanceWindowStepFunctionsParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input = "Input"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MaintenanceWindowStepFunctionsParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowStepFunctionsParameters(input: \(String(describing: input)), name: \(String(describing: name)))"}
}

/// <p>The parameters for a STEP_FUNCTIONS task.</p>
///          <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p>
///          <note>
///
///             <p>
///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
///       For information about how Systems Manager handles these options for the supported maintenance
///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///
///             <p>
///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
///       about how Systems Manager handles these options for the supported maintenance window task
///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
///             <p>For Step Functions tasks, Systems Manager ignores any values specified for
///      <code>TaskParameters</code> and <code>LoggingInfo</code>.</p>
///          </note>
public struct MaintenanceWindowStepFunctionsParameters: Equatable {
    /// <p>The inputs for the STEP_FUNCTIONS task.</p>
    public let input: String?
    /// <p>The name of the STEP_FUNCTIONS task.</p>
    public let name: String?

    public init (
        input: String? = nil,
        name: String? = nil
    )
    {
        self.input = input
        self.name = name
    }
}

extension MaintenanceWindowTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MaintenanceWindowTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowTarget(description: \(String(describing: description)), name: \(String(describing: name)), ownerInformation: \(String(describing: ownerInformation)), resourceType: \(String(describing: resourceType)), targets: \(String(describing: targets)), windowId: \(String(describing: windowId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

/// <p>The target registered with the maintenance window.</p>
public struct MaintenanceWindowTarget: Equatable {
    /// <p>A description for the target.</p>
    public let description: String?
    /// <p>The name for the maintenance window target.</p>
    public let name: String?
    /// <p>A user-provided value that will be included in any CloudWatch events that are raised while
    ///    running tasks for these targets in this maintenance window.</p>
    public let ownerInformation: String?
    /// <p>The type of target that is being registered with the maintenance window.</p>
    public let resourceType: MaintenanceWindowResourceType?
    /// <p>The targets, either instances or tags.</p>
    ///          <p>Specify instances using the following format:</p>
    ///          <p>
    ///             <code>Key=instanceids,Values=<instanceid1>,<instanceid2></code>
    ///          </p>
    ///          <p>Tags are specified using the following format:</p>
    ///          <p>
    ///             <code>Key=<tag name>,Values=<tag value></code>.</p>
    public let targets: [Target]?
    /// <p>The ID of the maintenance window to register the target with.</p>
    public let windowId: String?
    /// <p>The ID of the target.</p>
    public let windowTargetId: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        ownerInformation: String? = nil,
        resourceType: MaintenanceWindowResourceType? = nil,
        targets: [Target]? = nil,
        windowId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

extension MaintenanceWindowTask: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskParameters = "TaskParameters"
        case type = "Type"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .type)
        type = typeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskParametersContainer = try containerValues.decodeIfPresent([String: MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [String:MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [String:MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MaintenanceWindowTask: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowTask(description: \(String(describing: description)), loggingInfo: \(String(describing: loggingInfo)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), priority: \(String(describing: priority)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), taskArn: \(String(describing: taskArn)), taskParameters: \(String(describing: taskParameters)), type: \(String(describing: type)), windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

/// <p>Information about a task defined for a maintenance window.</p>
public struct MaintenanceWindowTask: Equatable {
    /// <p>A description of the task.</p>
    public let description: String?
    /// <p>Information about an S3 bucket to write task-level logs to.</p>
    ///          <note>
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let loggingInfo: LoggingInfo?
    /// <p>The maximum number of targets this task can be run for, in parallel.</p>
    public let maxConcurrency: String?
    /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
    public let maxErrors: String?
    /// <p>The task name.</p>
    public let name: String?
    /// <p>The priority of the task in the maintenance window. The lower the number, the higher the
    ///    priority. Tasks that have the same priority are scheduled in parallel.</p>
    public let priority: Int
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    ///    maintenance window Run Command tasks.</p>
    public let serviceRoleArn: String?
    /// <p>The targets (either instances or tags). Instances are specified using
    ///    Key=instanceids,Values=<instanceid1>,<instanceid2>. Tags are specified using
    ///    Key=<tag name>,Values=<tag value>.</p>
    public let targets: [Target]?
    /// <p>The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types,
    ///     <code>TaskArn</code> is the Systems Manager document name or ARN. For LAMBDA tasks, it's the function name
    ///    or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.</p>
    public let taskArn: String?
    /// <p>The parameters that should be passed to the task when it is run.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    /// <p>The type of task. The type can be one of the following: RUN_COMMAND, AUTOMATION, LAMBDA, or
    ///    STEP_FUNCTIONS.</p>
    public let type: MaintenanceWindowTaskType?
    /// <p>The ID of the maintenance window where the task is registered.</p>
    public let windowId: String?
    /// <p>The task ID.</p>
    public let windowTaskId: String?

    public init (
        description: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        priority: Int = 0,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        taskArn: String? = nil,
        taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]? = nil,
        type: MaintenanceWindowTaskType? = nil,
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskParameters = taskParameters
        self.type = type
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

extension MaintenanceWindowTaskInvocationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automation = "Automation"
        case lambda = "Lambda"
        case runCommand = "RunCommand"
        case stepFunctions = "StepFunctions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automation = automation {
            try encodeContainer.encode(automation, forKey: .automation)
        }
        if let lambda = lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
        if let runCommand = runCommand {
            try encodeContainer.encode(runCommand, forKey: .runCommand)
        }
        if let stepFunctions = stepFunctions {
            try encodeContainer.encode(stepFunctions, forKey: .stepFunctions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandDecoded = try containerValues.decodeIfPresent(MaintenanceWindowRunCommandParameters.self, forKey: .runCommand)
        runCommand = runCommandDecoded
        let automationDecoded = try containerValues.decodeIfPresent(MaintenanceWindowAutomationParameters.self, forKey: .automation)
        automation = automationDecoded
        let stepFunctionsDecoded = try containerValues.decodeIfPresent(MaintenanceWindowStepFunctionsParameters.self, forKey: .stepFunctions)
        stepFunctions = stepFunctionsDecoded
        let lambdaDecoded = try containerValues.decodeIfPresent(MaintenanceWindowLambdaParameters.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension MaintenanceWindowTaskInvocationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaintenanceWindowTaskInvocationParameters(automation: \(String(describing: automation)), lambda: \(String(describing: lambda)), runCommand: \(String(describing: runCommand)), stepFunctions: \(String(describing: stepFunctions)))"}
}

/// <p>The parameters for task execution.</p>
public struct MaintenanceWindowTaskInvocationParameters: Equatable {
    /// <p>The parameters for an AUTOMATION task type.</p>
    public let automation: MaintenanceWindowAutomationParameters?
    /// <p>The parameters for a LAMBDA task type.</p>
    public let lambda: MaintenanceWindowLambdaParameters?
    /// <p>The parameters for a RUN_COMMAND task type.</p>
    public let runCommand: MaintenanceWindowRunCommandParameters?
    /// <p>The parameters for a STEP_FUNCTIONS task type.</p>
    public let stepFunctions: MaintenanceWindowStepFunctionsParameters?

    public init (
        automation: MaintenanceWindowAutomationParameters? = nil,
        lambda: MaintenanceWindowLambdaParameters? = nil,
        runCommand: MaintenanceWindowRunCommandParameters? = nil,
        stepFunctions: MaintenanceWindowStepFunctionsParameters? = nil
    )
    {
        self.automation = automation
        self.lambda = lambda
        self.runCommand = runCommand
        self.stepFunctions = stepFunctions
    }
}

extension MaintenanceWindowTaskParameterValueExpression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for maintenancewindowtaskparametervaluelist0 in values {
                try valuesContainer.encode(maintenancewindowtaskparametervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MaintenanceWindowTaskParameterValueExpression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Defines the values for a task parameter.</p>
public struct MaintenanceWindowTaskParameterValueExpression: Equatable {
    /// <p>This field contains an array of 0 or more strings, each 1 to 255 characters in
    ///    length.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

public enum MaintenanceWindowTaskType {
    case automation
    case lambda
    case runcommand
    case stepfunctions
    case sdkUnknown(String)
}

extension MaintenanceWindowTaskType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MaintenanceWindowTaskType] {
        return [
            .automation,
            .lambda,
            .runcommand,
            .stepfunctions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automation: return "AUTOMATION"
        case .lambda: return "LAMBDA"
        case .runcommand: return "RUN_COMMAND"
        case .stepfunctions: return "STEP_FUNCTIONS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MaintenanceWindowTaskType(rawValue: rawValue) ?? MaintenanceWindowTaskType.sdkUnknown(rawValue)
    }
}

extension MaxDocumentSizeExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaxDocumentSizeExceeded(message: \(String(describing: message)))"}
}

extension MaxDocumentSizeExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaxDocumentSizeExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The size limit of a document is 64 KB.</p>
public struct MaxDocumentSizeExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaxDocumentSizeExceededBody: Equatable {
    public let message: String?
}

extension MaxDocumentSizeExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MetadataValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MetadataValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetadataValue(value: \(String(describing: value)))"}
}

/// <p>Metadata to assign to an Application Manager application.</p>
public struct MetadataValue: Equatable {
    /// <p>Metadata value to assign to an Application Manager application.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

public struct ModifyDocumentPermissionInputBodyMiddleware: Middleware {
    public let id: String = "ModifyDocumentPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDocumentPermissionOutputError>
}

extension ModifyDocumentPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDocumentPermissionInput(accountIdsToAdd: \(String(describing: accountIdsToAdd)), accountIdsToRemove: \(String(describing: accountIdsToRemove)), name: \(String(describing: name)), permissionType: \(String(describing: permissionType)), sharedDocumentVersion: \(String(describing: sharedDocumentVersion)))"}
}

extension ModifyDocumentPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIdsToAdd = accountIdsToAdd {
            var accountIdsToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToAdd)
            for accountidlist0 in accountIdsToAdd {
                try accountIdsToAddContainer.encode(accountidlist0)
            }
        }
        if let accountIdsToRemove = accountIdsToRemove {
            var accountIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIdsToRemove)
            for accountidlist0 in accountIdsToRemove {
                try accountIdsToRemoveContainer.encode(accountidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionType = permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedDocumentVersion = sharedDocumentVersion {
            try encodeContainer.encode(sharedDocumentVersion, forKey: .sharedDocumentVersion)
        }
    }
}

public struct ModifyDocumentPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyDocumentPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyDocumentPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyDocumentPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyDocumentPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyDocumentPermissionInput>
    public typealias MOutput = OperationOutput<ModifyDocumentPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyDocumentPermissionOutputError>
}

public struct ModifyDocumentPermissionInput: Equatable {
    /// <p>The AWS user accounts that should have access to the document. The account IDs can either be
    ///    a group of account IDs or <i>All</i>.</p>
    public let accountIdsToAdd: [String]?
    /// <p>The AWS user accounts that should no longer have access to the document. The AWS user
    ///    account can either be a group of account IDs or <i>All</i>. This action has a
    ///    higher priority than <i>AccountIdsToAdd</i>. If you specify an account ID to add
    ///    and the same ID to remove, the system removes access to the document.</p>
    public let accountIdsToRemove: [String]?
    /// <p>The name of the document that you want to share.</p>
    public let name: String?
    /// <p>The permission type for the document. The permission type can be
    ///    <i>Share</i>.</p>
    public let permissionType: DocumentPermissionType?
    /// <p>(Optional) The version of the document to share. If it's not specified, the system choose
    ///    the <code>Default</code> version to share.</p>
    public let sharedDocumentVersion: String?

    public init (
        accountIdsToAdd: [String]? = nil,
        accountIdsToRemove: [String]? = nil,
        name: String? = nil,
        permissionType: DocumentPermissionType? = nil,
        sharedDocumentVersion: String? = nil
    )
    {
        self.accountIdsToAdd = accountIdsToAdd
        self.accountIdsToRemove = accountIdsToRemove
        self.name = name
        self.permissionType = permissionType
        self.sharedDocumentVersion = sharedDocumentVersion
    }
}

struct ModifyDocumentPermissionInputBody: Equatable {
    public let name: String?
    public let permissionType: DocumentPermissionType?
    public let accountIdsToAdd: [String]?
    public let accountIdsToRemove: [String]?
    public let sharedDocumentVersion: String?
}

extension ModifyDocumentPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIdsToAdd = "AccountIdsToAdd"
        case accountIdsToRemove = "AccountIdsToRemove"
        case name = "Name"
        case permissionType = "PermissionType"
        case sharedDocumentVersion = "SharedDocumentVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(DocumentPermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let accountIdsToAddContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIdsToAdd)
        var accountIdsToAddDecoded0:[String]? = nil
        if let accountIdsToAddContainer = accountIdsToAddContainer {
            accountIdsToAddDecoded0 = [String]()
            for string0 in accountIdsToAddContainer {
                if let string0 = string0 {
                    accountIdsToAddDecoded0?.append(string0)
                }
            }
        }
        accountIdsToAdd = accountIdsToAddDecoded0
        let accountIdsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIdsToRemove)
        var accountIdsToRemoveDecoded0:[String]? = nil
        if let accountIdsToRemoveContainer = accountIdsToRemoveContainer {
            accountIdsToRemoveDecoded0 = [String]()
            for string0 in accountIdsToRemoveContainer {
                if let string0 = string0 {
                    accountIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        accountIdsToRemove = accountIdsToRemoveDecoded0
        let sharedDocumentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sharedDocumentVersion)
        sharedDocumentVersion = sharedDocumentVersionDecoded
    }
}

extension ModifyDocumentPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyDocumentPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DocumentLimitExceeded" : self = .documentLimitExceeded(try DocumentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DocumentPermissionLimit" : self = .documentPermissionLimit(try DocumentPermissionLimit(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPermissionType" : self = .invalidPermissionType(try InvalidPermissionType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDocumentPermissionOutputError: Equatable {
    case documentLimitExceeded(DocumentLimitExceeded)
    case documentPermissionLimit(DocumentPermissionLimit)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidPermissionType(InvalidPermissionType)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDocumentPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyDocumentPermissionOutputResponse()"}
}

extension ModifyDocumentPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ModifyDocumentPermissionOutputResponse: Equatable {

    public init() {}
}

struct ModifyDocumentPermissionOutputResponseBody: Equatable {
}

extension ModifyDocumentPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension NonCompliantSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nonCompliantCount = "NonCompliantCount"
        case severitySummary = "SeveritySummary"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if nonCompliantCount != 0 {
            try encodeContainer.encode(nonCompliantCount, forKey: .nonCompliantCount)
        }
        if let severitySummary = severitySummary {
            try encodeContainer.encode(severitySummary, forKey: .severitySummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonCompliantCountDecoded = try containerValues.decode(Int.self, forKey: .nonCompliantCount)
        nonCompliantCount = nonCompliantCountDecoded
        let severitySummaryDecoded = try containerValues.decodeIfPresent(SeveritySummary.self, forKey: .severitySummary)
        severitySummary = severitySummaryDecoded
    }
}

extension NonCompliantSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NonCompliantSummary(nonCompliantCount: \(String(describing: nonCompliantCount)), severitySummary: \(String(describing: severitySummary)))"}
}

/// <p>A summary of resources that are not compliant. The summary is organized according to
///    resource type.</p>
public struct NonCompliantSummary: Equatable {
    /// <p>The total number of compliance items that are not compliant.</p>
    public let nonCompliantCount: Int
    /// <p>A summary of the non-compliance severity by compliance type</p>
    public let severitySummary: SeveritySummary?

    public init (
        nonCompliantCount: Int = 0,
        severitySummary: SeveritySummary? = nil
    )
    {
        self.nonCompliantCount = nonCompliantCount
        self.severitySummary = severitySummary
    }
}

extension NotificationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notificationArn = "NotificationArn"
        case notificationEvents = "NotificationEvents"
        case notificationType = "NotificationType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationArn = notificationArn {
            try encodeContainer.encode(notificationArn, forKey: .notificationArn)
        }
        if let notificationEvents = notificationEvents {
            var notificationEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationEvents)
            for notificationeventlist0 in notificationEvents {
                try notificationEventsContainer.encode(notificationeventlist0.rawValue)
            }
        }
        if let notificationType = notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationArn)
        notificationArn = notificationArnDecoded
        let notificationEventsContainer = try containerValues.decodeIfPresent([NotificationEvent?].self, forKey: .notificationEvents)
        var notificationEventsDecoded0:[NotificationEvent]? = nil
        if let notificationEventsContainer = notificationEventsContainer {
            notificationEventsDecoded0 = [NotificationEvent]()
            for string0 in notificationEventsContainer {
                if let string0 = string0 {
                    notificationEventsDecoded0?.append(string0)
                }
            }
        }
        notificationEvents = notificationEventsDecoded0
        let notificationTypeDecoded = try containerValues.decodeIfPresent(NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
    }
}

extension NotificationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationConfig(notificationArn: \(String(describing: notificationArn)), notificationEvents: \(String(describing: notificationEvents)), notificationType: \(String(describing: notificationType)))"}
}

/// <p>Configurations for sending notifications.</p>
public struct NotificationConfig: Equatable {
    /// <p>An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes
    ///    notifications about command status changes to this topic.</p>
    public let notificationArn: String?
    /// <p>The different events for which you can receive notifications. These events include the
    ///    following: All (events), InProgress, Success, TimedOut, Cancelled, Failed. To learn more about
    ///    these events, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html">Monitoring Systems
    ///     Manager status changes using Amazon SNS notifications</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let notificationEvents: [NotificationEvent]?
    /// <p>Command: Receive notification when the status of a command changes. Invocation: For commands
    ///    sent to multiple instances, receive notification on a per-instance basis when the status of a
    ///    command changes. </p>
    public let notificationType: NotificationType?

    public init (
        notificationArn: String? = nil,
        notificationEvents: [NotificationEvent]? = nil,
        notificationType: NotificationType? = nil
    )
    {
        self.notificationArn = notificationArn
        self.notificationEvents = notificationEvents
        self.notificationType = notificationType
    }
}

public enum NotificationEvent {
    case all
    case cancelled
    case failed
    case inProgress
    case success
    case timedOut
    case sdkUnknown(String)
}

extension NotificationEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationEvent] {
        return [
            .all,
            .cancelled,
            .failed,
            .inProgress,
            .success,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "All"
        case .cancelled: return "Cancelled"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .success: return "Success"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationEvent(rawValue: rawValue) ?? NotificationEvent.sdkUnknown(rawValue)
    }
}

public enum NotificationType {
    case command
    case invocation
    case sdkUnknown(String)
}

extension NotificationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NotificationType] {
        return [
            .command,
            .invocation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .command: return "Command"
        case .invocation: return "Invocation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
    }
}

public enum OperatingSystem {
    case amazonlinux
    case amazonlinux2
    case centos
    case debian
    case macos
    case oraclelinux
    case redhatenterpriselinux
    case suse
    case ubuntu
    case windows
    case sdkUnknown(String)
}

extension OperatingSystem : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OperatingSystem] {
        return [
            .amazonlinux,
            .amazonlinux2,
            .centos,
            .debian,
            .macos,
            .oraclelinux,
            .redhatenterpriselinux,
            .suse,
            .ubuntu,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonlinux: return "AMAZON_LINUX"
        case .amazonlinux2: return "AMAZON_LINUX_2"
        case .centos: return "CENTOS"
        case .debian: return "DEBIAN"
        case .macos: return "MACOS"
        case .oraclelinux: return "ORACLE_LINUX"
        case .redhatenterpriselinux: return "REDHAT_ENTERPRISE_LINUX"
        case .suse: return "SUSE"
        case .ubuntu: return "UBUNTU"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OperatingSystem(rawValue: rawValue) ?? OperatingSystem.sdkUnknown(rawValue)
    }
}

extension OpsAggregator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregatorType = "AggregatorType"
        case aggregators = "Aggregators"
        case attributeName = "AttributeName"
        case filters = "Filters"
        case typeName = "TypeName"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatorType = aggregatorType {
            try encodeContainer.encode(aggregatorType, forKey: .aggregatorType)
        }
        if let aggregators = aggregators {
            var aggregatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregators)
            for opsaggregatorlist0 in aggregators {
                try aggregatorsContainer.encode(opsaggregatorlist0)
            }
        }
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for opsfilterlist0 in filters {
                try filtersContainer.encode(opsfilterlist0)
            }
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .values)
            for (dictKey0, opsaggregatorvaluemap0) in values {
                try valuesContainer.encode(opsaggregatorvaluemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatorTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aggregatorType)
        aggregatorType = aggregatorTypeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .values)
        var valuesDecoded0: [String:String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String:String]()
            for (key0, opsaggregatorvalue0) in valuesContainer {
                if let opsaggregatorvalue0 = opsaggregatorvalue0 {
                    valuesDecoded0?[key0] = opsaggregatorvalue0
                }
            }
        }
        values = valuesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([OpsFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpsFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpsFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let aggregatorsContainer = try containerValues.decodeIfPresent([OpsAggregator?].self, forKey: .aggregators)
        var aggregatorsDecoded0:[OpsAggregator]? = nil
        if let aggregatorsContainer = aggregatorsContainer {
            aggregatorsDecoded0 = [OpsAggregator]()
            for structure0 in aggregatorsContainer {
                if let structure0 = structure0 {
                    aggregatorsDecoded0?.append(structure0)
                }
            }
        }
        aggregators = aggregatorsDecoded0
    }
}

extension OpsAggregator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsAggregator(aggregatorType: \(String(describing: aggregatorType)), aggregators: \(String(describing: aggregators)), attributeName: \(String(describing: attributeName)), filters: \(String(describing: filters)), typeName: \(String(describing: typeName)), values: \(String(describing: values)))"}
}

/// <p>One or more aggregators for viewing counts of OpsItems using different dimensions such as
///     <code>Source</code>, <code>CreatedTime</code>, or <code>Source and CreatedTime</code>, to name a
///    few.</p>
public struct OpsAggregator: Equatable {
    /// <p>Either a Range or Count aggregator for limiting an OpsItem summary.</p>
    public let aggregatorType: String?
    /// <p>A nested aggregator for viewing counts of OpsItems.</p>
    public let aggregators: [OpsAggregator]?
    /// <p>The name of an OpsItem attribute on which to limit the count of OpsItems.</p>
    public let attributeName: String?
    /// <p>The aggregator filters.</p>
    public let filters: [OpsFilter]?
    /// <p>The data type name to use for viewing counts of OpsItems.</p>
    public let typeName: String?
    /// <p>The aggregator value.</p>
    public let values: [String:String]?

    public init (
        aggregatorType: String? = nil,
        aggregators: [OpsAggregator]? = nil,
        attributeName: String? = nil,
        filters: [OpsFilter]? = nil,
        typeName: String? = nil,
        values: [String:String]? = nil
    )
    {
        self.aggregatorType = aggregatorType
        self.aggregators = aggregators
        self.attributeName = attributeName
        self.filters = filters
        self.typeName = typeName
        self.values = values
    }
}

extension OpsEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, opsentityitemmap0) in data {
                try dataContainer.encode(opsentityitemmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: OpsEntityItem?].self, forKey: .data)
        var dataDecoded0: [String:OpsEntityItem]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:OpsEntityItem]()
            for (key0, opsentityitem0) in dataContainer {
                if let opsentityitem0 = opsentityitem0 {
                    dataDecoded0?[key0] = opsentityitem0
                }
            }
        }
        data = dataDecoded0
    }
}

extension OpsEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsEntity(data: \(String(describing: data)), id: \(String(describing: id)))"}
}

/// <p>The result of the query.</p>
public struct OpsEntity: Equatable {
    /// <p>The data returned by the query.</p>
    public let data: [String:OpsEntityItem]?
    /// <p>The query ID.</p>
    public let id: String?

    public init (
        data: [String:OpsEntityItem]? = nil,
        id: String? = nil
    )
    {
        self.data = data
        self.id = id
    }
}

extension OpsEntityItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case captureTime = "CaptureTime"
        case content = "Content"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captureTime = captureTime {
            try encodeContainer.encode(captureTime, forKey: .captureTime)
        }
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for opsentityitementrylist0 in content {
                var opsentityitementrylist0Container = contentContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, opsentityitementry1) in opsentityitementrylist0 {
                    try opsentityitementrylist0Container.encode(opsentityitementry1, forKey: Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let captureTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .captureTime)
        captureTime = captureTimeDecoded
        let contentContainer = try containerValues.decodeIfPresent([[String: String?]?].self, forKey: .content)
        var contentDecoded0:[[String:String]]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [[String:String]]()
            for map0 in contentContainer {
                var contentContainerDecoded0: [String: String]? = nil
                if let map0 = map0 {
                    contentContainerDecoded0 = [String: String]()
                    for (key1, attributevalue1) in map0 {
                        if let attributevalue1 = attributevalue1 {
                            contentContainerDecoded0?[key1] = attributevalue1
                        }
                    }
                }
                if let contentContainerDecoded0 = contentContainerDecoded0 {
                    contentDecoded0?.append(contentContainerDecoded0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension OpsEntityItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsEntityItem(captureTime: \(String(describing: captureTime)), content: \(String(describing: content)))"}
}

/// <p>The OpsItem summaries result item.</p>
public struct OpsEntityItem: Equatable {
    /// <p>The time OpsItem data was captured.</p>
    public let captureTime: String?
    /// <p>The detailed data content for an OpsItem summaries result item.</p>
    public let content: [[String:String]]?

    public init (
        captureTime: String? = nil,
        content: [[String:String]]? = nil
    )
    {
        self.captureTime = captureTime
        self.content = content
    }
}

extension OpsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsfiltervaluelist0 in values {
                try valuesContainer.encode(opsfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsFilterOperatorType.self, forKey: .type)
        type = typeDecoded
    }
}

extension OpsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsFilter(key: \(String(describing: key)), type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>A filter for viewing OpsItem summaries.</p>
public struct OpsFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: String?
    /// <p>The type of filter.</p>
    public let type: OpsFilterOperatorType?
    /// <p>The filter value.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        type: OpsFilterOperatorType? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.type = type
        self.values = values
    }
}

public enum OpsFilterOperatorType {
    case beginWith
    case equal
    case exists
    case greaterThan
    case lessThan
    case notEqual
    case sdkUnknown(String)
}

extension OpsFilterOperatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsFilterOperatorType] {
        return [
            .beginWith,
            .equal,
            .exists,
            .greaterThan,
            .lessThan,
            .notEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beginWith: return "BeginWith"
        case .equal: return "Equal"
        case .exists: return "Exists"
        case .greaterThan: return "GreaterThan"
        case .lessThan: return "LessThan"
        case .notEqual: return "NotEqual"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsFilterOperatorType(rawValue: rawValue) ?? OpsFilterOperatorType.sdkUnknown(rawValue)
    }
}

extension OpsItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let notificationsContainer = try containerValues.decodeIfPresent([OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([String: OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [String:OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [String:OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension OpsItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItem(actualEndTime: \(String(describing: actualEndTime)), actualStartTime: \(String(describing: actualStartTime)), category: \(String(describing: category)), createdBy: \(String(describing: createdBy)), createdTime: \(String(describing: createdTime)), description: \(String(describing: description)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedTime: \(String(describing: lastModifiedTime)), notifications: \(String(describing: notifications)), operationalData: \(String(describing: operationalData)), opsItemId: \(String(describing: opsItemId)), opsItemType: \(String(describing: opsItemType)), plannedEndTime: \(String(describing: plannedEndTime)), plannedStartTime: \(String(describing: plannedStartTime)), priority: \(String(describing: priority)), relatedOpsItems: \(String(describing: relatedOpsItems)), severity: \(String(describing: severity)), source: \(String(describing: source)), status: \(String(describing: status)), title: \(String(describing: title)), version: \(String(describing: version)))"}
}

/// <p>Operations engineers and IT professionals use OpsCenter to view, investigate, and remediate
///    operational issues impacting the performance and health of their AWS resources. For more
///    information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html">AWS Systems Manager OpsCenter</a> in the
///     <i>AWS Systems Manager User Guide</i>. </p>
public struct OpsItem: Equatable {
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualEndTime: Date?
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualStartTime: Date?
    /// <p>An OpsItem category. Category options include: Availability, Cost, Performance, Recovery,
    ///    Security.</p>
    public let category: String?
    /// <p>The ARN of the AWS account that created the OpsItem.</p>
    public let createdBy: String?
    /// <p>The date and time the OpsItem was created.</p>
    public let createdTime: Date?
    /// <p>The OpsItem description.</p>
    public let description: String?
    /// <p>The ARN of the AWS account that last updated the OpsItem.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time the OpsItem was last updated.</p>
    public let lastModifiedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    ///    OpsItem is edited or changed.</p>
    public let notifications: [OpsItemNotification]?
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    ///    For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    ///    other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    ///    of 128 characters. The value has a maximum size of 20 KB.</p>
    ///          <important>
    ///             <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    ///     amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    ///          </important>
    ///          <p>You can choose to make the data searchable by other users in the account or you can restrict
    ///    search access. Searchable data means that all users with access to the OpsItem Overview page (as
    ///    provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    ///    specified data. Operational data that is not searchable is only viewable by users who have access
    ///    to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    ///          <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    ///    the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    ///    Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    ///     <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let operationalData: [String:OpsItemDataValue]?
    /// <p>The ID of the OpsItem.</p>
    public let opsItemId: String?
    /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
    ///    and <code>/aws/issue</code>.</p>
    public let opsItemType: String?
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedEndTime: Date?
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedStartTime: Date?
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    public let priority: Int?
    /// <p>One or more OpsItems that share something in common with the current OpsItem. For example,
    ///    related OpsItems can include OpsItems with similar error messages, impacted resources, or
    ///    statuses for the impacted resource.</p>
    public let relatedOpsItems: [RelatedOpsItem]?
    /// <p>The severity of the OpsItem. Severity options range from 1 to 4.</p>
    public let severity: String?
    /// <p>The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of
    ///    source.</p>
    public let source: String?
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    ///     <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let status: OpsItemStatus?
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    public let title: String?
    /// <p>The version of this OpsItem. Each time the OpsItem is edited the version number increments
    ///    by one.</p>
    public let version: String?

    public init (
        actualEndTime: Date? = nil,
        actualStartTime: Date? = nil,
        category: String? = nil,
        createdBy: String? = nil,
        createdTime: Date? = nil,
        description: String? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedTime: Date? = nil,
        notifications: [OpsItemNotification]? = nil,
        operationalData: [String:OpsItemDataValue]? = nil,
        opsItemId: String? = nil,
        opsItemType: String? = nil,
        plannedEndTime: Date? = nil,
        plannedStartTime: Date? = nil,
        priority: Int? = nil,
        relatedOpsItems: [RelatedOpsItem]? = nil,
        severity: String? = nil,
        source: String? = nil,
        status: OpsItemStatus? = nil,
        title: String? = nil,
        version: String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.createdBy = createdBy
        self.createdTime = createdTime
        self.description = description
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedTime = lastModifiedTime
        self.notifications = notifications
        self.operationalData = operationalData
        self.opsItemId = opsItemId
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.source = source
        self.status = status
        self.title = title
        self.version = version
    }
}

extension OpsItemAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemAlreadyExistsException(message: \(String(describing: message)), opsItemId: \(String(describing: opsItemId)))"}
}

extension OpsItemAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.opsItemId = output.opsItemId
        } else {
            self.message = nil
            self.opsItemId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The OpsItem already exists.</p>
public struct OpsItemAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var opsItemId: String?

    public init (
        message: String? = nil,
        opsItemId: String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
    }
}

struct OpsItemAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let opsItemId: String?
}

extension OpsItemAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

public enum OpsItemDataType {
    case searchableString
    case string
    case sdkUnknown(String)
}

extension OpsItemDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemDataType] {
        return [
            .searchableString,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .searchableString: return "SearchableString"
        case .string: return "String"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemDataType(rawValue: rawValue) ?? OpsItemDataType.sdkUnknown(rawValue)
    }
}

extension OpsItemDataValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpsItemDataType.self, forKey: .type)
        type = typeDecoded
    }
}

extension OpsItemDataValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemDataValue(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>An object that defines the value of the key and its type in the OperationalData map.</p>
public struct OpsItemDataValue: Equatable {
    /// <p>The type of key-value pair. Valid types include <code>SearchableString</code> and
    ///     <code>String</code>.</p>
    public let type: OpsItemDataType?
    /// <p>The value of the OperationalData key.</p>
    public let value: String?

    public init (
        type: OpsItemDataType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

extension OpsItemEventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemeventfiltervalues0 in values {
                try valuesContainer.encode(opsitemeventfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(OpsItemEventFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(OpsItemEventFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension OpsItemEventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemEventFilter(key: \(String(describing: key)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter for a specific list of OpsItem events. You can filter event information
///    by using tags. You specify tags by using a key-value pair mapping. </p>
public struct OpsItemEventFilter: Equatable {
    /// <p>The operator used by the filter call. Currently, the only supported value is
    ///     <code>Equal</code>.</p>
    public let `operator`: OpsItemEventFilterOperator?
    /// <p>The name of the filter key. Currently, the only supported value is
    ///    <code>OpsItemId</code>.</p>
    public let key: OpsItemEventFilterKey?
    /// <p>The values for the filter, consisting of one or more OpsItem IDs.</p>
    public let values: [String]?

    public init (
        `operator`: OpsItemEventFilterOperator? = nil,
        key: OpsItemEventFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.key = key
        self.values = values
    }
}

public enum OpsItemEventFilterKey {
    case opsitemId
    case sdkUnknown(String)
}

extension OpsItemEventFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemEventFilterKey] {
        return [
            .opsitemId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .opsitemId: return "OpsItemId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemEventFilterKey(rawValue: rawValue) ?? OpsItemEventFilterKey.sdkUnknown(rawValue)
    }
}

public enum OpsItemEventFilterOperator {
    case equal
    case sdkUnknown(String)
}

extension OpsItemEventFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemEventFilterOperator] {
        return [
            .equal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "Equal"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemEventFilterOperator(rawValue: rawValue) ?? OpsItemEventFilterOperator.sdkUnknown(rawValue)
    }
}

extension OpsItemEventSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case detail = "Detail"
        case detailType = "DetailType"
        case eventId = "EventId"
        case opsItemId = "OpsItemId"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let detailTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detail)
        detail = detailDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension OpsItemEventSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemEventSummary(createdBy: \(String(describing: createdBy)), createdTime: \(String(describing: createdTime)), detail: \(String(describing: detail)), detailType: \(String(describing: detailType)), eventId: \(String(describing: eventId)), opsItemId: \(String(describing: opsItemId)), source: \(String(describing: source)))"}
}

/// <p>Summary information about an OpsItem event or that associated an OpsItem with a related
///    item.</p>
public struct OpsItemEventSummary: Equatable {
    /// <p>Information about the user or resource that created the OpsItem event.</p>
    public let createdBy: OpsItemIdentity?
    /// <p>The date and time the OpsItem event was created.</p>
    public let createdTime: Date?
    /// <p>Specific information about the OpsItem event.</p>
    public let detail: String?
    /// <p>The type of information provided as a detail.</p>
    public let detailType: String?
    /// <p>The ID of the OpsItem event.</p>
    public let eventId: String?
    /// <p>The ID of the OpsItem.</p>
    public let opsItemId: String?
    /// <p>The source of the OpsItem event.</p>
    public let source: String?

    public init (
        createdBy: OpsItemIdentity? = nil,
        createdTime: Date? = nil,
        detail: String? = nil,
        detailType: String? = nil,
        eventId: String? = nil,
        opsItemId: String? = nil,
        source: String? = nil
    )
    {
        self.createdBy = createdBy
        self.createdTime = createdTime
        self.detail = detail
        self.detailType = detailType
        self.eventId = eventId
        self.opsItemId = opsItemId
        self.source = source
    }
}

extension OpsItemFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemfiltervalues0 in values {
                try valuesContainer.encode(opsitemfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(OpsItemFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(OpsItemFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension OpsItemFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemFilter(key: \(String(describing: key)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Describes an OpsItem filter.</p>
public struct OpsItemFilter: Equatable {
    /// <p>The operator used by the filter call.</p>
    public let `operator`: OpsItemFilterOperator?
    /// <p>The name of the filter.</p>
    public let key: OpsItemFilterKey?
    /// <p>The filter value.</p>
    public let values: [String]?

    public init (
        `operator`: OpsItemFilterOperator? = nil,
        key: OpsItemFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.key = key
        self.values = values
    }
}

public enum OpsItemFilterKey {
    case actualEndTime
    case actualStartTime
    case automationId
    case category
    case changeRequestApproverArn
    case changeRequestApproverName
    case changeRequestRequesterArn
    case changeRequestRequesterName
    case changeRequestTargetsResourceGroup
    case changeRequestTemplate
    case createdBy
    case createdTime
    case lastModifiedTime
    case operationalData
    case operationalDataKey
    case operationalDataValue
    case opsitemId
    case opsitemType
    case plannedEndTime
    case plannedStartTime
    case priority
    case resourceId
    case severity
    case source
    case status
    case title
    case sdkUnknown(String)
}

extension OpsItemFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemFilterKey] {
        return [
            .actualEndTime,
            .actualStartTime,
            .automationId,
            .category,
            .changeRequestApproverArn,
            .changeRequestApproverName,
            .changeRequestRequesterArn,
            .changeRequestRequesterName,
            .changeRequestTargetsResourceGroup,
            .changeRequestTemplate,
            .createdBy,
            .createdTime,
            .lastModifiedTime,
            .operationalData,
            .operationalDataKey,
            .operationalDataValue,
            .opsitemId,
            .opsitemType,
            .plannedEndTime,
            .plannedStartTime,
            .priority,
            .resourceId,
            .severity,
            .source,
            .status,
            .title,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .actualEndTime: return "ActualEndTime"
        case .actualStartTime: return "ActualStartTime"
        case .automationId: return "AutomationId"
        case .category: return "Category"
        case .changeRequestApproverArn: return "ChangeRequestByApproverArn"
        case .changeRequestApproverName: return "ChangeRequestByApproverName"
        case .changeRequestRequesterArn: return "ChangeRequestByRequesterArn"
        case .changeRequestRequesterName: return "ChangeRequestByRequesterName"
        case .changeRequestTargetsResourceGroup: return "ChangeRequestByTargetsResourceGroup"
        case .changeRequestTemplate: return "ChangeRequestByTemplate"
        case .createdBy: return "CreatedBy"
        case .createdTime: return "CreatedTime"
        case .lastModifiedTime: return "LastModifiedTime"
        case .operationalData: return "OperationalData"
        case .operationalDataKey: return "OperationalDataKey"
        case .operationalDataValue: return "OperationalDataValue"
        case .opsitemId: return "OpsItemId"
        case .opsitemType: return "OpsItemType"
        case .plannedEndTime: return "PlannedEndTime"
        case .plannedStartTime: return "PlannedStartTime"
        case .priority: return "Priority"
        case .resourceId: return "ResourceId"
        case .severity: return "Severity"
        case .source: return "Source"
        case .status: return "Status"
        case .title: return "Title"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemFilterKey(rawValue: rawValue) ?? OpsItemFilterKey.sdkUnknown(rawValue)
    }
}

public enum OpsItemFilterOperator {
    case contains
    case equal
    case greaterThan
    case lessThan
    case sdkUnknown(String)
}

extension OpsItemFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemFilterOperator] {
        return [
            .contains,
            .equal,
            .greaterThan,
            .lessThan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "Contains"
        case .equal: return "Equal"
        case .greaterThan: return "GreaterThan"
        case .lessThan: return "LessThan"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemFilterOperator(rawValue: rawValue) ?? OpsItemFilterOperator.sdkUnknown(rawValue)
    }
}

extension OpsItemIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension OpsItemIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemIdentity(arn: \(String(describing: arn)))"}
}

/// <p>Information about the user or resource that created an OpsItem event.</p>
public struct OpsItemIdentity: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension OpsItemInvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemInvalidParameterException(message: \(String(describing: message)), parameterNames: \(String(describing: parameterNames)))"}
}

extension OpsItemInvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemInvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.parameterNames = output.parameterNames
        } else {
            self.message = nil
            self.parameterNames = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified parameter argument isn't valid. Verify the available arguments and try
///    again.</p>
public struct OpsItemInvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var parameterNames: [String]?

    public init (
        message: String? = nil,
        parameterNames: [String]? = nil
    )
    {
        self.message = message
        self.parameterNames = parameterNames
    }
}

struct OpsItemInvalidParameterExceptionBody: Equatable {
    public let parameterNames: [String]?
    public let message: String?
}

extension OpsItemInvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case parameterNames = "ParameterNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parameterNames)
        var parameterNamesDecoded0:[String]? = nil
        if let parameterNamesContainer = parameterNamesContainer {
            parameterNamesDecoded0 = [String]()
            for string0 in parameterNamesContainer {
                if let string0 = string0 {
                    parameterNamesDecoded0?.append(string0)
                }
            }
        }
        parameterNames = parameterNamesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemLimitExceededException(limit: \(String(describing: limit)), limitType: \(String(describing: limitType)), message: \(String(describing: message)), resourceTypes: \(String(describing: resourceTypes)))"}
}

extension OpsItemLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limit = output.limit
            self.limitType = output.limitType
            self.message = output.message
            self.resourceTypes = output.resourceTypes
        } else {
            self.limit = 0
            self.limitType = nil
            self.message = nil
            self.resourceTypes = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request caused OpsItems to exceed one or more quotas. For information about OpsItem
///    quotas, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-learn-more.html#OpsCenter-learn-more-limits">What are the resource limits for OpsCenter?</a>.</p>
public struct OpsItemLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var limit: Int
    public var limitType: String?
    public var message: String?
    public var resourceTypes: [String]?

    public init (
        limit: Int = 0,
        limitType: String? = nil,
        message: String? = nil,
        resourceTypes: [String]? = nil
    )
    {
        self.limit = limit
        self.limitType = limitType
        self.message = message
        self.resourceTypes = resourceTypes
    }
}

struct OpsItemLimitExceededExceptionBody: Equatable {
    public let resourceTypes: [String]?
    public let limit: Int
    public let limitType: String?
    public let message: String?
}

extension OpsItemLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case limitType = "LimitType"
        case message = "Message"
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let limitTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemNotFoundException(message: \(String(describing: message)))"}
}

extension OpsItemNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified OpsItem ID doesn't exist. Verify the ID and try again.</p>
public struct OpsItemNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension OpsItemNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemNotification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension OpsItemNotification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemNotification(arn: \(String(describing: arn)))"}
}

/// <p>A notification about the OpsItem.</p>
public struct OpsItemNotification: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    ///    OpsItem is edited or changed.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension OpsItemRelatedItemAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemRelatedItemAlreadyExistsException(message: \(String(describing: message)), opsItemId: \(String(describing: opsItemId)), resourceUri: \(String(describing: resourceUri)))"}
}

extension OpsItemRelatedItemAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemRelatedItemAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.opsItemId = output.opsItemId
            self.resourceUri = output.resourceUri
        } else {
            self.message = nil
            self.opsItemId = nil
            self.resourceUri = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) is already associated with the OpsItem.</p>
public struct OpsItemRelatedItemAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var opsItemId: String?
    public var resourceUri: String?

    public init (
        message: String? = nil,
        opsItemId: String? = nil,
        resourceUri: String? = nil
    )
    {
        self.message = message
        self.opsItemId = opsItemId
        self.resourceUri = resourceUri
    }
}

struct OpsItemRelatedItemAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceUri: String?
    public let opsItemId: String?
}

extension OpsItemRelatedItemAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case opsItemId = "OpsItemId"
        case resourceUri = "ResourceUri"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension OpsItemRelatedItemAssociationNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemRelatedItemAssociationNotFoundException(message: \(String(describing: message)))"}
}

extension OpsItemRelatedItemAssociationNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsItemRelatedItemAssociationNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The association was not found using the parameters you specified in the call. Verify the
///    information and try again.</p>
public struct OpsItemRelatedItemAssociationNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsItemRelatedItemAssociationNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension OpsItemRelatedItemAssociationNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsItemRelatedItemSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationId = "AssociationId"
        case associationType = "AssociationType"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case opsItemId = "OpsItemId"
        case resourceType = "ResourceType"
        case resourceUri = "ResourceUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType, forKey: .associationType)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let resourceUri = resourceUri {
            try encodeContainer.encode(resourceUri, forKey: .resourceUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceUri)
        resourceUri = resourceUriDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(OpsItemIdentity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(OpsItemIdentity.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension OpsItemRelatedItemSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemRelatedItemSummary(associationId: \(String(describing: associationId)), associationType: \(String(describing: associationType)), createdBy: \(String(describing: createdBy)), createdTime: \(String(describing: createdTime)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedTime: \(String(describing: lastModifiedTime)), opsItemId: \(String(describing: opsItemId)), resourceType: \(String(describing: resourceType)), resourceUri: \(String(describing: resourceUri)))"}
}

/// <p>Summary information about related-item resources for an OpsItem.</p>
public struct OpsItemRelatedItemSummary: Equatable {
    /// <p>The association ID.</p>
    public let associationId: String?
    /// <p>The association type.</p>
    public let associationType: String?
    /// <p>Information about the user or resource that created an OpsItem event.</p>
    public let createdBy: OpsItemIdentity?
    /// <p>The time the related-item association was created.</p>
    public let createdTime: Date?
    /// <p>Information about the user or resource that created an OpsItem event.</p>
    public let lastModifiedBy: OpsItemIdentity?
    /// <p>The time the related-item association was last updated.</p>
    public let lastModifiedTime: Date?
    /// <p>The OpsItem ID.</p>
    public let opsItemId: String?
    /// <p>The resource type.</p>
    public let resourceType: String?
    /// <p>The Amazon Resource Name (ARN) of the related-item resource.</p>
    public let resourceUri: String?

    public init (
        associationId: String? = nil,
        associationType: String? = nil,
        createdBy: OpsItemIdentity? = nil,
        createdTime: Date? = nil,
        lastModifiedBy: OpsItemIdentity? = nil,
        lastModifiedTime: Date? = nil,
        opsItemId: String? = nil,
        resourceType: String? = nil,
        resourceUri: String? = nil
    )
    {
        self.associationId = associationId
        self.associationType = associationType
        self.createdBy = createdBy
        self.createdTime = createdTime
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedTime = lastModifiedTime
        self.opsItemId = opsItemId
        self.resourceType = resourceType
        self.resourceUri = resourceUri
    }
}

extension OpsItemRelatedItemsFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsitemrelateditemsfiltervalues0 in values {
                try valuesContainer.encode(opsitemrelateditemsfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(OpsItemRelatedItemsFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(OpsItemRelatedItemsFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension OpsItemRelatedItemsFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemRelatedItemsFilter(key: \(String(describing: key)), operator: \(String(describing: `operator`)), values: \(String(describing: values)))"}
}

/// <p>Describes a filter for a specific list of related-item resources. </p>
public struct OpsItemRelatedItemsFilter: Equatable {
    /// <p>The operator used by the filter call. The only supported operator is
    ///    <code>EQUAL</code>.</p>
    public let `operator`: OpsItemRelatedItemsFilterOperator?
    /// <p>The name of the filter key. Supported values include <code>ResourceUri</code>,
    ///     <code>ResourceType</code>, or <code>AssociationId</code>.</p>
    public let key: OpsItemRelatedItemsFilterKey?
    /// <p>The values for the filter.</p>
    public let values: [String]?

    public init (
        `operator`: OpsItemRelatedItemsFilterOperator? = nil,
        key: OpsItemRelatedItemsFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.`operator` = `operator`
        self.key = key
        self.values = values
    }
}

public enum OpsItemRelatedItemsFilterKey {
    case associationId
    case resourceType
    case resourceUri
    case sdkUnknown(String)
}

extension OpsItemRelatedItemsFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemRelatedItemsFilterKey] {
        return [
            .associationId,
            .resourceType,
            .resourceUri,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .associationId: return "AssociationId"
        case .resourceType: return "ResourceType"
        case .resourceUri: return "ResourceUri"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemRelatedItemsFilterKey(rawValue: rawValue) ?? OpsItemRelatedItemsFilterKey.sdkUnknown(rawValue)
    }
}

public enum OpsItemRelatedItemsFilterOperator {
    case equal
    case sdkUnknown(String)
}

extension OpsItemRelatedItemsFilterOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemRelatedItemsFilterOperator] {
        return [
            .equal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equal: return "Equal"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemRelatedItemsFilterOperator(rawValue: rawValue) ?? OpsItemRelatedItemsFilterOperator.sdkUnknown(rawValue)
    }
}

public enum OpsItemStatus {
    case approved
    case cancelled
    case cancelling
    case changeCalendarOverrideApproved
    case changeCalendarOverrideRejected
    case completedWithFailure
    case completedWithSuccess
    case failed
    case inProgress
    case `open`
    case pending
    case pendingApproval
    case pendingChangeCalendarOverride
    case rejected
    case resolved
    case runbookInProgress
    case scheduled
    case timedOut
    case sdkUnknown(String)
}

extension OpsItemStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OpsItemStatus] {
        return [
            .approved,
            .cancelled,
            .cancelling,
            .changeCalendarOverrideApproved,
            .changeCalendarOverrideRejected,
            .completedWithFailure,
            .completedWithSuccess,
            .failed,
            .inProgress,
            .open,
            .pending,
            .pendingApproval,
            .pendingChangeCalendarOverride,
            .rejected,
            .resolved,
            .runbookInProgress,
            .scheduled,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "Approved"
        case .cancelled: return "Cancelled"
        case .cancelling: return "Cancelling"
        case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
        case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
        case .completedWithFailure: return "CompletedWithFailure"
        case .completedWithSuccess: return "CompletedWithSuccess"
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .open: return "Open"
        case .pending: return "Pending"
        case .pendingApproval: return "PendingApproval"
        case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
        case .rejected: return "Rejected"
        case .resolved: return "Resolved"
        case .runbookInProgress: return "RunbookInProgress"
        case .scheduled: return "Scheduled"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OpsItemStatus(rawValue: rawValue) ?? OpsItemStatus.sdkUnknown(rawValue)
    }
}

extension OpsItemSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case createdBy = "CreatedBy"
        case createdTime = "CreatedTime"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case operationalData = "OperationalData"
        case opsItemId = "OpsItemId"
        case opsItemType = "OpsItemType"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case severity = "Severity"
        case source = "Source"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let opsItemType = opsItemType {
            try encodeContainer.encode(opsItemType, forKey: .opsItemType)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([String: OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [String:OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [String:OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let opsItemTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemType)
        opsItemType = opsItemTypeDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension OpsItemSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsItemSummary(actualEndTime: \(String(describing: actualEndTime)), actualStartTime: \(String(describing: actualStartTime)), category: \(String(describing: category)), createdBy: \(String(describing: createdBy)), createdTime: \(String(describing: createdTime)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedTime: \(String(describing: lastModifiedTime)), operationalData: \(String(describing: operationalData)), opsItemId: \(String(describing: opsItemId)), opsItemType: \(String(describing: opsItemType)), plannedEndTime: \(String(describing: plannedEndTime)), plannedStartTime: \(String(describing: plannedStartTime)), priority: \(String(describing: priority)), severity: \(String(describing: severity)), source: \(String(describing: source)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

/// <p>A count of OpsItems.</p>
public struct OpsItemSummary: Equatable {
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualEndTime: Date?
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualStartTime: Date?
    /// <p>A list of OpsItems by category.</p>
    public let category: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
    public let createdBy: String?
    /// <p>The date and time the OpsItem was created.</p>
    public let createdTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time the OpsItem was last updated.</p>
    public let lastModifiedTime: Date?
    /// <p>Operational data is custom data that provides useful reference details about the OpsItem.
    ///   </p>
    public let operationalData: [String:OpsItemDataValue]?
    /// <p>The ID of the OpsItem.</p>
    public let opsItemId: String?
    /// <p>The type of OpsItem. Currently, the only valid values are <code>/aws/changerequest</code>
    ///    and <code>/aws/issue</code>.</p>
    public let opsItemType: String?
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedEndTime: Date?
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedStartTime: Date?
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    public let priority: Int?
    /// <p>A list of OpsItems by severity.</p>
    public let severity: String?
    /// <p>The impacted AWS resource.</p>
    public let source: String?
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    ///     <code>Resolved</code>.</p>
    public let status: OpsItemStatus?
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    public let title: String?

    public init (
        actualEndTime: Date? = nil,
        actualStartTime: Date? = nil,
        category: String? = nil,
        createdBy: String? = nil,
        createdTime: Date? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedTime: Date? = nil,
        operationalData: [String:OpsItemDataValue]? = nil,
        opsItemId: String? = nil,
        opsItemType: String? = nil,
        plannedEndTime: Date? = nil,
        plannedStartTime: Date? = nil,
        priority: Int? = nil,
        severity: String? = nil,
        source: String? = nil,
        status: OpsItemStatus? = nil,
        title: String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.createdBy = createdBy
        self.createdTime = createdTime
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedTime = lastModifiedTime
        self.operationalData = operationalData
        self.opsItemId = opsItemId
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.severity = severity
        self.source = source
        self.status = status
        self.title = title
    }
}

extension OpsMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case opsMetadataArn = "OpsMetadataArn"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension OpsMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadata(creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), opsMetadataArn: \(String(describing: opsMetadataArn)), resourceId: \(String(describing: resourceId)))"}
}

/// <p>Operational metadata for an application in Application Manager.</p>
public struct OpsMetadata: Equatable {
    /// <p>The date the OpsMetadata objects was created.</p>
    public let creationDate: Date?
    /// <p>The date the OpsMetadata object was last updated.</p>
    public let lastModifiedDate: Date?
    /// <p>The user name who last updated the OpsMetadata object.</p>
    public let lastModifiedUser: String?
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.</p>
    public let opsMetadataArn: String?
    /// <p>The ID of the Application Manager application.</p>
    public let resourceId: String?

    public init (
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        opsMetadataArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.opsMetadataArn = opsMetadataArn
        self.resourceId = resourceId
    }
}

extension OpsMetadataAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataAlreadyExistsException(message: \(String(describing: message)))"}
}

extension OpsMetadataAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An OpsMetadata object already exists for the selected resource.</p>
public struct OpsMetadataAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for opsmetadatafiltervaluelist0 in values {
                try valuesContainer.encode(opsmetadatafiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension OpsMetadataFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>A filter to limit the number of OpsMetadata objects displayed.</p>
public struct OpsMetadataFilter: Equatable {
    /// <p>A filter key.</p>
    public let key: String?
    /// <p>A filter value.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension OpsMetadataInvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataInvalidArgumentException(message: \(String(describing: message)))"}
}

extension OpsMetadataInvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataInvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the arguments passed is invalid. </p>
public struct OpsMetadataInvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataInvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataInvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataKeyLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataKeyLimitExceededException(message: \(String(describing: message)))"}
}

extension OpsMetadataKeyLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The OpsMetadata object exceeds the maximum number of OpsMetadata keys that you can assign to
///    an application in Application Manager.</p>
public struct OpsMetadataKeyLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataKeyLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataKeyLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataLimitExceededException(message: \(String(describing: message)))"}
}

extension OpsMetadataLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your account reached the maximum number of OpsMetadata objects allowed by Application Manager. The
///    maximum is 200 OpsMetadata objects. Delete one or more OpsMetadata object and try again.</p>
public struct OpsMetadataLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataNotFoundException(message: \(String(describing: message)))"}
}

extension OpsMetadataNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The OpsMetadata object does not exist. </p>
public struct OpsMetadataNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsMetadataTooManyUpdatesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsMetadataTooManyUpdatesException(message: \(String(describing: message)))"}
}

extension OpsMetadataTooManyUpdatesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OpsMetadataTooManyUpdatesExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The system is processing too many concurrent updates. Wait a few moments and try
///    again.</p>
public struct OpsMetadataTooManyUpdatesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OpsMetadataTooManyUpdatesExceptionBody: Equatable {
    public let message: String?
}

extension OpsMetadataTooManyUpdatesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsResultAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension OpsResultAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpsResultAttribute(typeName: \(String(describing: typeName)))"}
}

/// <p>The OpsItem data type to return.</p>
public struct OpsResultAttribute: Equatable {
    /// <p>Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation,
    ///    AWS:OpsItemTrendline, or AWS:ComplianceSummary.</p>
    public let typeName: String?

    public init (
        typeName: String? = nil
    )
    {
        self.typeName = typeName
    }
}

extension OutputSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputSourceId = "OutputSourceId"
        case outputSourceType = "OutputSourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputSourceId = outputSourceId {
            try encodeContainer.encode(outputSourceId, forKey: .outputSourceId)
        }
        if let outputSourceType = outputSourceType {
            try encodeContainer.encode(outputSourceType, forKey: .outputSourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputSourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputSourceId)
        outputSourceId = outputSourceIdDecoded
        let outputSourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputSourceType)
        outputSourceType = outputSourceTypeDecoded
    }
}

extension OutputSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputSource(outputSourceId: \(String(describing: outputSourceId)), outputSourceType: \(String(describing: outputSourceType)))"}
}

/// <p>Information about the source where the association execution details are stored.</p>
public struct OutputSource: Equatable {
    /// <p>The ID of the output source, for example the URL of an S3 bucket.</p>
    public let outputSourceId: String?
    /// <p>The type of source where the association execution details are stored, for example,
    ///    Amazon S3.</p>
    public let outputSourceType: String?

    public init (
        outputSourceId: String? = nil,
        outputSourceType: String? = nil
    )
    {
        self.outputSourceId = outputSourceId
        self.outputSourceType = outputSourceType
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case dataType = "DataType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case selector = "Selector"
        case sourceResult = "SourceResult"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let selector = selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
        if let sourceResult = sourceResult {
            try encodeContainer.encode(sourceResult, forKey: .sourceResult)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let selectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selector)
        selector = selectorDecoded
        let sourceResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceResult)
        sourceResult = sourceResultDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(aRN: \(String(describing: aRN)), dataType: \(String(describing: dataType)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), selector: \(String(describing: selector)), sourceResult: \(String(describing: sourceResult)), type: \(String(describing: type)), value: \(String(describing: value)), version: \(String(describing: version)))"}
}

/// <p>An Systems Manager parameter in Parameter Store.</p>
public struct Parameter: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the parameter.</p>
    public let aRN: String?
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    ///    default is <code>text</code>.</p>
    public let dataType: String?
    /// <p>Date the parameter was last changed or updated and the parameter version was created.</p>
    public let lastModifiedDate: Date?
    /// <p>The name of the parameter.</p>
    public let name: String?
    /// <p>Either the version number or the label used to retrieve the parameter value. Specify
    ///    selectors by using one of the following formats:</p>
    ///          <p>parameter_name:version</p>
    ///          <p>parameter_name:label</p>
    public let selector: String?
    /// <p>Applies to parameters that reference information in other AWS services. SourceResult is the
    ///    raw result or response from the source.</p>
    public let sourceResult: String?
    /// <p>The type of parameter. Valid values include the following: <code>String</code>,
    ///     <code>StringList</code>, and <code>SecureString</code>.</p>
    public let type: ParameterType?
    /// <p>The parameter value.</p>
    public let value: String?
    /// <p>The parameter version.</p>
    public let version: Int

    public init (
        aRN: String? = nil,
        dataType: String? = nil,
        lastModifiedDate: Date? = nil,
        name: String? = nil,
        selector: String? = nil,
        sourceResult: String? = nil,
        type: ParameterType? = nil,
        value: String? = nil,
        version: Int = 0
    )
    {
        self.aRN = aRN
        self.dataType = dataType
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.selector = selector
        self.sourceResult = sourceResult
        self.type = type
        self.value = value
        self.version = version
    }
}

extension ParameterAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterAlreadyExists(message: \(String(describing: message)))"}
}

extension ParameterAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterAlreadyExistsBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter already exists. You can't create duplicate parameters.</p>
public struct ParameterAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterAlreadyExistsBody: Equatable {
    public let message: String?
}

extension ParameterAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterHistory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case labels = "Labels"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension ParameterHistory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterHistory(allowedPattern: \(String(describing: allowedPattern)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), keyId: \(String(describing: keyId)), labels: \(String(describing: labels)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), name: \(String(describing: name)), policies: \(String(describing: policies)), tier: \(String(describing: tier)), type: \(String(describing: type)), value: \(String(describing: value)), version: \(String(describing: version)))"}
}

/// <p>Information about parameter usage.</p>
public struct ParameterHistory: Equatable {
    /// <p>Parameter names can include the following letters and symbols.</p>
    ///          <p>a-zA-Z0-9_.-</p>
    public let allowedPattern: String?
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    ///    default is <code>text</code>.</p>
    public let dataType: String?
    /// <p>Information about the parameter.</p>
    public let description: String?
    /// <p>The ID of the query key used for this parameter.</p>
    public let keyId: String?
    /// <p>Labels assigned to the parameter version.</p>
    public let labels: [String]?
    /// <p>Date the parameter was last changed or updated.</p>
    public let lastModifiedDate: Date?
    /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
    public let lastModifiedUser: String?
    /// <p>The name of the parameter.</p>
    public let name: String?
    /// <p>Information about the policies assigned to a parameter.</p>
    ///          <p>
    ///             <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html">Assigning parameter
    ///     policies</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let policies: [ParameterInlinePolicy]?
    /// <p>The parameter tier.</p>
    public let tier: ParameterTier?
    /// <p>The type of parameter used.</p>
    public let type: ParameterType?
    /// <p>The parameter value.</p>
    public let value: String?
    /// <p>The parameter version.</p>
    public let version: Int

    public init (
        allowedPattern: String? = nil,
        dataType: String? = nil,
        description: String? = nil,
        keyId: String? = nil,
        labels: [String]? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        name: String? = nil,
        policies: [ParameterInlinePolicy]? = nil,
        tier: ParameterTier? = nil,
        type: ParameterType? = nil,
        value: String? = nil,
        version: Int = 0
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.labels = labels
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.name = name
        self.policies = policies
        self.tier = tier
        self.type = type
        self.value = value
        self.version = version
    }
}

extension ParameterInlinePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyStatus = "PolicyStatus"
        case policyText = "PolicyText"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyStatus = policyStatus {
            try encodeContainer.encode(policyStatus, forKey: .policyStatus)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let policyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyStatus)
        policyStatus = policyStatusDecoded
    }
}

extension ParameterInlinePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterInlinePolicy(policyStatus: \(String(describing: policyStatus)), policyText: \(String(describing: policyText)), policyType: \(String(describing: policyType)))"}
}

/// <p>One or more policies assigned to a parameter.</p>
public struct ParameterInlinePolicy: Equatable {
    /// <p>The status of the policy. Policies report the following statuses: Pending (the policy has
    ///    not been enforced or applied yet), Finished (the policy was applied), Failed (the policy was not
    ///    applied), or InProgress (the policy is being applied now). </p>
    public let policyStatus: String?
    /// <p>The JSON text of the policy.</p>
    public let policyText: String?
    /// <p>The type of policy. Parameter Store supports the following policy types: Expiration,
    ///    ExpirationNotification, and NoChangeNotification. </p>
    public let policyType: String?

    public init (
        policyStatus: String? = nil,
        policyText: String? = nil,
        policyType: String? = nil
    )
    {
        self.policyStatus = policyStatus
        self.policyText = policyText
        self.policyType = policyType
    }
}

extension ParameterLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterLimitExceeded(message: \(String(describing: message)))"}
}

extension ParameterLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of parameters for this AWS account. Delete one or more
///    parameters and try again.</p>
public struct ParameterLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterLimitExceededBody: Equatable {
    public let message: String?
}

extension ParameterLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterMaxVersionLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterMaxVersionLimitExceeded(message: \(String(describing: message)))"}
}

extension ParameterMaxVersionLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterMaxVersionLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Parameter Store retains the 100 most recently created versions of a parameter. After this
///    number of versions has been created, Parameter Store deletes the oldest version when a new one is
///    created. However, if the oldest version has a <i>label</i> attached to it,
///    Parameter Store will not delete the version and instead presents this error message:</p>
///          <p>
///             <code>An error occurred (ParameterMaxVersionLimitExceeded) when calling the PutParameter
///     operation: You attempted to create a new version of <i>parameter-name</i> by
///     calling the PutParameter API with the overwrite flag. Version
///      <i>version-number</i>, the oldest version, can't be deleted because it has a
///     label associated with it. Move the label to another version of the parameter, and try
///     again.</code>
///          </p>
///          <p>This safeguard is to prevent parameter versions with mission critical labels assigned to
///    them from being deleted. To continue creating new parameters, first move the label from the
///    oldest version of the parameter to a newer one for use in your operations. For information about
///    moving parameter labels, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-console-move">Move a
///     parameter label (console)</a> or <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-cli-move">Move a
///     parameter label (CLI)</a> in the <i>AWS Systems Manager User Guide</i>. </p>
public struct ParameterMaxVersionLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterMaxVersionLimitExceededBody: Equatable {
    public let message: String?
}

extension ParameterMaxVersionLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case name = "Name"
        case policies = "Policies"
        case tier = "Tier"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for parameterpolicylist0 in policies {
                try policiesContainer.encode(parameterpolicylist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesContainer = try containerValues.decodeIfPresent([ParameterInlinePolicy?].self, forKey: .policies)
        var policiesDecoded0:[ParameterInlinePolicy]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [ParameterInlinePolicy]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension ParameterMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterMetadata(allowedPattern: \(String(describing: allowedPattern)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), keyId: \(String(describing: keyId)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), name: \(String(describing: name)), policies: \(String(describing: policies)), tier: \(String(describing: tier)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>Metadata includes information like the ARN of the last user and the date/time the parameter
///    was last used.</p>
public struct ParameterMetadata: Equatable {
    /// <p>A parameter name can include only the following letters and symbols.</p>
    ///          <p>a-zA-Z0-9_.-</p>
    public let allowedPattern: String?
    /// <p>The data type of the parameter, such as <code>text</code> or <code>aws:ec2:image</code>. The
    ///    default is <code>text</code>.</p>
    public let dataType: String?
    /// <p>Description of the parameter actions.</p>
    public let description: String?
    /// <p>The ID of the query key used for this parameter.</p>
    public let keyId: String?
    /// <p>Date the parameter was last changed or updated.</p>
    public let lastModifiedDate: Date?
    /// <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
    public let lastModifiedUser: String?
    /// <p>The parameter name.</p>
    public let name: String?
    /// <p>A list of policies associated with a parameter.</p>
    public let policies: [ParameterInlinePolicy]?
    /// <p>The parameter tier.</p>
    public let tier: ParameterTier?
    /// <p>The type of parameter. Valid parameter types include the following: <code>String</code>,
    ///     <code>StringList</code>, and <code>SecureString</code>.</p>
    public let type: ParameterType?
    /// <p>The parameter version.</p>
    public let version: Int

    public init (
        allowedPattern: String? = nil,
        dataType: String? = nil,
        description: String? = nil,
        keyId: String? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        name: String? = nil,
        policies: [ParameterInlinePolicy]? = nil,
        tier: ParameterTier? = nil,
        type: ParameterType? = nil,
        version: Int = 0
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.name = name
        self.policies = policies
        self.tier = tier
        self.type = type
        self.version = version
    }
}

extension ParameterNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterNotFound(message: \(String(describing: message)))"}
}

extension ParameterNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter could not be found. Verify the name and try again.</p>
public struct ParameterNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterNotFoundBody: Equatable {
    public let message: String?
}

extension ParameterNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterPatternMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterPatternMismatchException(message: \(String(describing: message)))"}
}

extension ParameterPatternMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterPatternMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter name is not valid.</p>
public struct ParameterPatternMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The parameter name is not valid.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterPatternMismatchExceptionBody: Equatable {
    public let message: String?
}

extension ParameterPatternMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterStringFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case option = "Option"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let option = option {
            try encodeContainer.encode(option, forKey: .option)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parameterstringfiltervaluelist0 in values {
                try valuesContainer.encode(parameterstringfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let optionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .option)
        option = optionDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ParameterStringFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterStringFilter(key: \(String(describing: key)), option: \(String(describing: option)), values: \(String(describing: values)))"}
}

/// <p>One or more filters. Use a filter to return a more specific list of results.</p>
public struct ParameterStringFilter: Equatable {
    /// <p>The name of the filter.</p>
    ///          <note>
    ///             <p>The <code>ParameterStringFilter</code> object is used by the <a>DescribeParameters</a> and <a>GetParametersByPath</a> API actions. However,
    ///     not all of the pattern values listed for <code>Key</code> can be used with both actions.</p>
    ///             <p>For <code>DescribeActions</code>, all of the listed patterns are valid, with the exception
    ///     of <code>Label</code>.</p>
    ///             <p>For <code>GetParametersByPath</code>, the following patterns listed for <code>Key</code>
    ///     are not valid: <code>tag</code>, <code>Name</code>, <code>Path</code>, and
    ///     <code>Tier</code>.</p>
    ///             <p>For examples of CLI commands demonstrating valid parameter filter constructions, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html">Searching for
    ///      Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          </note>
    public let key: String?
    /// <p>For all filters used with <a>DescribeParameters</a>, valid options include
    ///     <code>Equals</code> and <code>BeginsWith</code>. The <code>Name</code> filter additionally
    ///    supports the <code>Contains</code> option. (Exception: For filters using the key
    ///     <code>Path</code>, valid options include <code>Recursive</code> and
    ///    <code>OneLevel</code>.)</p>
    ///          <p>For filters used with <a>GetParametersByPath</a>, valid options include
    ///     <code>Equals</code> and <code>BeginsWith</code>. (Exception: For filters using
    ///     <code>Label</code> as the Key name, the only valid option is <code>Equals</code>.)</p>
    public let option: String?
    /// <p>The value you want to search for.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        option: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.option = option
        self.values = values
    }
}

public enum ParameterTier {
    case advanced
    case intelligentTiering
    case standard
    case sdkUnknown(String)
}

extension ParameterTier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterTier] {
        return [
            .advanced,
            .intelligentTiering,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .advanced: return "Advanced"
        case .intelligentTiering: return "Intelligent-Tiering"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterTier(rawValue: rawValue) ?? ParameterTier.sdkUnknown(rawValue)
    }
}

public enum ParameterType {
    case secureString
    case string
    case stringList
    case sdkUnknown(String)
}

extension ParameterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterType] {
        return [
            .secureString,
            .string,
            .stringList,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .secureString: return "SecureString"
        case .string: return "String"
        case .stringList: return "StringList"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
    }
}

extension ParameterVersionLabelLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterVersionLabelLimitExceeded(message: \(String(describing: message)))"}
}

extension ParameterVersionLabelLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterVersionLabelLimitExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parameter version can have a maximum of ten labels.</p>
public struct ParameterVersionLabelLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionLabelLimitExceededBody: Equatable {
    public let message: String?
}

extension ParameterVersionLabelLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterVersionNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterVersionNotFound(message: \(String(describing: message)))"}
}

extension ParameterVersionNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterVersionNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter version was not found. Verify the parameter name and version, and
///    try again.</p>
public struct ParameterVersionNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterVersionNotFoundBody: Equatable {
    public let message: String?
}

extension ParameterVersionNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParametersFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for parametersfiltervaluelist0 in values {
                try valuesContainer.encode(parametersfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ParametersFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ParametersFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParametersFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>This data type is deprecated. Instead, use <a>ParameterStringFilter</a>.</p>
public struct ParametersFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: ParametersFilterKey?
    /// <p>The filter values.</p>
    public let values: [String]?

    public init (
        key: ParametersFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public enum ParametersFilterKey {
    case keyId
    case name
    case type
    case sdkUnknown(String)
}

extension ParametersFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParametersFilterKey] {
        return [
            .keyId,
            .name,
            .type,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .keyId: return "KeyId"
        case .name: return "Name"
        case .type: return "Type"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParametersFilterKey(rawValue: rawValue) ?? ParametersFilterKey.sdkUnknown(rawValue)
    }
}

extension Patch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advisoryIds = "AdvisoryIds"
        case arch = "Arch"
        case bugzillaIds = "BugzillaIds"
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case contentUrl = "ContentUrl"
        case description = "Description"
        case epoch = "Epoch"
        case id = "Id"
        case kbNumber = "KbNumber"
        case language = "Language"
        case msrcNumber = "MsrcNumber"
        case msrcSeverity = "MsrcSeverity"
        case name = "Name"
        case product = "Product"
        case productFamily = "ProductFamily"
        case release = "Release"
        case releaseDate = "ReleaseDate"
        case repository = "Repository"
        case severity = "Severity"
        case title = "Title"
        case vendor = "Vendor"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advisoryIds = advisoryIds {
            var advisoryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advisoryIds)
            for patchadvisoryidlist0 in advisoryIds {
                try advisoryIdsContainer.encode(patchadvisoryidlist0)
            }
        }
        if let arch = arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if let bugzillaIds = bugzillaIds {
            var bugzillaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bugzillaIds)
            for patchbugzillaidlist0 in bugzillaIds {
                try bugzillaIdsContainer.encode(patchbugzillaidlist0)
            }
        }
        if let cVEIds = cVEIds {
            var cVEIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cVEIds)
            for patchcveidlist0 in cVEIds {
                try cVEIdsContainer.encode(patchcveidlist0)
            }
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let contentUrl = contentUrl {
            try encodeContainer.encode(contentUrl, forKey: .contentUrl)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if epoch != 0 {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kbNumber = kbNumber {
            try encodeContainer.encode(kbNumber, forKey: .kbNumber)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let msrcNumber = msrcNumber {
            try encodeContainer.encode(msrcNumber, forKey: .msrcNumber)
        }
        if let msrcSeverity = msrcSeverity {
            try encodeContainer.encode(msrcSeverity, forKey: .msrcSeverity)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let product = product {
            try encodeContainer.encode(product, forKey: .product)
        }
        if let productFamily = productFamily {
            try encodeContainer.encode(productFamily, forKey: .productFamily)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate.timeIntervalSince1970, forKey: .releaseDate)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let contentUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentUrl)
        contentUrl = contentUrlDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendor)
        vendor = vendorDecoded
        let productFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productFamily)
        productFamily = productFamilyDecoded
        let productDecoded = try containerValues.decodeIfPresent(String.self, forKey: .product)
        product = productDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let msrcSeverityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .msrcSeverity)
        msrcSeverity = msrcSeverityDecoded
        let kbNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kbNumber)
        kbNumber = kbNumberDecoded
        let msrcNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .msrcNumber)
        msrcNumber = msrcNumberDecoded
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
        let advisoryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .advisoryIds)
        var advisoryIdsDecoded0:[String]? = nil
        if let advisoryIdsContainer = advisoryIdsContainer {
            advisoryIdsDecoded0 = [String]()
            for string0 in advisoryIdsContainer {
                if let string0 = string0 {
                    advisoryIdsDecoded0?.append(string0)
                }
            }
        }
        advisoryIds = advisoryIdsDecoded0
        let bugzillaIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .bugzillaIds)
        var bugzillaIdsDecoded0:[String]? = nil
        if let bugzillaIdsContainer = bugzillaIdsContainer {
            bugzillaIdsDecoded0 = [String]()
            for string0 in bugzillaIdsContainer {
                if let string0 = string0 {
                    bugzillaIdsDecoded0?.append(string0)
                }
            }
        }
        bugzillaIds = bugzillaIdsDecoded0
        let cVEIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cVEIds)
        var cVEIdsDecoded0:[String]? = nil
        if let cVEIdsContainer = cVEIdsContainer {
            cVEIdsDecoded0 = [String]()
            for string0 in cVEIdsContainer {
                if let string0 = string0 {
                    cVEIdsDecoded0?.append(string0)
                }
            }
        }
        cVEIds = cVEIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let epochDecoded = try containerValues.decode(Int.self, forKey: .epoch)
        epoch = epochDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arch)
        arch = archDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension Patch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Patch(advisoryIds: \(String(describing: advisoryIds)), arch: \(String(describing: arch)), bugzillaIds: \(String(describing: bugzillaIds)), cVEIds: \(String(describing: cVEIds)), classification: \(String(describing: classification)), contentUrl: \(String(describing: contentUrl)), description: \(String(describing: description)), epoch: \(String(describing: epoch)), id: \(String(describing: id)), kbNumber: \(String(describing: kbNumber)), language: \(String(describing: language)), msrcNumber: \(String(describing: msrcNumber)), msrcSeverity: \(String(describing: msrcSeverity)), name: \(String(describing: name)), product: \(String(describing: product)), productFamily: \(String(describing: productFamily)), release: \(String(describing: release)), releaseDate: \(String(describing: releaseDate)), repository: \(String(describing: repository)), severity: \(String(describing: severity)), title: \(String(describing: title)), vendor: \(String(describing: vendor)), version: \(String(describing: version)))"}
}

/// <p>Represents metadata about a patch.</p>
public struct Patch: Equatable {
    /// <p>The Advisory ID of the patch. For example, <code>RHSA-2020:3779</code>. Applies to
    ///    Linux-based instances only.</p>
    public let advisoryIds: [String]?
    /// <p>The architecture of the patch. For example, in
    ///     <code>example-pkg-0.710.10-2.7.abcd.x86_64</code>, the architecture is indicated by
    ///     <code>x86_64</code>. Applies to Linux-based instances only.</p>
    public let arch: String?
    /// <p>The Bugzilla ID of the patch. For example, <code>1600646</code>. Applies to Linux-based
    ///    instances only.</p>
    public let bugzillaIds: [String]?
    /// <p>The Common Vulnerabilities and Exposures (CVE) ID of the patch. For example,
    ///     <code>CVE-2011-3192</code>. Applies to Linux-based instances only.</p>
    public let cVEIds: [String]?
    /// <p>The classification of the patch. For example, <code>SecurityUpdates</code>,
    ///     <code>Updates</code>, or <code>CriticalUpdates</code>.</p>
    public let classification: String?
    /// <p>The URL where more information can be obtained about the patch.</p>
    public let contentUrl: String?
    /// <p>The description of the patch.</p>
    public let description: String?
    /// <p>The epoch of the patch. For example in
    ///    <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the epoch value is
    ///    <code>20180914-2</code>. Applies to Linux-based instances only.</p>
    public let epoch: Int
    /// <p>The ID of the patch. Applies to Windows patches only.</p>
    ///          <note>
    ///             <p>This ID is not the same as the Microsoft Knowledge Base ID.</p>
    ///          </note>
    public let id: String?
    /// <p>The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.</p>
    public let kbNumber: String?
    /// <p>The language of the patch if it's language-specific.</p>
    public let language: String?
    /// <p>The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to.
    ///    For example, <code>MS14-045</code>. Applies to Windows patches only.</p>
    public let msrcNumber: String?
    /// <p>The severity of the patch, such as <code>Critical</code>, <code>Important</code>, or
    ///     <code>Moderate</code>. Applies to Windows patches only.</p>
    public let msrcSeverity: String?
    /// <p>The name of the patch. Applies to Linux-based instances only.</p>
    public let name: String?
    /// <p>The specific product the patch is applicable for. For example,
    ///     <code>WindowsServer2016</code> or <code>AmazonLinux2018.03</code>.</p>
    public let product: String?
    /// <p>The product family the patch is applicable for. For example, <code>Windows</code> or
    ///     <code>Amazon Linux 2</code>.</p>
    public let productFamily: String?
    /// <p>The particular release of a patch. For example, in
    ///     <code>pkg-example-EE-20180914-2.2.amzn1.noarch</code>, the release is <code>2.amaz1</code>.
    ///    Applies to Linux-based instances only.</p>
    public let release: String?
    /// <p>The date the patch was released.</p>
    public let releaseDate: Date?
    /// <p>The source patch repository for the operating system and version, such as
    ///     <code>trusty-security</code> for Ubuntu Server 14.04 LTE and <code>focal-security</code> for
    ///    Ubuntu Server 20.04 LTE. Applies to Linux-based instances only.</p>
    public let repository: String?
    /// <p>The severity level of the patch. For example, <code>CRITICAL</code> or
    ///    <code>MODERATE</code>.</p>
    public let severity: String?
    /// <p>The title of the patch.</p>
    public let title: String?
    /// <p>The name of the vendor providing the patch.</p>
    public let vendor: String?
    /// <p>The version number of the patch. For example, in
    ///     <code>example-pkg-1.710.10-2.7.abcd.x86_64</code>, the version number is indicated by
    ///     <code>-1</code>. Applies to Linux-based instances only.</p>
    public let version: String?

    public init (
        advisoryIds: [String]? = nil,
        arch: String? = nil,
        bugzillaIds: [String]? = nil,
        cVEIds: [String]? = nil,
        classification: String? = nil,
        contentUrl: String? = nil,
        description: String? = nil,
        epoch: Int = 0,
        id: String? = nil,
        kbNumber: String? = nil,
        language: String? = nil,
        msrcNumber: String? = nil,
        msrcSeverity: String? = nil,
        name: String? = nil,
        product: String? = nil,
        productFamily: String? = nil,
        release: String? = nil,
        releaseDate: Date? = nil,
        repository: String? = nil,
        severity: String? = nil,
        title: String? = nil,
        vendor: String? = nil,
        version: String? = nil
    )
    {
        self.advisoryIds = advisoryIds
        self.arch = arch
        self.bugzillaIds = bugzillaIds
        self.cVEIds = cVEIds
        self.classification = classification
        self.contentUrl = contentUrl
        self.description = description
        self.epoch = epoch
        self.id = id
        self.kbNumber = kbNumber
        self.language = language
        self.msrcNumber = msrcNumber
        self.msrcSeverity = msrcSeverity
        self.name = name
        self.product = product
        self.productFamily = productFamily
        self.release = release
        self.releaseDate = releaseDate
        self.repository = repository
        self.severity = severity
        self.title = title
        self.vendor = vendor
        self.version = version
    }
}

public enum PatchAction {
    case allowasdependency
    case block
    case sdkUnknown(String)
}

extension PatchAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchAction] {
        return [
            .allowasdependency,
            .block,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowasdependency: return "ALLOW_AS_DEPENDENCY"
        case .block: return "BLOCK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchAction(rawValue: rawValue) ?? PatchAction.sdkUnknown(rawValue)
    }
}

extension PatchBaselineIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineDescription = "BaselineDescription"
        case baselineId = "BaselineId"
        case baselineName = "BaselineName"
        case defaultBaseline = "DefaultBaseline"
        case operatingSystem = "OperatingSystem"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineDescription = baselineDescription {
            try encodeContainer.encode(baselineDescription, forKey: .baselineDescription)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let baselineName = baselineName {
            try encodeContainer.encode(baselineName, forKey: .baselineName)
        }
        if defaultBaseline != false {
            try encodeContainer.encode(defaultBaseline, forKey: .defaultBaseline)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let baselineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineName)
        baselineName = baselineNameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let baselineDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineDescription)
        baselineDescription = baselineDescriptionDecoded
        let defaultBaselineDecoded = try containerValues.decode(Bool.self, forKey: .defaultBaseline)
        defaultBaseline = defaultBaselineDecoded
    }
}

extension PatchBaselineIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchBaselineIdentity(baselineDescription: \(String(describing: baselineDescription)), baselineId: \(String(describing: baselineId)), baselineName: \(String(describing: baselineName)), defaultBaseline: \(String(describing: defaultBaseline)), operatingSystem: \(String(describing: operatingSystem)))"}
}

/// <p>Defines the basic information about a patch baseline.</p>
public struct PatchBaselineIdentity: Equatable {
    /// <p>The description of the patch baseline.</p>
    public let baselineDescription: String?
    /// <p>The ID of the patch baseline.</p>
    public let baselineId: String?
    /// <p>The name of the patch baseline.</p>
    public let baselineName: String?
    /// <p>Whether this is the default baseline. Note that Systems Manager supports creating multiple default
    ///    patch baselines. For example, you can create a default patch baseline for each operating
    ///    system.</p>
    public let defaultBaseline: Bool
    /// <p>Defines the operating system the patch baseline applies to. The Default value is WINDOWS.
    ///   </p>
    public let operatingSystem: OperatingSystem?

    public init (
        baselineDescription: String? = nil,
        baselineId: String? = nil,
        baselineName: String? = nil,
        defaultBaseline: Bool = false,
        operatingSystem: OperatingSystem? = nil
    )
    {
        self.baselineDescription = baselineDescription
        self.baselineId = baselineId
        self.baselineName = baselineName
        self.defaultBaseline = defaultBaseline
        self.operatingSystem = operatingSystem
    }
}

extension PatchComplianceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cVEIds = "CVEIds"
        case classification = "Classification"
        case installedTime = "InstalledTime"
        case kBId = "KBId"
        case severity = "Severity"
        case state = "State"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cVEIds = cVEIds {
            try encodeContainer.encode(cVEIds, forKey: .cVEIds)
        }
        if let classification = classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let installedTime = installedTime {
            try encodeContainer.encode(installedTime.timeIntervalSince1970, forKey: .installedTime)
        }
        if let kBId = kBId {
            try encodeContainer.encode(kBId, forKey: .kBId)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let kBIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kBId)
        kBId = kBIdDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .classification)
        classification = classificationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(PatchComplianceDataState.self, forKey: .state)
        state = stateDecoded
        let installedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .installedTime)
        installedTime = installedTimeDecoded
        let cVEIdsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cVEIds)
        cVEIds = cVEIdsDecoded
    }
}

extension PatchComplianceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchComplianceData(cVEIds: \(String(describing: cVEIds)), classification: \(String(describing: classification)), installedTime: \(String(describing: installedTime)), kBId: \(String(describing: kBId)), severity: \(String(describing: severity)), state: \(String(describing: state)), title: \(String(describing: title)))"}
}

/// <p>Information about the state of a patch on a particular instance as it relates to the patch
///    baseline used to patch the instance.</p>
public struct PatchComplianceData: Equatable {
    /// <p>The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by
    ///    the patch.</p>
    public let cVEIds: String?
    /// <p>The classification of the patch (for example, SecurityUpdates, Updates,
    ///    CriticalUpdates).</p>
    public let classification: String?
    /// <p>The date/time the patch was installed on the instance. Note that not all operating systems
    ///    provide this level of information.</p>
    public let installedTime: Date?
    /// <p>The operating system-specific ID of the patch.</p>
    public let kBId: String?
    /// <p>The severity of the patch (for example, Critical, Important, Moderate).</p>
    public let severity: String?
    /// <p>The state of the patch on the instance, such as INSTALLED or FAILED.</p>
    ///          <p>For descriptions of each patch state, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch">About patch compliance</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let state: PatchComplianceDataState?
    /// <p>The title of the patch.</p>
    public let title: String?

    public init (
        cVEIds: String? = nil,
        classification: String? = nil,
        installedTime: Date? = nil,
        kBId: String? = nil,
        severity: String? = nil,
        state: PatchComplianceDataState? = nil,
        title: String? = nil
    )
    {
        self.cVEIds = cVEIds
        self.classification = classification
        self.installedTime = installedTime
        self.kBId = kBId
        self.severity = severity
        self.state = state
        self.title = title
    }
}

public enum PatchComplianceDataState {
    case failed
    case installed
    case installedother
    case installedpendingreboot
    case installedrejected
    case missing
    case notapplicable
    case sdkUnknown(String)
}

extension PatchComplianceDataState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchComplianceDataState] {
        return [
            .failed,
            .installed,
            .installedother,
            .installedpendingreboot,
            .installedrejected,
            .missing,
            .notapplicable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .installed: return "INSTALLED"
        case .installedother: return "INSTALLED_OTHER"
        case .installedpendingreboot: return "INSTALLED_PENDING_REBOOT"
        case .installedrejected: return "INSTALLED_REJECTED"
        case .missing: return "MISSING"
        case .notapplicable: return "NOT_APPLICABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchComplianceDataState(rawValue: rawValue) ?? PatchComplianceDataState.sdkUnknown(rawValue)
    }
}

public enum PatchComplianceLevel {
    case critical
    case high
    case informational
    case low
    case medium
    case unspecified
    case sdkUnknown(String)
}

extension PatchComplianceLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchComplianceLevel] {
        return [
            .critical,
            .high,
            .informational,
            .low,
            .medium,
            .unspecified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .high: return "HIGH"
        case .informational: return "INFORMATIONAL"
        case .low: return "LOW"
        case .medium: return "MEDIUM"
        case .unspecified: return "UNSPECIFIED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchComplianceLevel(rawValue: rawValue) ?? PatchComplianceLevel.sdkUnknown(rawValue)
    }
}

public enum PatchDeploymentStatus {
    case approved
    case explicitapproved
    case explicitrejected
    case pendingapproval
    case sdkUnknown(String)
}

extension PatchDeploymentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchDeploymentStatus] {
        return [
            .approved,
            .explicitapproved,
            .explicitrejected,
            .pendingapproval,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "APPROVED"
        case .explicitapproved: return "EXPLICIT_APPROVED"
        case .explicitrejected: return "EXPLICIT_REJECTED"
        case .pendingapproval: return "PENDING_APPROVAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchDeploymentStatus(rawValue: rawValue) ?? PatchDeploymentStatus.sdkUnknown(rawValue)
    }
}

extension PatchFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchfiltervaluelist0 in values {
                try valuesContainer.encode(patchfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(PatchFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PatchFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p> Defines which patches should be included in a patch baseline.</p>
///          <p>A patch filter consists of a key and a set of values. The filter key is a patch property.
///    For example, the available filter keys for WINDOWS are PATCH_SET, PRODUCT, PRODUCT_FAMILY,
///    CLASSIFICATION, and MSRC_SEVERITY. The filter values define a matching criterion for the patch
///    property indicated by the key. For example, if the filter key is PRODUCT and the filter values
///    are ["Office 2013", "Office 2016"], then the filter accepts all patches where product name is
///    either "Office 2013" or "Office 2016". The filter values can be exact values for the patch
///    property given as a key, or a wildcard (*), which matches all values.</p>
///          <p>You can view lists of valid values for the patch properties by running the
///     <code>DescribePatchProperties</code> command. For information about which patch properties can
///    be used with each major operating system, see <a>DescribePatchProperties</a>.</p>
public struct PatchFilter: Equatable {
    /// <p>The key for the filter.</p>
    ///          <p>Run the <a>DescribePatchProperties</a> command to view lists of valid keys for
    ///    each operating system type.</p>
    public let key: PatchFilterKey?
    /// <p>The value for the filter key.</p>
    ///          <p>Run the <a>DescribePatchProperties</a> command to view lists of valid values for
    ///    each key based on operating system type.</p>
    public let values: [String]?

    public init (
        key: PatchFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension PatchFilterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchFilters = "PatchFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchFilters = patchFilters {
            var patchFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchFilters)
            for patchfilterlist0 in patchFilters {
                try patchFiltersContainer.encode(patchfilterlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFiltersContainer = try containerValues.decodeIfPresent([PatchFilter?].self, forKey: .patchFilters)
        var patchFiltersDecoded0:[PatchFilter]? = nil
        if let patchFiltersContainer = patchFiltersContainer {
            patchFiltersDecoded0 = [PatchFilter]()
            for structure0 in patchFiltersContainer {
                if let structure0 = structure0 {
                    patchFiltersDecoded0?.append(structure0)
                }
            }
        }
        patchFilters = patchFiltersDecoded0
    }
}

extension PatchFilterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchFilterGroup(patchFilters: \(String(describing: patchFilters)))"}
}

/// <p>A set of patch filters, typically used for approval rules.</p>
public struct PatchFilterGroup: Equatable {
    /// <p>The set of patch filters that make up the group.</p>
    public let patchFilters: [PatchFilter]?

    public init (
        patchFilters: [PatchFilter]? = nil
    )
    {
        self.patchFilters = patchFilters
    }
}

public enum PatchFilterKey {
    case advisoryid
    case arch
    case bugzillaid
    case cveid
    case classification
    case epoch
    case msrcseverity
    case name
    case patchid
    case patchset
    case priority
    case product
    case productfamily
    case release
    case repository
    case section
    case security
    case severity
    case version
    case sdkUnknown(String)
}

extension PatchFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchFilterKey] {
        return [
            .advisoryid,
            .arch,
            .bugzillaid,
            .cveid,
            .classification,
            .epoch,
            .msrcseverity,
            .name,
            .patchid,
            .patchset,
            .priority,
            .product,
            .productfamily,
            .release,
            .repository,
            .section,
            .security,
            .severity,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .advisoryid: return "ADVISORY_ID"
        case .arch: return "ARCH"
        case .bugzillaid: return "BUGZILLA_ID"
        case .cveid: return "CVE_ID"
        case .classification: return "CLASSIFICATION"
        case .epoch: return "EPOCH"
        case .msrcseverity: return "MSRC_SEVERITY"
        case .name: return "NAME"
        case .patchid: return "PATCH_ID"
        case .patchset: return "PATCH_SET"
        case .priority: return "PRIORITY"
        case .product: return "PRODUCT"
        case .productfamily: return "PRODUCT_FAMILY"
        case .release: return "RELEASE"
        case .repository: return "REPOSITORY"
        case .section: return "SECTION"
        case .security: return "SECURITY"
        case .severity: return "SEVERITY"
        case .version: return "VERSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchFilterKey(rawValue: rawValue) ?? PatchFilterKey.sdkUnknown(rawValue)
    }
}

extension PatchGroupPatchBaselineMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineIdentity = "BaselineIdentity"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineIdentity = baselineIdentity {
            try encodeContainer.encode(baselineIdentity, forKey: .baselineIdentity)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
        let baselineIdentityDecoded = try containerValues.decodeIfPresent(PatchBaselineIdentity.self, forKey: .baselineIdentity)
        baselineIdentity = baselineIdentityDecoded
    }
}

extension PatchGroupPatchBaselineMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchGroupPatchBaselineMapping(baselineIdentity: \(String(describing: baselineIdentity)), patchGroup: \(String(describing: patchGroup)))"}
}

/// <p>The mapping between a patch group and the patch baseline the patch group is registered
///    with.</p>
public struct PatchGroupPatchBaselineMapping: Equatable {
    /// <p>The patch baseline the patch group is registered with.</p>
    public let baselineIdentity: PatchBaselineIdentity?
    /// <p>The name of the patch group registered with the patch baseline.</p>
    public let patchGroup: String?

    public init (
        baselineIdentity: PatchBaselineIdentity? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineIdentity = baselineIdentity
        self.patchGroup = patchGroup
    }
}

public enum PatchOperationType {
    case install
    case scan
    case sdkUnknown(String)
}

extension PatchOperationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchOperationType] {
        return [
            .install,
            .scan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .install: return "Install"
        case .scan: return "Scan"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchOperationType(rawValue: rawValue) ?? PatchOperationType.sdkUnknown(rawValue)
    }
}

extension PatchOrchestratorFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for patchorchestratorfiltervalues0 in values {
                try valuesContainer.encode(patchorchestratorfiltervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PatchOrchestratorFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchOrchestratorFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Defines a filter used in Patch Manager APIs.</p>
public struct PatchOrchestratorFilter: Equatable {
    /// <p>The key for the filter.</p>
    public let key: String?
    /// <p>The value for the filter.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public enum PatchProperty {
    case patchclassification
    case patchmsrcseverity
    case patchpriority
    case patchproductfamily
    case patchseverity
    case product
    case sdkUnknown(String)
}

extension PatchProperty : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchProperty] {
        return [
            .patchclassification,
            .patchmsrcseverity,
            .patchpriority,
            .patchproductfamily,
            .patchseverity,
            .product,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .patchclassification: return "CLASSIFICATION"
        case .patchmsrcseverity: return "MSRC_SEVERITY"
        case .patchpriority: return "PRIORITY"
        case .patchproductfamily: return "PRODUCT_FAMILY"
        case .patchseverity: return "SEVERITY"
        case .product: return "PRODUCT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchProperty(rawValue: rawValue) ?? PatchProperty.sdkUnknown(rawValue)
    }
}

extension PatchRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approveAfterDays = "ApproveAfterDays"
        case approveUntilDate = "ApproveUntilDate"
        case complianceLevel = "ComplianceLevel"
        case enableNonSecurity = "EnableNonSecurity"
        case patchFilterGroup = "PatchFilterGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approveAfterDays != 0 {
            try encodeContainer.encode(approveAfterDays, forKey: .approveAfterDays)
        }
        if let approveUntilDate = approveUntilDate {
            try encodeContainer.encode(approveUntilDate, forKey: .approveUntilDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if enableNonSecurity != false {
            try encodeContainer.encode(enableNonSecurity, forKey: .enableNonSecurity)
        }
        if let patchFilterGroup = patchFilterGroup {
            try encodeContainer.encode(patchFilterGroup, forKey: .patchFilterGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchFilterGroupDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .patchFilterGroup)
        patchFilterGroup = patchFilterGroupDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approveAfterDaysDecoded = try containerValues.decode(Int.self, forKey: .approveAfterDays)
        approveAfterDays = approveAfterDaysDecoded
        let approveUntilDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approveUntilDate)
        approveUntilDate = approveUntilDateDecoded
        let enableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .enableNonSecurity)
        enableNonSecurity = enableNonSecurityDecoded
    }
}

extension PatchRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchRule(approveAfterDays: \(String(describing: approveAfterDays)), approveUntilDate: \(String(describing: approveUntilDate)), complianceLevel: \(String(describing: complianceLevel)), enableNonSecurity: \(String(describing: enableNonSecurity)), patchFilterGroup: \(String(describing: patchFilterGroup)))"}
}

/// <p>Defines an approval rule for a patch baseline.</p>
public struct PatchRule: Equatable {
    /// <p>The number of days after the release date of each patch matched by the rule that the patch
    ///    is marked as approved in the patch baseline. For example, a value of <code>7</code> means that
    ///    patches are approved seven days after they are released. Not supported on Debian Server or Ubuntu
    ///    Server.</p>
    public let approveAfterDays: Int
    /// <p>The cutoff date for auto approval of released patches. Any patches released on or before
    ///    this date are installed automatically. Not supported on Debian Server or Ubuntu Server.</p>
    ///          <p>Enter dates in the format <code>YYYY-MM-DD</code>. For example,
    ///    <code>2020-12-31</code>.</p>
    public let approveUntilDate: String?
    /// <p>A compliance severity level for all approved patches in a patch baseline.</p>
    public let complianceLevel: PatchComplianceLevel?
    /// <p>For instances identified by the approval rule filters, enables a patch baseline to apply
    ///    non-security updates available in the specified repository. The default value is 'false'. Applies
    ///    to Linux instances only.</p>
    public let enableNonSecurity: Bool
    /// <p>The patch filter group that defines the criteria for the rule.</p>
    public let patchFilterGroup: PatchFilterGroup?

    public init (
        approveAfterDays: Int = 0,
        approveUntilDate: String? = nil,
        complianceLevel: PatchComplianceLevel? = nil,
        enableNonSecurity: Bool = false,
        patchFilterGroup: PatchFilterGroup? = nil
    )
    {
        self.approveAfterDays = approveAfterDays
        self.approveUntilDate = approveUntilDate
        self.complianceLevel = complianceLevel
        self.enableNonSecurity = enableNonSecurity
        self.patchFilterGroup = patchFilterGroup
    }
}

extension PatchRuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patchRules = "PatchRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchRules = patchRules {
            var patchRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchRules)
            for patchrulelist0 in patchRules {
                try patchRulesContainer.encode(patchrulelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchRulesContainer = try containerValues.decodeIfPresent([PatchRule?].self, forKey: .patchRules)
        var patchRulesDecoded0:[PatchRule]? = nil
        if let patchRulesContainer = patchRulesContainer {
            patchRulesDecoded0 = [PatchRule]()
            for structure0 in patchRulesContainer {
                if let structure0 = structure0 {
                    patchRulesDecoded0?.append(structure0)
                }
            }
        }
        patchRules = patchRulesDecoded0
    }
}

extension PatchRuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchRuleGroup(patchRules: \(String(describing: patchRules)))"}
}

/// <p>A set of rules defining the approval rules for a patch baseline.</p>
public struct PatchRuleGroup: Equatable {
    /// <p>The rules that make up the rule group.</p>
    public let patchRules: [PatchRule]?

    public init (
        patchRules: [PatchRule]? = nil
    )
    {
        self.patchRules = patchRules
    }
}

public enum PatchSet {
    case application
    case os
    case sdkUnknown(String)
}

extension PatchSet : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PatchSet] {
        return [
            .application,
            .os,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .application: return "APPLICATION"
        case .os: return "OS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PatchSet(rawValue: rawValue) ?? PatchSet.sdkUnknown(rawValue)
    }
}

extension PatchSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case name = "Name"
        case products = "Products"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for patchsourceproductlist0 in products {
                try productsContainer.encode(patchsourceproductlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let productsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .products)
        var productsDecoded0:[String]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [String]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension PatchSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchSource(configuration: \(String(describing: configuration)), name: \(String(describing: name)), products: \(String(describing: products)))"}
}

/// <p>Information about the patches to use to update the instances, including target operating
///    systems and source repository. Applies to Linux instances only.</p>
public struct PatchSource: Equatable {
    /// <p>The value of the yum repo configuration. For example:</p>
    ///          <p>
    ///             <code>[main]</code>
    ///          </p>
    ///          <p>
    ///             <code>name=MyCustomRepository</code>
    ///          </p>
    ///          <p>
    ///             <code>baseurl=https://my-custom-repository</code>
    ///          </p>
    ///          <p>
    ///             <code>enabled=1</code>
    ///          </p>
    ///          <note>
    ///             <p>For information about other options available for your yum repository configuration, see
    ///      <a href="https://man7.org/linux/man-pages/man5/dnf.conf.5.html">dnf.conf(5)</a>.</p>
    ///          </note>
    public let configuration: String?
    /// <p>The name specified to identify the patch source.</p>
    public let name: String?
    /// <p>The specific operating system versions a patch repository applies to, such as "Ubuntu16.04",
    ///    "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product
    ///    values, see <a>PatchFilter</a>.</p>
    public let products: [String]?

    public init (
        configuration: String? = nil,
        name: String? = nil,
        products: [String]? = nil
    )
    {
        self.configuration = configuration
        self.name = name
        self.products = products
    }
}

extension PatchStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalDate = "ApprovalDate"
        case complianceLevel = "ComplianceLevel"
        case deploymentStatus = "DeploymentStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalDate = approvalDate {
            try encodeContainer.encode(approvalDate.timeIntervalSince1970, forKey: .approvalDate)
        }
        if let complianceLevel = complianceLevel {
            try encodeContainer.encode(complianceLevel.rawValue, forKey: .complianceLevel)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(PatchDeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let complianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .complianceLevel)
        complianceLevel = complianceLevelDecoded
        let approvalDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approvalDate)
        approvalDate = approvalDateDecoded
    }
}

extension PatchStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PatchStatus(approvalDate: \(String(describing: approvalDate)), complianceLevel: \(String(describing: complianceLevel)), deploymentStatus: \(String(describing: deploymentStatus)))"}
}

/// <p>Information about the approval status of a patch.</p>
public struct PatchStatus: Equatable {
    /// <p>The date the patch was approved (or will be approved if the status is
    ///    PENDING_APPROVAL).</p>
    public let approvalDate: Date?
    /// <p>The compliance severity level for a patch.</p>
    public let complianceLevel: PatchComplianceLevel?
    /// <p>The approval status of a patch (APPROVED, PENDING_APPROVAL, EXPLICIT_APPROVED,
    ///    EXPLICIT_REJECTED).</p>
    public let deploymentStatus: PatchDeploymentStatus?

    public init (
        approvalDate: Date? = nil,
        complianceLevel: PatchComplianceLevel? = nil,
        deploymentStatus: PatchDeploymentStatus? = nil
    )
    {
        self.approvalDate = approvalDate
        self.complianceLevel = complianceLevel
        self.deploymentStatus = deploymentStatus
    }
}

public enum PingStatus {
    case connectionLost
    case inactive
    case online
    case sdkUnknown(String)
}

extension PingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PingStatus] {
        return [
            .connectionLost,
            .inactive,
            .online,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectionLost: return "ConnectionLost"
        case .inactive: return "Inactive"
        case .online: return "Online"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PingStatus(rawValue: rawValue) ?? PingStatus.sdkUnknown(rawValue)
    }
}

public enum PlatformType {
    case linux
    case windows
    case sdkUnknown(String)
}

extension PlatformType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformType] {
        return [
            .linux,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linux: return "Linux"
        case .windows: return "Windows"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
    }
}

extension PoliciesLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PoliciesLimitExceededException(message: \(String(describing: message)))"}
}

extension PoliciesLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PoliciesLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified more than the maximum number of allowed policies for the parameter. The
///    maximum is 10.</p>
public struct PoliciesLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PoliciesLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension PoliciesLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProgressCounters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cancelledSteps = "CancelledSteps"
        case failedSteps = "FailedSteps"
        case successSteps = "SuccessSteps"
        case timedOutSteps = "TimedOutSteps"
        case totalSteps = "TotalSteps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cancelledSteps != 0 {
            try encodeContainer.encode(cancelledSteps, forKey: .cancelledSteps)
        }
        if failedSteps != 0 {
            try encodeContainer.encode(failedSteps, forKey: .failedSteps)
        }
        if successSteps != 0 {
            try encodeContainer.encode(successSteps, forKey: .successSteps)
        }
        if timedOutSteps != 0 {
            try encodeContainer.encode(timedOutSteps, forKey: .timedOutSteps)
        }
        if totalSteps != 0 {
            try encodeContainer.encode(totalSteps, forKey: .totalSteps)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalStepsDecoded = try containerValues.decode(Int.self, forKey: .totalSteps)
        totalSteps = totalStepsDecoded
        let successStepsDecoded = try containerValues.decode(Int.self, forKey: .successSteps)
        successSteps = successStepsDecoded
        let failedStepsDecoded = try containerValues.decode(Int.self, forKey: .failedSteps)
        failedSteps = failedStepsDecoded
        let cancelledStepsDecoded = try containerValues.decode(Int.self, forKey: .cancelledSteps)
        cancelledSteps = cancelledStepsDecoded
        let timedOutStepsDecoded = try containerValues.decode(Int.self, forKey: .timedOutSteps)
        timedOutSteps = timedOutStepsDecoded
    }
}

extension ProgressCounters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProgressCounters(cancelledSteps: \(String(describing: cancelledSteps)), failedSteps: \(String(describing: failedSteps)), successSteps: \(String(describing: successSteps)), timedOutSteps: \(String(describing: timedOutSteps)), totalSteps: \(String(describing: totalSteps)))"}
}

/// <p>An aggregate of step execution statuses displayed in the AWS Console for a multi-Region and
///    multi-account Automation execution.</p>
public struct ProgressCounters: Equatable {
    /// <p>The total number of steps that the system cancelled in all specified AWS Regions and
    ///    accounts for the current Automation execution.</p>
    public let cancelledSteps: Int
    /// <p>The total number of steps that failed to run in all specified AWS Regions and accounts for
    ///    the current Automation execution.</p>
    public let failedSteps: Int
    /// <p>The total number of steps that successfully completed in all specified AWS Regions and
    ///    accounts for the current Automation execution.</p>
    public let successSteps: Int
    /// <p>The total number of steps that timed out in all specified AWS Regions and accounts for the
    ///    current Automation execution.</p>
    public let timedOutSteps: Int
    /// <p>The total number of steps run in all specified AWS Regions and accounts for the current
    ///    Automation execution.</p>
    public let totalSteps: Int

    public init (
        cancelledSteps: Int = 0,
        failedSteps: Int = 0,
        successSteps: Int = 0,
        timedOutSteps: Int = 0,
        totalSteps: Int = 0
    )
    {
        self.cancelledSteps = cancelledSteps
        self.failedSteps = failedSteps
        self.successSteps = successSteps
        self.timedOutSteps = timedOutSteps
        self.totalSteps = totalSteps
    }
}

public struct PutComplianceItemsInputBodyMiddleware: Middleware {
    public let id: String = "PutComplianceItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComplianceItemsOutputError>
}

extension PutComplianceItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutComplianceItemsInput(complianceType: \(String(describing: complianceType)), executionSummary: \(String(describing: executionSummary)), itemContentHash: \(String(describing: itemContentHash)), items: \(String(describing: items)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), uploadType: \(String(describing: uploadType)))"}
}

extension PutComplianceItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let itemContentHash = itemContentHash {
            try encodeContainer.encode(itemContentHash, forKey: .itemContentHash)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for complianceitementrylist0 in items {
                try itemsContainer.encode(complianceitementrylist0)
            }
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let uploadType = uploadType {
            try encodeContainer.encode(uploadType.rawValue, forKey: .uploadType)
        }
    }
}

public struct PutComplianceItemsInputHeadersMiddleware: Middleware {
    public let id: String = "PutComplianceItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutComplianceItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComplianceItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComplianceItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComplianceItemsInput>
    public typealias MOutput = OperationOutput<PutComplianceItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComplianceItemsOutputError>
}

public struct PutComplianceItemsInput: Equatable {
    /// <p>Specify the compliance type. For example, specify Association (for a State Manager
    ///    association), Patch, or Custom:<code>string</code>.</p>
    public let complianceType: String?
    /// <p>A summary of the call execution that includes an execution ID, the type of execution (for
    ///    example, <code>Command</code>), and the date/time of the execution using a datetime object that
    ///    is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
    public let executionSummary: ComplianceExecutionSummary?
    /// <p>MD5 or SHA-256 content hash. The content hash is used to determine if existing information
    ///    should be overwritten or ignored. If the content hashes match, the request to put compliance
    ///    information is ignored.</p>
    public let itemContentHash: String?
    /// <p>Information about the compliance as defined by the resource type. For example, for a patch
    ///    compliance type, <code>Items</code> includes information about the PatchSeverity, Classification,
    ///    and so on.</p>
    public let items: [ComplianceItemEntry]?
    /// <p>Specify an ID for this resource. For a managed instance, this is the instance ID.</p>
    public let resourceId: String?
    /// <p>Specify the type of resource. <code>ManagedInstance</code> is currently the only supported
    ///    resource type.</p>
    public let resourceType: String?
    /// <p>The mode for uploading compliance items. You can specify <code>COMPLETE</code> or
    ///     <code>PARTIAL</code>. In <code>COMPLETE</code> mode, the system overwrites all existing
    ///    compliance information for the resource. You must provide a full list of compliance items each
    ///    time you send the request.</p>
    ///          <p>In <code>PARTIAL</code> mode, the system overwrites compliance information for a specific
    ///    association. The association must be configured with <code>SyncCompliance</code> set to
    ///     <code>MANUAL</code>. By default, all requests use <code>COMPLETE</code> mode.</p>
    ///          <note>
    ///             <p>This attribute is only valid for association compliance.</p>
    ///          </note>
    public let uploadType: ComplianceUploadType?

    public init (
        complianceType: String? = nil,
        executionSummary: ComplianceExecutionSummary? = nil,
        itemContentHash: String? = nil,
        items: [ComplianceItemEntry]? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        uploadType: ComplianceUploadType? = nil
    )
    {
        self.complianceType = complianceType
        self.executionSummary = executionSummary
        self.itemContentHash = itemContentHash
        self.items = items
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.uploadType = uploadType
    }
}

struct PutComplianceItemsInputBody: Equatable {
    public let resourceId: String?
    public let resourceType: String?
    public let complianceType: String?
    public let executionSummary: ComplianceExecutionSummary?
    public let items: [ComplianceItemEntry]?
    public let itemContentHash: String?
    public let uploadType: ComplianceUploadType?
}

extension PutComplianceItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case executionSummary = "ExecutionSummary"
        case itemContentHash = "ItemContentHash"
        case items = "Items"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case uploadType = "UploadType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ComplianceItemEntry?].self, forKey: .items)
        var itemsDecoded0:[ComplianceItemEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ComplianceItemEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let itemContentHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .itemContentHash)
        itemContentHash = itemContentHashDecoded
        let uploadTypeDecoded = try containerValues.decodeIfPresent(ComplianceUploadType.self, forKey: .uploadType)
        uploadType = uploadTypeDecoded
    }
}

extension PutComplianceItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComplianceItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ComplianceTypeCountLimitExceededException" : self = .complianceTypeCountLimitExceededException(try ComplianceTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContentException" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceededException" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceededException" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutComplianceItemsOutputError: Equatable {
    case complianceTypeCountLimitExceededException(ComplianceTypeCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidItemContentException(InvalidItemContentException)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComplianceItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutComplianceItemsOutputResponse()"}
}

extension PutComplianceItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutComplianceItemsOutputResponse: Equatable {

    public init() {}
}

struct PutComplianceItemsOutputResponseBody: Equatable {
}

extension PutComplianceItemsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutInventoryInputBodyMiddleware: Middleware {
    public let id: String = "PutInventoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInventoryInput>
    public typealias MOutput = OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInventoryOutputError>
}

extension PutInventoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInventoryInput(instanceId: \(String(describing: instanceId)), items: \(String(describing: items)))"}
}

extension PutInventoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for inventoryitemlist0 in items {
                try itemsContainer.encode(inventoryitemlist0)
            }
        }
    }
}

public struct PutInventoryInputHeadersMiddleware: Middleware {
    public let id: String = "PutInventoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInventoryInput>
    public typealias MOutput = OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInventoryOutputError>
}

public struct PutInventoryInputQueryItemMiddleware: Middleware {
    public let id: String = "PutInventoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInventoryInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInventoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInventoryInput>
    public typealias MOutput = OperationOutput<PutInventoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInventoryOutputError>
}

public struct PutInventoryInput: Equatable {
    /// <p>An instance ID where you want to add or update inventory items.</p>
    public let instanceId: String?
    /// <p>The inventory items that you want to add or update on instances.</p>
    public let items: [InventoryItem]?

    public init (
        instanceId: String? = nil,
        items: [InventoryItem]? = nil
    )
    {
        self.instanceId = instanceId
        self.items = items
    }
}

struct PutInventoryInputBody: Equatable {
    public let instanceId: String?
    public let items: [InventoryItem]?
}

extension PutInventoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case items = "Items"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let itemsContainer = try containerValues.decodeIfPresent([InventoryItem?].self, forKey: .items)
        var itemsDecoded0:[InventoryItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [InventoryItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension PutInventoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInventoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CustomSchemaCountLimitExceededException" : self = .customSchemaCountLimitExceededException(try CustomSchemaCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInventoryItemContextException" : self = .invalidInventoryItemContextException(try InvalidInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidItemContentException" : self = .invalidItemContentException(try InvalidItemContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeNameException" : self = .invalidTypeNameException(try InvalidTypeNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemContentMismatchException" : self = .itemContentMismatchException(try ItemContentMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ItemSizeLimitExceededException" : self = .itemSizeLimitExceededException(try ItemSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubTypeCountLimitExceededException" : self = .subTypeCountLimitExceededException(try SubTypeCountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TotalSizeLimitExceededException" : self = .totalSizeLimitExceededException(try TotalSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventoryItemContextException" : self = .unsupportedInventoryItemContextException(try UnsupportedInventoryItemContextException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedInventorySchemaVersionException" : self = .unsupportedInventorySchemaVersionException(try UnsupportedInventorySchemaVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInventoryOutputError: Equatable {
    case customSchemaCountLimitExceededException(CustomSchemaCountLimitExceededException)
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case invalidInventoryItemContextException(InvalidInventoryItemContextException)
    case invalidItemContentException(InvalidItemContentException)
    case invalidTypeNameException(InvalidTypeNameException)
    case itemContentMismatchException(ItemContentMismatchException)
    case itemSizeLimitExceededException(ItemSizeLimitExceededException)
    case subTypeCountLimitExceededException(SubTypeCountLimitExceededException)
    case totalSizeLimitExceededException(TotalSizeLimitExceededException)
    case unsupportedInventoryItemContextException(UnsupportedInventoryItemContextException)
    case unsupportedInventorySchemaVersionException(UnsupportedInventorySchemaVersionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInventoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInventoryOutputResponse(message: \(String(describing: message)))"}
}

extension PutInventoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutInventoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
    }
}

public struct PutInventoryOutputResponse: Equatable {
    /// <p>Information about the request.</p>
    public let message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PutInventoryOutputResponseBody: Equatable {
    public let message: String?
}

extension PutInventoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutParameterInputBodyMiddleware: Middleware {
    public let id: String = "PutParameterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutParameterInput>
    public typealias MOutput = OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutParameterOutputError>
}

extension PutParameterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutParameterInput(allowedPattern: \(String(describing: allowedPattern)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), keyId: \(String(describing: keyId)), name: \(String(describing: name)), overwrite: \(String(describing: overwrite)), policies: \(String(describing: policies)), tags: \(String(describing: tags)), tier: \(String(describing: tier)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

extension PutParameterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if overwrite != false {
            try encodeContainer.encode(overwrite, forKey: .overwrite)
        }
        if let policies = policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct PutParameterInputHeadersMiddleware: Middleware {
    public let id: String = "PutParameterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutParameterInput>
    public typealias MOutput = OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutParameterOutputError>
}

public struct PutParameterInputQueryItemMiddleware: Middleware {
    public let id: String = "PutParameterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutParameterInput>,
                  next: H) -> Swift.Result<OperationOutput<PutParameterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutParameterInput>
    public typealias MOutput = OperationOutput<PutParameterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutParameterOutputError>
}

public struct PutParameterInput: Equatable {
    /// <p>A regular expression used to validate the parameter value. For example, for String types
    ///    with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$ </p>
    public let allowedPattern: String?
    /// <p>The data type for a <code>String</code> parameter. Supported data types include plain text
    ///    and Amazon Machine Image IDs.</p>
    ///          <p>
    ///             <b>The following data type values are supported.</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>text</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>aws:ec2:image</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>When you create a <code>String</code> parameter and specify <code>aws:ec2:image</code>,
    ///    Systems Manager validates the parameter value is in the required format, such as
    ///     <code>ami-12345abcdeEXAMPLE</code>, and that the specified AMI is available in your AWS account.
    ///    For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html">Native
    ///     parameter support for Amazon Machine Image IDs</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let dataType: String?
    /// <p>Information about the parameter that you want to add to the system. Optional but
    ///    recommended.</p>
    ///          <important>
    ///             <p>Do not enter personally identifiable information in this field.</p>
    ///          </important>
    public let description: String?
    /// <p>The KMS Key ID that you want to use to encrypt a parameter. Either the default AWS Key
    ///    Management Service (AWS KMS) key automatically assigned to your AWS account or a custom key.
    ///    Required for parameters that use the <code>SecureString</code> data type.</p>
    ///          <p>If you don't specify a key ID, the system uses the default key associated with your AWS
    ///    account.</p>
    ///          <ul>
    ///             <li>
    ///                <p>To use your default AWS KMS key, choose the <code>SecureString</code> data
    ///      type, and do <i>not</i> specify the <code>Key ID</code> when you
    ///      create the parameter. The system automatically populates <code>Key ID</code> with
    ///      your default KMS key.</p>
    ///             </li>
    ///             <li>
    ///                <p>To use a custom KMS key, choose the <code>SecureString</code> data type with
    ///      the <code>Key ID</code> parameter.</p>
    ///             </li>
    ///          </ul>
    public let keyId: String?
    /// <p>The fully qualified name of the parameter that you want to add to the system. The fully
    ///    qualified name includes the complete hierarchy of the parameter path and name. For parameters in
    ///    a hierarchy, you must include a leading forward slash character (/) when you create or reference
    ///    a parameter. For example: <code>/Dev/DBServer/MySQL/db-string13</code>
    ///          </p>
    ///          <p>Naming Constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Parameter names are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>A parameter name must be unique within an AWS Region</p>
    ///             </li>
    ///             <li>
    ///                <p>A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).</p>
    ///             </li>
    ///             <li>
    ///                <p>Parameter names can include only the following symbols and letters:
    ///       <code>a-zA-Z0-9_.-</code>
    ///                </p>
    ///                <p>In addition, the slash character ( / ) is used to delineate hierarchies in parameter
    ///      names. For example: <code>/Dev/Production/East/Project-ABC/MyParameter</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>A parameter name can't include spaces.</p>
    ///             </li>
    ///             <li>
    ///                <p>Parameter hierarchies are limited to a maximum depth of fifteen levels.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For additional information about valid values for parameter names, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html">Creating Systems Manager parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          <note>
    ///             <p>The maximum length constraint listed below includes capacity for additional system
    ///     attributes that are not part of the name. The maximum length for a parameter name, including the
    ///     full length of the parameter ARN, is 1011 characters. For example, the length of the following
    ///     parameter name is 65 characters, not 20 characters:</p>
    ///             <p>
    ///                <code>arn:aws:ssm:us-east-2:111122223333:parameter/ExampleParameterName</code>
    ///             </p>
    ///          </note>
    public let name: String?
    /// <p>Overwrite an existing parameter. The default value is 'false'.</p>
    public let overwrite: Bool
    /// <p>One or more policies to apply to a parameter. This action takes a JSON array. Parameter
    ///    Store supports the following policy types:</p>
    ///          <p>Expiration: This policy deletes the parameter after it expires. When you create the policy,
    ///    you specify the expiration date. You can update the expiration date and time by updating the
    ///    policy. Updating the <i>parameter</i> does not affect the expiration date and time.
    ///    When the expiration time is reached, Parameter Store deletes the parameter.</p>
    ///          <p>ExpirationNotification: This policy triggers an event in Amazon CloudWatch Events that
    ///    notifies you about the expiration. By using this policy, you can receive notification before or
    ///    after the expiration time is reached, in units of days or hours.</p>
    ///          <p>NoChangeNotification: This policy triggers a CloudWatch event if a parameter has not been
    ///    modified for a specified period of time. This policy type is useful when, for example, a secret
    ///    needs to be changed within a period of time, but it has not been changed.</p>
    ///          <p>All existing policies are preserved until you send new policies or an empty policy. For more
    ///    information about parameter policies, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html">Assigning parameter
    ///     policies</a>. </p>
    public let policies: String?
    /// <p>Optional metadata that you assign to a resource. Tags enable you to categorize a resource in
    ///    different ways, such as by purpose, owner, or environment. For example, you might want to tag a
    ///    Systems Manager parameter to identify the type of resource to which it applies, the environment, or the
    ///    type of configuration data referenced by the parameter. In this case, you could specify the
    ///    following key name/value pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Resource,Value=S3bucket</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=ParameterType,Value=LicenseKey</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>To add tags to an existing Systems Manager parameter, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>The parameter tier to assign to a parameter.</p>
    ///          <p>Parameter Store offers a standard tier and an advanced tier for parameters. Standard
    ///    parameters have a content size limit of 4 KB and can't be configured to use parameter policies.
    ///    You can create a maximum of 10,000 standard parameters for each Region in an AWS account.
    ///    Standard parameters are offered at no additional cost. </p>
    ///          <p>Advanced parameters have a content size limit of 8 KB and can be configured to use parameter
    ///    policies. You can create a maximum of 100,000 advanced parameters for each Region in an AWS
    ///    account. Advanced parameters incur a charge. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html">Standard and
    ///     advanced parameter tiers</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    ///          <p>You can change a standard parameter to an advanced parameter any time. But you can't revert
    ///    an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard
    ///    parameter would result in data loss because the system would truncate the size of the parameter
    ///    from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly,
    ///    advanced parameters use a different form of encryption than standard parameters. </p>
    ///          <p>If you no longer need an advanced parameter, or if you no longer want to incur charges for
    ///    an advanced parameter, you must delete it and recreate it as a new standard parameter. </p>
    ///          <p>
    ///             <b>Using the Default Tier Configuration</b>
    ///          </p>
    ///          <p>In <code>PutParameter</code> requests, you can specify the tier to create the parameter in.
    ///    Whenever you specify a tier in the request, Parameter Store creates or updates the parameter
    ///    according to that request. However, if you do not specify a tier in a request, Parameter Store
    ///    assigns the tier based on the current Parameter Store default tier configuration.</p>
    ///          <p>The default tier when you begin using Parameter Store is the standard-parameter tier. If you
    ///    use the advanced-parameter tier, you can specify one of the following as the default:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Advanced</b>: With this option, Parameter Store evaluates all
    ///      requests as advanced parameters. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Intelligent-Tiering</b>: With this option, Parameter Store
    ///      evaluates each request to determine if the parameter is standard or advanced. </p>
    ///                <p>If the request doesn't include any options that require an advanced parameter, the
    ///      parameter is created in the standard-parameter tier. If one or more options requiring an
    ///      advanced parameter are included in the request, Parameter Store create a parameter in the
    ///      advanced-parameter tier.</p>
    ///                <p>This approach helps control your parameter-related costs by always creating standard
    ///      parameters unless an advanced parameter is necessary. </p>
    ///             </li>
    ///          </ul>
    ///          <p>Options that require an advanced parameter include the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The content size of the parameter is more than 4 KB.</p>
    ///             </li>
    ///             <li>
    ///                <p>The parameter uses a parameter policy.</p>
    ///             </li>
    ///             <li>
    ///                <p>More than 10,000 parameters already exist in your AWS account in the current
    ///      Region.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about configuring the default tier option, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ps-default-tier.html">Specifying a
    ///     default parameter tier</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let tier: ParameterTier?
    /// <p>The type of parameter that you want to add to the system.</p>
    ///          <note>
    ///             <p>
    ///                <code>SecureString</code> is not currently supported for AWS CloudFormation
    ///     templates.</p>
    ///          </note>
    ///          <p>Items in a <code>StringList</code> must be separated by a comma (,). You can't
    ///    use other punctuation or special character to escape items in the list. If you have a parameter
    ///    value that requires a comma, then use the <code>String</code> data type.</p>
    ///          <important>
    ///             <p>Specifying a parameter type is not required when updating a parameter. You must specify a
    ///     parameter type when creating a parameter.</p>
    ///          </important>
    public let type: ParameterType?
    /// <p>The parameter value that you want to add to the system. Standard parameters have a value
    ///    limit of 4 KB. Advanced parameters have a value limit of 8 KB.</p>
    ///          <note>
    ///             <p>Parameters can't be referenced or nested in the values of other parameters. You can't
    ///     include <code>{{}}</code> or <code>{{ssm:<i>parameter-name</i>}}</code> in a
    ///     parameter value.</p>
    ///          </note>
    public let value: String?

    public init (
        allowedPattern: String? = nil,
        dataType: String? = nil,
        description: String? = nil,
        keyId: String? = nil,
        name: String? = nil,
        overwrite: Bool = false,
        policies: String? = nil,
        tags: [Tag]? = nil,
        tier: ParameterTier? = nil,
        type: ParameterType? = nil,
        value: String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.name = name
        self.overwrite = overwrite
        self.policies = policies
        self.tags = tags
        self.tier = tier
        self.type = type
        self.value = value
    }
}

struct PutParameterInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let value: String?
    public let type: ParameterType?
    public let keyId: String?
    public let overwrite: Bool
    public let allowedPattern: String?
    public let tags: [Tag]?
    public let tier: ParameterTier?
    public let policies: String?
    public let dataType: String?
}

extension PutParameterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedPattern = "AllowedPattern"
        case dataType = "DataType"
        case description = "Description"
        case keyId = "KeyId"
        case name = "Name"
        case overwrite = "Overwrite"
        case policies = "Policies"
        case tags = "Tags"
        case tier = "Tier"
        case type = "Type"
        case value = "Value"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .type)
        type = typeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let overwriteDecoded = try containerValues.decode(Bool.self, forKey: .overwrite)
        overwrite = overwriteDecoded
        let allowedPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(ParameterTier.self, forKey: .tier)
        tier = tierDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policies)
        policies = policiesDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
    }
}

extension PutParameterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutParameterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HierarchyLevelLimitExceededException" : self = .hierarchyLevelLimitExceededException(try HierarchyLevelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HierarchyTypeMismatchException" : self = .hierarchyTypeMismatchException(try HierarchyTypeMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatiblePolicyException" : self = .incompatiblePolicyException(try IncompatiblePolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAllowedPatternException" : self = .invalidAllowedPatternException(try InvalidAllowedPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKeyId" : self = .invalidKeyId(try InvalidKeyId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyAttributeException" : self = .invalidPolicyAttributeException(try InvalidPolicyAttributeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPolicyTypeException" : self = .invalidPolicyTypeException(try InvalidPolicyTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterAlreadyExists" : self = .parameterAlreadyExists(try ParameterAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterLimitExceeded" : self = .parameterLimitExceeded(try ParameterLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterMaxVersionLimitExceeded" : self = .parameterMaxVersionLimitExceeded(try ParameterMaxVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterPatternMismatchException" : self = .parameterPatternMismatchException(try ParameterPatternMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PoliciesLimitExceededException" : self = .policiesLimitExceededException(try PoliciesLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedParameterType" : self = .unsupportedParameterType(try UnsupportedParameterType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutParameterOutputError: Equatable {
    case hierarchyLevelLimitExceededException(HierarchyLevelLimitExceededException)
    case hierarchyTypeMismatchException(HierarchyTypeMismatchException)
    case incompatiblePolicyException(IncompatiblePolicyException)
    case internalServerError(InternalServerError)
    case invalidAllowedPatternException(InvalidAllowedPatternException)
    case invalidKeyId(InvalidKeyId)
    case invalidPolicyAttributeException(InvalidPolicyAttributeException)
    case invalidPolicyTypeException(InvalidPolicyTypeException)
    case parameterAlreadyExists(ParameterAlreadyExists)
    case parameterLimitExceeded(ParameterLimitExceeded)
    case parameterMaxVersionLimitExceeded(ParameterMaxVersionLimitExceeded)
    case parameterPatternMismatchException(ParameterPatternMismatchException)
    case policiesLimitExceededException(PoliciesLimitExceededException)
    case tooManyUpdates(TooManyUpdates)
    case unsupportedParameterType(UnsupportedParameterType)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutParameterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutParameterOutputResponse(tier: \(String(describing: tier)), version: \(String(describing: version)))"}
}

extension PutParameterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutParameterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tier = output.tier
            self.version = output.version
        } else {
            self.tier = nil
            self.version = 0
        }
    }
}

public struct PutParameterOutputResponse: Equatable {
    /// <p>The tier assigned to the parameter.</p>
    public let tier: ParameterTier?
    /// <p>The new version number of a parameter. If you edit a parameter value, Parameter Store
    ///    automatically creates a new version and assigns this new version a unique ID. You can reference a
    ///    parameter version ID in API actions or in Systems Manager documents (SSM documents). By default, if you
    ///    don't specify a specific version, the system returns the latest parameter value when a parameter
    ///    is called.</p>
    public let version: Int

    public init (
        tier: ParameterTier? = nil,
        version: Int = 0
    )
    {
        self.tier = tier
        self.version = version
    }
}

struct PutParameterOutputResponseBody: Equatable {
    public let version: Int
    public let tier: ParameterTier?
}

extension PutParameterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tier = "Tier"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ParameterTier.self, forKey: .tier)
        tier = tierDecoded
    }
}

public enum RebootOption {
    case noReboot
    case rebootIfNeeded
    case sdkUnknown(String)
}

extension RebootOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RebootOption] {
        return [
            .noReboot,
            .rebootIfNeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .noReboot: return "NoReboot"
        case .rebootIfNeeded: return "RebootIfNeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RebootOption(rawValue: rawValue) ?? RebootOption.sdkUnknown(rawValue)
    }
}

public struct RegisterDefaultPatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "RegisterDefaultPatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDefaultPatchBaselineOutputError>
}

extension RegisterDefaultPatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDefaultPatchBaselineInput(baselineId: \(String(describing: baselineId)))"}
}

extension RegisterDefaultPatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
    }
}

public struct RegisterDefaultPatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterDefaultPatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterDefaultPatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterDefaultPatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterDefaultPatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterDefaultPatchBaselineInput>
    public typealias MOutput = OperationOutput<RegisterDefaultPatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterDefaultPatchBaselineOutputError>
}

public struct RegisterDefaultPatchBaselineInput: Equatable {
    /// <p>The ID of the patch baseline that should be the default patch baseline.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineInputBody: Equatable {
    public let baselineId: String?
}

extension RegisterDefaultPatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

extension RegisterDefaultPatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDefaultPatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDefaultPatchBaselineOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDefaultPatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterDefaultPatchBaselineOutputResponse(baselineId: \(String(describing: baselineId)))"}
}

extension RegisterDefaultPatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterDefaultPatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
        } else {
            self.baselineId = nil
        }
    }
}

public struct RegisterDefaultPatchBaselineOutputResponse: Equatable {
    /// <p>The ID of the default patch baseline.</p>
    public let baselineId: String?

    public init (
        baselineId: String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

struct RegisterDefaultPatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
}

extension RegisterDefaultPatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
    }
}

public struct RegisterPatchBaselineForPatchGroupInputBodyMiddleware: Middleware {
    public let id: String = "RegisterPatchBaselineForPatchGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

extension RegisterPatchBaselineForPatchGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterPatchBaselineForPatchGroupInput(baselineId: \(String(describing: baselineId)), patchGroup: \(String(describing: patchGroup)))"}
}

extension RegisterPatchBaselineForPatchGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let patchGroup = patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
    }
}

public struct RegisterPatchBaselineForPatchGroupInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterPatchBaselineForPatchGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterPatchBaselineForPatchGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterPatchBaselineForPatchGroupInput>
    public typealias MOutput = OperationOutput<RegisterPatchBaselineForPatchGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterPatchBaselineForPatchGroupOutputError>
}

public struct RegisterPatchBaselineForPatchGroupInput: Equatable {
    /// <p>The ID of the patch baseline to register the patch group with.</p>
    public let baselineId: String?
    /// <p>The name of the patch group that should be registered with the patch baseline.</p>
    public let patchGroup: String?

    public init (
        baselineId: String? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupInputBody: Equatable {
    public let baselineId: String?
    public let patchGroup: String?
}

extension RegisterPatchBaselineForPatchGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterPatchBaselineForPatchGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterPatchBaselineForPatchGroupOutputError: Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterPatchBaselineForPatchGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterPatchBaselineForPatchGroupOutputResponse(baselineId: \(String(describing: baselineId)), patchGroup: \(String(describing: patchGroup)))"}
}

extension RegisterPatchBaselineForPatchGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterPatchBaselineForPatchGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baselineId = output.baselineId
            self.patchGroup = output.patchGroup
        } else {
            self.baselineId = nil
            self.patchGroup = nil
        }
    }
}

public struct RegisterPatchBaselineForPatchGroupOutputResponse: Equatable {
    /// <p>The ID of the patch baseline the patch group was registered with.</p>
    public let baselineId: String?
    /// <p>The name of the patch group registered with the patch baseline.</p>
    public let patchGroup: String?

    public init (
        baselineId: String? = nil,
        patchGroup: String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

struct RegisterPatchBaselineForPatchGroupOutputResponseBody: Equatable {
    public let baselineId: String?
    public let patchGroup: String?
}

extension RegisterPatchBaselineForPatchGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baselineId = "BaselineId"
        case patchGroup = "PatchGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

public struct RegisterTargetWithMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTargetWithMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

extension RegisterTargetWithMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTargetWithMaintenanceWindowInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), ownerInformation: \(String(describing: ownerInformation)), resourceType: \(String(describing: resourceType)), targets: \(String(describing: targets)), windowId: \(String(describing: windowId)))"}
}

extension RegisterTargetWithMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct RegisterTargetWithMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTargetWithMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTargetWithMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTargetWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetWithMaintenanceWindowOutputError>
}

public struct RegisterTargetWithMaintenanceWindowInput: Equatable {
    /// <p>User-provided idempotency token.</p>
    public var clientToken: String?
    /// <p>An optional description for the target.</p>
    public let description: String?
    /// <p>An optional name for the target.</p>
    public let name: String?
    /// <p>User-provided value that will be included in any CloudWatch events raised while running
    ///    tasks for these targets in this maintenance window.</p>
    public let ownerInformation: String?
    /// <p>The type of target being registered with the maintenance window.</p>
    public let resourceType: MaintenanceWindowResourceType?
    /// <p>The targets to register with the maintenance window. In other words, the instances to run
    ///    commands on when the maintenance window runs.</p>
    ///          <note>
    ///             <p>If a single maintenance window task is registered with multiple targets, its task
    ///     invocations occur sequentially and not in parallel. If your task must run on multiple targets at
    ///     the same time, register a task for each target individually and assign each task the same
    ///     priority level.</p>
    ///          </note>
    ///          <p>You can specify targets using instance IDs, resource group names, or tags that have been
    ///    applied to instances.</p>
    ///          <p>
    ///             <b>Example 1</b>: Specify instance IDs</p>
    ///          <p>
    ///             <code>Key=InstanceIds,Values=<i>instance-id-1</i>,<i>instance-id-2</i>,<i>instance-id-3</i>
    ///             </code>
    ///          </p>
    ///          <p>
    ///             <b>Example 2</b>: Use tag key-pairs applied to instances</p>
    ///          <p>
    ///             <code>Key=tag:<i>my-tag-key</i>,Values=<i>my-tag-value-1</i>,<i>my-tag-value-2</i>
    ///             </code>
    ///          </p>
    ///          <p>
    ///             <b>Example 3</b>: Use tag-keys applied to instances</p>
    ///          <p>
    ///             <code>Key=tag-key,Values=<i>my-tag-key-1</i>,<i>my-tag-key-2</i>
    ///             </code>
    ///          </p>
    ///
    ///          <p>
    ///             <b>Example 4</b>: Use resource group names</p>
    ///          <p>
    ///             <code>Key=resource-groups:Name,Values=<i>resource-group-name</i>
    ///             </code>
    ///          </p>
    ///          <p>
    ///             <b>Example 5</b>: Use filters for resource group types</p>
    ///          <p>
    ///             <code>Key=resource-groups:ResourceTypeFilters,Values=<i>resource-type-1</i>,<i>resource-type-2</i>
    ///             </code>
    ///          </p>
    ///          <note>
    ///             <p>For <code>Key=resource-groups:ResourceTypeFilters</code>, specify resource types in the
    ///     following format</p>
    ///             <p>
    ///                <code>Key=resource-groups:ResourceTypeFilters,Values=<i>AWS::EC2::INSTANCE</i>,<i>AWS::EC2::VPC</i>
    ///                </code>
    ///             </p>
    ///          </note>
    ///
    ///          <p>For more information about these examples formats, including the best use case for each one,
    ///    see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html">Examples: Register
    ///     targets with a maintenance window</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let targets: [Target]?
    /// <p>The ID of the maintenance window the target should be registered with.</p>
    public let windowId: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        ownerInformation: String? = nil,
        resourceType: MaintenanceWindowResourceType? = nil,
        targets: [Target]? = nil,
        windowId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

struct RegisterTargetWithMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
    public let resourceType: MaintenanceWindowResourceType?
    public let targets: [Target]?
    public let ownerInformation: String?
    public let name: String?
    public let description: String?
    public let clientToken: String?
}

extension RegisterTargetWithMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case resourceType = "ResourceType"
        case targets = "Targets"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTargetWithMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTargetWithMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetWithMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTargetWithMaintenanceWindowOutputResponse(windowTargetId: \(String(describing: windowTargetId)))"}
}

extension RegisterTargetWithMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterTargetWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowTargetId = output.windowTargetId
        } else {
            self.windowTargetId = nil
        }
    }
}

public struct RegisterTargetWithMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the target definition in this maintenance window.</p>
    public let windowTargetId: String?

    public init (
        windowTargetId: String? = nil
    )
    {
        self.windowTargetId = windowTargetId
    }
}

struct RegisterTargetWithMaintenanceWindowOutputResponseBody: Equatable {
    public let windowTargetId: String?
}

extension RegisterTargetWithMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
    }
}

public struct RegisterTaskWithMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTaskWithMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

extension RegisterTaskWithMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTaskWithMaintenanceWindowInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), loggingInfo: \(String(describing: loggingInfo)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), priority: \(String(describing: priority)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), taskArn: \(String(describing: taskArn)), taskInvocationParameters: \(String(describing: taskInvocationParameters)), taskParameters: \(String(describing: taskParameters)), taskType: \(String(describing: taskType)), windowId: \(String(describing: windowId)))"}
}

extension RegisterTaskWithMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let taskType = taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct RegisterTaskWithMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTaskWithMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTaskWithMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTaskWithMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<RegisterTaskWithMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTaskWithMaintenanceWindowOutputError>
}

public struct RegisterTaskWithMaintenanceWindowInput: Equatable {
    /// <p>User-provided idempotency token.</p>
    public var clientToken: String?
    /// <p>An optional description for the task.</p>
    public let description: String?
    /// <p>A structure containing information about an S3 bucket to write instance-level logs to. </p>
    ///          <note>
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let loggingInfo: LoggingInfo?
    /// <p>The maximum number of targets this task can be run for in parallel.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
    ///     affect the running of your task.</p>
    ///          </note>
    public let maxConcurrency: String?
    /// <p>The maximum number of errors allowed before this task stops being scheduled.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>. This value does not
    ///     affect the running of your task.</p>
    ///          </note>
    public let maxErrors: String?
    /// <p>An optional name for the task.</p>
    public let name: String?
    /// <p>The priority of the task in the maintenance window, the lower the number the higher the
    ///    priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the
    ///    same priority scheduled in parallel.</p>
    public let priority: Int
    /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
    ///   maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
    ///   service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
    ///   <code>RegisterTaskWithMaintenanceWindow</code>.</p>
    ///          <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
    ///     service-linked roles for Systems Manager</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
    ///    </a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let serviceRoleArn: String?
    /// <p>The targets (either instances or maintenance window targets).</p>
    ///          <note>
    ///             <p>One or more targets must be specified for maintenance window Run Command-type tasks.
    ///     Depending on the task, targets are optional for other maintenance window task types (Automation,
    ///     AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
    ///     specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
    ///      maintenance window tasks without targets</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    ///          </note>
    ///          <p>Specify instances using the following format: </p>
    ///          <p>
    ///             <code>Key=InstanceIds,Values=<instance-id-1>,<instance-id-2></code>
    ///          </p>
    ///          <p>Specify maintenance window targets using the following format:</p>
    ///          <p>
    ///             <code>Key=WindowTargetIds,Values=<window-target-id-1>,<window-target-id-2></code>
    ///          </p>
    public let targets: [Target]?
    /// <p>The ARN of the task to run.</p>
    public let taskArn: String?
    /// <p>The parameters that the task should use during execution. Populate only the fields that
    ///    match the task type. All other fields should be empty. </p>
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    /// <p>The parameters that should be passed to the task when it is run.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    /// <p>The type of task being registered.</p>
    public let taskType: MaintenanceWindowTaskType?
    /// <p>The ID of the maintenance window the task should be added to.</p>
    public let windowId: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        priority: Int = 0,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        taskArn: String? = nil,
        taskInvocationParameters: MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: MaintenanceWindowTaskType? = nil,
        windowId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
    }
}

struct RegisterTaskWithMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
    public let targets: [Target]?
    public let taskArn: String?
    public let serviceRoleArn: String?
    public let taskType: MaintenanceWindowTaskType?
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    public let priority: Int
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let loggingInfo: LoggingInfo?
    public let name: String?
    public let description: String?
    public let clientToken: String?
}

extension RegisterTaskWithMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case taskType = "TaskType"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([String: MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [String:MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [String:MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTaskWithMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FeatureNotAvailableException" : self = .featureNotAvailableException(try FeatureNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTaskWithMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case featureNotAvailableException(FeatureNotAvailableException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTaskWithMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTaskWithMaintenanceWindowOutputResponse(windowTaskId: \(String(describing: windowTaskId)))"}
}

extension RegisterTaskWithMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterTaskWithMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.windowTaskId = output.windowTaskId
        } else {
            self.windowTaskId = nil
        }
    }
}

public struct RegisterTaskWithMaintenanceWindowOutputResponse: Equatable {
    /// <p>The ID of the task in the maintenance window.</p>
    public let windowTaskId: String?

    public init (
        windowTaskId: String? = nil
    )
    {
        self.windowTaskId = windowTaskId
    }
}

struct RegisterTaskWithMaintenanceWindowOutputResponseBody: Equatable {
    public let windowTaskId: String?
}

extension RegisterTaskWithMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
    }
}

extension RelatedOpsItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case opsItemId = "OpsItemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
    }
}

extension RelatedOpsItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelatedOpsItem(opsItemId: \(String(describing: opsItemId)))"}
}

/// <p>An OpsItems that shares something in common with the current OpsItem. For example, related
///    OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for
///    the impacted resource.</p>
public struct RelatedOpsItem: Equatable {
    /// <p>The ID of an OpsItem related to the current OpsItem.</p>
    public let opsItemId: String?

    public init (
        opsItemId: String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceInput(resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Equatable {
    /// <p>The ID of the resource from which you want to remove tags. For example:</p>
    ///          <p>ManagedInstance: mi-012345abcde</p>
    ///          <p>MaintenanceWindow: mw-012345abcde</p>
    ///          <p>PatchBaseline: pb-012345abcde</p>
    ///          <p>OpsMetadata object: <code>ResourceID</code> for tagging is created from the Amazon Resource
    ///    Name (ARN) for the object. Specifically, <code>ResourceID</code> is created from the strings that
    ///    come after the word <code>opsmetadata</code> in the ARN. For example, an OpsMetadata object with
    ///    an ARN of <code>arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager</code>
    ///    has a <code>ResourceID</code> of either <code>aws/ssm/MyGroup/appmanager</code> or
    ///     <code>/aws/ssm/MyGroup/appmanager</code>.</p>
    ///          <p>For the Document and Parameter values, use the name of the resource.</p>
    ///          <note>
    ///             <p>The ManagedInstance type for this API action is only for on-premises managed instances.
    ///     Specify the name of the managed instance in the following format: mi-ID_number. For example,
    ///     mi-1a2b3c4d5e6f.</p>
    ///          </note>
    public let resourceId: String?
    /// <p>The type of resource from which you want to remove a tag.</p>
    ///          <note>
    ///             <p>The ManagedInstance type for this API action is only for on-premises managed instances.
    ///     Specify the name of the managed instance in the following format: mi-ID_number. For example,
    ///     mi-1a2b3c4d5e6f.</p>
    ///          </note>
    public let resourceType: ResourceTypeForTagging?
    /// <p>Tag keys that you want to remove from the specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceId: String? = nil,
        resourceType: ResourceTypeForTagging? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Equatable {
    public let resourceType: ResourceTypeForTagging?
    public let resourceId: String?
    public let tagKeys: [String]?
}

extension RemoveTagsFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceTypeForTagging.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceId" : self = .invalidResourceId(try InvalidResourceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType" : self = .invalidResourceType(try InvalidResourceType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidResourceId(InvalidResourceId)
    case invalidResourceType(InvalidResourceType)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct ResetServiceSettingInputBodyMiddleware: Middleware {
    public let id: String = "ResetServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSettingOutputError>
}

extension ResetServiceSettingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetServiceSettingInput(settingId: \(String(describing: settingId)))"}
}

extension ResetServiceSettingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
    }
}

public struct ResetServiceSettingInputHeadersMiddleware: Middleware {
    public let id: String = "ResetServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSettingOutputError>
}

public struct ResetServiceSettingInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetServiceSettingInput>
    public typealias MOutput = OperationOutput<ResetServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetServiceSettingOutputError>
}

/// <p>The request body of the ResetServiceSetting API action.</p>
public struct ResetServiceSettingInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-destination</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-group-name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/documents/console/public-sharing-permission</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/default-parameter-tier</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/high-throughput-enabled</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/managed-instance/activation-tier</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let settingId: String?

    public init (
        settingId: String? = nil
    )
    {
        self.settingId = settingId
    }
}

struct ResetServiceSettingInputBody: Equatable {
    public let settingId: String?
}

extension ResetServiceSettingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingId)
        settingId = settingIdDecoded
    }
}

extension ResetServiceSettingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetServiceSettingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetServiceSettingOutputError: Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetServiceSettingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetServiceSettingOutputResponse(serviceSetting: \(String(describing: serviceSetting)))"}
}

extension ResetServiceSettingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResetServiceSettingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceSetting = output.serviceSetting
        } else {
            self.serviceSetting = nil
        }
    }
}

/// <p>The result body of the ResetServiceSetting API action.</p>
public struct ResetServiceSettingOutputResponse: Equatable {
    /// <p>The current, effective service setting after calling the ResetServiceSetting API
    ///    action.</p>
    public let serviceSetting: ServiceSetting?

    public init (
        serviceSetting: ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

struct ResetServiceSettingOutputResponseBody: Equatable {
    public let serviceSetting: ServiceSetting?
}

extension ResetServiceSettingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceSetting = "ServiceSetting"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSettingDecoded = try containerValues.decodeIfPresent(ServiceSetting.self, forKey: .serviceSetting)
        serviceSetting = serviceSettingDecoded
    }
}

extension ResolvedTargets: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterValues = "ParameterValues"
        case truncated = "Truncated"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterValues = parameterValues {
            var parameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterValues)
            for targetparameterlist0 in parameterValues {
                try parameterValuesContainer.encode(targetparameterlist0)
            }
        }
        if truncated != false {
            try encodeContainer.encode(truncated, forKey: .truncated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parameterValues)
        var parameterValuesDecoded0:[String]? = nil
        if let parameterValuesContainer = parameterValuesContainer {
            parameterValuesDecoded0 = [String]()
            for string0 in parameterValuesContainer {
                if let string0 = string0 {
                    parameterValuesDecoded0?.append(string0)
                }
            }
        }
        parameterValues = parameterValuesDecoded0
        let truncatedDecoded = try containerValues.decode(Bool.self, forKey: .truncated)
        truncated = truncatedDecoded
    }
}

extension ResolvedTargets: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolvedTargets(parameterValues: \(String(describing: parameterValues)), truncated: \(String(describing: truncated)))"}
}

/// <p>Information about targets that resolved during the Automation execution.</p>
public struct ResolvedTargets: Equatable {
    /// <p>A list of parameter values sent to targets that resolved during the Automation
    ///    execution.</p>
    public let parameterValues: [String]?
    /// <p>A boolean value indicating whether the resolved target list is truncated.</p>
    public let truncated: Bool

    public init (
        parameterValues: [String]? = nil,
        truncated: Bool = false
    )
    {
        self.parameterValues = parameterValues
        self.truncated = truncated
    }
}

extension ResourceComplianceSummaryItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType = "ComplianceType"
        case compliantSummary = "CompliantSummary"
        case executionSummary = "ExecutionSummary"
        case nonCompliantSummary = "NonCompliantSummary"
        case overallSeverity = "OverallSeverity"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let compliantSummary = compliantSummary {
            try encodeContainer.encode(compliantSummary, forKey: .compliantSummary)
        }
        if let executionSummary = executionSummary {
            try encodeContainer.encode(executionSummary, forKey: .executionSummary)
        }
        if let nonCompliantSummary = nonCompliantSummary {
            try encodeContainer.encode(nonCompliantSummary, forKey: .nonCompliantSummary)
        }
        if let overallSeverity = overallSeverity {
            try encodeContainer.encode(overallSeverity.rawValue, forKey: .overallSeverity)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let overallSeverityDecoded = try containerValues.decodeIfPresent(ComplianceSeverity.self, forKey: .overallSeverity)
        overallSeverity = overallSeverityDecoded
        let executionSummaryDecoded = try containerValues.decodeIfPresent(ComplianceExecutionSummary.self, forKey: .executionSummary)
        executionSummary = executionSummaryDecoded
        let compliantSummaryDecoded = try containerValues.decodeIfPresent(CompliantSummary.self, forKey: .compliantSummary)
        compliantSummary = compliantSummaryDecoded
        let nonCompliantSummaryDecoded = try containerValues.decodeIfPresent(NonCompliantSummary.self, forKey: .nonCompliantSummary)
        nonCompliantSummary = nonCompliantSummaryDecoded
    }
}

extension ResourceComplianceSummaryItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceComplianceSummaryItem(complianceType: \(String(describing: complianceType)), compliantSummary: \(String(describing: compliantSummary)), executionSummary: \(String(describing: executionSummary)), nonCompliantSummary: \(String(describing: nonCompliantSummary)), overallSeverity: \(String(describing: overallSeverity)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), status: \(String(describing: status)))"}
}

/// <p>Compliance summary information for a specific resource. </p>
public struct ResourceComplianceSummaryItem: Equatable {
    /// <p>The compliance type.</p>
    public let complianceType: String?
    /// <p>A list of items that are compliant for the resource.</p>
    public let compliantSummary: CompliantSummary?
    /// <p>Information about the execution.</p>
    public let executionSummary: ComplianceExecutionSummary?
    /// <p>A list of items that aren't compliant for the resource.</p>
    public let nonCompliantSummary: NonCompliantSummary?
    /// <p>The highest severity item found for the resource. The resource is compliant for this
    ///    item.</p>
    public let overallSeverity: ComplianceSeverity?
    /// <p>The resource ID.</p>
    public let resourceId: String?
    /// <p>The resource type.</p>
    public let resourceType: String?
    /// <p>The compliance status for the resource.</p>
    public let status: ComplianceStatus?

    public init (
        complianceType: String? = nil,
        compliantSummary: CompliantSummary? = nil,
        executionSummary: ComplianceExecutionSummary? = nil,
        nonCompliantSummary: NonCompliantSummary? = nil,
        overallSeverity: ComplianceSeverity? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        status: ComplianceStatus? = nil
    )
    {
        self.complianceType = complianceType
        self.compliantSummary = compliantSummary
        self.executionSummary = executionSummary
        self.nonCompliantSummary = nonCompliantSummary
        self.overallSeverity = overallSeverity
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.status = status
    }
}

extension ResourceDataSyncAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncAlreadyExistsException(syncName: \(String(describing: syncName)))"}
}

extension ResourceDataSyncAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDataSyncAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.syncName = output.syncName
        } else {
            self.syncName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A sync configuration with the same name already exists.</p>
public struct ResourceDataSyncAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var syncName: String?

    public init (
        syncName: String? = nil
    )
    {
        self.syncName = syncName
    }
}

struct ResourceDataSyncAlreadyExistsExceptionBody: Equatable {
    public let syncName: String?
}

extension ResourceDataSyncAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case syncName = "SyncName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
    }
}

extension ResourceDataSyncAwsOrganizationsSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationSourceType = "OrganizationSourceType"
        case organizationalUnits = "OrganizationalUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationSourceType = organizationSourceType {
            try encodeContainer.encode(organizationSourceType, forKey: .organizationSourceType)
        }
        if let organizationalUnits = organizationalUnits {
            var organizationalUnitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnits)
            for resourcedatasyncorganizationalunitlist0 in organizationalUnits {
                try organizationalUnitsContainer.encode(resourcedatasyncorganizationalunitlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationSourceType)
        organizationSourceType = organizationSourceTypeDecoded
        let organizationalUnitsContainer = try containerValues.decodeIfPresent([ResourceDataSyncOrganizationalUnit?].self, forKey: .organizationalUnits)
        var organizationalUnitsDecoded0:[ResourceDataSyncOrganizationalUnit]? = nil
        if let organizationalUnitsContainer = organizationalUnitsContainer {
            organizationalUnitsDecoded0 = [ResourceDataSyncOrganizationalUnit]()
            for structure0 in organizationalUnitsContainer {
                if let structure0 = structure0 {
                    organizationalUnitsDecoded0?.append(structure0)
                }
            }
        }
        organizationalUnits = organizationalUnitsDecoded0
    }
}

extension ResourceDataSyncAwsOrganizationsSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncAwsOrganizationsSource(organizationSourceType: \(String(describing: organizationSourceType)), organizationalUnits: \(String(describing: organizationalUnits)))"}
}

/// <p>Information about the AwsOrganizationsSource resource data sync source. A sync source of
///    this type can synchronize data from AWS Organizations or, if an AWS Organization is not present, from
///    multiple AWS Regions.</p>
public struct ResourceDataSyncAwsOrganizationsSource: Equatable {
    /// <p>If an AWS Organization is present, this is either <code>OrganizationalUnits</code> or
    ///     <code>EntireOrganization</code>. For <code>OrganizationalUnits</code>, the data is aggregated
    ///    from a set of organization units. For <code>EntireOrganization</code>, the data is aggregated
    ///    from the entire AWS Organization. </p>
    public let organizationSourceType: String?
    /// <p>The AWS Organizations organization units included in the sync.</p>
    public let organizationalUnits: [ResourceDataSyncOrganizationalUnit]?

    public init (
        organizationSourceType: String? = nil,
        organizationalUnits: [ResourceDataSyncOrganizationalUnit]? = nil
    )
    {
        self.organizationSourceType = organizationSourceType
        self.organizationalUnits = organizationalUnits
    }
}

extension ResourceDataSyncConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncConflictException(message: \(String(describing: message)))"}
}

extension ResourceDataSyncConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDataSyncConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another <code>UpdateResourceDataSync</code> request is being processed. Wait a few minutes
///    and try again.</p>
public struct ResourceDataSyncConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncConflictExceptionBody: Equatable {
    public let message: String?
}

extension ResourceDataSyncConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncCountExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncCountExceededException(message: \(String(describing: message)))"}
}

extension ResourceDataSyncCountExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDataSyncCountExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the allowed maximum sync configurations.</p>
public struct ResourceDataSyncCountExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncCountExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceDataSyncCountExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncDestinationDataSharing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationDataSharingType = "DestinationDataSharingType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDataSharingType = destinationDataSharingType {
            try encodeContainer.encode(destinationDataSharingType, forKey: .destinationDataSharingType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDataSharingTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationDataSharingType)
        destinationDataSharingType = destinationDataSharingTypeDecoded
    }
}

extension ResourceDataSyncDestinationDataSharing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncDestinationDataSharing(destinationDataSharingType: \(String(describing: destinationDataSharingType)))"}
}

/// <p>Synchronize Systems Manager Inventory data from multiple AWS accounts defined in AWS Organizations to
///    a centralized S3 bucket. Data is synchronized to individual key prefixes in the central bucket.
///    Each key prefix represents a different AWS account ID.</p>
public struct ResourceDataSyncDestinationDataSharing: Equatable {
    /// <p>The sharing data type. Only <code>Organization</code> is supported.</p>
    public let destinationDataSharingType: String?

    public init (
        destinationDataSharingType: String? = nil
    )
    {
        self.destinationDataSharingType = destinationDataSharingType
    }
}

extension ResourceDataSyncInvalidConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncInvalidConfigurationException(message: \(String(describing: message)))"}
}

extension ResourceDataSyncInvalidConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDataSyncInvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified sync configuration is invalid.</p>
public struct ResourceDataSyncInvalidConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDataSyncInvalidConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension ResourceDataSyncInvalidConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastStatus = "LastStatus"
        case lastSuccessfulSyncTime = "LastSuccessfulSyncTime"
        case lastSyncStatusMessage = "LastSyncStatusMessage"
        case lastSyncTime = "LastSyncTime"
        case s3Destination = "S3Destination"
        case syncCreatedTime = "SyncCreatedTime"
        case syncLastModifiedTime = "SyncLastModifiedTime"
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastStatus = lastStatus {
            try encodeContainer.encode(lastStatus.rawValue, forKey: .lastStatus)
        }
        if let lastSuccessfulSyncTime = lastSuccessfulSyncTime {
            try encodeContainer.encode(lastSuccessfulSyncTime.timeIntervalSince1970, forKey: .lastSuccessfulSyncTime)
        }
        if let lastSyncStatusMessage = lastSyncStatusMessage {
            try encodeContainer.encode(lastSyncStatusMessage, forKey: .lastSyncStatusMessage)
        }
        if let lastSyncTime = lastSyncTime {
            try encodeContainer.encode(lastSyncTime.timeIntervalSince1970, forKey: .lastSyncTime)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
        if let syncCreatedTime = syncCreatedTime {
            try encodeContainer.encode(syncCreatedTime.timeIntervalSince1970, forKey: .syncCreatedTime)
        }
        if let syncLastModifiedTime = syncLastModifiedTime {
            try encodeContainer.encode(syncLastModifiedTime.timeIntervalSince1970, forKey: .syncLastModifiedTime)
        }
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(ResourceDataSyncSourceWithState.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(ResourceDataSyncS3Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
        let lastSyncTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSyncTime)
        lastSyncTime = lastSyncTimeDecoded
        let lastSuccessfulSyncTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastSuccessfulSyncTime)
        lastSuccessfulSyncTime = lastSuccessfulSyncTimeDecoded
        let syncLastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .syncLastModifiedTime)
        syncLastModifiedTime = syncLastModifiedTimeDecoded
        let lastStatusDecoded = try containerValues.decodeIfPresent(LastResourceDataSyncStatus.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let syncCreatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .syncCreatedTime)
        syncCreatedTime = syncCreatedTimeDecoded
        let lastSyncStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastSyncStatusMessage)
        lastSyncStatusMessage = lastSyncStatusMessageDecoded
    }
}

extension ResourceDataSyncItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncItem(lastStatus: \(String(describing: lastStatus)), lastSuccessfulSyncTime: \(String(describing: lastSuccessfulSyncTime)), lastSyncStatusMessage: \(String(describing: lastSyncStatusMessage)), lastSyncTime: \(String(describing: lastSyncTime)), s3Destination: \(String(describing: s3Destination)), syncCreatedTime: \(String(describing: syncCreatedTime)), syncLastModifiedTime: \(String(describing: syncLastModifiedTime)), syncName: \(String(describing: syncName)), syncSource: \(String(describing: syncSource)), syncType: \(String(describing: syncType)))"}
}

/// <p>Information about a Resource Data Sync configuration, including its current status and last
///    successful sync.</p>
public struct ResourceDataSyncItem: Equatable {
    /// <p>The status reported by the last sync.</p>
    public let lastStatus: LastResourceDataSyncStatus?
    /// <p>The last time the sync operations returned a status of <code>SUCCESSFUL</code> (UTC).</p>
    public let lastSuccessfulSyncTime: Date?
    /// <p>The status message details reported by the last sync.</p>
    public let lastSyncStatusMessage: String?
    /// <p>The last time the configuration attempted to sync (UTC).</p>
    public let lastSyncTime: Date?
    /// <p>Configuration information for the target S3 bucket.</p>
    public let s3Destination: ResourceDataSyncS3Destination?
    /// <p>The date and time the configuration was created (UTC).</p>
    public let syncCreatedTime: Date?
    /// <p>The date and time the resource data sync was changed. </p>
    public let syncLastModifiedTime: Date?
    /// <p>The name of the Resource Data Sync.</p>
    public let syncName: String?
    /// <p>Information about the source where the data was synchronized. </p>
    public let syncSource: ResourceDataSyncSourceWithState?
    /// <p>The type of resource data sync. If <code>SyncType</code> is <code>SyncToDestination</code>,
    ///    then the resource data sync synchronizes data to an S3 bucket. If the <code>SyncType</code> is
    ///     <code>SyncFromSource</code> then the resource data sync synchronizes data from AWS Organizations or from
    ///    multiple AWS Regions.</p>
    public let syncType: String?

    public init (
        lastStatus: LastResourceDataSyncStatus? = nil,
        lastSuccessfulSyncTime: Date? = nil,
        lastSyncStatusMessage: String? = nil,
        lastSyncTime: Date? = nil,
        s3Destination: ResourceDataSyncS3Destination? = nil,
        syncCreatedTime: Date? = nil,
        syncLastModifiedTime: Date? = nil,
        syncName: String? = nil,
        syncSource: ResourceDataSyncSourceWithState? = nil,
        syncType: String? = nil
    )
    {
        self.lastStatus = lastStatus
        self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
        self.lastSyncStatusMessage = lastSyncStatusMessage
        self.lastSyncTime = lastSyncTime
        self.s3Destination = s3Destination
        self.syncCreatedTime = syncCreatedTime
        self.syncLastModifiedTime = syncLastModifiedTime
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

extension ResourceDataSyncNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncNotFoundException(message: \(String(describing: message)), syncName: \(String(describing: syncName)), syncType: \(String(describing: syncType)))"}
}

extension ResourceDataSyncNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDataSyncNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.syncName = output.syncName
            self.syncType = output.syncType
        } else {
            self.message = nil
            self.syncName = nil
            self.syncType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified sync name was not found.</p>
public struct ResourceDataSyncNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var syncName: String?
    public var syncType: String?

    public init (
        message: String? = nil,
        syncName: String? = nil,
        syncType: String? = nil
    )
    {
        self.message = message
        self.syncName = syncName
        self.syncType = syncType
    }
}

struct ResourceDataSyncNotFoundExceptionBody: Equatable {
    public let syncName: String?
    public let syncType: String?
    public let message: String?
}

extension ResourceDataSyncNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case syncName = "SyncName"
        case syncType = "SyncType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDataSyncOrganizationalUnit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationalUnitId = "OrganizationalUnitId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationalUnitId = organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
    }
}

extension ResourceDataSyncOrganizationalUnit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncOrganizationalUnit(organizationalUnitId: \(String(describing: organizationalUnitId)))"}
}

/// <p>The AWS Organizations organizational unit data source for the sync.</p>
public struct ResourceDataSyncOrganizationalUnit: Equatable {
    /// <p>The AWS Organization unit ID data source for the sync.</p>
    public let organizationalUnitId: String?

    public init (
        organizationalUnitId: String? = nil
    )
    {
        self.organizationalUnitId = organizationalUnitId
    }
}

extension ResourceDataSyncS3Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSKMSKeyARN = "AWSKMSKeyARN"
        case bucketName = "BucketName"
        case destinationDataSharing = "DestinationDataSharing"
        case prefix = "Prefix"
        case region = "Region"
        case syncFormat = "SyncFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSKMSKeyARN = aWSKMSKeyARN {
            try encodeContainer.encode(aWSKMSKeyARN, forKey: .aWSKMSKeyARN)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let destinationDataSharing = destinationDataSharing {
            try encodeContainer.encode(destinationDataSharing, forKey: .destinationDataSharing)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let syncFormat = syncFormat {
            try encodeContainer.encode(syncFormat.rawValue, forKey: .syncFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let syncFormatDecoded = try containerValues.decodeIfPresent(ResourceDataSyncS3Format.self, forKey: .syncFormat)
        syncFormat = syncFormatDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let aWSKMSKeyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aWSKMSKeyARN)
        aWSKMSKeyARN = aWSKMSKeyARNDecoded
        let destinationDataSharingDecoded = try containerValues.decodeIfPresent(ResourceDataSyncDestinationDataSharing.self, forKey: .destinationDataSharing)
        destinationDataSharing = destinationDataSharingDecoded
    }
}

extension ResourceDataSyncS3Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncS3Destination(aWSKMSKeyARN: \(String(describing: aWSKMSKeyARN)), bucketName: \(String(describing: bucketName)), destinationDataSharing: \(String(describing: destinationDataSharing)), prefix: \(String(describing: prefix)), region: \(String(describing: region)), syncFormat: \(String(describing: syncFormat)))"}
}

/// <p>Information about the target S3 bucket for the Resource Data Sync.</p>
public struct ResourceDataSyncS3Destination: Equatable {
    /// <p>The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as
    ///    the destination S3 bucket.</p>
    public let aWSKMSKeyARN: String?
    /// <p>The name of the S3 bucket where the aggregated data is stored.</p>
    public let bucketName: String?
    /// <p>Enables destination data sharing. By default, this field is <code>null</code>.</p>
    public let destinationDataSharing: ResourceDataSyncDestinationDataSharing?
    /// <p>An Amazon S3 prefix for the bucket.</p>
    public let prefix: String?
    /// <p>The AWS Region with the S3 bucket targeted by the Resource Data Sync.</p>
    public let region: String?
    /// <p>A supported sync format. The following format is currently supported: JsonSerDe</p>
    public let syncFormat: ResourceDataSyncS3Format?

    public init (
        aWSKMSKeyARN: String? = nil,
        bucketName: String? = nil,
        destinationDataSharing: ResourceDataSyncDestinationDataSharing? = nil,
        prefix: String? = nil,
        region: String? = nil,
        syncFormat: ResourceDataSyncS3Format? = nil
    )
    {
        self.aWSKMSKeyARN = aWSKMSKeyARN
        self.bucketName = bucketName
        self.destinationDataSharing = destinationDataSharing
        self.prefix = prefix
        self.region = region
        self.syncFormat = syncFormat
    }
}

public enum ResourceDataSyncS3Format {
    case jsonSerde
    case sdkUnknown(String)
}

extension ResourceDataSyncS3Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceDataSyncS3Format] {
        return [
            .jsonSerde,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jsonSerde: return "JsonSerDe"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceDataSyncS3Format(rawValue: rawValue) ?? ResourceDataSyncS3Format.sdkUnknown(rawValue)
    }
}

extension ResourceDataSyncSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension ResourceDataSyncSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncSource(awsOrganizationsSource: \(String(describing: awsOrganizationsSource)), enableAllOpsDataSources: \(String(describing: enableAllOpsDataSources)), includeFutureRegions: \(String(describing: includeFutureRegions)), sourceRegions: \(String(describing: sourceRegions)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Information about the source of the data included in the resource data sync.</p>
public struct ResourceDataSyncSource: Equatable {
    /// <p>Information about the AwsOrganizationsSource resource data sync source. A sync source of
    ///    this type can synchronize data from AWS Organizations.</p>
    public let awsOrganizationsSource: ResourceDataSyncAwsOrganizationsSource?
    /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
    ///    automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
    ///    your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let enableAllOpsDataSources: Bool
    /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
    ///    Regions come online.</p>
    public let includeFutureRegions: Bool
    /// <p>The <code>SyncSource</code> AWS Regions included in the resource data sync.</p>
    public let sourceRegions: [String]?
    /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
    ///     <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
    ///     <code>SingleAccountMultiRegions</code>.</p>
    public let sourceType: String?

    public init (
        awsOrganizationsSource: ResourceDataSyncAwsOrganizationsSource? = nil,
        enableAllOpsDataSources: Bool = false,
        includeFutureRegions: Bool = false,
        sourceRegions: [String]? = nil,
        sourceType: String? = nil
    )
    {
        self.awsOrganizationsSource = awsOrganizationsSource
        self.enableAllOpsDataSources = enableAllOpsDataSources
        self.includeFutureRegions = includeFutureRegions
        self.sourceRegions = sourceRegions
        self.sourceType = sourceType
    }
}

extension ResourceDataSyncSourceWithState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsOrganizationsSource = "AwsOrganizationsSource"
        case enableAllOpsDataSources = "EnableAllOpsDataSources"
        case includeFutureRegions = "IncludeFutureRegions"
        case sourceRegions = "SourceRegions"
        case sourceType = "SourceType"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsOrganizationsSource = awsOrganizationsSource {
            try encodeContainer.encode(awsOrganizationsSource, forKey: .awsOrganizationsSource)
        }
        if enableAllOpsDataSources != false {
            try encodeContainer.encode(enableAllOpsDataSources, forKey: .enableAllOpsDataSources)
        }
        if includeFutureRegions != false {
            try encodeContainer.encode(includeFutureRegions, forKey: .includeFutureRegions)
        }
        if let sourceRegions = sourceRegions {
            var sourceRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRegions)
            for resourcedatasyncsourceregionlist0 in sourceRegions {
                try sourceRegionsContainer.encode(resourcedatasyncsourceregionlist0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let awsOrganizationsSourceDecoded = try containerValues.decodeIfPresent(ResourceDataSyncAwsOrganizationsSource.self, forKey: .awsOrganizationsSource)
        awsOrganizationsSource = awsOrganizationsSourceDecoded
        let sourceRegionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sourceRegions)
        var sourceRegionsDecoded0:[String]? = nil
        if let sourceRegionsContainer = sourceRegionsContainer {
            sourceRegionsDecoded0 = [String]()
            for string0 in sourceRegionsContainer {
                if let string0 = string0 {
                    sourceRegionsDecoded0?.append(string0)
                }
            }
        }
        sourceRegions = sourceRegionsDecoded0
        let includeFutureRegionsDecoded = try containerValues.decode(Bool.self, forKey: .includeFutureRegions)
        includeFutureRegions = includeFutureRegionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let enableAllOpsDataSourcesDecoded = try containerValues.decode(Bool.self, forKey: .enableAllOpsDataSources)
        enableAllOpsDataSources = enableAllOpsDataSourcesDecoded
    }
}

extension ResourceDataSyncSourceWithState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDataSyncSourceWithState(awsOrganizationsSource: \(String(describing: awsOrganizationsSource)), enableAllOpsDataSources: \(String(describing: enableAllOpsDataSources)), includeFutureRegions: \(String(describing: includeFutureRegions)), sourceRegions: \(String(describing: sourceRegions)), sourceType: \(String(describing: sourceType)), state: \(String(describing: state)))"}
}

/// <p>The data type name for including resource data sync state. There are four sync
///    states:</p>
///          <p>
///             <code>OrganizationNotExists</code> (Your organization doesn't exist)</p>
///          <p>
///             <code>NoPermissions</code> (The system can't locate the service-linked role. This role is
///    automatically created when a user creates a resource data sync in Explorer.)</p>
///          <p>
///             <code>InvalidOrganizationalUnit</code> (You specified or selected an invalid unit in the
///    resource data sync configuration.)</p>
///          <p>
///             <code>TrustedAccessDisabled</code> (You disabled Systems Manager access in the organization in
///    AWS Organizations.)</p>
public struct ResourceDataSyncSourceWithState: Equatable {
    /// <p>The field name in <code>SyncSource</code> for the
    ///     <code>ResourceDataSyncAwsOrganizationsSource</code> type.</p>
    public let awsOrganizationsSource: ResourceDataSyncAwsOrganizationsSource?
    /// <p>When you create a resource data sync, if you choose one of the AWS Organizations options, then Systems Manager
    ///    automatically enables all OpsData sources in the selected AWS Regions for all AWS accounts in
    ///    your organization (or in the selected organization units). For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resouce-data-sync-multiple-accounts-and-regions.html">About multiple account and Region resource data syncs</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    public let enableAllOpsDataSources: Bool
    /// <p>Whether to automatically synchronize and aggregate data from new AWS Regions when those
    ///    Regions come online.</p>
    public let includeFutureRegions: Bool
    /// <p>The <code>SyncSource</code> AWS Regions included in the resource data sync.</p>
    public let sourceRegions: [String]?
    /// <p>The type of data source for the resource data sync. <code>SourceType</code> is either
    ///     <code>AwsOrganizations</code> (if an organization is present in AWS Organizations) or
    ///     <code>singleAccountMultiRegions</code>.</p>
    public let sourceType: String?
    /// <p>The data type name for including resource data sync state. There are four sync
    ///    states:</p>
    ///          <p>
    ///             <code>OrganizationNotExists</code>: Your organization doesn't exist.</p>
    ///          <p>
    ///             <code>NoPermissions</code>: The system can't locate the service-linked role. This role is
    ///    automatically created when a user creates a resource data sync in Explorer.</p>
    ///          <p>
    ///             <code>InvalidOrganizationalUnit</code>: You specified or selected an invalid unit in the
    ///    resource data sync configuration.</p>
    ///          <p>
    ///             <code>TrustedAccessDisabled</code>: You disabled Systems Manager access in the organization in
    ///    AWS Organizations.</p>
    public let state: String?

    public init (
        awsOrganizationsSource: ResourceDataSyncAwsOrganizationsSource? = nil,
        enableAllOpsDataSources: Bool = false,
        includeFutureRegions: Bool = false,
        sourceRegions: [String]? = nil,
        sourceType: String? = nil,
        state: String? = nil
    )
    {
        self.awsOrganizationsSource = awsOrganizationsSource
        self.enableAllOpsDataSources = enableAllOpsDataSources
        self.includeFutureRegions = includeFutureRegions
        self.sourceRegions = sourceRegions
        self.sourceType = sourceType
        self.state = state
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error returned if an attempt is made to delete a patch baseline that is registered for a
///    patch group.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceLimitExceededException(message: \(String(describing: message)))"}
}

extension ResourceLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Error returned when the caller has exceeded the default resource quotas. For example, too
///    many maintenance windows or patch baselines have been created.</p>
///          <p>For information about resource quotas in Systems Manager, see <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm">Systems Manager service quotas</a> in the
///         <i>AWS General Reference</i>.</p>
public struct ResourceLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ResourceLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case document
    case ec2Instance
    case managedInstance
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .document,
            .ec2Instance,
            .managedInstance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .document: return "Document"
        case .ec2Instance: return "EC2Instance"
        case .managedInstance: return "ManagedInstance"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public enum ResourceTypeForTagging {
    case document
    case maintenanceWindow
    case managedInstance
    case opsmetadata
    case opsItem
    case parameter
    case patchBaseline
    case sdkUnknown(String)
}

extension ResourceTypeForTagging : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceTypeForTagging] {
        return [
            .document,
            .maintenanceWindow,
            .managedInstance,
            .opsmetadata,
            .opsItem,
            .parameter,
            .patchBaseline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .document: return "Document"
        case .maintenanceWindow: return "MaintenanceWindow"
        case .managedInstance: return "ManagedInstance"
        case .opsmetadata: return "OpsMetadata"
        case .opsItem: return "OpsItem"
        case .parameter: return "Parameter"
        case .patchBaseline: return "PatchBaseline"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceTypeForTagging(rawValue: rawValue) ?? ResourceTypeForTagging.sdkUnknown(rawValue)
    }
}

extension ResultAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case typeName = "TypeName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
    }
}

extension ResultAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultAttribute(typeName: \(String(describing: typeName)))"}
}

/// <p>The inventory item result attribute.</p>
public struct ResultAttribute: Equatable {
    /// <p>Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value:
    ///    AWS:InstanceInformation.</p>
    public let typeName: String?

    public init (
        typeName: String? = nil
    )
    {
        self.typeName = typeName
    }
}

public struct ResumeSessionInputBodyMiddleware: Middleware {
    public let id: String = "ResumeSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeSessionOutputError>
}

extension ResumeSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeSessionInput(sessionId: \(String(describing: sessionId)))"}
}

extension ResumeSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct ResumeSessionInputHeadersMiddleware: Middleware {
    public let id: String = "ResumeSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "ResumeSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResumeSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<ResumeSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResumeSessionInput>
    public typealias MOutput = OperationOutput<ResumeSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResumeSessionOutputError>
}

public struct ResumeSessionInput: Equatable {
    /// <p>The ID of the disconnected session to resume.</p>
    public let sessionId: String?

    public init (
        sessionId: String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ResumeSessionInputBody: Equatable {
    public let sessionId: String?
}

extension ResumeSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ResumeSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeSessionOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResumeSessionOutputResponse(sessionId: \(String(describing: sessionId)), streamUrl: \(String(describing: streamUrl)), tokenValue: \(String(describing: tokenValue)))"}
}

extension ResumeSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResumeSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct ResumeSessionOutputResponse: Equatable {
    /// <p>The ID of the session.</p>
    public let sessionId: String?
    /// <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and
    ///    receive output from the instance. Format: <code>wss://ssmmessages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code>.</p>
    ///          <p>
    ///             <b>region</b> represents the Region identifier for an
    /// 						AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region.
    /// 						For a list of supported <b>region</b> values, see the <b>Region</b> column in <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region">Systems Manager service endpoints</a> in the
    ///         <i>AWS General Reference</i>.</p>
    ///          <p>
    ///             <b>session-id</b> represents the ID of a Session Manager session, such as
    ///     <code>1a2b3c4dEXAMPLE</code>.</p>
    public let streamUrl: String?
    /// <p>An encrypted token value containing session and caller information. Used to authenticate the
    ///    connection to the instance.</p>
    public let tokenValue: String?

    public init (
        sessionId: String? = nil,
        streamUrl: String? = nil,
        tokenValue: String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct ResumeSessionOutputResponseBody: Equatable {
    public let sessionId: String?
    public let tokenValue: String?
    public let streamUrl: String?
}

extension ResumeSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension ReviewInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reviewedTime = "ReviewedTime"
        case reviewer = "Reviewer"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reviewedTime = reviewedTime {
            try encodeContainer.encode(reviewedTime.timeIntervalSince1970, forKey: .reviewedTime)
        }
        if let reviewer = reviewer {
            try encodeContainer.encode(reviewer, forKey: .reviewer)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .reviewedTime)
        reviewedTime = reviewedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ReviewStatus.self, forKey: .status)
        status = statusDecoded
        let reviewerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reviewer)
        reviewer = reviewerDecoded
    }
}

extension ReviewInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReviewInformation(reviewedTime: \(String(describing: reviewedTime)), reviewer: \(String(describing: reviewer)), status: \(String(describing: status)))"}
}

/// <p>Information about the result of a document review request.</p>
public struct ReviewInformation: Equatable {
    /// <p>The time that the reviewer took action on the document review request.</p>
    public let reviewedTime: Date?
    /// <p>The reviewer assigned to take action on the document review request.</p>
    public let reviewer: String?
    /// <p>The current status of the document review request.</p>
    public let status: ReviewStatus?

    public init (
        reviewedTime: Date? = nil,
        reviewer: String? = nil,
        status: ReviewStatus? = nil
    )
    {
        self.reviewedTime = reviewedTime
        self.reviewer = reviewer
        self.status = status
    }
}

public enum ReviewStatus {
    case approved
    case notReviewed
    case pending
    case rejected
    case sdkUnknown(String)
}

extension ReviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReviewStatus] {
        return [
            .approved,
            .notReviewed,
            .pending,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "APPROVED"
        case .notReviewed: return "NOT_REVIEWED"
        case .pending: return "PENDING"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReviewStatus(rawValue: rawValue) ?? ReviewStatus.sdkUnknown(rawValue)
    }
}

extension Runbook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case parameters = "Parameters"
        case targetLocations = "TargetLocations"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension Runbook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Runbook(documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), parameters: \(String(describing: parameters)), targetLocations: \(String(describing: targetLocations)), targetParameterName: \(String(describing: targetParameterName)), targets: \(String(describing: targets)))"}
}

/// <p>Information about an Automation runbook (Automation document) used in a runbook workflow in
///    Change Manager.</p>
///          <note>
///             <p>The Automation runbooks specified for the runbook workflow can't run until all required
///     approvals for the change request have been received.</p>
///          </note>
public struct Runbook: Equatable {
    /// <p>The name of the Automation runbook (Automation document) used in a runbook workflow.</p>
    public let documentName: String?
    /// <p>The version of the Automation runbook (Automation document) used in a
    ///    runbook workflow.</p>
    public let documentVersion: String?
    /// <p>The <code>MaxConcurrency</code> value specified by the user when the operation started,
    ///    indicating the maximum number of resources that the runbook operation can run on at the same
    ///    time.</p>
    public let maxConcurrency: String?
    /// <p>The <code>MaxErrors</code> value specified by the user when the execution started,
    ///    indicating the maximum number of errors that can occur during the operation before the updates
    ///    are stopped or rolled back.</p>
    public let maxErrors: String?
    /// <p>The key-value map of execution parameters, which were supplied when calling
    ///     <code>StartChangeRequestExecution</code>.</p>
    public let parameters: [String:[String]]?
    /// <p>Information about the AWS Regions and accounts targeted by the current Runbook
    ///    operation.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The name of the parameter used as the target resource for the rate-controlled
    ///    runbook workflow. Required if you specify <code>Targets</code>. </p>
    public let targetParameterName: String?
    /// <p>A key-value mapping to target resources that the Runbook operation performs tasks on.
    ///    Required if you specify <code>TargetParameterName</code>.</p>
    public let targets: [Target]?

    public init (
        documentName: String? = nil,
        documentVersion: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        parameters: [String:[String]]? = nil,
        targetLocations: [TargetLocation]? = nil,
        targetParameterName: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.parameters = parameters
        self.targetLocations = targetLocations
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

extension S3OutputLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
    }
}

extension S3OutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3OutputLocation(outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), outputS3Region: \(String(describing: outputS3Region)))"}
}

/// <p>An S3 bucket where you want to store the results of this request.</p>
public struct S3OutputLocation: Equatable {
    /// <p>The name of the S3 bucket.</p>
    public let outputS3BucketName: String?
    /// <p>The S3 bucket subfolder.</p>
    public let outputS3KeyPrefix: String?
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    ///    automatically determines the Region of the S3 bucket.</p>
    public let outputS3Region: String?

    public init (
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        outputS3Region: String? = nil
    )
    {
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
    }
}

extension S3OutputUrl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case outputUrl = "OutputUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
    }
}

extension S3OutputUrl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3OutputUrl(outputUrl: \(String(describing: outputUrl)))"}
}

/// <p>A URL for the S3 bucket where you want to store the results of this request.</p>
public struct S3OutputUrl: Equatable {
    /// <p>A URL for an S3 bucket where you want to store the results of this request.</p>
    public let outputUrl: String?

    public init (
        outputUrl: String? = nil
    )
    {
        self.outputUrl = outputUrl
    }
}

extension ScheduledWindowExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionTime = "ExecutionTime"
        case name = "Name"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionTime = executionTime {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
    }
}

extension ScheduledWindowExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ScheduledWindowExecution(executionTime: \(String(describing: executionTime)), name: \(String(describing: name)), windowId: \(String(describing: windowId)))"}
}

/// <p>Information about a scheduled execution for a maintenance window.</p>
public struct ScheduledWindowExecution: Equatable {
    /// <p>The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be
    ///    run.</p>
    public let executionTime: String?
    /// <p>The name of the maintenance window to be run.</p>
    public let name: String?
    /// <p>The ID of the maintenance window to be run.</p>
    public let windowId: String?

    public init (
        executionTime: String? = nil,
        name: String? = nil,
        windowId: String? = nil
    )
    {
        self.executionTime = executionTime
        self.name = name
        self.windowId = windowId
    }
}

public struct SendAutomationSignalInputBodyMiddleware: Middleware {
    public let id: String = "SendAutomationSignalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAutomationSignalOutputError>
}

extension SendAutomationSignalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAutomationSignalInput(automationExecutionId: \(String(describing: automationExecutionId)), payload: \(String(describing: payload)), signalType: \(String(describing: signalType)))"}
}

extension SendAutomationSignalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let payload = payload {
            var payloadContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .payload)
            for (dictKey0, automationparametermap0) in payload {
                try payloadContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let signalType = signalType {
            try encodeContainer.encode(signalType.rawValue, forKey: .signalType)
        }
    }
}

public struct SendAutomationSignalInputHeadersMiddleware: Middleware {
    public let id: String = "SendAutomationSignalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInputQueryItemMiddleware: Middleware {
    public let id: String = "SendAutomationSignalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendAutomationSignalInput>,
                  next: H) -> Swift.Result<OperationOutput<SendAutomationSignalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendAutomationSignalInput>
    public typealias MOutput = OperationOutput<SendAutomationSignalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendAutomationSignalOutputError>
}

public struct SendAutomationSignalInput: Equatable {
    /// <p>The unique identifier for an existing Automation execution that you want to send the signal
    ///    to.</p>
    public let automationExecutionId: String?
    /// <p>The data sent with the signal. The data schema depends on the type of signal used in the
    ///    request.</p>
    ///          <p>For <code>Approve</code> and <code>Reject</code> signal types, the payload is an optional
    ///    comment that you can send with the signal type. For example:</p>
    ///          <p>
    ///             <code>Comment="Looks good"</code>
    ///          </p>
    ///          <p>For <code>StartStep</code> and <code>Resume</code> signal types, you must send the name of
    ///    the Automation step to start or resume as the payload. For example:</p>
    ///          <p>
    ///             <code>StepName="step1"</code>
    ///          </p>
    ///          <p>For the <code>StopStep</code> signal type, you must send the step execution ID as the
    ///    payload. For example:</p>
    ///          <p>
    ///             <code>StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"</code>
    ///          </p>
    public let payload: [String:[String]]?
    /// <p>The type of signal to send to an Automation execution. </p>
    public let signalType: SignalType?

    public init (
        automationExecutionId: String? = nil,
        payload: [String:[String]]? = nil,
        signalType: SignalType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.payload = payload
        self.signalType = signalType
    }
}

struct SendAutomationSignalInputBody: Equatable {
    public let automationExecutionId: String?
    public let signalType: SignalType?
    public let payload: [String:[String]]?
}

extension SendAutomationSignalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case payload = "Payload"
        case signalType = "SignalType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let signalTypeDecoded = try containerValues.decodeIfPresent(SignalType.self, forKey: .signalType)
        signalType = signalTypeDecoded
        let payloadContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .payload)
        var payloadDecoded0: [String:[String]]? = nil
        if let payloadContainer = payloadContainer {
            payloadDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in payloadContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                payloadDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        payload = payloadDecoded0
    }
}

extension SendAutomationSignalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAutomationSignalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFoundException" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationStepNotFoundException" : self = .automationStepNotFoundException(try AutomationStepNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationSignalException" : self = .invalidAutomationSignalException(try InvalidAutomationSignalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAutomationSignalOutputError: Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case automationStepNotFoundException(AutomationStepNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationSignalException(InvalidAutomationSignalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAutomationSignalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAutomationSignalOutputResponse()"}
}

extension SendAutomationSignalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SendAutomationSignalOutputResponse: Equatable {

    public init() {}
}

struct SendAutomationSignalOutputResponseBody: Equatable {
}

extension SendAutomationSignalOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SendCommandInputBodyMiddleware: Middleware {
    public let id: String = "SendCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

extension SendCommandInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCommandInput(cloudWatchOutputConfig: \(String(describing: cloudWatchOutputConfig)), comment: \(String(describing: comment)), documentHash: \(String(describing: documentHash)), documentHashType: \(String(describing: documentHashType)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), instanceIds: \(String(describing: instanceIds)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), notificationConfig: \(String(describing: notificationConfig)), outputS3BucketName: \(String(describing: outputS3BucketName)), outputS3KeyPrefix: \(String(describing: outputS3KeyPrefix)), outputS3Region: \(String(describing: outputS3Region)), parameters: \(String(describing: parameters)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), timeoutSeconds: \(String(describing: timeoutSeconds)))"}
}

extension SendCommandInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputConfig = cloudWatchOutputConfig {
            try encodeContainer.encode(cloudWatchOutputConfig, forKey: .cloudWatchOutputConfig)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let documentHash = documentHash {
            try encodeContainer.encode(documentHash, forKey: .documentHash)
        }
        if let documentHashType = documentHashType {
            try encodeContainer.encode(documentHashType.rawValue, forKey: .documentHashType)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceidlist0 in instanceIds {
                try instanceIdsContainer.encode(instanceidlist0)
            }
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let notificationConfig = notificationConfig {
            try encodeContainer.encode(notificationConfig, forKey: .notificationConfig)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let outputS3KeyPrefix = outputS3KeyPrefix {
            try encodeContainer.encode(outputS3KeyPrefix, forKey: .outputS3KeyPrefix)
        }
        if let outputS3Region = outputS3Region {
            try encodeContainer.encode(outputS3Region, forKey: .outputS3Region)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

public struct SendCommandInputHeadersMiddleware: Middleware {
    public let id: String = "SendCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

public struct SendCommandInputQueryItemMiddleware: Middleware {
    public let id: String = "SendCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendCommandInput>
    public typealias MOutput = OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendCommandOutputError>
}

public struct SendCommandInput: Equatable {
    /// <p>Enables Systems Manager to send Run Command output to Amazon CloudWatch Logs. </p>
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
    /// <p>User-specified information about the command, such as a brief description of what the
    ///    command should do.</p>
    public let comment: String?
    /// <p>The Sha256 or Sha1 hash created by the system when the document was created. </p>
    ///          <note>
    ///             <p>Sha1 hashes have been deprecated.</p>
    ///          </note>
    public let documentHash: String?
    /// <p>Sha256 or Sha1.</p>
    ///          <note>
    ///             <p>Sha1 hashes have been deprecated.</p>
    ///          </note>
    public let documentHashType: DocumentHashType?
    /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
    ///    To run a shared document belonging to another account, specify the document ARN. For more
    ///    information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
    ///    in the <i>AWS Systems Manager User Guide</i>.</p>
    public let documentName: String?
    /// <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a
    ///    specific version number. If you run commands by using the AWS CLI, then you must escape the first
    ///    two options by using a backslash. If you specify a version number, then you don't need to use the
    ///    backslash. For example:</p>
    ///          <p>--document-version "\$DEFAULT"</p>
    ///          <p>--document-version "\$LATEST"</p>
    ///          <p>--document-version "3"</p>
    public let documentVersion: String?
    /// <p>The IDs of the instances where the command should run. Specifying instance IDs is most
    ///    useful when you are targeting a limited number of instances, though you can specify up to 50
    ///    IDs.</p>
    ///          <p>To target a larger number of instances, or if you prefer not to list individual instance
    ///    IDs, we recommend using the <code>Targets</code> option instead. Using <code>Targets</code>,
    ///    which accepts tag key-value pairs to identify the instances to send commands to, you can a send
    ///    command to tens, hundreds, or thousands of instances at once.</p>
    ///          <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Using targets and rate
    ///     controls to send commands to a fleet</a> in the
    ///    <i>AWS Systems Manager User Guide</i>.</p>
    public let instanceIds: [String]?
    /// <p>(Optional) The maximum number of instances that are allowed to run the command at the same
    ///    time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50.
    ///    For more information about how to use MaxConcurrency, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity">Using
    ///     concurrency controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let maxConcurrency: String?
    /// <p>The maximum number of errors allowed without the command failing. When the command fails one
    ///    more time beyond the value of MaxErrors, the systems stops sending the command to additional
    ///    targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For
    ///    more information about how to use MaxErrors, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors">Using
    ///     error controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let maxErrors: String?
    /// <p>Configurations for sending notifications.</p>
    public let notificationConfig: NotificationConfig?
    /// <p>The name of the S3 bucket where command execution responses should be stored.</p>
    public let outputS3BucketName: String?
    /// <p>The directory structure within the S3 bucket where the responses should be stored.</p>
    public let outputS3KeyPrefix: String?
    /// <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager
    ///    automatically determines the Region of the S3 bucket.</p>
    public let outputS3Region: String?
    /// <p>The required and optional parameters specified in the document being run.</p>
    public let parameters: [String:[String]]?
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run
    ///    Command commands.</p>
    public let serviceRoleArn: String?
    /// <p>An array of search criteria that targets instances using a <code>Key,Value</code>
    ///    combination that you specify. Specifying targets is most useful when you want to send a command
    ///    to a large number of instances at once. Using <code>Targets</code>, which accepts tag key-value
    ///    pairs to identify instances, you can send a command to tens, hundreds, or thousands of instances
    ///    at once.</p>
    ///          <p>To send a command to a smaller number of instances, you can use the <code>InstanceIds</code>
    ///    option instead.</p>
    ///          <p>For more information about how to use targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending commands to a
    ///     fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let targets: [Target]?
    /// <p>If this time is reached and the command has not already started running, it will not
    ///    run.</p>
    public let timeoutSeconds: Int

    public init (
        cloudWatchOutputConfig: CloudWatchOutputConfig? = nil,
        comment: String? = nil,
        documentHash: String? = nil,
        documentHashType: DocumentHashType? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        instanceIds: [String]? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        notificationConfig: NotificationConfig? = nil,
        outputS3BucketName: String? = nil,
        outputS3KeyPrefix: String? = nil,
        outputS3Region: String? = nil,
        parameters: [String:[String]]? = nil,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        timeoutSeconds: Int = 0
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.comment = comment
        self.documentHash = documentHash
        self.documentHashType = documentHashType
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.instanceIds = instanceIds
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.parameters = parameters
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
    }
}

struct SendCommandInputBody: Equatable {
    public let instanceIds: [String]?
    public let targets: [Target]?
    public let documentName: String?
    public let documentVersion: String?
    public let documentHash: String?
    public let documentHashType: DocumentHashType?
    public let timeoutSeconds: Int
    public let comment: String?
    public let parameters: [String:[String]]?
    public let outputS3Region: String?
    public let outputS3BucketName: String?
    public let outputS3KeyPrefix: String?
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let serviceRoleArn: String?
    public let notificationConfig: NotificationConfig?
    public let cloudWatchOutputConfig: CloudWatchOutputConfig?
}

extension SendCommandInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputConfig = "CloudWatchOutputConfig"
        case comment = "Comment"
        case documentHash = "DocumentHash"
        case documentHashType = "DocumentHashType"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case instanceIds = "InstanceIds"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case notificationConfig = "NotificationConfig"
        case outputS3BucketName = "OutputS3BucketName"
        case outputS3KeyPrefix = "OutputS3KeyPrefix"
        case outputS3Region = "OutputS3Region"
        case parameters = "Parameters"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentHash)
        documentHash = documentHashDecoded
        let documentHashTypeDecoded = try containerValues.decodeIfPresent(DocumentHashType.self, forKey: .documentHashType)
        documentHashType = documentHashTypeDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let outputS3RegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3Region)
        outputS3Region = outputS3RegionDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
        let outputS3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3KeyPrefix)
        outputS3KeyPrefix = outputS3KeyPrefixDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let notificationConfigDecoded = try containerValues.decodeIfPresent(NotificationConfig.self, forKey: .notificationConfig)
        notificationConfig = notificationConfigDecoded
        let cloudWatchOutputConfigDecoded = try containerValues.decodeIfPresent(CloudWatchOutputConfig.self, forKey: .cloudWatchOutputConfig)
        cloudWatchOutputConfig = cloudWatchOutputConfigDecoded
    }
}

extension SendCommandOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateInstanceId" : self = .duplicateInstanceId(try DuplicateInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNotificationConfig" : self = .invalidNotificationConfig(try InvalidNotificationConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputFolder" : self = .invalidOutputFolder(try InvalidOutputFolder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRole" : self = .invalidRole(try InvalidRole(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedPlatformType" : self = .unsupportedPlatformType(try UnsupportedPlatformType(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Equatable {
    case duplicateInstanceId(DuplicateInstanceId)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidInstanceId(InvalidInstanceId)
    case invalidNotificationConfig(InvalidNotificationConfig)
    case invalidOutputFolder(InvalidOutputFolder)
    case invalidParameters(InvalidParameters)
    case invalidRole(InvalidRole)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unsupportedPlatformType(UnsupportedPlatformType)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendCommandOutputResponse(command: \(String(describing: command)))"}
}

extension SendCommandOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.command = output.command
        } else {
            self.command = nil
        }
    }
}

public struct SendCommandOutputResponse: Equatable {
    /// <p>The request as it was received by Systems Manager. Also provides the command ID which can be used
    ///    future references to this request.</p>
    public let command: Command?

    public init (
        command: Command? = nil
    )
    {
        self.command = command
    }
}

struct SendCommandOutputResponseBody: Equatable {
    public let command: Command?
}

extension SendCommandOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case command = "Command"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandDecoded = try containerValues.decodeIfPresent(Command.self, forKey: .command)
        command = commandDecoded
    }
}

extension ServiceSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case lastModifiedDate = "LastModifiedDate"
        case lastModifiedUser = "LastModifiedUser"
        case settingId = "SettingId"
        case settingValue = "SettingValue"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSetting(aRN: \(String(describing: aRN)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), settingId: \(String(describing: settingId)), settingValue: \(String(describing: settingValue)), status: \(String(describing: status)))"}
}

/// <p>The service setting data structure.</p>
///          <p>
///             <code>ServiceSetting</code> is an account-level setting for an AWS service. This setting
///    defines how a user interacts with or uses a service or a feature of a service. For example, if an
///    AWS service charges money to the account based on feature or service usage, then the AWS service
///    team might create a default setting of "false". This means the user can't use this feature unless
///    they change the setting to "true" and intentionally opt in for a paid feature.</p>
///          <p>Services map a <code>SettingId</code> object to a setting value. AWS services teams define
///    the default value for a <code>SettingId</code>. You can't create a new <code>SettingId</code>,
///    but you can overwrite the default value if you have the <code>ssm:UpdateServiceSetting</code>
///    permission for the setting. Use the <a>UpdateServiceSetting</a> API action to change
///    the default setting. Or, use the <a>ResetServiceSetting</a> to change the value back
///    to the original value defined by the AWS service team.</p>
public struct ServiceSetting: Equatable {
    /// <p>The ARN of the service setting.</p>
    public let aRN: String?
    /// <p>The last time the service setting was modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The ARN of the last modified user. This field is populated only if the setting value was
    ///    overwritten.</p>
    public let lastModifiedUser: String?
    /// <p>The ID of the service setting.</p>
    public let settingId: String?
    /// <p>The value of the service setting.</p>
    public let settingValue: String?
    /// <p>The status of the service setting. The value can be Default, Customized or
    ///    PendingUpdate.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Default: The current setting uses a default value provisioned by the AWS service
    ///      team.</p>
    ///             </li>
    ///             <li>
    ///                <p>Customized: The current setting use a custom value specified by the customer.</p>
    ///             </li>
    ///             <li>
    ///                <p>PendingUpdate: The current setting uses a default or custom value, but a setting change
    ///      request is pending approval.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        aRN: String? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        settingId: String? = nil,
        settingValue: String? = nil,
        status: String? = nil
    )
    {
        self.aRN = aRN
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.settingId = settingId
        self.settingValue = settingValue
        self.status = status
    }
}

extension ServiceSettingNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSettingNotFound(message: \(String(describing: message)))"}
}

extension ServiceSettingNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceSettingNotFoundBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified service setting was not found. Either the service name or the setting has not
///    been provisioned by the AWS service team.</p>
public struct ServiceSettingNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceSettingNotFoundBody: Equatable {
    public let message: String?
}

extension ServiceSettingNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Session: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case details = "Details"
        case documentName = "DocumentName"
        case endDate = "EndDate"
        case outputUrl = "OutputUrl"
        case owner = "Owner"
        case sessionId = "SessionId"
        case startDate = "StartDate"
        case status = "Status"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
        if let outputUrl = outputUrl {
            try encodeContainer.encode(outputUrl, forKey: .outputUrl)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate.timeIntervalSince1970, forKey: .startDate)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SessionStatus.self, forKey: .status)
        status = statusDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endDate)
        endDate = endDateDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .details)
        details = detailsDecoded
        let outputUrlDecoded = try containerValues.decodeIfPresent(SessionManagerOutputUrl.self, forKey: .outputUrl)
        outputUrl = outputUrlDecoded
    }
}

extension Session: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Session(details: \(String(describing: details)), documentName: \(String(describing: documentName)), endDate: \(String(describing: endDate)), outputUrl: \(String(describing: outputUrl)), owner: \(String(describing: owner)), sessionId: \(String(describing: sessionId)), startDate: \(String(describing: startDate)), status: \(String(describing: status)), target: \(String(describing: target)))"}
}

/// <p>Information about a Session Manager connection to an instance.</p>
public struct Session: Equatable {
    /// <p>Reserved for future use.</p>
    public let details: String?
    /// <p>The name of the Session Manager SSM document used to define the parameters and plugin settings for the
    ///    session. For example, <code>SSM-SessionManagerRunShell</code>.</p>
    public let documentName: String?
    /// <p>The date and time, in ISO-8601 Extended format, when the session was terminated.</p>
    public let endDate: Date?
    /// <p>Reserved for future use.</p>
    public let outputUrl: SessionManagerOutputUrl?
    /// <p>The ID of the AWS user account that started the session.</p>
    public let owner: String?
    /// <p>The ID of the session.</p>
    public let sessionId: String?
    /// <p>The date and time, in ISO-8601 Extended format, when the session began.</p>
    public let startDate: Date?
    /// <p>The status of the session. For example, "Connected" or "Terminated".</p>
    public let status: SessionStatus?
    /// <p>The instance that the Session Manager session connected to.</p>
    public let target: String?

    public init (
        details: String? = nil,
        documentName: String? = nil,
        endDate: Date? = nil,
        outputUrl: SessionManagerOutputUrl? = nil,
        owner: String? = nil,
        sessionId: String? = nil,
        startDate: Date? = nil,
        status: SessionStatus? = nil,
        target: String? = nil
    )
    {
        self.details = details
        self.documentName = documentName
        self.endDate = endDate
        self.outputUrl = outputUrl
        self.owner = owner
        self.sessionId = sessionId
        self.startDate = startDate
        self.status = status
        self.target = target
    }
}

extension SessionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(SessionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SessionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionFilter(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a filter for Session Manager information.</p>
public struct SessionFilter: Equatable {
    /// <p>The name of the filter.</p>
    public let key: SessionFilterKey?
    /// <p>The filter value. Valid values for each filter key are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>InvokedAfter: Specify a timestamp to limit your results. For example, specify
    ///      2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.</p>
    ///             </li>
    ///             <li>
    ///                <p>InvokedBefore: Specify a timestamp to limit your results. For example, specify
    ///      2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.</p>
    ///             </li>
    ///             <li>
    ///                <p>Target: Specify an instance to which session connections have been made.</p>
    ///             </li>
    ///             <li>
    ///                <p>Owner: Specify an AWS user account to see a list of sessions started by that user.</p>
    ///             </li>
    ///             <li>
    ///                <p>Status: Specify a valid session status to see a list of all sessions with that status.
    ///      Status values you can specify include:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Connected</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Connecting</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Disconnected</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Terminated</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Terminating</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Failed</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>SessionId: Specify a session ID to return details about the session.</p>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        key: SessionFilterKey? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum SessionFilterKey {
    case invokedAfter
    case invokedBefore
    case owner
    case sessionId
    case status
    case targetId
    case sdkUnknown(String)
}

extension SessionFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionFilterKey] {
        return [
            .invokedAfter,
            .invokedBefore,
            .owner,
            .sessionId,
            .status,
            .targetId,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invokedAfter: return "InvokedAfter"
        case .invokedBefore: return "InvokedBefore"
        case .owner: return "Owner"
        case .sessionId: return "SessionId"
        case .status: return "Status"
        case .targetId: return "Target"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionFilterKey(rawValue: rawValue) ?? SessionFilterKey.sdkUnknown(rawValue)
    }
}

extension SessionManagerOutputUrl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchOutputUrl = "CloudWatchOutputUrl"
        case s3OutputUrl = "S3OutputUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchOutputUrl = cloudWatchOutputUrl {
            try encodeContainer.encode(cloudWatchOutputUrl, forKey: .cloudWatchOutputUrl)
        }
        if let s3OutputUrl = s3OutputUrl {
            try encodeContainer.encode(s3OutputUrl, forKey: .s3OutputUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3OutputUrl)
        s3OutputUrl = s3OutputUrlDecoded
        let cloudWatchOutputUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchOutputUrl)
        cloudWatchOutputUrl = cloudWatchOutputUrlDecoded
    }
}

extension SessionManagerOutputUrl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionManagerOutputUrl(cloudWatchOutputUrl: \(String(describing: cloudWatchOutputUrl)), s3OutputUrl: \(String(describing: s3OutputUrl)))"}
}

/// <p>Reserved for future use.</p>
public struct SessionManagerOutputUrl: Equatable {
    /// <p>Reserved for future use.</p>
    public let cloudWatchOutputUrl: String?
    /// <p>Reserved for future use.</p>
    public let s3OutputUrl: String?

    public init (
        cloudWatchOutputUrl: String? = nil,
        s3OutputUrl: String? = nil
    )
    {
        self.cloudWatchOutputUrl = cloudWatchOutputUrl
        self.s3OutputUrl = s3OutputUrl
    }
}

public enum SessionState {
    case active
    case history
    case sdkUnknown(String)
}

extension SessionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionState] {
        return [
            .active,
            .history,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .history: return "History"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
    }
}

public enum SessionStatus {
    case connected
    case connecting
    case disconnected
    case failed
    case terminated
    case terminating
    case sdkUnknown(String)
}

extension SessionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SessionStatus] {
        return [
            .connected,
            .connecting,
            .disconnected,
            .failed,
            .terminated,
            .terminating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "Connected"
        case .connecting: return "Connecting"
        case .disconnected: return "Disconnected"
        case .failed: return "Failed"
        case .terminated: return "Terminated"
        case .terminating: return "Terminating"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SessionStatus(rawValue: rawValue) ?? SessionStatus.sdkUnknown(rawValue)
    }
}

extension SeveritySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criticalCount = "CriticalCount"
        case highCount = "HighCount"
        case informationalCount = "InformationalCount"
        case lowCount = "LowCount"
        case mediumCount = "MediumCount"
        case unspecifiedCount = "UnspecifiedCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if criticalCount != 0 {
            try encodeContainer.encode(criticalCount, forKey: .criticalCount)
        }
        if highCount != 0 {
            try encodeContainer.encode(highCount, forKey: .highCount)
        }
        if informationalCount != 0 {
            try encodeContainer.encode(informationalCount, forKey: .informationalCount)
        }
        if lowCount != 0 {
            try encodeContainer.encode(lowCount, forKey: .lowCount)
        }
        if mediumCount != 0 {
            try encodeContainer.encode(mediumCount, forKey: .mediumCount)
        }
        if unspecifiedCount != 0 {
            try encodeContainer.encode(unspecifiedCount, forKey: .unspecifiedCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criticalCountDecoded = try containerValues.decode(Int.self, forKey: .criticalCount)
        criticalCount = criticalCountDecoded
        let highCountDecoded = try containerValues.decode(Int.self, forKey: .highCount)
        highCount = highCountDecoded
        let mediumCountDecoded = try containerValues.decode(Int.self, forKey: .mediumCount)
        mediumCount = mediumCountDecoded
        let lowCountDecoded = try containerValues.decode(Int.self, forKey: .lowCount)
        lowCount = lowCountDecoded
        let informationalCountDecoded = try containerValues.decode(Int.self, forKey: .informationalCount)
        informationalCount = informationalCountDecoded
        let unspecifiedCountDecoded = try containerValues.decode(Int.self, forKey: .unspecifiedCount)
        unspecifiedCount = unspecifiedCountDecoded
    }
}

extension SeveritySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SeveritySummary(criticalCount: \(String(describing: criticalCount)), highCount: \(String(describing: highCount)), informationalCount: \(String(describing: informationalCount)), lowCount: \(String(describing: lowCount)), mediumCount: \(String(describing: mediumCount)), unspecifiedCount: \(String(describing: unspecifiedCount)))"}
}

/// <p>The number of managed instances found for each patch severity level defined in the request
///    filter.</p>
public struct SeveritySummary: Equatable {
    /// <p>The total number of resources or compliance items that have a severity level of critical.
    ///    Critical severity is determined by the organization that published the compliance items.</p>
    public let criticalCount: Int
    /// <p>The total number of resources or compliance items that have a severity level of high. High
    ///    severity is determined by the organization that published the compliance items.</p>
    public let highCount: Int
    /// <p>The total number of resources or compliance items that have a severity level of
    ///    informational. Informational severity is determined by the organization that published the
    ///    compliance items.</p>
    public let informationalCount: Int
    /// <p>The total number of resources or compliance items that have a severity level of low. Low
    ///    severity is determined by the organization that published the compliance items.</p>
    public let lowCount: Int
    /// <p>The total number of resources or compliance items that have a severity level of medium.
    ///    Medium severity is determined by the organization that published the compliance items.</p>
    public let mediumCount: Int
    /// <p>The total number of resources or compliance items that have a severity level of unspecified.
    ///    Unspecified severity is determined by the organization that published the compliance
    ///    items.</p>
    public let unspecifiedCount: Int

    public init (
        criticalCount: Int = 0,
        highCount: Int = 0,
        informationalCount: Int = 0,
        lowCount: Int = 0,
        mediumCount: Int = 0,
        unspecifiedCount: Int = 0
    )
    {
        self.criticalCount = criticalCount
        self.highCount = highCount
        self.informationalCount = informationalCount
        self.lowCount = lowCount
        self.mediumCount = mediumCount
        self.unspecifiedCount = unspecifiedCount
    }
}

public enum SignalType {
    case approve
    case reject
    case resume
    case startStep
    case stopStep
    case sdkUnknown(String)
}

extension SignalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SignalType] {
        return [
            .approve,
            .reject,
            .resume,
            .startStep,
            .stopStep,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approve: return "Approve"
        case .reject: return "Reject"
        case .resume: return "Resume"
        case .startStep: return "StartStep"
        case .stopStep: return "StopStep"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SignalType(rawValue: rawValue) ?? SignalType.sdkUnknown(rawValue)
    }
}

public struct StartAssociationsOnceInputBodyMiddleware: Middleware {
    public let id: String = "StartAssociationsOnceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssociationsOnceOutputError>
}

extension StartAssociationsOnceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAssociationsOnceInput(associationIds: \(String(describing: associationIds)))"}
}

extension StartAssociationsOnceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationIds = associationIds {
            var associationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associationIds)
            for associationidlist0 in associationIds {
                try associationIdsContainer.encode(associationidlist0)
            }
        }
    }
}

public struct StartAssociationsOnceInputHeadersMiddleware: Middleware {
    public let id: String = "StartAssociationsOnceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAssociationsOnceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssociationsOnceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssociationsOnceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssociationsOnceInput>
    public typealias MOutput = OperationOutput<StartAssociationsOnceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssociationsOnceOutputError>
}

public struct StartAssociationsOnceInput: Equatable {
    /// <p>The association IDs that you want to run immediately and only one time.</p>
    public let associationIds: [String]?

    public init (
        associationIds: [String]? = nil
    )
    {
        self.associationIds = associationIds
    }
}

struct StartAssociationsOnceInputBody: Equatable {
    public let associationIds: [String]?
}

extension StartAssociationsOnceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationIds = "AssociationIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .associationIds)
        var associationIdsDecoded0:[String]? = nil
        if let associationIdsContainer = associationIdsContainer {
            associationIdsDecoded0 = [String]()
            for string0 in associationIdsContainer {
                if let string0 = string0 {
                    associationIdsDecoded0?.append(string0)
                }
            }
        }
        associationIds = associationIdsDecoded0
    }
}

extension StartAssociationsOnceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssociationsOnceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociation" : self = .invalidAssociation(try InvalidAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssociationsOnceOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case invalidAssociation(InvalidAssociation)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssociationsOnceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAssociationsOnceOutputResponse()"}
}

extension StartAssociationsOnceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartAssociationsOnceOutputResponse: Equatable {

    public init() {}
}

struct StartAssociationsOnceOutputResponseBody: Equatable {
}

extension StartAssociationsOnceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartAutomationExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAutomationExecutionOutputError>
}

extension StartAutomationExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAutomationExecutionInput(clientToken: \(String(describing: clientToken)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), mode: \(String(describing: mode)), parameters: \(String(describing: parameters)), tags: \(String(describing: tags)), targetLocations: \(String(describing: targetLocations)), targetMaps: \(String(describing: targetMaps)), targetParameterName: \(String(describing: targetParameterName)), targets: \(String(describing: targets)))"}
}

extension StartAutomationExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targetMaps = targetMaps {
            var targetMapsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetMaps)
            for targetmaps0 in targetMaps {
                var targetmaps0Container = targetMapsContainer.nestedContainer(keyedBy: Key.self)
                for (dictKey1, targetmap1) in targetmaps0 {
                    var targetmap1Container = targetmaps0Container.nestedContainer(keyedBy: Key.self)
                    for (dictKey2, targetmapvaluelist2) in targetmap1 {
                        try targetmap1Container.encode(targetmapvaluelist2, forKey: Key(stringValue: dictKey2))
                    }
                }
            }
        }
        if let targetParameterName = targetParameterName {
            try encodeContainer.encode(targetParameterName, forKey: .targetParameterName)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct StartAutomationExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StartAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAutomationExecutionOutputError>
}

public struct StartAutomationExecutionInput: Equatable {
    /// <p>User-provided idempotency token. The token must be unique, is case insensitive, enforces the
    ///    UUID format, and can't be reused.</p>
    public let clientToken: String?
    /// <p>The name of the Systems Manager document to run. This can be a public document or a custom document.
    ///    To run a shared document belonging to another account, specify the document ARN. For more
    ///    information about how to use shared documents, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html">Using shared SSM documents</a>
    ///    in the <i>AWS Systems Manager User Guide</i>.</p>
    public let documentName: String?
    /// <p>The version of the Automation document to use for this execution.</p>
    public let documentVersion: String?
    /// <p>The maximum number of targets allowed to run this task in parallel. You can specify a
    ///    number, such as 10, or a percentage, such as 10%. The default value is 10.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops running the automation on
    ///    additional targets. You can specify either an absolute number of errors, for example 10, or a
    ///    percentage of the target set, for example 10%. If you specify 3, for example, the system stops
    ///    running the automation when the fourth error is received. If you specify 0, then the system stops
    ///    running the automation on additional targets after the first error result is returned. If you run
    ///    an automation on 50 resources and set max-errors to 10%, then the system stops running the
    ///    automation on additional targets when the sixth error is received.</p>
    ///          <p>Executions that are already running an automation when max-errors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The execution mode of the automation. Valid modes include the following: Auto and
    ///    Interactive. The default mode is Auto.</p>
    public let mode: ExecutionMode?
    /// <p>A key-value map of execution parameters, which match the declared parameters in the
    ///    Automation document.</p>
    public let parameters: [String:[String]]?
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    ///    an automation. Tags enable you to categorize a resource in different ways, such as by purpose,
    ///    owner, or environment. For example, you might want to tag an automation to identify an
    ///    environment or operating system. In this case, you could specify the following key name/value
    ///    pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=environment,Value=test</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=OS,Value=Windows</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>To add tags to an existing patch baseline, use the <a>AddTagsToResource</a>
    ///     action.</p>
    ///          </note>
    public let tags: [Tag]?
    /// <p>A location is a combination of AWS Regions and/or AWS accounts where you want to run the
    ///    Automation. Use this action to start an Automation in multiple Regions and multiple accounts. For
    ///    more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html">Running Automation workflows in multiple AWS Regions and accounts</a> in the
    ///     <i>AWS Systems Manager User Guide</i>. </p>
    public let targetLocations: [TargetLocation]?
    /// <p>A key-value mapping of document parameters to target resources. Both Targets and TargetMaps
    ///    cannot be specified together.</p>
    public let targetMaps: [[String:[String]]]?
    /// <p>The name of the parameter used as the target resource for the rate-controlled execution.
    ///    Required if you specify targets.</p>
    public let targetParameterName: String?
    /// <p>A key-value mapping to target resources. Required if you specify TargetParameterName.</p>
    public let targets: [Target]?

    public init (
        clientToken: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        mode: ExecutionMode? = nil,
        parameters: [String:[String]]? = nil,
        tags: [Tag]? = nil,
        targetLocations: [TargetLocation]? = nil,
        targetMaps: [[String:[String]]]? = nil,
        targetParameterName: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.parameters = parameters
        self.tags = tags
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

struct StartAutomationExecutionInputBody: Equatable {
    public let documentName: String?
    public let documentVersion: String?
    public let parameters: [String:[String]]?
    public let clientToken: String?
    public let mode: ExecutionMode?
    public let targetParameterName: String?
    public let targets: [Target]?
    public let targetMaps: [[String:[String]]]?
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let targetLocations: [TargetLocation]?
    public let tags: [Tag]?
}

extension StartAutomationExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case mode = "Mode"
        case parameters = "Parameters"
        case tags = "Tags"
        case targetLocations = "TargetLocations"
        case targetMaps = "TargetMaps"
        case targetParameterName = "TargetParameterName"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ExecutionMode.self, forKey: .mode)
        mode = modeDecoded
        let targetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetParameterName)
        targetParameterName = targetParameterNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetMapsContainer = try containerValues.decodeIfPresent([[String: [String?]?]?].self, forKey: .targetMaps)
        var targetMapsDecoded0:[[String:[String]]]? = nil
        if let targetMapsContainer = targetMapsContainer {
            targetMapsDecoded0 = [[String:[String]]]()
            for map0 in targetMapsContainer {
                var targetMapsContainerDecoded0: [String: [String]]? = nil
                if let map0 = map0 {
                    targetMapsContainerDecoded0 = [String: [String]]()
                    for (key1, targetmapvaluelist1) in map0 {
                        var targetmapvaluelist1Decoded1: [String]? = nil
                        if let targetmapvaluelist1 = targetmapvaluelist1 {
                            targetmapvaluelist1Decoded1 = [String]()
                            for string2 in targetmapvaluelist1 {
                                if let string2 = string2 {
                                    targetmapvaluelist1Decoded1?.append(string2)
                                }
                            }
                        }
                        targetMapsContainerDecoded0?[key1] = targetmapvaluelist1Decoded1
                    }
                }
                if let targetMapsContainerDecoded0 = targetMapsContainerDecoded0 {
                    targetMapsDecoded0?.append(targetMapsContainerDecoded0)
                }
            }
        }
        targetMaps = targetMapsDecoded0
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAutomationExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAutomationExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotFoundException" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFoundException" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceededException" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParametersException" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAutomationExecutionOutputError: Equatable {
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case invalidTarget(InvalidTarget)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAutomationExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAutomationExecutionOutputResponse(automationExecutionId: \(String(describing: automationExecutionId)))"}
}

extension StartAutomationExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartAutomationExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartAutomationExecutionOutputResponse: Equatable {
    /// <p>The unique ID of a newly scheduled automation execution.</p>
    public let automationExecutionId: String?

    public init (
        automationExecutionId: String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartAutomationExecutionOutputResponseBody: Equatable {
    public let automationExecutionId: String?
}

extension StartAutomationExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

public struct StartChangeRequestExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartChangeRequestExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeRequestExecutionOutputError>
}

extension StartChangeRequestExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChangeRequestExecutionInput(changeDetails: \(String(describing: changeDetails)), changeRequestName: \(String(describing: changeRequestName)), clientToken: \(String(describing: clientToken)), documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), parameters: \(String(describing: parameters)), runbooks: \(String(describing: runbooks)), scheduledEndTime: \(String(describing: scheduledEndTime)), scheduledTime: \(String(describing: scheduledTime)), tags: \(String(describing: tags)))"}
}

extension StartChangeRequestExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDetails = changeDetails {
            try encodeContainer.encode(changeDetails, forKey: .changeDetails)
        }
        if let changeRequestName = changeRequestName {
            try encodeContainer.encode(changeRequestName, forKey: .changeRequestName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, automationparametermap0) in parameters {
                try parametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let runbooks = runbooks {
            var runbooksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runbooks)
            for runbooks0 in runbooks {
                try runbooksContainer.encode(runbooks0)
            }
        }
        if let scheduledEndTime = scheduledEndTime {
            try encodeContainer.encode(scheduledEndTime.timeIntervalSince1970, forKey: .scheduledEndTime)
        }
        if let scheduledTime = scheduledTime {
            try encodeContainer.encode(scheduledTime.timeIntervalSince1970, forKey: .scheduledTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct StartChangeRequestExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartChangeRequestExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartChangeRequestExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartChangeRequestExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartChangeRequestExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartChangeRequestExecutionInput>
    public typealias MOutput = OperationOutput<StartChangeRequestExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartChangeRequestExecutionOutputError>
}

public struct StartChangeRequestExecutionInput: Equatable {
    /// <p>User-provided details about the change. If no details are provided, content specified in the
    ///     <b>Template information</b> section of the associated change template
    ///    is added.</p>
    public let changeDetails: String?
    /// <p>The name of the change request associated with the runbook workflow to be run.</p>
    public let changeRequestName: String?
    /// <p>The user-provided idempotency token. The token must be unique, is case insensitive, enforces
    ///    the UUID format, and can't be reused.</p>
    public let clientToken: String?
    /// <p>The name of the change template document to run during the runbook workflow.</p>
    public let documentName: String?
    /// <p>The version of the change template document to run during the runbook workflow.</p>
    public let documentVersion: String?
    /// <p>A key-value map of parameters that match the declared parameters in the change template
    ///    document.</p>
    public let parameters: [String:[String]]?
    /// <p>Information about the Automation runbooks (Automation documents) that are run during the
    ///    runbook workflow.</p>
    ///          <note>
    ///             <p>The Automation runbooks specified for the runbook workflow can't run until all required
    ///     approvals for the change request have been received.</p>
    ///          </note>
    public let runbooks: [Runbook]?
    /// <p>The time that the requester expects the runbook workflow related to the change request to
    ///    complete. The time is an estimate only that the requester provides for reviewers.</p>
    public let scheduledEndTime: Date?
    /// <p>The date and time specified in the change request to run the Automation runbooks.</p>
    ///          <note>
    ///             <p>The Automation runbooks specified for the runbook workflow can't run until all required
    ///     approvals for the change request have been received.</p>
    ///          </note>
    public let scheduledTime: Date?
    /// <p>Optional metadata that you assign to a resource. You can specify a maximum of five tags for
    ///    a change request. Tags enable you to categorize a resource in different ways, such as by
    ///    purpose, owner, or environment. For example, you might want to tag a change request to identify
    ///    an environment or target AWS Region. In this case, you could specify the following key-value
    ///    pairs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Environment,Value=Production</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key=Region,Value=us-east-2</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        changeDetails: String? = nil,
        changeRequestName: String? = nil,
        clientToken: String? = nil,
        documentName: String? = nil,
        documentVersion: String? = nil,
        parameters: [String:[String]]? = nil,
        runbooks: [Runbook]? = nil,
        scheduledEndTime: Date? = nil,
        scheduledTime: Date? = nil,
        tags: [Tag]? = nil
    )
    {
        self.changeDetails = changeDetails
        self.changeRequestName = changeRequestName
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.parameters = parameters
        self.runbooks = runbooks
        self.scheduledEndTime = scheduledEndTime
        self.scheduledTime = scheduledTime
        self.tags = tags
    }
}

struct StartChangeRequestExecutionInputBody: Equatable {
    public let scheduledTime: Date?
    public let documentName: String?
    public let documentVersion: String?
    public let parameters: [String:[String]]?
    public let changeRequestName: String?
    public let clientToken: String?
    public let runbooks: [Runbook]?
    public let tags: [Tag]?
    public let scheduledEndTime: Date?
    public let changeDetails: String?
}

extension StartChangeRequestExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeDetails = "ChangeDetails"
        case changeRequestName = "ChangeRequestName"
        case clientToken = "ClientToken"
        case documentName = "DocumentName"
        case documentVersion = "DocumentVersion"
        case parameters = "Parameters"
        case runbooks = "Runbooks"
        case scheduledEndTime = "ScheduledEndTime"
        case scheduledTime = "ScheduledTime"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledTime)
        scheduledTime = scheduledTimeDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in parametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let changeRequestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeRequestName)
        changeRequestName = changeRequestNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let runbooksContainer = try containerValues.decodeIfPresent([Runbook?].self, forKey: .runbooks)
        var runbooksDecoded0:[Runbook]? = nil
        if let runbooksContainer = runbooksContainer {
            runbooksDecoded0 = [Runbook]()
            for structure0 in runbooksContainer {
                if let structure0 = structure0 {
                    runbooksDecoded0?.append(structure0)
                }
            }
        }
        runbooks = runbooksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let scheduledEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledEndTime)
        scheduledEndTime = scheduledEndTimeDecoded
        let changeDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeDetails)
        changeDetails = changeDetailsDecoded
    }
}

extension StartChangeRequestExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChangeRequestExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationDefinitionNotApprovedException" : self = .automationDefinitionNotApprovedException(try AutomationDefinitionNotApprovedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionNotFoundException" : self = .automationDefinitionNotFoundException(try AutomationDefinitionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationDefinitionVersionNotFoundException" : self = .automationDefinitionVersionNotFoundException(try AutomationDefinitionVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionLimitExceededException" : self = .automationExecutionLimitExceededException(try AutomationExecutionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatch(try IdempotentParameterMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationExecutionParametersException" : self = .invalidAutomationExecutionParametersException(try InvalidAutomationExecutionParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartChangeRequestExecutionOutputError: Equatable {
    case automationDefinitionNotApprovedException(AutomationDefinitionNotApprovedException)
    case automationDefinitionNotFoundException(AutomationDefinitionNotFoundException)
    case automationDefinitionVersionNotFoundException(AutomationDefinitionVersionNotFoundException)
    case automationExecutionLimitExceededException(AutomationExecutionLimitExceededException)
    case idempotentParameterMismatch(IdempotentParameterMismatch)
    case internalServerError(InternalServerError)
    case invalidAutomationExecutionParametersException(InvalidAutomationExecutionParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChangeRequestExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartChangeRequestExecutionOutputResponse(automationExecutionId: \(String(describing: automationExecutionId)))"}
}

extension StartChangeRequestExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartChangeRequestExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.automationExecutionId = output.automationExecutionId
        } else {
            self.automationExecutionId = nil
        }
    }
}

public struct StartChangeRequestExecutionOutputResponse: Equatable {
    /// <p>The unique ID of a runbook workflow operation. (A runbook workflow is a type of Automation
    ///    operation.) </p>
    public let automationExecutionId: String?

    public init (
        automationExecutionId: String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

struct StartChangeRequestExecutionOutputResponseBody: Equatable {
    public let automationExecutionId: String?
}

extension StartChangeRequestExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
    }
}

public struct StartSessionInputBodyMiddleware: Middleware {
    public let id: String = "StartSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSessionInput>
    public typealias MOutput = OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSessionOutputError>
}

extension StartSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSessionInput(documentName: \(String(describing: documentName)), parameters: \(String(describing: parameters)), target: \(String(describing: target)))"}
}

extension StartSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, sessionmanagerparameters0) in parameters {
                try parametersContainer.encode(sessionmanagerparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

public struct StartSessionInputHeadersMiddleware: Middleware {
    public let id: String = "StartSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSessionInput>
    public typealias MOutput = OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSessionOutputError>
}

public struct StartSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSessionInput>
    public typealias MOutput = OperationOutput<StartSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSessionOutputError>
}

public struct StartSessionInput: Equatable {
    /// <p>The name of the SSM document to define the parameters and plugin settings for the session.
    ///    For example, <code>SSM-SessionManagerRunShell</code>. You can call the <a>GetDocument</a> API to verify the document exists before attempting to start a session.
    ///    If no document name is provided, a shell to the instance is launched by default.</p>
    public let documentName: String?
    /// <p>Reserved for future use.</p>
    public let parameters: [String:[String]]?
    /// <p>The instance to connect to for the session.</p>
    public let target: String?

    public init (
        documentName: String? = nil,
        parameters: [String:[String]]? = nil,
        target: String? = nil
    )
    {
        self.documentName = documentName
        self.parameters = parameters
        self.target = target
    }
}

struct StartSessionInputBody: Equatable {
    public let target: String?
    public let documentName: String?
    public let parameters: [String:[String]]?
}

extension StartSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentName = "DocumentName"
        case parameters = "Parameters"
        case target = "Target"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, sessionmanagerparametervaluelist0) in parametersContainer {
                var sessionmanagerparametervaluelist0Decoded0: [String]? = nil
                if let sessionmanagerparametervaluelist0 = sessionmanagerparametervaluelist0 {
                    sessionmanagerparametervaluelist0Decoded0 = [String]()
                    for string1 in sessionmanagerparametervaluelist0 {
                        if let string1 = string1 {
                            sessionmanagerparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = sessionmanagerparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension StartSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetNotConnected" : self = .targetNotConnected(try TargetNotConnected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSessionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case targetNotConnected(TargetNotConnected)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSessionOutputResponse(sessionId: \(String(describing: sessionId)), streamUrl: \(String(describing: streamUrl)), tokenValue: \(String(describing: tokenValue)))"}
}

extension StartSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sessionId = output.sessionId
            self.streamUrl = output.streamUrl
            self.tokenValue = output.tokenValue
        } else {
            self.sessionId = nil
            self.streamUrl = nil
            self.tokenValue = nil
        }
    }
}

public struct StartSessionOutputResponse: Equatable {
    /// <p>The ID of the session.</p>
    public let sessionId: String?
    /// <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and
    ///    receive output from the instance. Format: <code>wss://ssmmessages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code>
    ///          </p>
    ///          <p>
    ///             <b>region</b> represents the Region identifier for an
    /// 						AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region.
    /// 						For a list of supported <b>region</b> values, see the <b>Region</b> column in <a href="http://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region">Systems Manager service endpoints</a> in the
    ///         <i>AWS General Reference</i>.</p>
    ///          <p>
    ///             <b>session-id</b> represents the ID of a Session Manager session, such as
    ///     <code>1a2b3c4dEXAMPLE</code>.</p>
    public let streamUrl: String?
    /// <p>An encrypted token value containing session and caller information. Used to authenticate the
    ///    connection to the instance.</p>
    public let tokenValue: String?

    public init (
        sessionId: String? = nil,
        streamUrl: String? = nil,
        tokenValue: String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

struct StartSessionOutputResponseBody: Equatable {
    public let sessionId: String?
    public let tokenValue: String?
    public let streamUrl: String?
}

extension StartSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
        case streamUrl = "StreamUrl"
        case tokenValue = "TokenValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
        let streamUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
    }
}

extension StatusUnchanged: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusUnchanged()"}
}

extension StatusUnchanged: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The updated status is the same as the current status.</p>
public struct StatusUnchanged: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension StepExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureDetails = "FailureDetails"
        case failureMessage = "FailureMessage"
        case inputs = "Inputs"
        case isCritical = "IsCritical"
        case isEnd = "IsEnd"
        case maxAttempts = "MaxAttempts"
        case nextStep = "NextStep"
        case onFailure = "OnFailure"
        case outputs = "Outputs"
        case overriddenParameters = "OverriddenParameters"
        case response = "Response"
        case responseCode = "ResponseCode"
        case stepExecutionId = "StepExecutionId"
        case stepName = "StepName"
        case stepStatus = "StepStatus"
        case targetLocation = "TargetLocation"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
        case validNextSteps = "ValidNextSteps"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let executionEndTime = executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .inputs)
            for (dictKey0, normalstringmap0) in inputs {
                try inputsContainer.encode(normalstringmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if isCritical != false {
            try encodeContainer.encode(isCritical, forKey: .isCritical)
        }
        if isEnd != false {
            try encodeContainer.encode(isEnd, forKey: .isEnd)
        }
        if maxAttempts != 0 {
            try encodeContainer.encode(maxAttempts, forKey: .maxAttempts)
        }
        if let nextStep = nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let overriddenParameters = overriddenParameters {
            var overriddenParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .overriddenParameters)
            for (dictKey0, automationparametermap0) in overriddenParameters {
                try overriddenParametersContainer.encode(automationparametermap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let response = response {
            try encodeContainer.encode(response, forKey: .response)
        }
        if let responseCode = responseCode {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let stepExecutionId = stepExecutionId {
            try encodeContainer.encode(stepExecutionId, forKey: .stepExecutionId)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let stepStatus = stepStatus {
            try encodeContainer.encode(stepStatus.rawValue, forKey: .stepStatus)
        }
        if let targetLocation = targetLocation {
            try encodeContainer.encode(targetLocation, forKey: .targetLocation)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
        if let validNextSteps = validNextSteps {
            var validNextStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validNextSteps)
            for validnextsteplist0 in validNextSteps {
                try validNextStepsContainer.encode(validnextsteplist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let timeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onFailure)
        onFailure = onFailureDecoded
        let maxAttemptsDecoded = try containerValues.decode(Int.self, forKey: .maxAttempts)
        maxAttempts = maxAttemptsDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let stepStatusDecoded = try containerValues.decodeIfPresent(AutomationExecutionStatus.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let inputsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .inputs)
        var inputsDecoded0: [String:String]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [String:String]()
            for (key0, string0) in inputsContainer {
                if let string0 = string0 {
                    inputsDecoded0?[key0] = string0
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .outputs)
        var outputsDecoded0: [String:[String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let responseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .response)
        response = responseDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let overriddenParametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .overriddenParameters)
        var overriddenParametersDecoded0: [String:[String]]? = nil
        if let overriddenParametersContainer = overriddenParametersContainer {
            overriddenParametersDecoded0 = [String:[String]]()
            for (key0, automationparametervaluelist0) in overriddenParametersContainer {
                var automationparametervaluelist0Decoded0: [String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                overriddenParametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        overriddenParameters = overriddenParametersDecoded0
        let isEndDecoded = try containerValues.decode(Bool.self, forKey: .isEnd)
        isEnd = isEndDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let isCriticalDecoded = try containerValues.decode(Bool.self, forKey: .isCritical)
        isCritical = isCriticalDecoded
        let validNextStepsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validNextSteps)
        var validNextStepsDecoded0:[String]? = nil
        if let validNextStepsContainer = validNextStepsContainer {
            validNextStepsDecoded0 = [String]()
            for string0 in validNextStepsContainer {
                if let string0 = string0 {
                    validNextStepsDecoded0?.append(string0)
                }
            }
        }
        validNextSteps = validNextStepsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetLocationDecoded = try containerValues.decodeIfPresent(TargetLocation.self, forKey: .targetLocation)
        targetLocation = targetLocationDecoded
    }
}

extension StepExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StepExecution(action: \(String(describing: action)), executionEndTime: \(String(describing: executionEndTime)), executionStartTime: \(String(describing: executionStartTime)), failureDetails: \(String(describing: failureDetails)), failureMessage: \(String(describing: failureMessage)), inputs: \(String(describing: inputs)), isCritical: \(String(describing: isCritical)), isEnd: \(String(describing: isEnd)), maxAttempts: \(String(describing: maxAttempts)), nextStep: \(String(describing: nextStep)), onFailure: \(String(describing: onFailure)), outputs: \(String(describing: outputs)), overriddenParameters: \(String(describing: overriddenParameters)), response: \(String(describing: response)), responseCode: \(String(describing: responseCode)), stepExecutionId: \(String(describing: stepExecutionId)), stepName: \(String(describing: stepName)), stepStatus: \(String(describing: stepStatus)), targetLocation: \(String(describing: targetLocation)), targets: \(String(describing: targets)), timeoutSeconds: \(String(describing: timeoutSeconds)), validNextSteps: \(String(describing: validNextSteps)))"}
}

/// <p>Detailed information about an the execution state of an Automation step.</p>
public struct StepExecution: Equatable {
    /// <p>The action this step performs. The action determines the behavior of the step.</p>
    public let action: String?
    /// <p>If a step has finished execution, this contains the time the execution ended. If the step
    ///    has not yet concluded, this field is not populated.</p>
    public let executionEndTime: Date?
    /// <p>If a step has begun execution, this contains the time the step started. If the step is in
    ///    Pending status, this field is not populated.</p>
    public let executionStartTime: Date?
    /// <p>Information about the Automation failure.</p>
    public let failureDetails: FailureDetails?
    /// <p>If a step failed, this message explains why the execution failed.</p>
    public let failureMessage: String?
    /// <p>Fully-resolved values passed into the step before execution.</p>
    public let inputs: [String:String]?
    /// <p>The flag which can be used to help decide whether the failure of current step leads to the
    ///    Automation failure.</p>
    public let isCritical: Bool
    /// <p>The flag which can be used to end automation no matter whether the step succeeds or
    ///    fails.</p>
    public let isEnd: Bool
    /// <p>The maximum number of tries to run the action of the step. The default value is 1.</p>
    public let maxAttempts: Int
    /// <p>The next step after the step succeeds.</p>
    public let nextStep: String?
    /// <p>The action to take if the step fails. The default value is Abort.</p>
    public let onFailure: String?
    /// <p>Returned values from the execution of the step.</p>
    public let outputs: [String:[String]]?
    /// <p>A user-specified list of parameters to override when running a step.</p>
    public let overriddenParameters: [String:[String]]?
    /// <p>A message associated with the response code for an execution.</p>
    public let response: String?
    /// <p>The response code returned by the execution of the step.</p>
    public let responseCode: String?
    /// <p>The unique ID of a step execution.</p>
    public let stepExecutionId: String?
    /// <p>The name of this execution step.</p>
    public let stepName: String?
    /// <p>The execution status for this step.</p>
    public let stepStatus: AutomationExecutionStatus?
    /// <p>The combination of AWS Regions and accounts targeted by the current Automation
    ///    execution.</p>
    public let targetLocation: TargetLocation?
    /// <p>The targets for the step execution.</p>
    public let targets: [Target]?
    /// <p>The timeout seconds of the step.</p>
    public let timeoutSeconds: Int
    /// <p>Strategies used when step fails, we support Continue and Abort. Abort will fail the
    ///    automation when the step fails. Continue will ignore the failure of current step and allow
    ///    automation to run the next step. With conditional branching, we add step:stepName to support the
    ///    automation to go to another specific step.</p>
    public let validNextSteps: [String]?

    public init (
        action: String? = nil,
        executionEndTime: Date? = nil,
        executionStartTime: Date? = nil,
        failureDetails: FailureDetails? = nil,
        failureMessage: String? = nil,
        inputs: [String:String]? = nil,
        isCritical: Bool = false,
        isEnd: Bool = false,
        maxAttempts: Int = 0,
        nextStep: String? = nil,
        onFailure: String? = nil,
        outputs: [String:[String]]? = nil,
        overriddenParameters: [String:[String]]? = nil,
        response: String? = nil,
        responseCode: String? = nil,
        stepExecutionId: String? = nil,
        stepName: String? = nil,
        stepStatus: AutomationExecutionStatus? = nil,
        targetLocation: TargetLocation? = nil,
        targets: [Target]? = nil,
        timeoutSeconds: Int = 0,
        validNextSteps: [String]? = nil
    )
    {
        self.action = action
        self.executionEndTime = executionEndTime
        self.executionStartTime = executionStartTime
        self.failureDetails = failureDetails
        self.failureMessage = failureMessage
        self.inputs = inputs
        self.isCritical = isCritical
        self.isEnd = isEnd
        self.maxAttempts = maxAttempts
        self.nextStep = nextStep
        self.onFailure = onFailure
        self.outputs = outputs
        self.overriddenParameters = overriddenParameters
        self.response = response
        self.responseCode = responseCode
        self.stepExecutionId = stepExecutionId
        self.stepName = stepName
        self.stepStatus = stepStatus
        self.targetLocation = targetLocation
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
        self.validNextSteps = validNextSteps
    }
}

extension StepExecutionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for stepexecutionfiltervaluelist0 in values {
                try valuesContainer.encode(stepexecutionfiltervaluelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(StepExecutionFilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension StepExecutionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StepExecutionFilter(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>A filter to limit the amount of step execution information returned by the call.</p>
public struct StepExecutionFilter: Equatable {
    /// <p>One or more keys to limit the results. Valid filter keys include the following: StepName,
    ///    Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.</p>
    public let key: StepExecutionFilterKey?
    /// <p>The values of the filter key.</p>
    public let values: [String]?

    public init (
        key: StepExecutionFilterKey? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

public enum StepExecutionFilterKey {
    case action
    case startTimeAfter
    case startTimeBefore
    case stepExecutionId
    case stepExecutionStatus
    case stepName
    case sdkUnknown(String)
}

extension StepExecutionFilterKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StepExecutionFilterKey] {
        return [
            .action,
            .startTimeAfter,
            .startTimeBefore,
            .stepExecutionId,
            .stepExecutionStatus,
            .stepName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .action: return "Action"
        case .startTimeAfter: return "StartTimeAfter"
        case .startTimeBefore: return "StartTimeBefore"
        case .stepExecutionId: return "StepExecutionId"
        case .stepExecutionStatus: return "StepExecutionStatus"
        case .stepName: return "StepName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StepExecutionFilterKey(rawValue: rawValue) ?? StepExecutionFilterKey.sdkUnknown(rawValue)
    }
}

public struct StopAutomationExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StopAutomationExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAutomationExecutionOutputError>
}

extension StopAutomationExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAutomationExecutionInput(automationExecutionId: \(String(describing: automationExecutionId)), type: \(String(describing: type)))"}
}

extension StopAutomationExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automationExecutionId = automationExecutionId {
            try encodeContainer.encode(automationExecutionId, forKey: .automationExecutionId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct StopAutomationExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StopAutomationExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopAutomationExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAutomationExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAutomationExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAutomationExecutionInput>
    public typealias MOutput = OperationOutput<StopAutomationExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAutomationExecutionOutputError>
}

public struct StopAutomationExecutionInput: Equatable {
    /// <p>The execution ID of the Automation to stop.</p>
    public let automationExecutionId: String?
    /// <p>The stop request type. Valid types include the following: Cancel and Complete. The default
    ///    type is Cancel.</p>
    public let type: StopType?

    public init (
        automationExecutionId: String? = nil,
        type: StopType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.type = type
    }
}

struct StopAutomationExecutionInputBody: Equatable {
    public let automationExecutionId: String?
    public let type: StopType?
}

extension StopAutomationExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case automationExecutionId = "AutomationExecutionId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automationExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationExecutionId)
        automationExecutionId = automationExecutionIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(StopType.self, forKey: .type)
        type = typeDecoded
    }
}

extension StopAutomationExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAutomationExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AutomationExecutionNotFoundException" : self = .automationExecutionNotFoundException(try AutomationExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAutomationStatusUpdateException" : self = .invalidAutomationStatusUpdateException(try InvalidAutomationStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAutomationExecutionOutputError: Equatable {
    case automationExecutionNotFoundException(AutomationExecutionNotFoundException)
    case internalServerError(InternalServerError)
    case invalidAutomationStatusUpdateException(InvalidAutomationStatusUpdateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAutomationExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAutomationExecutionOutputResponse()"}
}

extension StopAutomationExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopAutomationExecutionOutputResponse: Equatable {

    public init() {}
}

struct StopAutomationExecutionOutputResponseBody: Equatable {
}

extension StopAutomationExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum StopType {
    case cancel
    case complete
    case sdkUnknown(String)
}

extension StopType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StopType] {
        return [
            .cancel,
            .complete,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancel: return "Cancel"
        case .complete: return "Complete"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StopType(rawValue: rawValue) ?? StopType.sdkUnknown(rawValue)
    }
}

extension SubTypeCountLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubTypeCountLimitExceededException(message: \(String(describing: message)))"}
}

extension SubTypeCountLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubTypeCountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The sub-type count exceeded the limit for the inventory type.</p>
public struct SubTypeCountLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubTypeCountLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension SubTypeCountLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Metadata that you assign to your AWS resources. Tags enable you to categorize your resources
///    in different ways, for example, by purpose, owner, or environment. In Systems Manager, you can apply tags
///    to documents, managed instances, maintenance windows, Parameter Store parameters, and patch
///    baselines.</p>
public struct Tag: Equatable {
    /// <p>The name of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for targetvalues0 in values {
                try valuesContainer.encode(targetvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>An array of search criteria that targets instances using a Key,Value combination that you
///    specify.</p>
///          <note>
///             <p> One or more targets must be specified for maintenance window Run Command-type tasks.
///     Depending on the task, targets are optional for other maintenance window task types (Automation,
///     AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
///     specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
///      maintenance window tasks without targets</a> in the
///     <i>AWS Systems Manager User Guide</i>.</p>
///          </note>
///          <p>Supported formats include the following.</p>
///          <ul>
///             <li>
///                <p>
///                   <code>Key=InstanceIds,Values=<i>instance-id-1</i>,<i>instance-id-2</i>,<i>instance-id-3</i>
///                   </code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>Key=tag:<i>my-tag-key</i>,Values=<i>my-tag-value-1</i>,<i>my-tag-value-2</i>
///                   </code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>Key=tag-key,Values=<i>my-tag-key-1</i>,<i>my-tag-key-2</i>
///                   </code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <b>Run Command and Maintenance window targets only</b>:
///        <code>Key=resource-groups:Name,Values=<i>resource-group-name</i>
///                   </code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <b>Maintenance window targets only</b>:
///        <code>Key=resource-groups:ResourceTypeFilters,Values=<i>resource-type-1</i>,<i>resource-type-2</i>
///                   </code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <b>Automation targets only</b>:
///        <code>Key=ResourceGroup;Values=<i>resource-group-name</i>
///                   </code>
///                </p>
///             </li>
///          </ul>
///          <p>For example:</p>
///          <ul>
///             <li>
///                <p>
///                   <code>Key=InstanceIds,Values=i-02573cafcfEXAMPLE,i-0471e04240EXAMPLE,i-07782c72faEXAMPLE</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>Key=tag:CostCenter,Values=CostCenter1,CostCenter2,CostCenter3</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>Key=tag-key,Values=Name,Instance-Type,CostCenter</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <b>Run Command and Maintenance window targets only</b>:
///       <code>Key=resource-groups:Name,Values=ProductionResourceGroup</code>
///                </p>
///                <p>This example demonstrates how to target all resources in the resource group <b>ProductionResourceGroup</b> in your maintenance window.</p>
///             </li>
///             <li>
///                <p>
///                   <b>Maintenance window targets only</b>:
///        <code>Key=resource-groups:ResourceTypeFilters,Values=<i>AWS::EC2::INSTANCE</i>,<i>AWS::EC2::VPC</i>
///                   </code>
///                </p>
///                <p>This example demonstrates how to target only EC2 instances and VPCs in your maintenance
///      window.</p>
///             </li>
///             <li>
///                <p>
///                   <b>Automation targets only</b>:
///       <code>Key=ResourceGroup,Values=MyResourceGroup</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <b>State Manager association targets only</b>:
///        <code>Key=InstanceIds,Values=<i>*</i>
///                   </code>
///                </p>
///                <p>This example demonstrates how to target all managed instances in the AWS Region where the
///      association was created.</p>
///             </li>
///          </ul>
///          <p>For more information about how to send commands that target instances using
///     <code>Key,Value</code> parameters, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting">Targeting multiple instances</a> in the <i>AWS Systems Manager User Guide</i>.</p>
public struct Target: Equatable {
    /// <p>User-defined criteria for sending commands that target instances that meet the
    ///    criteria.</p>
    public let key: String?
    /// <p>User-defined criteria that maps to <code>Key</code>. For example, if you specified
    ///     <code>tag:ServerRole</code>, you could specify <code>value:WebServer</code> to run a command on
    ///    instances that include EC2 tags of <code>ServerRole,WebServer</code>. </p>
    ///          <p>Depending on the type of <code>Target</code>, the maximum number of values for a
    ///     <code>Key</code> might be lower than the global maximum of 50.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension TargetInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetInUseException(message: \(String(describing: message)))"}
}

extension TargetInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TargetInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You specified the <code>Safe</code> option for the DeregisterTargetFromMaintenanceWindow
///    operation, but the target is still referenced in a task.</p>
public struct TargetInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetInUseExceptionBody: Equatable {
    public let message: String?
}

extension TargetInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accounts = "Accounts"
        case executionRoleName = "ExecutionRoleName"
        case regions = "Regions"
        case targetLocationMaxConcurrency = "TargetLocationMaxConcurrency"
        case targetLocationMaxErrors = "TargetLocationMaxErrors"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accounts0 in accounts {
                try accountsContainer.encode(accounts0)
            }
        }
        if let executionRoleName = executionRoleName {
            try encodeContainer.encode(executionRoleName, forKey: .executionRoleName)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regions0 in regions {
                try regionsContainer.encode(regions0)
            }
        }
        if let targetLocationMaxConcurrency = targetLocationMaxConcurrency {
            try encodeContainer.encode(targetLocationMaxConcurrency, forKey: .targetLocationMaxConcurrency)
        }
        if let targetLocationMaxErrors = targetLocationMaxErrors {
            try encodeContainer.encode(targetLocationMaxErrors, forKey: .targetLocationMaxErrors)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accounts)
        var accountsDecoded0:[String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let targetLocationMaxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetLocationMaxConcurrency)
        targetLocationMaxConcurrency = targetLocationMaxConcurrencyDecoded
        let targetLocationMaxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetLocationMaxErrors)
        targetLocationMaxErrors = targetLocationMaxErrorsDecoded
        let executionRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleName)
        executionRoleName = executionRoleNameDecoded
    }
}

extension TargetLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetLocation(accounts: \(String(describing: accounts)), executionRoleName: \(String(describing: executionRoleName)), regions: \(String(describing: regions)), targetLocationMaxConcurrency: \(String(describing: targetLocationMaxConcurrency)), targetLocationMaxErrors: \(String(describing: targetLocationMaxErrors)))"}
}

/// <p>The combination of AWS Regions and accounts targeted by the current Automation
///    execution.</p>
public struct TargetLocation: Equatable {
    /// <p>The AWS accounts targeted by the current Automation execution.</p>
    public let accounts: [String]?
    /// <p>The Automation execution role used by the currently running Automation. If not specified,
    ///    the default value is <code>AWS-SystemsManager-AutomationExecutionRole</code>.</p>
    public let executionRoleName: String?
    /// <p>The AWS Regions targeted by the current Automation execution.</p>
    public let regions: [String]?
    /// <p>The maximum number of AWS accounts and AWS regions allowed to run the Automation
    ///    concurrently.</p>
    public let targetLocationMaxConcurrency: String?
    /// <p>The maximum number of errors allowed before the system stops queueing additional Automation
    ///    executions for the currently running Automation.</p>
    public let targetLocationMaxErrors: String?

    public init (
        accounts: [String]? = nil,
        executionRoleName: String? = nil,
        regions: [String]? = nil,
        targetLocationMaxConcurrency: String? = nil,
        targetLocationMaxErrors: String? = nil
    )
    {
        self.accounts = accounts
        self.executionRoleName = executionRoleName
        self.regions = regions
        self.targetLocationMaxConcurrency = targetLocationMaxConcurrency
        self.targetLocationMaxErrors = targetLocationMaxErrors
    }
}

extension TargetNotConnected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetNotConnected(message: \(String(describing: message)))"}
}

extension TargetNotConnected: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TargetNotConnectedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target instance for the session is not fully configured for use with Session Manager.
///    For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-getting-started.html">Getting started with
///     Session Manager</a> in the <i>AWS Systems Manager User Guide</i>. This error is also returned if you
///    attempt to start a session on an instance that is located in a different account or Region</p>
public struct TargetNotConnected: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetNotConnectedBody: Equatable {
    public let message: String?
}

extension TargetNotConnectedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TerminateSessionInputBodyMiddleware: Middleware {
    public let id: String = "TerminateSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateSessionOutputError>
}

extension TerminateSessionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateSessionInput(sessionId: \(String(describing: sessionId)))"}
}

extension TerminateSessionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

public struct TerminateSessionInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateSessionInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateSessionInput>
    public typealias MOutput = OperationOutput<TerminateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateSessionOutputError>
}

public struct TerminateSessionInput: Equatable {
    /// <p>The ID of the session to terminate.</p>
    public let sessionId: String?

    public init (
        sessionId: String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionInputBody: Equatable {
    public let sessionId: String?
}

extension TerminateSessionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TerminateSessionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateSessionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateSessionOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateSessionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateSessionOutputResponse(sessionId: \(String(describing: sessionId)))"}
}

extension TerminateSessionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TerminateSessionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sessionId = output.sessionId
        } else {
            self.sessionId = nil
        }
    }
}

public struct TerminateSessionOutputResponse: Equatable {
    /// <p>The ID of the session that has been terminated.</p>
    public let sessionId: String?

    public init (
        sessionId: String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionOutputResponseBody: Equatable {
    public let sessionId: String?
}

extension TerminateSessionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TooManyTagsError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsError()"}
}

extension TooManyTagsError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>Targets</code> parameter includes too many tags. Remove one or more tags and try
///    the command again.</p>
public struct TooManyTagsError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension TooManyUpdates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyUpdates(message: \(String(describing: message)))"}
}

extension TooManyUpdates: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyUpdatesBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are concurrent updates for a resource that supports one update at a time.</p>
public struct TooManyUpdates: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyUpdatesBody: Equatable {
    public let message: String?
}

extension TooManyUpdatesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TotalSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TotalSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension TotalSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TotalSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The size of inventory data has exceeded the total size limit for the resource.</p>
public struct TotalSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TotalSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TotalSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnlabelParameterVersionInputBodyMiddleware: Middleware {
    public let id: String = "UnlabelParameterVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlabelParameterVersionOutputError>
}

extension UnlabelParameterVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlabelParameterVersionInput(labels: \(String(describing: labels)), name: \(String(describing: name)), parameterVersion: \(String(describing: parameterVersion)))"}
}

extension UnlabelParameterVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for parameterlabellist0 in labels {
                try labelsContainer.encode(parameterlabellist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parameterVersion != 0 {
            try encodeContainer.encode(parameterVersion, forKey: .parameterVersion)
        }
    }
}

public struct UnlabelParameterVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UnlabelParameterVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UnlabelParameterVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlabelParameterVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlabelParameterVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlabelParameterVersionInput>
    public typealias MOutput = OperationOutput<UnlabelParameterVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlabelParameterVersionOutputError>
}

public struct UnlabelParameterVersionInput: Equatable {
    /// <p>One or more labels to delete from the specified parameter version.</p>
    public let labels: [String]?
    /// <p>The parameter name of which you want to delete one or more labels.</p>
    public let name: String?
    /// <p>The specific version of the parameter which you want to delete one or more labels from. If
    ///    it is not present, the call will fail.</p>
    public let parameterVersion: Int

    public init (
        labels: [String]? = nil,
        name: String? = nil,
        parameterVersion: Int = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

struct UnlabelParameterVersionInputBody: Equatable {
    public let name: String?
    public let parameterVersion: Int
    public let labels: [String]?
}

extension UnlabelParameterVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case labels = "Labels"
        case name = "Name"
        case parameterVersion = "ParameterVersion"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let parameterVersionDecoded = try containerValues.decode(Int.self, forKey: .parameterVersion)
        parameterVersion = parameterVersionDecoded
        let labelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .labels)
        var labelsDecoded0:[String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension UnlabelParameterVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlabelParameterVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterNotFound" : self = .parameterNotFound(try ParameterNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterVersionNotFound" : self = .parameterVersionNotFound(try ParameterVersionNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlabelParameterVersionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case parameterNotFound(ParameterNotFound)
    case parameterVersionNotFound(ParameterVersionNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlabelParameterVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlabelParameterVersionOutputResponse(invalidLabels: \(String(describing: invalidLabels)), removedLabels: \(String(describing: removedLabels)))"}
}

extension UnlabelParameterVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnlabelParameterVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.invalidLabels = output.invalidLabels
            self.removedLabels = output.removedLabels
        } else {
            self.invalidLabels = nil
            self.removedLabels = nil
        }
    }
}

public struct UnlabelParameterVersionOutputResponse: Equatable {
    /// <p>The labels that are not attached to the given parameter version.</p>
    public let invalidLabels: [String]?
    /// <p>A list of all labels deleted from the parameter.</p>
    public let removedLabels: [String]?

    public init (
        invalidLabels: [String]? = nil,
        removedLabels: [String]? = nil
    )
    {
        self.invalidLabels = invalidLabels
        self.removedLabels = removedLabels
    }
}

struct UnlabelParameterVersionOutputResponseBody: Equatable {
    public let removedLabels: [String]?
    public let invalidLabels: [String]?
}

extension UnlabelParameterVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidLabels = "InvalidLabels"
        case removedLabels = "RemovedLabels"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let removedLabelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .removedLabels)
        var removedLabelsDecoded0:[String]? = nil
        if let removedLabelsContainer = removedLabelsContainer {
            removedLabelsDecoded0 = [String]()
            for string0 in removedLabelsContainer {
                if let string0 = string0 {
                    removedLabelsDecoded0?.append(string0)
                }
            }
        }
        removedLabels = removedLabelsDecoded0
        let invalidLabelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .invalidLabels)
        var invalidLabelsDecoded0:[String]? = nil
        if let invalidLabelsContainer = invalidLabelsContainer {
            invalidLabelsDecoded0 = [String]()
            for string0 in invalidLabelsContainer {
                if let string0 = string0 {
                    invalidLabelsDecoded0?.append(string0)
                }
            }
        }
        invalidLabels = invalidLabelsDecoded0
    }
}

extension UnsupportedCalendarException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedCalendarException(message: \(String(describing: message)))"}
}

extension UnsupportedCalendarException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedCalendarExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The calendar entry contained in the specified Systems Manager document is not supported.</p>
public struct UnsupportedCalendarException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCalendarExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedCalendarExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedFeatureRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedFeatureRequiredException(message: \(String(describing: message)))"}
}

extension UnsupportedFeatureRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedFeatureRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Microsoft application patching is only available on EC2 instances and advanced instances. To
///    patch Microsoft applications on on-premises servers and VMs, you must enable advanced instances.
///    For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances-advanced.html">Using the
///     advanced-instances tier</a> in the <i>AWS Systems Manager User Guide</i>.</p>
public struct UnsupportedFeatureRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedFeatureRequiredExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedFeatureRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventoryItemContextException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedInventoryItemContextException(message: \(String(describing: message)), typeName: \(String(describing: typeName)))"}
}

extension UnsupportedInventoryItemContextException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedInventoryItemContextExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.typeName = output.typeName
        } else {
            self.message = nil
            self.typeName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>Context</code> attribute that you specified for the <code>InventoryItem</code> is
///    not allowed for this inventory type. You can only use the <code>Context</code> attribute with
///    inventory types like <code>AWS:ComplianceItem</code>.</p>
public struct UnsupportedInventoryItemContextException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var typeName: String?

    public init (
        message: String? = nil,
        typeName: String? = nil
    )
    {
        self.message = message
        self.typeName = typeName
    }
}

struct UnsupportedInventoryItemContextExceptionBody: Equatable {
    public let typeName: String?
    public let message: String?
}

extension UnsupportedInventoryItemContextExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case typeName = "TypeName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedInventorySchemaVersionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedInventorySchemaVersionException(message: \(String(describing: message)))"}
}

extension UnsupportedInventorySchemaVersionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedInventorySchemaVersionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Inventory item type schema version has to match supported versions in the service. Check
///    output of GetInventorySchema to see the available schema version for each type.</p>
public struct UnsupportedInventorySchemaVersionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedInventorySchemaVersionExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedInventorySchemaVersionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperatingSystem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperatingSystem(message: \(String(describing: message)))"}
}

extension UnsupportedOperatingSystem: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperatingSystemBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operating systems you specified is not supported, or the operation is not supported for
///    the operating system.</p>
public struct UnsupportedOperatingSystem: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperatingSystemBody: Equatable {
    public let message: String?
}

extension UnsupportedOperatingSystemBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedParameterType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedParameterType(message: \(String(describing: message)))"}
}

extension UnsupportedParameterType: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedParameterTypeBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter type is not supported.</p>
public struct UnsupportedParameterType: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedParameterTypeBody: Equatable {
    public let message: String?
}

extension UnsupportedParameterTypeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedPlatformType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedPlatformType(message: \(String(describing: message)))"}
}

extension UnsupportedPlatformType: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedPlatformTypeBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The document does not support the platform type of the given instance ID(s). For example,
///    you sent an document for a Windows instance to a Linux instance.</p>
public struct UnsupportedPlatformType: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedPlatformTypeBody: Equatable {
    public let message: String?
}

extension UnsupportedPlatformTypeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateAssociationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationOutputError>
}

extension UpdateAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssociationInput(applyOnlyAtCronInterval: \(String(describing: applyOnlyAtCronInterval)), associationId: \(String(describing: associationId)), associationName: \(String(describing: associationName)), associationVersion: \(String(describing: associationVersion)), automationTargetParameterName: \(String(describing: automationTargetParameterName)), calendarNames: \(String(describing: calendarNames)), complianceSeverity: \(String(describing: complianceSeverity)), documentVersion: \(String(describing: documentVersion)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), outputLocation: \(String(describing: outputLocation)), parameters: \(String(describing: parameters)), scheduleExpression: \(String(describing: scheduleExpression)), syncCompliance: \(String(describing: syncCompliance)), targetLocations: \(String(describing: targetLocations)), targets: \(String(describing: targets)))"}
}

extension UpdateAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applyOnlyAtCronInterval != false {
            try encodeContainer.encode(applyOnlyAtCronInterval, forKey: .applyOnlyAtCronInterval)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let associationName = associationName {
            try encodeContainer.encode(associationName, forKey: .associationName)
        }
        if let associationVersion = associationVersion {
            try encodeContainer.encode(associationVersion, forKey: .associationVersion)
        }
        if let automationTargetParameterName = automationTargetParameterName {
            try encodeContainer.encode(automationTargetParameterName, forKey: .automationTargetParameterName)
        }
        if let calendarNames = calendarNames {
            var calendarNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .calendarNames)
            for calendarnameorarnlist0 in calendarNames {
                try calendarNamesContainer.encode(calendarnameorarnlist0)
            }
        }
        if let complianceSeverity = complianceSeverity {
            try encodeContainer.encode(complianceSeverity.rawValue, forKey: .complianceSeverity)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parameters0) in parameters {
                try parametersContainer.encode(parameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let syncCompliance = syncCompliance {
            try encodeContainer.encode(syncCompliance.rawValue, forKey: .syncCompliance)
        }
        if let targetLocations = targetLocations {
            var targetLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLocations)
            for targetlocations0 in targetLocations {
                try targetLocationsContainer.encode(targetlocations0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
    }
}

public struct UpdateAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationInput>
    public typealias MOutput = OperationOutput<UpdateAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationOutputError>
}

public struct UpdateAssociationInput: Equatable {
    /// <p>By default, when you update an association, the system runs it immediately after it is
    ///    updated and then according to the schedule you specified. Specify this option if you don't want
    ///    an association to run immediately after you update it. This parameter is not supported for rate
    ///    expressions.</p>
    ///          <p>Also, if you specified this option when you created the association, you can reset it. To do
    ///    so, specify the <code>no-apply-only-at-cron-interval</code> parameter when you update the
    ///    association from the command line. This parameter forces the association to run immediately after
    ///    updating it and according to the interval specified.</p>
    public let applyOnlyAtCronInterval: Bool
    /// <p>The ID of the association you want to update. </p>
    public let associationId: String?
    /// <p>The name of the association that you want to update.</p>
    public let associationName: String?
    /// <p>This parameter is provided for concurrency control purposes. You must specify the latest
    ///    association version in the service. If you want to ensure that this request succeeds, either
    ///    specify <code>$LATEST</code>, or omit this parameter.</p>
    public let associationVersion: String?
    /// <p>Specify the target for the association. This target is required for associations that use an
    ///    Automation document and target resources by using rate controls.</p>
    public let automationTargetParameterName: String?
    /// <p>The names or Amazon Resource Names (ARNs) of the Systems Manager Change Calendar type
    ///    documents you want to gate your associations under. The associations only run when that Change
    ///    Calendar is open. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar">AWS Systems Manager Change
    ///     Calendar</a>.</p>
    public let calendarNames: [String]?
    /// <p>The severity level to assign to the association.</p>
    public let complianceSeverity: AssociationComplianceSeverity?
    /// <p>The document version you want update for the association. </p>
    public let documentVersion: String?
    /// <p>The maximum number of targets allowed to run the association at the same time. You can
    ///    specify a number, for example 10, or a percentage of the target set, for example 10%. The default
    ///    value is 100%, which means all targets run the association at the same time.</p>
    ///          <p>If a new instance starts and attempts to run an association while Systems Manager is running
    ///    MaxConcurrency associations, the association is allowed to run. During the next association
    ///    interval, the new instance will process its association within the limit specified for
    ///    MaxConcurrency.</p>
    public let maxConcurrency: String?
    /// <p>The number of errors that are allowed before the system stops sending requests to run the
    ///    association on additional targets. You can specify either an absolute number of errors, for
    ///    example 10, or a percentage of the target set, for example 10%. If you specify 3, for example,
    ///    the system stops sending requests when the fourth error is received. If you specify 0, then the
    ///    system stops sending requests after the first error is returned. If you run an association on 50
    ///    instances and set MaxError to 10%, then the system stops sending the request when the sixth error
    ///    is received.</p>
    ///          <p>Executions that are already running an association when MaxErrors is reached are allowed to
    ///    complete, but some of these executions may fail as well. If you need to ensure that there won't
    ///    be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one
    ///    at a time.</p>
    public let maxErrors: String?
    /// <p>The name of the SSM document that contains the configuration information for the instance.
    ///    You can specify Command or Automation documents.</p>
    ///          <p>You can specify AWS-predefined documents, documents you created, or a document that is
    ///    shared with you from another account.</p>
    ///          <p>For SSM documents that are shared with you from other AWS accounts, you must specify the
    ///    complete SSM document ARN, in the following format:</p>
    ///          <p>
    ///             <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:document/<i>document-name</i>
    ///             </code>
    ///          </p>
    ///          <p>For example:</p>
    ///          <p>
    ///             <code>arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document</code>
    ///          </p>
    ///          <p>For AWS-predefined documents and SSM documents you created in your account, you only need to
    ///    specify the document name. For example, <code>AWS-ApplyPatchBaseline</code> or
    ///     <code>My-Document</code>.</p>
    public let name: String?
    /// <p>An S3 bucket where you want to store the results of this request.</p>
    public let outputLocation: InstanceAssociationOutputLocation?
    /// <p>The parameters you want to update for the association. If you create a parameter using
    ///    Parameter Store, you can reference the parameter using {{ssm:parameter-name}}</p>
    public let parameters: [String:[String]]?
    /// <p>The cron expression used to schedule the association that you want to update.</p>
    public let scheduleExpression: String?
    /// <p>The mode for generating association compliance. You can specify <code>AUTO</code> or
    ///     <code>MANUAL</code>. In <code>AUTO</code> mode, the system uses the status of the association
    ///    execution to determine the compliance status. If the association execution runs successfully,
    ///    then the association is <code>COMPLIANT</code>. If the association execution doesn't run
    ///    successfully, the association is <code>NON-COMPLIANT</code>.</p>
    ///          <p>In <code>MANUAL</code> mode, you must specify the <code>AssociationId</code> as a parameter
    ///    for the <a>PutComplianceItems</a> API action. In this case, compliance data is not
    ///    managed by State Manager. It is managed by your direct call to the <a>PutComplianceItems</a> API action.</p>
    ///          <p>By default, all associations use <code>AUTO</code> mode.</p>
    public let syncCompliance: AssociationSyncCompliance?
    /// <p>A location is a combination of AWS Regions and AWS accounts where you want to run the
    ///    association. Use this action to update an association in multiple Regions and multiple
    ///    accounts.</p>
    public let targetLocations: [TargetLocation]?
    /// <p>The targets of the association.</p>
    public let targets: [Target]?

    public init (
        applyOnlyAtCronInterval: Bool = false,
        associationId: String? = nil,
        associationName: String? = nil,
        associationVersion: String? = nil,
        automationTargetParameterName: String? = nil,
        calendarNames: [String]? = nil,
        complianceSeverity: AssociationComplianceSeverity? = nil,
        documentVersion: String? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        outputLocation: InstanceAssociationOutputLocation? = nil,
        parameters: [String:[String]]? = nil,
        scheduleExpression: String? = nil,
        syncCompliance: AssociationSyncCompliance? = nil,
        targetLocations: [TargetLocation]? = nil,
        targets: [Target]? = nil
    )
    {
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targets = targets
    }
}

struct UpdateAssociationInputBody: Equatable {
    public let associationId: String?
    public let parameters: [String:[String]]?
    public let documentVersion: String?
    public let scheduleExpression: String?
    public let outputLocation: InstanceAssociationOutputLocation?
    public let name: String?
    public let targets: [Target]?
    public let associationName: String?
    public let associationVersion: String?
    public let automationTargetParameterName: String?
    public let maxErrors: String?
    public let maxConcurrency: String?
    public let complianceSeverity: AssociationComplianceSeverity?
    public let syncCompliance: AssociationSyncCompliance?
    public let applyOnlyAtCronInterval: Bool
    public let calendarNames: [String]?
    public let targetLocations: [TargetLocation]?
}

extension UpdateAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applyOnlyAtCronInterval = "ApplyOnlyAtCronInterval"
        case associationId = "AssociationId"
        case associationName = "AssociationName"
        case associationVersion = "AssociationVersion"
        case automationTargetParameterName = "AutomationTargetParameterName"
        case calendarNames = "CalendarNames"
        case complianceSeverity = "ComplianceSeverity"
        case documentVersion = "DocumentVersion"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case outputLocation = "OutputLocation"
        case parameters = "Parameters"
        case scheduleExpression = "ScheduleExpression"
        case syncCompliance = "SyncCompliance"
        case targetLocations = "TargetLocations"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, parametervaluelist0) in parametersContainer {
                var parametervaluelist0Decoded0: [String]? = nil
                if let parametervaluelist0 = parametervaluelist0 {
                    parametervaluelist0Decoded0 = [String]()
                    for string1 in parametervaluelist0 {
                        if let string1 = string1 {
                            parametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = parametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(InstanceAssociationOutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let associationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationName)
        associationName = associationNameDecoded
        let associationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .associationVersion)
        associationVersion = associationVersionDecoded
        let automationTargetParameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .automationTargetParameterName)
        automationTargetParameterName = automationTargetParameterNameDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let complianceSeverityDecoded = try containerValues.decodeIfPresent(AssociationComplianceSeverity.self, forKey: .complianceSeverity)
        complianceSeverity = complianceSeverityDecoded
        let syncComplianceDecoded = try containerValues.decodeIfPresent(AssociationSyncCompliance.self, forKey: .syncCompliance)
        syncCompliance = syncComplianceDecoded
        let applyOnlyAtCronIntervalDecoded = try containerValues.decode(Bool.self, forKey: .applyOnlyAtCronInterval)
        applyOnlyAtCronInterval = applyOnlyAtCronIntervalDecoded
        let calendarNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .calendarNames)
        var calendarNamesDecoded0:[String]? = nil
        if let calendarNamesContainer = calendarNamesContainer {
            calendarNamesDecoded0 = [String]()
            for string0 in calendarNamesContainer {
                if let string0 = string0 {
                    calendarNamesDecoded0?.append(string0)
                }
            }
        }
        calendarNames = calendarNamesDecoded0
        let targetLocationsContainer = try containerValues.decodeIfPresent([TargetLocation?].self, forKey: .targetLocations)
        var targetLocationsDecoded0:[TargetLocation]? = nil
        if let targetLocationsContainer = targetLocationsContainer {
            targetLocationsDecoded0 = [TargetLocation]()
            for structure0 in targetLocationsContainer {
                if let structure0 = structure0 {
                    targetLocationsDecoded0?.append(structure0)
                }
            }
        }
        targetLocations = targetLocationsDecoded0
    }
}

extension UpdateAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssociationVersionLimitExceeded" : self = .associationVersionLimitExceeded(try AssociationVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAssociationVersion" : self = .invalidAssociationVersion(try InvalidAssociationVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOutputLocation" : self = .invalidOutputLocation(try InvalidOutputLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameters" : self = .invalidParameters(try InvalidParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchedule" : self = .invalidSchedule(try InvalidSchedule(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTarget" : self = .invalidTarget(try InvalidTarget(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUpdate" : self = .invalidUpdate(try InvalidUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case associationVersionLimitExceeded(AssociationVersionLimitExceeded)
    case internalServerError(InternalServerError)
    case invalidAssociationVersion(InvalidAssociationVersion)
    case invalidDocument(InvalidDocument)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case invalidOutputLocation(InvalidOutputLocation)
    case invalidParameters(InvalidParameters)
    case invalidSchedule(InvalidSchedule)
    case invalidTarget(InvalidTarget)
    case invalidUpdate(InvalidUpdate)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssociationOutputResponse(associationDescription: \(String(describing: associationDescription)))"}
}

extension UpdateAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationOutputResponse: Equatable {
    /// <p>The description of the association that was updated.</p>
    public let associationDescription: AssociationDescription?

    public init (
        associationDescription: AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationOutputResponseBody: Equatable {
    public let associationDescription: AssociationDescription?
}

extension UpdateAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct UpdateAssociationStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssociationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationStatusOutputError>
}

extension UpdateAssociationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssociationStatusInput(associationStatus: \(String(describing: associationStatus)), instanceId: \(String(describing: instanceId)), name: \(String(describing: name)))"}
}

extension UpdateAssociationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus, forKey: .associationStatus)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAssociationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssociationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssociationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssociationStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssociationStatusOutputError>
}

public struct UpdateAssociationStatusInput: Equatable {
    /// <p>The association status.</p>
    public let associationStatus: AssociationStatus?
    /// <p>The ID of the instance.</p>
    public let instanceId: String?
    /// <p>The name of the Systems Manager document.</p>
    public let name: String?

    public init (
        associationStatus: AssociationStatus? = nil,
        instanceId: String? = nil,
        name: String? = nil
    )
    {
        self.associationStatus = associationStatus
        self.instanceId = instanceId
        self.name = name
    }
}

struct UpdateAssociationStatusInputBody: Equatable {
    public let name: String?
    public let instanceId: String?
    public let associationStatus: AssociationStatus?
}

extension UpdateAssociationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationStatus = "AssociationStatus"
        case instanceId = "InstanceId"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(AssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
    }
}

extension UpdateAssociationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssociationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AssociationDoesNotExist" : self = .associationDoesNotExist(try AssociationDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatusUnchanged" : self = .statusUnchanged(try StatusUnchanged(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssociationStatusOutputError: Equatable {
    case associationDoesNotExist(AssociationDoesNotExist)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidInstanceId(InvalidInstanceId)
    case statusUnchanged(StatusUnchanged)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssociationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssociationStatusOutputResponse(associationDescription: \(String(describing: associationDescription)))"}
}

extension UpdateAssociationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associationDescription = output.associationDescription
        } else {
            self.associationDescription = nil
        }
    }
}

public struct UpdateAssociationStatusOutputResponse: Equatable {
    /// <p>Information about the association.</p>
    public let associationDescription: AssociationDescription?

    public init (
        associationDescription: AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

struct UpdateAssociationStatusOutputResponseBody: Equatable {
    public let associationDescription: AssociationDescription?
}

extension UpdateAssociationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associationDescription = "AssociationDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDescriptionDecoded = try containerValues.decodeIfPresent(AssociationDescription.self, forKey: .associationDescription)
        associationDescription = associationDescriptionDecoded
    }
}

public struct UpdateDocumentDefaultVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentDefaultVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentDefaultVersionOutputError>
}

extension UpdateDocumentDefaultVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentDefaultVersionInput(documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)))"}
}

extension UpdateDocumentDefaultVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDocumentDefaultVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentDefaultVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentDefaultVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentDefaultVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentDefaultVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentDefaultVersionInput>
    public typealias MOutput = OperationOutput<UpdateDocumentDefaultVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentDefaultVersionOutputError>
}

public struct UpdateDocumentDefaultVersionInput: Equatable {
    /// <p>The version of a custom document that you want to set as the default version.</p>
    public let documentVersion: String?
    /// <p>The name of a custom document that you want to set as the default version.</p>
    public let name: String?

    public init (
        documentVersion: String? = nil,
        name: String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentDefaultVersionInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
}

extension UpdateDocumentDefaultVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
    }
}

extension UpdateDocumentDefaultVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentDefaultVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentDefaultVersionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentDefaultVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentDefaultVersionOutputResponse(description: \(String(describing: description)))"}
}

extension UpdateDocumentDefaultVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDocumentDefaultVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
        } else {
            self.description = nil
        }
    }
}

public struct UpdateDocumentDefaultVersionOutputResponse: Equatable {
    /// <p>The description of a custom document that you want to set as the default version.</p>
    public let description: DocumentDefaultVersionDescription?

    public init (
        description: DocumentDefaultVersionDescription? = nil
    )
    {
        self.description = description
    }
}

struct UpdateDocumentDefaultVersionOutputResponseBody: Equatable {
    public let description: DocumentDefaultVersionDescription?
}

extension UpdateDocumentDefaultVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(DocumentDefaultVersionDescription.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateDocumentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

extension UpdateDocumentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentInput(attachments: \(String(describing: attachments)), content: \(String(describing: content)), displayName: \(String(describing: displayName)), documentFormat: \(String(describing: documentFormat)), documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)), targetType: \(String(describing: targetType)), versionName: \(String(describing: versionName)))"}
}

extension UpdateDocumentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentssourcelist0 in attachments {
                try attachmentsContainer.encode(attachmentssourcelist0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentFormat = documentFormat {
            try encodeContainer.encode(documentFormat.rawValue, forKey: .documentFormat)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetType = targetType {
            try encodeContainer.encode(targetType, forKey: .targetType)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

public struct UpdateDocumentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentInput>
    public typealias MOutput = OperationOutput<UpdateDocumentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentOutputError>
}

public struct UpdateDocumentInput: Equatable {
    /// <p>A list of key and value pairs that describe attachments to a version of a document.</p>
    public let attachments: [AttachmentsSource]?
    /// <p>A valid JSON or YAML string.</p>
    public let content: String?
    /// <p>The friendly name of the Systems Manager document that you want to update. This value can differ for
    ///    each version of the document. If you do not specify a value for this parameter in your request,
    ///    the existing value is applied to the new document version.</p>
    public let displayName: String?
    /// <p>Specify the document format for the new document version. Systems Manager supports JSON and YAML
    ///    documents. JSON is the default format.</p>
    public let documentFormat: DocumentFormat?
    /// <p>The version of the document that you want to update. Currently, Systems Manager supports updating only
    ///    the latest version of the document. You can specify the version number of the latest version or
    ///    use the <code>$LATEST</code> variable.</p>
    public let documentVersion: String?
    /// <p>The name of the Systems Manager document that you want to update.</p>
    public let name: String?
    /// <p>Specify a new target type for the document.</p>
    public let targetType: String?
    /// <p>An optional field specifying the version of the artifact you are updating with the document.
    ///    For example, "Release 12, Update 6". This value is unique across all versions of a document, and
    ///    cannot be changed.</p>
    public let versionName: String?

    public init (
        attachments: [AttachmentsSource]? = nil,
        content: String? = nil,
        displayName: String? = nil,
        documentFormat: DocumentFormat? = nil,
        documentVersion: String? = nil,
        name: String? = nil,
        targetType: String? = nil,
        versionName: String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.targetType = targetType
        self.versionName = versionName
    }
}

struct UpdateDocumentInputBody: Equatable {
    public let content: String?
    public let attachments: [AttachmentsSource]?
    public let name: String?
    public let displayName: String?
    public let versionName: String?
    public let documentVersion: String?
    public let documentFormat: DocumentFormat?
    public let targetType: String?
}

extension UpdateDocumentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachments = "Attachments"
        case content = "Content"
        case displayName = "DisplayName"
        case documentFormat = "DocumentFormat"
        case documentVersion = "DocumentVersion"
        case name = "Name"
        case targetType = "TargetType"
        case versionName = "VersionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([AttachmentsSource?].self, forKey: .attachments)
        var attachmentsDecoded0:[AttachmentsSource]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [AttachmentsSource]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentFormatDecoded = try containerValues.decodeIfPresent(DocumentFormat.self, forKey: .documentFormat)
        documentFormat = documentFormatDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

public struct UpdateDocumentMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDocumentMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentMetadataOutputError>
}

extension UpdateDocumentMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentMetadataInput(documentReviews: \(String(describing: documentReviews)), documentVersion: \(String(describing: documentVersion)), name: \(String(describing: name)))"}
}

extension UpdateDocumentMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentReviews = documentReviews {
            try encodeContainer.encode(documentReviews, forKey: .documentReviews)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateDocumentMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDocumentMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDocumentMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDocumentMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDocumentMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDocumentMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDocumentMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDocumentMetadataOutputError>
}

public struct UpdateDocumentMetadataInput: Equatable {
    /// <p>The document review details to update.</p>
    public let documentReviews: DocumentReviews?
    /// <p>The version of a document to update.</p>
    public let documentVersion: String?
    /// <p>The name of the document for which a version is to be updated.</p>
    public let name: String?

    public init (
        documentReviews: DocumentReviews? = nil,
        documentVersion: String? = nil,
        name: String? = nil
    )
    {
        self.documentReviews = documentReviews
        self.documentVersion = documentVersion
        self.name = name
    }
}

struct UpdateDocumentMetadataInputBody: Equatable {
    public let name: String?
    public let documentVersion: String?
    public let documentReviews: DocumentReviews?
}

extension UpdateDocumentMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentReviews = "DocumentReviews"
        case documentVersion = "DocumentVersion"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let documentReviewsDecoded = try containerValues.decodeIfPresent(DocumentReviews.self, forKey: .documentReviews)
        documentReviews = documentReviewsDecoded
    }
}

extension UpdateDocumentMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentMetadataOutputResponse()"}
}

extension UpdateDocumentMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentMetadataOutputResponse: Equatable {

    public init() {}
}

struct UpdateDocumentMetadataOutputResponseBody: Equatable {
}

extension UpdateDocumentMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateDocumentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DocumentVersionLimitExceeded" : self = .documentVersionLimitExceeded(try DocumentVersionLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentContent" : self = .duplicateDocumentContent(try DuplicateDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateDocumentVersionName" : self = .duplicateDocumentVersionName(try DuplicateDocumentVersionName(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocument" : self = .invalidDocument(try InvalidDocument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentContent" : self = .invalidDocumentContent(try InvalidDocumentContent(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentOperation" : self = .invalidDocumentOperation(try InvalidDocumentOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentSchemaVersion" : self = .invalidDocumentSchemaVersion(try InvalidDocumentSchemaVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDocumentVersion" : self = .invalidDocumentVersion(try InvalidDocumentVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaxDocumentSizeExceeded" : self = .maxDocumentSizeExceeded(try MaxDocumentSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentOutputError: Equatable {
    case documentVersionLimitExceeded(DocumentVersionLimitExceeded)
    case duplicateDocumentContent(DuplicateDocumentContent)
    case duplicateDocumentVersionName(DuplicateDocumentVersionName)
    case internalServerError(InternalServerError)
    case invalidDocument(InvalidDocument)
    case invalidDocumentContent(InvalidDocumentContent)
    case invalidDocumentOperation(InvalidDocumentOperation)
    case invalidDocumentSchemaVersion(InvalidDocumentSchemaVersion)
    case invalidDocumentVersion(InvalidDocumentVersion)
    case maxDocumentSizeExceeded(MaxDocumentSizeExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDocumentOutputResponse(documentDescription: \(String(describing: documentDescription)))"}
}

extension UpdateDocumentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDocumentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.documentDescription = output.documentDescription
        } else {
            self.documentDescription = nil
        }
    }
}

public struct UpdateDocumentOutputResponse: Equatable {
    /// <p>A description of the document that was updated.</p>
    public let documentDescription: DocumentDescription?

    public init (
        documentDescription: DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

struct UpdateDocumentOutputResponseBody: Equatable {
    public let documentDescription: DocumentDescription?
}

extension UpdateDocumentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case documentDescription = "DocumentDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDescriptionDecoded = try containerValues.decodeIfPresent(DocumentDescription.self, forKey: .documentDescription)
        documentDescription = documentDescriptionDecoded
    }
}

public struct UpdateMaintenanceWindowInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowOutputError>
}

extension UpdateMaintenanceWindowInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowInput(allowUnassociatedTargets: \(String(describing: allowUnassociatedTargets)), cutoff: \(String(describing: cutoff)), description: \(String(describing: description)), duration: \(String(describing: duration)), enabled: \(String(describing: enabled)), endDate: \(String(describing: endDate)), name: \(String(describing: name)), replace: \(String(describing: replace)), schedule: \(String(describing: schedule)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleTimezone: \(String(describing: scheduleTimezone)), startDate: \(String(describing: startDate)), windowId: \(String(describing: windowId)))"}
}

extension UpdateMaintenanceWindowInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowUnassociatedTargets != false {
            try encodeContainer.encode(allowUnassociatedTargets, forKey: .allowUnassociatedTargets)
        }
        if cutoff != 0 {
            try encodeContainer.encode(cutoff, forKey: .cutoff)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if scheduleOffset != 0 {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleTimezone = scheduleTimezone {
            try encodeContainer.encode(scheduleTimezone, forKey: .scheduleTimezone)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
    }
}

public struct UpdateMaintenanceWindowInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowOutputError>
}

public struct UpdateMaintenanceWindowInput: Equatable {
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    ///    for those targets.</p>
    public let allowUnassociatedTargets: Bool
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    ///    tasks for execution.</p>
    public let cutoff: Int
    /// <p>An optional description for the update request.</p>
    public let description: String?
    /// <p>The duration of the maintenance window in hours.</p>
    public let duration: Int
    /// <p>Whether the maintenance window is enabled.</p>
    public let enabled: Bool
    /// <p>The date and time, in ISO-8601 Extended format, for when you want the maintenance window to
    ///    become inactive. EndDate allows you to set a date and time in the future when the maintenance
    ///    window will no longer run.</p>
    public let endDate: String?
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>If True, then all fields that are required by the CreateMaintenanceWindow action are also
    ///    required for this API request. Optional fields that are not specified are set to null. </p>
    public let replace: Bool
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    public let schedule: String?
    /// <p>The number of days to wait after the date and time specified by a CRON expression before
    ///    running the maintenance window.</p>
    ///          <p>For example, the following cron expression schedules a maintenance window to run the third
    ///    Tuesday of every month at 11:30 PM.</p>
    ///          <p>
    ///             <code>cron(30 23 ? * TUE#3 *)</code>
    ///          </p>
    ///          <p>If the schedule offset is <code>2</code>, the maintenance window won't run until two days
    ///    later.</p>
    public let scheduleOffset: Int
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    ///    "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    ///     Zone Database</a> on the IANA website.</p>
    public let scheduleTimezone: String?
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    ///    "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    ///     Zone Database</a> on the IANA website.</p>
    public let startDate: String?
    /// <p>The ID of the maintenance window to update.</p>
    public let windowId: String?

    public init (
        allowUnassociatedTargets: Bool = false,
        cutoff: Int = 0,
        description: String? = nil,
        duration: Int = 0,
        enabled: Bool = false,
        endDate: String? = nil,
        name: String? = nil,
        replace: Bool = false,
        schedule: String? = nil,
        scheduleOffset: Int = 0,
        scheduleTimezone: String? = nil,
        startDate: String? = nil,
        windowId: String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.replace = replace
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowInputBody: Equatable {
    public let windowId: String?
    public let name: String?
    public let description: String?
    public let startDate: String?
    public let endDate: String?
    public let schedule: String?
    public let scheduleTimezone: String?
    public let scheduleOffset: Int
    public let duration: Int
    public let cutoff: Int
    public let allowUnassociatedTargets: Bool
    public let enabled: Bool
    public let replace: Bool
}

extension UpdateMaintenanceWindowInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case replace = "Replace"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let replaceDecoded = try containerValues.decode(Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowOutputResponse(allowUnassociatedTargets: \(String(describing: allowUnassociatedTargets)), cutoff: \(String(describing: cutoff)), description: \(String(describing: description)), duration: \(String(describing: duration)), enabled: \(String(describing: enabled)), endDate: \(String(describing: endDate)), name: \(String(describing: name)), schedule: \(String(describing: schedule)), scheduleOffset: \(String(describing: scheduleOffset)), scheduleTimezone: \(String(describing: scheduleTimezone)), startDate: \(String(describing: startDate)), windowId: \(String(describing: windowId)))"}
}

extension UpdateMaintenanceWindowOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMaintenanceWindowOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowUnassociatedTargets = output.allowUnassociatedTargets
            self.cutoff = output.cutoff
            self.description = output.description
            self.duration = output.duration
            self.enabled = output.enabled
            self.endDate = output.endDate
            self.name = output.name
            self.schedule = output.schedule
            self.scheduleOffset = output.scheduleOffset
            self.scheduleTimezone = output.scheduleTimezone
            self.startDate = output.startDate
            self.windowId = output.windowId
        } else {
            self.allowUnassociatedTargets = false
            self.cutoff = 0
            self.description = nil
            self.duration = 0
            self.enabled = false
            self.endDate = nil
            self.name = nil
            self.schedule = nil
            self.scheduleOffset = 0
            self.scheduleTimezone = nil
            self.startDate = nil
            self.windowId = nil
        }
    }
}

public struct UpdateMaintenanceWindowOutputResponse: Equatable {
    /// <p>Whether targets must be registered with the maintenance window before tasks can be defined
    ///    for those targets.</p>
    public let allowUnassociatedTargets: Bool
    /// <p>The number of hours before the end of the maintenance window that Systems Manager stops scheduling new
    ///    tasks for execution.</p>
    public let cutoff: Int
    /// <p>An optional description of the update.</p>
    public let description: String?
    /// <p>The duration of the maintenance window in hours.</p>
    public let duration: Int
    /// <p>Whether the maintenance window is enabled.</p>
    public let enabled: Bool
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become inactive. The maintenance window will not run after this specified time.</p>
    public let endDate: String?
    /// <p>The name of the maintenance window.</p>
    public let name: String?
    /// <p>The schedule of the maintenance window in the form of a cron or rate expression.</p>
    public let schedule: String?
    /// <p>The number of days to wait to run a maintenance window after the scheduled CRON expression
    ///    date and time.</p>
    public let scheduleOffset: Int
    /// <p>The time zone that the scheduled maintenance window executions are based on, in Internet
    ///    Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or
    ///    "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time
    ///     Zone Database</a> on the IANA website.</p>
    public let scheduleTimezone: String?
    /// <p>The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled
    ///    to become active. The maintenance window will not run before this specified time.</p>
    public let startDate: String?
    /// <p>The ID of the created maintenance window.</p>
    public let windowId: String?

    public init (
        allowUnassociatedTargets: Bool = false,
        cutoff: Int = 0,
        description: String? = nil,
        duration: Int = 0,
        enabled: Bool = false,
        endDate: String? = nil,
        name: String? = nil,
        schedule: String? = nil,
        scheduleOffset: Int = 0,
        scheduleTimezone: String? = nil,
        startDate: String? = nil,
        windowId: String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

struct UpdateMaintenanceWindowOutputResponseBody: Equatable {
    public let windowId: String?
    public let name: String?
    public let description: String?
    public let startDate: String?
    public let endDate: String?
    public let schedule: String?
    public let scheduleTimezone: String?
    public let scheduleOffset: Int
    public let duration: Int
    public let cutoff: Int
    public let allowUnassociatedTargets: Bool
    public let enabled: Bool
}

extension UpdateMaintenanceWindowOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowUnassociatedTargets = "AllowUnassociatedTargets"
        case cutoff = "Cutoff"
        case description = "Description"
        case duration = "Duration"
        case enabled = "Enabled"
        case endDate = "EndDate"
        case name = "Name"
        case schedule = "Schedule"
        case scheduleOffset = "ScheduleOffset"
        case scheduleTimezone = "ScheduleTimezone"
        case startDate = "StartDate"
        case windowId = "WindowId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schedule)
        schedule = scheduleDecoded
        let scheduleTimezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleTimezone)
        scheduleTimezone = scheduleTimezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decode(Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let cutoffDecoded = try containerValues.decode(Int.self, forKey: .cutoff)
        cutoff = cutoffDecoded
        let allowUnassociatedTargetsDecoded = try containerValues.decode(Bool.self, forKey: .allowUnassociatedTargets)
        allowUnassociatedTargets = allowUnassociatedTargetsDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

public struct UpdateMaintenanceWindowTargetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTargetOutputError>
}

extension UpdateMaintenanceWindowTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowTargetInput(description: \(String(describing: description)), name: \(String(describing: name)), ownerInformation: \(String(describing: ownerInformation)), replace: \(String(describing: replace)), targets: \(String(describing: targets)), windowId: \(String(describing: windowId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

extension UpdateMaintenanceWindowTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerInformation = ownerInformation {
            try encodeContainer.encode(ownerInformation, forKey: .ownerInformation)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTargetId = windowTargetId {
            try encodeContainer.encode(windowTargetId, forKey: .windowTargetId)
        }
    }
}

public struct UpdateMaintenanceWindowTargetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTargetInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTargetOutputError>
}

public struct UpdateMaintenanceWindowTargetInput: Equatable {
    /// <p>An optional description for the update.</p>
    public let description: String?
    /// <p>A name for the update.</p>
    public let name: String?
    /// <p>User-provided value that will be included in any CloudWatch events raised while running
    ///    tasks for these targets in this maintenance window.</p>
    public let ownerInformation: String?
    /// <p>If True, then all fields that are required by the RegisterTargetWithMaintenanceWindow action
    ///    are also required for this API request. Optional fields that are not specified are set to
    ///    null.</p>
    public let replace: Bool
    /// <p>The targets to add or replace.</p>
    public let targets: [Target]?
    /// <p>The maintenance window ID with which to modify the target.</p>
    public let windowId: String?
    /// <p>The target ID to modify.</p>
    public let windowTargetId: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        ownerInformation: String? = nil,
        replace: Bool = false,
        targets: [Target]? = nil,
        windowId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.replace = replace
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetInputBody: Equatable {
    public let windowId: String?
    public let windowTargetId: String?
    public let targets: [Target]?
    public let ownerInformation: String?
    public let name: String?
    public let description: String?
    public let replace: Bool
}

extension UpdateMaintenanceWindowTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case replace = "Replace"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTargetOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowTargetOutputResponse(description: \(String(describing: description)), name: \(String(describing: name)), ownerInformation: \(String(describing: ownerInformation)), targets: \(String(describing: targets)), windowId: \(String(describing: windowId)), windowTargetId: \(String(describing: windowTargetId)))"}
}

extension UpdateMaintenanceWindowTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMaintenanceWindowTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.name = output.name
            self.ownerInformation = output.ownerInformation
            self.targets = output.targets
            self.windowId = output.windowId
            self.windowTargetId = output.windowTargetId
        } else {
            self.description = nil
            self.name = nil
            self.ownerInformation = nil
            self.targets = nil
            self.windowId = nil
            self.windowTargetId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTargetOutputResponse: Equatable {
    /// <p>The updated description.</p>
    public let description: String?
    /// <p>The updated name.</p>
    public let name: String?
    /// <p>The updated owner.</p>
    public let ownerInformation: String?
    /// <p>The updated targets.</p>
    public let targets: [Target]?
    /// <p>The maintenance window ID specified in the update request.</p>
    public let windowId: String?
    /// <p>The target ID specified in the update request.</p>
    public let windowTargetId: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        ownerInformation: String? = nil,
        targets: [Target]? = nil,
        windowId: String? = nil,
        windowTargetId: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

struct UpdateMaintenanceWindowTargetOutputResponseBody: Equatable {
    public let windowId: String?
    public let windowTargetId: String?
    public let targets: [Target]?
    public let ownerInformation: String?
    public let name: String?
    public let description: String?
}

extension UpdateMaintenanceWindowTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case ownerInformation = "OwnerInformation"
        case targets = "Targets"
        case windowId = "WindowId"
        case windowTargetId = "WindowTargetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTargetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTargetId)
        windowTargetId = windowTargetIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let ownerInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerInformation)
        ownerInformation = ownerInformationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateMaintenanceWindowTaskInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTaskOutputError>
}

extension UpdateMaintenanceWindowTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowTaskInput(description: \(String(describing: description)), loggingInfo: \(String(describing: loggingInfo)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), priority: \(String(describing: priority)), replace: \(String(describing: replace)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), taskArn: \(String(describing: taskArn)), taskInvocationParameters: \(String(describing: taskInvocationParameters)), taskParameters: \(String(describing: taskParameters)), windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension UpdateMaintenanceWindowTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loggingInfo = loggingInfo {
            try encodeContainer.encode(loggingInfo, forKey: .loggingInfo)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxErrors = maxErrors {
            try encodeContainer.encode(maxErrors, forKey: .maxErrors)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let taskArn = taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskInvocationParameters = taskInvocationParameters {
            try encodeContainer.encode(taskInvocationParameters, forKey: .taskInvocationParameters)
        }
        if let taskParameters = taskParameters {
            var taskParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .taskParameters)
            for (dictKey0, maintenancewindowtaskparameters0) in taskParameters {
                try taskParametersContainer.encode(maintenancewindowtaskparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let windowId = windowId {
            try encodeContainer.encode(windowId, forKey: .windowId)
        }
        if let windowTaskId = windowTaskId {
            try encodeContainer.encode(windowTaskId, forKey: .windowTaskId)
        }
    }
}

public struct UpdateMaintenanceWindowTaskInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMaintenanceWindowTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMaintenanceWindowTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMaintenanceWindowTaskInput>
    public typealias MOutput = OperationOutput<UpdateMaintenanceWindowTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMaintenanceWindowTaskOutputError>
}

public struct UpdateMaintenanceWindowTaskInput: Equatable {
    /// <p>The new task description to specify.</p>
    public let description: String?
    /// <p>The new logging location in Amazon S3 to specify.</p>
    ///          <note>
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let loggingInfo: LoggingInfo?
    /// <p>The new <code>MaxConcurrency</code> value you want to specify. <code>MaxConcurrency</code>
    ///    is the number of targets that are allowed to run this task in parallel.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    ///     in the response to this command. This value does not affect the running of your task and can be
    ///     ignored.</p>
    ///          </note>
    public let maxConcurrency: String?
    /// <p>The new <code>MaxErrors</code> value to specify. <code>MaxErrors</code> is the maximum
    ///    number of errors that are allowed before the task stops being scheduled.</p>
    ///          <note>
    ///             <p>For maintenance window tasks without a target specified, you cannot supply a value for this
    ///     option. Instead, the system inserts a placeholder value of <code>1</code>, which may be reported
    ///     in the response to this command. This value does not affect the running of your task and can be
    ///     ignored.</p>
    ///          </note>
    public let maxErrors: String?
    /// <p>The new task name to specify.</p>
    public let name: String?
    /// <p>The new task priority to specify. The lower the number, the higher the priority. Tasks that
    ///    have the same priority are scheduled in parallel.</p>
    public let priority: Int
    /// <p>If True, then all fields that are required by the RegisterTaskWithMaintenanceWindow action
    ///    are also required for this API request. Optional fields that are not specified are set to
    ///    null.</p>
    public let replace: Bool
    /// <p>The ARN of the IAM service role for Systems Manager to assume when running a
    ///   maintenance window task. If you do not specify a service role ARN, Systems Manager uses your account's
    ///   service-linked role.  If no service-linked role for Systems Manager exists in your account, it is created when you run
    ///   <code>RegisterTaskWithMaintenanceWindow</code>.</p>
    ///          <p>For more information, see the following topics in the in the <i>AWS Systems Manager User Guide</i>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Using
    ///     service-linked roles for Systems Manager</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I use a service-linked role or a custom service role to run maintenance window tasks?
    ///    </a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let serviceRoleArn: String?
    /// <p>The targets (either instances or tags) to modify. Instances are specified using
    ///    Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using
    ///    Key=tag_name,Values=tag_value. </p>
    ///          <note>
    ///             <p>One or more targets must be specified for maintenance window Run Command-type tasks.
    ///     Depending on the task, targets are optional for other maintenance window task types (Automation,
    ///     AWS Lambda, and AWS Step Functions). For more information about running tasks that do not
    ///     specify targets, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html">Registering
    ///      maintenance window tasks without targets</a> in the
    ///     <i>AWS Systems Manager User Guide</i>.</p>
    ///          </note>
    public let targets: [Target]?
    /// <p>The task ARN to modify.</p>
    public let taskArn: String?
    /// <p>The parameters that the task should use during execution. Populate only the fields that
    ///    match the task type. All other fields should be empty.</p>
    ///          <important>
    ///             <p>When you update a maintenance window task that has options specified in
    ///      <code>TaskInvocationParameters</code>, you must provide again all the
    ///      <code>TaskInvocationParameters</code> values that you want to retain. The values you do not
    ///     specify again are removed. For example, suppose that when you registered a Run Command task, you
    ///     specified <code>TaskInvocationParameters</code> values for <code>Comment</code>,
    ///      <code>NotificationConfig</code>, and <code>OutputS3BucketName</code>. If you update the
    ///     maintenance window task and specify only a different <code>OutputS3BucketName</code> value, the
    ///     values for <code>Comment</code> and <code>NotificationConfig</code> are removed.</p>
    ///          </important>
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    /// <p>The parameters to modify.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    ///          <p>The map has the following format:</p>
    ///          <p>Key: string, between 1 and 255 characters</p>
    ///          <p>Value: an array of strings, each string is between 1 and 255 characters</p>
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    /// <p>The maintenance window ID that contains the task to modify.</p>
    public let windowId: String?
    /// <p>The task ID to modify.</p>
    public let windowTaskId: String?

    public init (
        description: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        priority: Int = 0,
        replace: Bool = false,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        taskArn: String? = nil,
        taskInvocationParameters: MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.replace = replace
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskInputBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
    public let targets: [Target]?
    public let taskArn: String?
    public let serviceRoleArn: String?
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    public let priority: Int
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let loggingInfo: LoggingInfo?
    public let name: String?
    public let description: String?
    public let replace: Bool
}

extension UpdateMaintenanceWindowTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case replace = "Replace"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([String: MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [String:MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [String:MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let replaceDecoded = try containerValues.decode(Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdateMaintenanceWindowTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMaintenanceWindowTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMaintenanceWindowTaskOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMaintenanceWindowTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMaintenanceWindowTaskOutputResponse(description: \(String(describing: description)), loggingInfo: \(String(describing: loggingInfo)), maxConcurrency: \(String(describing: maxConcurrency)), maxErrors: \(String(describing: maxErrors)), name: \(String(describing: name)), priority: \(String(describing: priority)), serviceRoleArn: \(String(describing: serviceRoleArn)), targets: \(String(describing: targets)), taskArn: \(String(describing: taskArn)), taskInvocationParameters: \(String(describing: taskInvocationParameters)), taskParameters: \(String(describing: taskParameters)), windowId: \(String(describing: windowId)), windowTaskId: \(String(describing: windowTaskId)))"}
}

extension UpdateMaintenanceWindowTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateMaintenanceWindowTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.loggingInfo = output.loggingInfo
            self.maxConcurrency = output.maxConcurrency
            self.maxErrors = output.maxErrors
            self.name = output.name
            self.priority = output.priority
            self.serviceRoleArn = output.serviceRoleArn
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskInvocationParameters = output.taskInvocationParameters
            self.taskParameters = output.taskParameters
            self.windowId = output.windowId
            self.windowTaskId = output.windowTaskId
        } else {
            self.description = nil
            self.loggingInfo = nil
            self.maxConcurrency = nil
            self.maxErrors = nil
            self.name = nil
            self.priority = 0
            self.serviceRoleArn = nil
            self.targets = nil
            self.taskArn = nil
            self.taskInvocationParameters = nil
            self.taskParameters = nil
            self.windowId = nil
            self.windowTaskId = nil
        }
    }
}

public struct UpdateMaintenanceWindowTaskOutputResponse: Equatable {
    /// <p>The updated task description.</p>
    public let description: String?
    /// <p>The updated logging information in Amazon S3.</p>
    ///          <note>
    ///             <p>
    ///                <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the
    ///       <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure.
    ///       For information about how Systems Manager handles these options for the supported maintenance
    ///       window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let loggingInfo: LoggingInfo?
    /// <p>The updated MaxConcurrency value.</p>
    public let maxConcurrency: String?
    /// <p>The updated MaxErrors value.</p>
    public let maxErrors: String?
    /// <p>The updated task name.</p>
    public let name: String?
    /// <p>The updated priority value.</p>
    public let priority: Int
    /// <p>The ARN of the IAM service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for
    ///    maintenance window Run Command tasks.</p>
    public let serviceRoleArn: String?
    /// <p>The updated target values.</p>
    public let targets: [Target]?
    /// <p>The updated task ARN value.</p>
    public let taskArn: String?
    /// <p>The updated parameter values.</p>
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    /// <p>The updated parameter values.</p>
    ///          <note>
    ///             <p>
    ///                <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs,
    ///       instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information
    ///       about how Systems Manager handles these options for the supported maintenance window task
    ///       types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p>
    ///          </note>
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    /// <p>The ID of the maintenance window that was updated.</p>
    public let windowId: String?
    /// <p>The task ID of the maintenance window that was updated.</p>
    public let windowTaskId: String?

    public init (
        description: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        maxConcurrency: String? = nil,
        maxErrors: String? = nil,
        name: String? = nil,
        priority: Int = 0,
        serviceRoleArn: String? = nil,
        targets: [Target]? = nil,
        taskArn: String? = nil,
        taskInvocationParameters: MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: String? = nil,
        windowTaskId: String? = nil
    )
    {
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

struct UpdateMaintenanceWindowTaskOutputResponseBody: Equatable {
    public let windowId: String?
    public let windowTaskId: String?
    public let targets: [Target]?
    public let taskArn: String?
    public let serviceRoleArn: String?
    public let taskParameters: [String:MaintenanceWindowTaskParameterValueExpression]?
    public let taskInvocationParameters: MaintenanceWindowTaskInvocationParameters?
    public let priority: Int
    public let maxConcurrency: String?
    public let maxErrors: String?
    public let loggingInfo: LoggingInfo?
    public let name: String?
    public let description: String?
}

extension UpdateMaintenanceWindowTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case loggingInfo = "LoggingInfo"
        case maxConcurrency = "MaxConcurrency"
        case maxErrors = "MaxErrors"
        case name = "Name"
        case priority = "Priority"
        case serviceRoleArn = "ServiceRoleArn"
        case targets = "Targets"
        case taskArn = "TaskArn"
        case taskInvocationParameters = "TaskInvocationParameters"
        case taskParameters = "TaskParameters"
        case windowId = "WindowId"
        case windowTaskId = "WindowTaskId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let windowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowId)
        windowId = windowIdDecoded
        let windowTaskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .windowTaskId)
        windowTaskId = windowTaskIdDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let taskParametersContainer = try containerValues.decodeIfPresent([String: MaintenanceWindowTaskParameterValueExpression?].self, forKey: .taskParameters)
        var taskParametersDecoded0: [String:MaintenanceWindowTaskParameterValueExpression]? = nil
        if let taskParametersContainer = taskParametersContainer {
            taskParametersDecoded0 = [String:MaintenanceWindowTaskParameterValueExpression]()
            for (key0, maintenancewindowtaskparametervalueexpression0) in taskParametersContainer {
                if let maintenancewindowtaskparametervalueexpression0 = maintenancewindowtaskparametervalueexpression0 {
                    taskParametersDecoded0?[key0] = maintenancewindowtaskparametervalueexpression0
                }
            }
        }
        taskParameters = taskParametersDecoded0
        let taskInvocationParametersDecoded = try containerValues.decodeIfPresent(MaintenanceWindowTaskInvocationParameters.self, forKey: .taskInvocationParameters)
        taskInvocationParameters = taskInvocationParametersDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let maxErrorsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxErrors)
        maxErrors = maxErrorsDecoded
        let loggingInfoDecoded = try containerValues.decodeIfPresent(LoggingInfo.self, forKey: .loggingInfo)
        loggingInfo = loggingInfoDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateManagedInstanceRoleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateManagedInstanceRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateManagedInstanceRoleOutputError>
}

extension UpdateManagedInstanceRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateManagedInstanceRoleInput(iamRole: \(String(describing: iamRole)), instanceId: \(String(describing: instanceId)))"}
}

extension UpdateManagedInstanceRoleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

public struct UpdateManagedInstanceRoleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateManagedInstanceRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateManagedInstanceRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateManagedInstanceRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateManagedInstanceRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateManagedInstanceRoleInput>
    public typealias MOutput = OperationOutput<UpdateManagedInstanceRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateManagedInstanceRoleOutputError>
}

public struct UpdateManagedInstanceRoleInput: Equatable {
    /// <p>The IAM role you want to assign or change.</p>
    public let iamRole: String?
    /// <p>The ID of the managed instance where you want to update the role.</p>
    public let instanceId: String?

    public init (
        iamRole: String? = nil,
        instanceId: String? = nil
    )
    {
        self.iamRole = iamRole
        self.instanceId = instanceId
    }
}

struct UpdateManagedInstanceRoleInputBody: Equatable {
    public let instanceId: String?
    public let iamRole: String?
}

extension UpdateManagedInstanceRoleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iamRole = "IamRole"
        case instanceId = "InstanceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension UpdateManagedInstanceRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateManagedInstanceRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstanceId" : self = .invalidInstanceId(try InvalidInstanceId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateManagedInstanceRoleOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidInstanceId(InvalidInstanceId)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateManagedInstanceRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateManagedInstanceRoleOutputResponse()"}
}

extension UpdateManagedInstanceRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateManagedInstanceRoleOutputResponse: Equatable {

    public init() {}
}

struct UpdateManagedInstanceRoleOutputResponseBody: Equatable {
}

extension UpdateManagedInstanceRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateOpsItemInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOpsItemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsItemOutputError>
}

extension UpdateOpsItemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpsItemInput(actualEndTime: \(String(describing: actualEndTime)), actualStartTime: \(String(describing: actualStartTime)), category: \(String(describing: category)), description: \(String(describing: description)), notifications: \(String(describing: notifications)), operationalData: \(String(describing: operationalData)), operationalDataToDelete: \(String(describing: operationalDataToDelete)), opsItemId: \(String(describing: opsItemId)), plannedEndTime: \(String(describing: plannedEndTime)), plannedStartTime: \(String(describing: plannedStartTime)), priority: \(String(describing: priority)), relatedOpsItems: \(String(describing: relatedOpsItems)), severity: \(String(describing: severity)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

extension UpdateOpsItemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualEndTime = actualEndTime {
            try encodeContainer.encode(actualEndTime.timeIntervalSince1970, forKey: .actualEndTime)
        }
        if let actualStartTime = actualStartTime {
            try encodeContainer.encode(actualStartTime.timeIntervalSince1970, forKey: .actualStartTime)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for opsitemnotifications0 in notifications {
                try notificationsContainer.encode(opsitemnotifications0)
            }
        }
        if let operationalData = operationalData {
            var operationalDataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .operationalData)
            for (dictKey0, opsitemoperationaldata0) in operationalData {
                try operationalDataContainer.encode(opsitemoperationaldata0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let operationalDataToDelete = operationalDataToDelete {
            var operationalDataToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operationalDataToDelete)
            for opsitemopsdatakeyslist0 in operationalDataToDelete {
                try operationalDataToDeleteContainer.encode(opsitemopsdatakeyslist0)
            }
        }
        if let opsItemId = opsItemId {
            try encodeContainer.encode(opsItemId, forKey: .opsItemId)
        }
        if let plannedEndTime = plannedEndTime {
            try encodeContainer.encode(plannedEndTime.timeIntervalSince1970, forKey: .plannedEndTime)
        }
        if let plannedStartTime = plannedStartTime {
            try encodeContainer.encode(plannedStartTime.timeIntervalSince1970, forKey: .plannedStartTime)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let relatedOpsItems = relatedOpsItems {
            var relatedOpsItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedOpsItems)
            for relatedopsitems0 in relatedOpsItems {
                try relatedOpsItemsContainer.encode(relatedopsitems0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct UpdateOpsItemInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOpsItemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOpsItemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsItemInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsItemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsItemInput>
    public typealias MOutput = OperationOutput<UpdateOpsItemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsItemOutputError>
}

public struct UpdateOpsItemInput: Equatable {
    /// <p>The time a runbook workflow ended. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualEndTime: Date?
    /// <p>The time a runbook workflow started. Currently reported only for the OpsItem type
    ///     <code>/aws/changerequest</code>.</p>
    public let actualStartTime: Date?
    /// <p>Specify a new category for an OpsItem.</p>
    public let category: String?
    /// <p>Update the information about the OpsItem. Provide enough information so that users reading
    ///    this OpsItem for the first time understand the issue. </p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this
    ///    OpsItem is edited or changed.</p>
    public let notifications: [OpsItemNotification]?
    /// <p>Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem
    ///    object.</p>
    ///          <p>Operational data is custom data that provides useful reference details about the OpsItem.
    ///    For example, you can specify log files, error strings, license keys, troubleshooting tips, or
    ///    other relevant data. You enter operational data as key-value pairs. The key has a maximum length
    ///    of 128 characters. The value has a maximum size of 20 KB.</p>
    ///          <important>
    ///             <p>Operational data keys <i>can't</i> begin with the following: amazon, aws,
    ///     amzn, ssm, /amazon, /aws, /amzn, /ssm.</p>
    ///          </important>
    ///          <p>You can choose to make the data searchable by other users in the account or you can restrict
    ///    search access. Searchable data means that all users with access to the OpsItem Overview page (as
    ///    provided by the <a>DescribeOpsItems</a> API action) can view and search on the
    ///    specified data. Operational data that is not searchable is only viewable by users who have access
    ///    to the OpsItem (as provided by the <a>GetOpsItem</a> API action).</p>
    ///          <p>Use the <code>/aws/resources</code> key in OperationalData to specify a related resource in
    ///    the request. Use the <code>/aws/automations</code> key in OperationalData to associate an
    ///    Automation runbook with the OpsItem. To view AWS CLI example commands that use these keys, see
    ///     <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-creating-OpsItems.html#OpsCenter-manually-create-OpsItems">Creating OpsItems manually</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let operationalData: [String:OpsItemDataValue]?
    /// <p>Keys that you want to remove from the OperationalData map.</p>
    public let operationalDataToDelete: [String]?
    /// <p>The ID of the OpsItem.</p>
    public let opsItemId: String?
    /// <p>The time specified in a change request for a runbook workflow to end. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedEndTime: Date?
    /// <p>The time specified in a change request for a runbook workflow to start. Currently supported
    ///    only for the OpsItem type <code>/aws/changerequest</code>.</p>
    public let plannedStartTime: Date?
    /// <p>The importance of this OpsItem in relation to other OpsItems in the system.</p>
    public let priority: Int?
    /// <p>One or more OpsItems that share something in common with the current OpsItems. For example,
    ///    related OpsItems can include OpsItems with similar error messages, impacted resources, or
    ///    statuses for the impacted resource.</p>
    public let relatedOpsItems: [RelatedOpsItem]?
    /// <p>Specify a new severity for an OpsItem.</p>
    public let severity: String?
    /// <p>The OpsItem status. Status can be <code>Open</code>, <code>In Progress</code>, or
    ///     <code>Resolved</code>. For more information, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems.html#OpsCenter-working-with-OpsItems-editing-details">Editing OpsItem details</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let status: OpsItemStatus?
    /// <p>A short heading that describes the nature of the OpsItem and the impacted resource.</p>
    public let title: String?

    public init (
        actualEndTime: Date? = nil,
        actualStartTime: Date? = nil,
        category: String? = nil,
        description: String? = nil,
        notifications: [OpsItemNotification]? = nil,
        operationalData: [String:OpsItemDataValue]? = nil,
        operationalDataToDelete: [String]? = nil,
        opsItemId: String? = nil,
        plannedEndTime: Date? = nil,
        plannedStartTime: Date? = nil,
        priority: Int? = nil,
        relatedOpsItems: [RelatedOpsItem]? = nil,
        severity: String? = nil,
        status: OpsItemStatus? = nil,
        title: String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.operationalDataToDelete = operationalDataToDelete
        self.opsItemId = opsItemId
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.status = status
        self.title = title
    }
}

struct UpdateOpsItemInputBody: Equatable {
    public let description: String?
    public let operationalData: [String:OpsItemDataValue]?
    public let operationalDataToDelete: [String]?
    public let notifications: [OpsItemNotification]?
    public let priority: Int?
    public let relatedOpsItems: [RelatedOpsItem]?
    public let status: OpsItemStatus?
    public let opsItemId: String?
    public let title: String?
    public let category: String?
    public let severity: String?
    public let actualStartTime: Date?
    public let actualEndTime: Date?
    public let plannedStartTime: Date?
    public let plannedEndTime: Date?
}

extension UpdateOpsItemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actualEndTime = "ActualEndTime"
        case actualStartTime = "ActualStartTime"
        case category = "Category"
        case description = "Description"
        case notifications = "Notifications"
        case operationalData = "OperationalData"
        case operationalDataToDelete = "OperationalDataToDelete"
        case opsItemId = "OpsItemId"
        case plannedEndTime = "PlannedEndTime"
        case plannedStartTime = "PlannedStartTime"
        case priority = "Priority"
        case relatedOpsItems = "RelatedOpsItems"
        case severity = "Severity"
        case status = "Status"
        case title = "Title"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let operationalDataContainer = try containerValues.decodeIfPresent([String: OpsItemDataValue?].self, forKey: .operationalData)
        var operationalDataDecoded0: [String:OpsItemDataValue]? = nil
        if let operationalDataContainer = operationalDataContainer {
            operationalDataDecoded0 = [String:OpsItemDataValue]()
            for (key0, opsitemdatavalue0) in operationalDataContainer {
                if let opsitemdatavalue0 = opsitemdatavalue0 {
                    operationalDataDecoded0?[key0] = opsitemdatavalue0
                }
            }
        }
        operationalData = operationalDataDecoded0
        let operationalDataToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .operationalDataToDelete)
        var operationalDataToDeleteDecoded0:[String]? = nil
        if let operationalDataToDeleteContainer = operationalDataToDeleteContainer {
            operationalDataToDeleteDecoded0 = [String]()
            for string0 in operationalDataToDeleteContainer {
                if let string0 = string0 {
                    operationalDataToDeleteDecoded0?.append(string0)
                }
            }
        }
        operationalDataToDelete = operationalDataToDeleteDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([OpsItemNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[OpsItemNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [OpsItemNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let relatedOpsItemsContainer = try containerValues.decodeIfPresent([RelatedOpsItem?].self, forKey: .relatedOpsItems)
        var relatedOpsItemsDecoded0:[RelatedOpsItem]? = nil
        if let relatedOpsItemsContainer = relatedOpsItemsContainer {
            relatedOpsItemsDecoded0 = [RelatedOpsItem]()
            for structure0 in relatedOpsItemsContainer {
                if let structure0 = structure0 {
                    relatedOpsItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedOpsItems = relatedOpsItemsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpsItemStatus.self, forKey: .status)
        status = statusDecoded
        let opsItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemId)
        opsItemId = opsItemIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let severityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severity)
        severity = severityDecoded
        let actualStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualStartTime)
        actualStartTime = actualStartTimeDecoded
        let actualEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .actualEndTime)
        actualEndTime = actualEndTimeDecoded
        let plannedStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedStartTime)
        plannedStartTime = plannedStartTimeDecoded
        let plannedEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .plannedEndTime)
        plannedEndTime = plannedEndTimeDecoded
    }
}

extension UpdateOpsItemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsItemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemAlreadyExistsException" : self = .opsItemAlreadyExistsException(try OpsItemAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemInvalidParameterException" : self = .opsItemInvalidParameterException(try OpsItemInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemLimitExceededException" : self = .opsItemLimitExceededException(try OpsItemLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsItemNotFoundException" : self = .opsItemNotFoundException(try OpsItemNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsItemOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsItemAlreadyExistsException(OpsItemAlreadyExistsException)
    case opsItemInvalidParameterException(OpsItemInvalidParameterException)
    case opsItemLimitExceededException(OpsItemLimitExceededException)
    case opsItemNotFoundException(OpsItemNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsItemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpsItemOutputResponse()"}
}

extension UpdateOpsItemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOpsItemOutputResponse: Equatable {

    public init() {}
}

struct UpdateOpsItemOutputResponseBody: Equatable {
}

extension UpdateOpsItemOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateOpsMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOpsMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsMetadataOutputError>
}

extension UpdateOpsMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpsMetadataInput(keysToDelete: \(String(describing: keysToDelete)), metadataToUpdate: \(String(describing: metadataToUpdate)), opsMetadataArn: \(String(describing: opsMetadataArn)))"}
}

extension UpdateOpsMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keysToDelete = keysToDelete {
            var keysToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keysToDelete)
            for metadatakeystodeletelist0 in keysToDelete {
                try keysToDeleteContainer.encode(metadatakeystodeletelist0)
            }
        }
        if let metadataToUpdate = metadataToUpdate {
            var metadataToUpdateContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metadataToUpdate)
            for (dictKey0, metadatamap0) in metadataToUpdate {
                try metadataToUpdateContainer.encode(metadatamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let opsMetadataArn = opsMetadataArn {
            try encodeContainer.encode(opsMetadataArn, forKey: .opsMetadataArn)
        }
    }
}

public struct UpdateOpsMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOpsMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOpsMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOpsMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOpsMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOpsMetadataInput>
    public typealias MOutput = OperationOutput<UpdateOpsMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOpsMetadataOutputError>
}

public struct UpdateOpsMetadataInput: Equatable {
    /// <p>The metadata keys to delete from the OpsMetadata object. </p>
    public let keysToDelete: [String]?
    /// <p>Metadata to add to an OpsMetadata object.</p>
    public let metadataToUpdate: [String:MetadataValue]?
    /// <p>The Amazon Resoure Name (ARN) of the OpsMetadata Object to update.</p>
    public let opsMetadataArn: String?

    public init (
        keysToDelete: [String]? = nil,
        metadataToUpdate: [String:MetadataValue]? = nil,
        opsMetadataArn: String? = nil
    )
    {
        self.keysToDelete = keysToDelete
        self.metadataToUpdate = metadataToUpdate
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataInputBody: Equatable {
    public let opsMetadataArn: String?
    public let metadataToUpdate: [String:MetadataValue]?
    public let keysToDelete: [String]?
}

extension UpdateOpsMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keysToDelete = "KeysToDelete"
        case metadataToUpdate = "MetadataToUpdate"
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
        let metadataToUpdateContainer = try containerValues.decodeIfPresent([String: MetadataValue?].self, forKey: .metadataToUpdate)
        var metadataToUpdateDecoded0: [String:MetadataValue]? = nil
        if let metadataToUpdateContainer = metadataToUpdateContainer {
            metadataToUpdateDecoded0 = [String:MetadataValue]()
            for (key0, metadatavalue0) in metadataToUpdateContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataToUpdateDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadataToUpdate = metadataToUpdateDecoded0
        let keysToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keysToDelete)
        var keysToDeleteDecoded0:[String]? = nil
        if let keysToDeleteContainer = keysToDeleteContainer {
            keysToDeleteDecoded0 = [String]()
            for string0 in keysToDeleteContainer {
                if let string0 = string0 {
                    keysToDeleteDecoded0?.append(string0)
                }
            }
        }
        keysToDelete = keysToDeleteDecoded0
    }
}

extension UpdateOpsMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOpsMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataInvalidArgumentException" : self = .opsMetadataInvalidArgumentException(try OpsMetadataInvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataKeyLimitExceededException" : self = .opsMetadataKeyLimitExceededException(try OpsMetadataKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataNotFoundException" : self = .opsMetadataNotFoundException(try OpsMetadataNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OpsMetadataTooManyUpdatesException" : self = .opsMetadataTooManyUpdatesException(try OpsMetadataTooManyUpdatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOpsMetadataOutputError: Equatable {
    case internalServerError(InternalServerError)
    case opsMetadataInvalidArgumentException(OpsMetadataInvalidArgumentException)
    case opsMetadataKeyLimitExceededException(OpsMetadataKeyLimitExceededException)
    case opsMetadataNotFoundException(OpsMetadataNotFoundException)
    case opsMetadataTooManyUpdatesException(OpsMetadataTooManyUpdatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOpsMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOpsMetadataOutputResponse(opsMetadataArn: \(String(describing: opsMetadataArn)))"}
}

extension UpdateOpsMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateOpsMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.opsMetadataArn = output.opsMetadataArn
        } else {
            self.opsMetadataArn = nil
        }
    }
}

public struct UpdateOpsMetadataOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the OpsMetadata Object that was updated.</p>
    public let opsMetadataArn: String?

    public init (
        opsMetadataArn: String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

struct UpdateOpsMetadataOutputResponseBody: Equatable {
    public let opsMetadataArn: String?
}

extension UpdateOpsMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case opsMetadataArn = "OpsMetadataArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsMetadataArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsMetadataArn)
        opsMetadataArn = opsMetadataArnDecoded
    }
}

public struct UpdatePatchBaselineInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePatchBaselineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePatchBaselineOutputError>
}

extension UpdatePatchBaselineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePatchBaselineInput(approvalRules: \(String(describing: approvalRules)), approvedPatches: \(String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(String(describing: baselineId)), description: \(String(describing: description)), globalFilters: \(String(describing: globalFilters)), name: \(String(describing: name)), rejectedPatches: \(String(describing: rejectedPatches)), rejectedPatchesAction: \(String(describing: rejectedPatchesAction)), replace: \(String(describing: replace)), sources: \(String(describing: sources)))"}
}

extension UpdatePatchBaselineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let baselineId = baselineId {
            try encodeContainer.encode(baselineId, forKey: .baselineId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalFilters = globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if replace != false {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }
}

public struct UpdatePatchBaselineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePatchBaselineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePatchBaselineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePatchBaselineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePatchBaselineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePatchBaselineInput>
    public typealias MOutput = OperationOutput<UpdatePatchBaselineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePatchBaselineOutputError>
}

public struct UpdatePatchBaselineInput: Equatable {
    /// <p>A set of rules used to include patches in the baseline.</p>
    public let approvalRules: PatchRuleGroup?
    /// <p>A list of explicitly approved patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let approvedPatches: [String]?
    /// <p>Assigns a new compliance severity level to an existing patch baseline.</p>
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    ///    applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    public let approvedPatchesEnableNonSecurity: Bool
    /// <p>The ID of the patch baseline to update.</p>
    public let baselineId: String?
    /// <p>A description of the patch baseline.</p>
    public let description: String?
    /// <p>A set of global filters used to include patches in the baseline.</p>
    public let globalFilters: PatchFilterGroup?
    /// <p>The name of the patch baseline.</p>
    public let name: String?
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    ///          <p>For information about accepted formats for lists of approved patches and rejected patches,
    ///                         see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">About
    ///                         package name formats for approved and rejected patch lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
    public let rejectedPatches: [String]?
    /// <p>The action for Patch Manager to take on patches included in the RejectedPackages
    ///    list.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches
    ///      list is installed only if it is a dependency of another package. It is considered compliant
    ///      with the patch baseline, and its status is reported as <i>InstalledOther</i>.
    ///      This is the default action if no option is specified.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>BLOCK</b>: Packages in the RejectedPatches list, and packages
    ///      that include them as dependencies, are not installed under any circumstances. If a package was
    ///      installed before it was added to the Rejected patches list, it is considered non-compliant with
    ///      the patch baseline, and its status is reported as
    ///      <i>InstalledRejected</i>.</p>
    ///             </li>
    ///          </ul>
    public let rejectedPatchesAction: PatchAction?
    /// <p>If True, then all fields that are required by the CreatePatchBaseline action are also
    ///    required for this API request. Optional fields that are not specified are set to null.</p>
    public let replace: Bool
    /// <p>Information about the patches to use to update the instances, including target operating
    ///    systems and source repositories. Applies to Linux instances only.</p>
    public let sources: [PatchSource]?

    public init (
        approvalRules: PatchRuleGroup? = nil,
        approvedPatches: [String]? = nil,
        approvedPatchesComplianceLevel: PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Bool = false,
        baselineId: String? = nil,
        description: String? = nil,
        globalFilters: PatchFilterGroup? = nil,
        name: String? = nil,
        rejectedPatches: [String]? = nil,
        rejectedPatchesAction: PatchAction? = nil,
        replace: Bool = false,
        sources: [PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.replace = replace
        self.sources = sources
    }
}

struct UpdatePatchBaselineInputBody: Equatable {
    public let baselineId: String?
    public let name: String?
    public let globalFilters: PatchFilterGroup?
    public let approvalRules: PatchRuleGroup?
    public let approvedPatches: [String]?
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Bool
    public let rejectedPatches: [String]?
    public let rejectedPatchesAction: PatchAction?
    public let description: String?
    public let sources: [PatchSource]?
    public let replace: Bool
}

extension UpdatePatchBaselineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case name = "Name"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case replace = "Replace"
        case sources = "Sources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let replaceDecoded = try containerValues.decode(Bool.self, forKey: .replace)
        replace = replaceDecoded
    }
}

extension UpdatePatchBaselineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePatchBaselineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DoesNotExistException" : self = .doesNotExistException(try DoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePatchBaselineOutputError: Equatable {
    case doesNotExistException(DoesNotExistException)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePatchBaselineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePatchBaselineOutputResponse(approvalRules: \(String(describing: approvalRules)), approvedPatches: \(String(describing: approvedPatches)), approvedPatchesComplianceLevel: \(String(describing: approvedPatchesComplianceLevel)), approvedPatchesEnableNonSecurity: \(String(describing: approvedPatchesEnableNonSecurity)), baselineId: \(String(describing: baselineId)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), globalFilters: \(String(describing: globalFilters)), modifiedDate: \(String(describing: modifiedDate)), name: \(String(describing: name)), operatingSystem: \(String(describing: operatingSystem)), rejectedPatches: \(String(describing: rejectedPatches)), rejectedPatchesAction: \(String(describing: rejectedPatchesAction)), sources: \(String(describing: sources)))"}
}

extension UpdatePatchBaselineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePatchBaselineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRules = output.approvalRules
            self.approvedPatches = output.approvedPatches
            self.approvedPatchesComplianceLevel = output.approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = output.approvedPatchesEnableNonSecurity
            self.baselineId = output.baselineId
            self.createdDate = output.createdDate
            self.description = output.description
            self.globalFilters = output.globalFilters
            self.modifiedDate = output.modifiedDate
            self.name = output.name
            self.operatingSystem = output.operatingSystem
            self.rejectedPatches = output.rejectedPatches
            self.rejectedPatchesAction = output.rejectedPatchesAction
            self.sources = output.sources
        } else {
            self.approvalRules = nil
            self.approvedPatches = nil
            self.approvedPatchesComplianceLevel = nil
            self.approvedPatchesEnableNonSecurity = false
            self.baselineId = nil
            self.createdDate = nil
            self.description = nil
            self.globalFilters = nil
            self.modifiedDate = nil
            self.name = nil
            self.operatingSystem = nil
            self.rejectedPatches = nil
            self.rejectedPatchesAction = nil
            self.sources = nil
        }
    }
}

public struct UpdatePatchBaselineOutputResponse: Equatable {
    /// <p>A set of rules used to include patches in the baseline.</p>
    public let approvalRules: PatchRuleGroup?
    /// <p>A list of explicitly approved patches for the baseline.</p>
    public let approvedPatches: [String]?
    /// <p>The compliance severity level assigned to the patch baseline after the update
    ///    completed.</p>
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    /// <p>Indicates whether the list of approved patches includes non-security updates that should be
    ///    applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
    public let approvedPatchesEnableNonSecurity: Bool
    /// <p>The ID of the deleted patch baseline.</p>
    public let baselineId: String?
    /// <p>The date when the patch baseline was created.</p>
    public let createdDate: Date?
    /// <p>A description of the Patch Baseline.</p>
    public let description: String?
    /// <p>A set of global filters used to exclude patches from the baseline.</p>
    public let globalFilters: PatchFilterGroup?
    /// <p>The date when the patch baseline was last modified.</p>
    public let modifiedDate: Date?
    /// <p>The name of the patch baseline.</p>
    public let name: String?
    /// <p>The operating system rule used by the updated patch baseline.</p>
    public let operatingSystem: OperatingSystem?
    /// <p>A list of explicitly rejected patches for the baseline.</p>
    public let rejectedPatches: [String]?
    /// <p>The action specified to take on patches included in the RejectedPatches list. A patch can be
    ///    allowed only if it is a dependency of another package, or blocked entirely along with packages
    ///    that include it as a dependency.</p>
    public let rejectedPatchesAction: PatchAction?
    /// <p>Information about the patches to use to update the instances, including target operating
    ///    systems and source repositories. Applies to Linux instances only.</p>
    public let sources: [PatchSource]?

    public init (
        approvalRules: PatchRuleGroup? = nil,
        approvedPatches: [String]? = nil,
        approvedPatchesComplianceLevel: PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Bool = false,
        baselineId: String? = nil,
        createdDate: Date? = nil,
        description: String? = nil,
        globalFilters: PatchFilterGroup? = nil,
        modifiedDate: Date? = nil,
        name: String? = nil,
        operatingSystem: OperatingSystem? = nil,
        rejectedPatches: [String]? = nil,
        rejectedPatchesAction: PatchAction? = nil,
        sources: [PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

struct UpdatePatchBaselineOutputResponseBody: Equatable {
    public let baselineId: String?
    public let name: String?
    public let operatingSystem: OperatingSystem?
    public let globalFilters: PatchFilterGroup?
    public let approvalRules: PatchRuleGroup?
    public let approvedPatches: [String]?
    public let approvedPatchesComplianceLevel: PatchComplianceLevel?
    public let approvedPatchesEnableNonSecurity: Bool
    public let rejectedPatches: [String]?
    public let rejectedPatchesAction: PatchAction?
    public let createdDate: Date?
    public let modifiedDate: Date?
    public let description: String?
    public let sources: [PatchSource]?
}

extension UpdatePatchBaselineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case baselineId = "BaselineId"
        case createdDate = "CreatedDate"
        case description = "Description"
        case globalFilters = "GlobalFilters"
        case modifiedDate = "ModifiedDate"
        case name = "Name"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baselineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baselineId)
        baselineId = baselineIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decode(Bool.self, forKey: .approvedPatchesEnableNonSecurity)
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public struct UpdateResourceDataSyncInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceDataSyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDataSyncOutputError>
}

extension UpdateResourceDataSyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceDataSyncInput(syncName: \(String(describing: syncName)), syncSource: \(String(describing: syncSource)), syncType: \(String(describing: syncType)))"}
}

extension UpdateResourceDataSyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncName = syncName {
            try encodeContainer.encode(syncName, forKey: .syncName)
        }
        if let syncSource = syncSource {
            try encodeContainer.encode(syncSource, forKey: .syncSource)
        }
        if let syncType = syncType {
            try encodeContainer.encode(syncType, forKey: .syncType)
        }
    }
}

public struct UpdateResourceDataSyncInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceDataSyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceDataSyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceDataSyncInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceDataSyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceDataSyncInput>
    public typealias MOutput = OperationOutput<UpdateResourceDataSyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceDataSyncOutputError>
}

public struct UpdateResourceDataSyncInput: Equatable {
    /// <p>The name of the resource data sync you want to update.</p>
    public let syncName: String?
    /// <p>Specify information about the data sources to synchronize.</p>
    public let syncSource: ResourceDataSyncSource?
    /// <p>The type of resource data sync. The supported <code>SyncType</code> is
    ///    SyncFromSource.</p>
    public let syncType: String?

    public init (
        syncName: String? = nil,
        syncSource: ResourceDataSyncSource? = nil,
        syncType: String? = nil
    )
    {
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

struct UpdateResourceDataSyncInputBody: Equatable {
    public let syncName: String?
    public let syncType: String?
    public let syncSource: ResourceDataSyncSource?
}

extension UpdateResourceDataSyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case syncName = "SyncName"
        case syncSource = "SyncSource"
        case syncType = "SyncType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncName)
        syncName = syncNameDecoded
        let syncTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .syncType)
        syncType = syncTypeDecoded
        let syncSourceDecoded = try containerValues.decodeIfPresent(ResourceDataSyncSource.self, forKey: .syncSource)
        syncSource = syncSourceDecoded
    }
}

extension UpdateResourceDataSyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceDataSyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncConflictException" : self = .resourceDataSyncConflictException(try ResourceDataSyncConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncInvalidConfigurationException" : self = .resourceDataSyncInvalidConfigurationException(try ResourceDataSyncInvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDataSyncNotFoundException" : self = .resourceDataSyncNotFoundException(try ResourceDataSyncNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceDataSyncOutputError: Equatable {
    case internalServerError(InternalServerError)
    case resourceDataSyncConflictException(ResourceDataSyncConflictException)
    case resourceDataSyncInvalidConfigurationException(ResourceDataSyncInvalidConfigurationException)
    case resourceDataSyncNotFoundException(ResourceDataSyncNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceDataSyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceDataSyncOutputResponse()"}
}

extension UpdateResourceDataSyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceDataSyncOutputResponse: Equatable {

    public init() {}
}

struct UpdateResourceDataSyncOutputResponseBody: Equatable {
}

extension UpdateResourceDataSyncOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServiceSettingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingOutputError>
}

extension UpdateServiceSettingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSettingInput(settingId: \(String(describing: settingId)), settingValue: \(String(describing: settingValue)))"}
}

extension UpdateServiceSettingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let settingId = settingId {
            try encodeContainer.encode(settingId, forKey: .settingId)
        }
        if let settingValue = settingValue {
            try encodeContainer.encode(settingValue, forKey: .settingValue)
        }
    }
}

public struct UpdateServiceSettingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingOutputError>
}

public struct UpdateServiceSettingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServiceSettingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServiceSettingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServiceSettingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServiceSettingInput>
    public typealias MOutput = OperationOutput<UpdateServiceSettingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServiceSettingOutputError>
}

/// <p>The request body of the UpdateServiceSetting API action.</p>
public struct UpdateServiceSettingInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the service setting to reset. For example,
    ///     <code>arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled</code>.
    ///    The setting ID can be one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-destination</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/automation/customer-script-log-group-name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/documents/console/public-sharing-permission</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/default-parameter-tier</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/parameter-store/high-throughput-enabled</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>/ssm/managed-instance/activation-tier</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let settingId: String?
    /// <p>The new value to specify for the service setting. For the
    ///     <code>/ssm/parameter-store/default-parameter-tier</code> setting ID, the setting value can be
    ///    one of the following.</p>
    ///          <ul>
    ///             <li>
    ///                <p>Standard</p>
    ///             </li>
    ///             <li>
    ///                <p>Advanced</p>
    ///             </li>
    ///             <li>
    ///                <p>Intelligent-Tiering</p>
    ///             </li>
    ///          </ul>
    ///          <p>For the <code>/ssm/parameter-store/high-throughput-enabled</code>, and
    ///     <code>/ssm/managed-instance/activation-tier</code> setting IDs, the setting value can be true or
    ///    false.</p>
    ///          <p>For the <code>/ssm/automation/customer-script-log-destination</code> setting ID, the setting
    ///    value can be CloudWatch.</p>
    ///          <p>For the <code>/ssm/automation/customer-script-log-group-name</code> setting ID, the setting
    ///    value can be the name of a CloudWatch Logs log group.</p>
    ///          <p>For the <code>/ssm/documents/console/public-sharing-permission</code> setting ID, the setting
    ///    value can be Enable or Disable.</p>
    public let settingValue: String?

    public init (
        settingId: String? = nil,
        settingValue: String? = nil
    )
    {
        self.settingId = settingId
        self.settingValue = settingValue
    }
}

struct UpdateServiceSettingInputBody: Equatable {
    public let settingId: String?
    public let settingValue: String?
}

extension UpdateServiceSettingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case settingId = "SettingId"
        case settingValue = "SettingValue"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingId)
        settingId = settingIdDecoded
        let settingValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .settingValue)
        settingValue = settingValueDecoded
    }
}

extension UpdateServiceSettingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceSettingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceSettingNotFound" : self = .serviceSettingNotFound(try ServiceSettingNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUpdates" : self = .tooManyUpdates(try TooManyUpdates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceSettingOutputError: Equatable {
    case internalServerError(InternalServerError)
    case serviceSettingNotFound(ServiceSettingNotFound)
    case tooManyUpdates(TooManyUpdates)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceSettingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServiceSettingOutputResponse()"}
}

extension UpdateServiceSettingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The result body of the UpdateServiceSetting API action.</p>
public struct UpdateServiceSettingOutputResponse: Equatable {

    public init() {}
}

struct UpdateServiceSettingOutputResponseBody: Equatable {
}

extension UpdateServiceSettingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
