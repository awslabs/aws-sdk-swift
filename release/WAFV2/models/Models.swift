// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActionCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ActionValue.self, forKey: .action)
        action = actionDecoded
    }
}

extension ActionCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionCondition(action: \(String(describing: action)))"}
}

/// <p>A single action condition for a <a>Condition</a> in a logging filter.</p>
public struct ActionCondition: Equatable {
    /// <p>The action setting that a log record must contain in order to meet the condition. </p>
    public let action: ActionValue?

    public init (
        action: ActionValue? = nil
    )
    {
        self.action = action
    }
}

public enum ActionValue {
    case allow
    case block
    case count
    case sdkUnknown(String)
}

extension ActionValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionValue] {
        return [
            .allow,
            .block,
            .count,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .block: return "BLOCK"
        case .count: return "COUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionValue(rawValue: rawValue) ?? ActionValue.sdkUnknown(rawValue)
    }
}

extension All: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension All: CustomDebugStringConvertible {
    public var debugDescription: String {
        "All()"}
}

/// <p>Inspect all of the elements that AWS WAF has parsed and extracted from the web request JSON body that are within the <a>JsonBody</a>
///             <code>MatchScope</code>. This is used with the <a>FieldToMatch</a> option <code>JsonBody</code>.  </p>
///          <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct All: Equatable {

    public init() {}
}

extension AllQueryArguments: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension AllQueryArguments: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllQueryArguments()"}
}

/// <p>All query arguments of a web request. </p>
///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct AllQueryArguments: Equatable {

    public init() {}
}

extension AllowAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRequestHandling = "CustomRequestHandling"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRequestHandling = customRequestHandling {
            try encodeContainer.encode(customRequestHandling, forKey: .customRequestHandling)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRequestHandlingDecoded = try containerValues.decodeIfPresent(CustomRequestHandling.self, forKey: .customRequestHandling)
        customRequestHandling = customRequestHandlingDecoded
    }
}

extension AllowAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllowAction(customRequestHandling: \(String(describing: customRequestHandling)))"}
}

/// <p>Specifies that AWS WAF should allow the request and optionally defines additional custom handling for the request.</p>
///            <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
public struct AllowAction: Equatable {
    /// <p>Defines custom handling for the web request.</p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customRequestHandling: CustomRequestHandling?

    public init (
        customRequestHandling: CustomRequestHandling? = nil
    )
    {
        self.customRequestHandling = customRequestHandling
    }
}

extension AndStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statements = "Statements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statements = statements {
            var statementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statements)
            for statements0 in statements {
                try statementsContainer.encode(statements0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([Statement?].self, forKey: .statements)
        var statementsDecoded0:[Statement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [Statement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension AndStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AndStatement(statements: \(String(describing: statements)))"}
}

/// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <a>Statement</a> within the <code>AndStatement</code>. </p>
public struct AndStatement: Equatable {
    /// <p>The statements to combine with AND logic. You can use any statements that can be nested. </p>
    public let statements: [Statement]?

    public init (
        statements: [Statement]? = nil
    )
    {
        self.statements = statements
    }
}

public struct AssociateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebACLInput>
    public typealias MOutput = OperationOutput<AssociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebACLOutputError>
}

extension AssociateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebACLInput(resourceArn: \(String(describing: resourceArn)), webACLArn: \(String(describing: webACLArn)))"}
}

extension AssociateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case webACLArn = "WebACLArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let webACLArn = webACLArn {
            try encodeContainer.encode(webACLArn, forKey: .webACLArn)
        }
    }
}

public struct AssociateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebACLInput>
    public typealias MOutput = OperationOutput<AssociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebACLOutputError>
}

public struct AssociateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebACLInput>
    public typealias MOutput = OperationOutput<AssociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebACLOutputError>
}

public struct AssociateWebACLInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to associate with the web ACL. </p>
    ///
    ///          <p>The ARN must be in one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let resourceArn: String?
    /// <p>The Amazon Resource Name (ARN) of the Web ACL that you want to associate with the resource.</p>
    public let webACLArn: String?

    public init (
        resourceArn: String? = nil,
        webACLArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.webACLArn = webACLArn
    }
}

struct AssociateWebACLInputBody: Equatable {
    public let webACLArn: String?
    public let resourceArn: String?
}

extension AssociateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case webACLArn = "WebACLArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLArn)
        webACLArn = webACLArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension AssociateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebACLOutputResponse()"}
}

extension AssociateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWebACLOutputResponse: Equatable {

    public init() {}
}

struct AssociateWebACLOutputResponseBody: Equatable {
}

extension AssociateWebACLOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension BlockAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customResponse = "CustomResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponse = customResponse {
            try encodeContainer.encode(customResponse, forKey: .customResponse)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customResponseDecoded = try containerValues.decodeIfPresent(CustomResponse.self, forKey: .customResponse)
        customResponse = customResponseDecoded
    }
}

extension BlockAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlockAction(customResponse: \(String(describing: customResponse)))"}
}

/// <p>Specifies that AWS WAF should block the request and optionally defines additional custom handling for the response to the web request.</p>
///            <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
public struct BlockAction: Equatable {
    /// <p>Defines a custom response for the web request.</p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponse: CustomResponse?

    public init (
        customResponse: CustomResponse? = nil
    )
    {
        self.customResponse = customResponse
    }
}

extension Body: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension Body: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Body()"}
}

/// <p>The body of a web request. This immediately follows the request headers.</p>
///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct Body: Equatable {

    public init() {}
}

public enum BodyParsingFallbackBehavior {
    case evaluateAsString
    case match
    case noMatch
    case sdkUnknown(String)
}

extension BodyParsingFallbackBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BodyParsingFallbackBehavior] {
        return [
            .evaluateAsString,
            .match,
            .noMatch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .evaluateAsString: return "EVALUATE_AS_STRING"
        case .match: return "MATCH"
        case .noMatch: return "NO_MATCH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BodyParsingFallbackBehavior(rawValue: rawValue) ?? BodyParsingFallbackBehavior.sdkUnknown(rawValue)
    }
}

extension ByteMatchStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case positionalConstraint = "PositionalConstraint"
        case searchString = "SearchString"
        case textTransformations = "TextTransformations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let positionalConstraint = positionalConstraint {
            try encodeContainer.encode(positionalConstraint.rawValue, forKey: .positionalConstraint)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString.base64EncodedString(), forKey: .searchString)
        }
        if let textTransformations = textTransformations {
            var textTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textTransformations)
            for texttransformations0 in textTransformations {
                try textTransformationsContainer.encode(texttransformations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .searchString)
        searchString = searchStringDecoded
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationsContainer = try containerValues.decodeIfPresent([TextTransformation?].self, forKey: .textTransformations)
        var textTransformationsDecoded0:[TextTransformation]? = nil
        if let textTransformationsContainer = textTransformationsContainer {
            textTransformationsDecoded0 = [TextTransformation]()
            for structure0 in textTransformationsContainer {
                if let structure0 = structure0 {
                    textTransformationsDecoded0?.append(structure0)
                }
            }
        }
        textTransformations = textTransformationsDecoded0
        let positionalConstraintDecoded = try containerValues.decodeIfPresent(PositionalConstraint.self, forKey: .positionalConstraint)
        positionalConstraint = positionalConstraintDecoded
    }
}

extension ByteMatchStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByteMatchStatement(fieldToMatch: \(String(describing: fieldToMatch)), positionalConstraint: \(String(describing: positionalConstraint)), searchString: \(String(describing: searchString)), textTransformations: \(String(describing: textTransformations)))"}
}

/// <p>A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is refered to as a string match statement.</p>
public struct ByteMatchStatement: Equatable {
    /// <p>The part of a web request that you want AWS WAF to inspect. For more information, see <a>FieldToMatch</a>. </p>
    public let fieldToMatch: FieldToMatch?
    /// <p>The area within the portion of a web request that you want AWS WAF to search for <code>SearchString</code>. Valid values include the following:</p>
    ///          <p>
    ///             <b>CONTAINS</b>
    ///          </p>
    ///          <p>The specified part of the web request must include the value of <code>SearchString</code>, but the location doesn't matter.</p>		
    ///          <p>
    ///             <b>CONTAINS_WORD</b>
    ///          </p>
    ///          <p>The specified part of the web request must include the value of <code>SearchString</code>, and
    ///          <code>SearchString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition,
    ///          <code>SearchString</code> must be a word, which means that both of the following are true:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SearchString</code> is at the beginning of the specified part of the web request or is
    ///                   preceded by a character other than an alphanumeric character or underscore (_).
    ///                   Examples include the value of a header and <code>;BadBot</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SearchString</code> is at the end of the specified part of the web request or is
    ///                   followed by a character other than an alphanumeric character or underscore (_), for example,
    ///                   <code>BadBot;</code> and <code>-BadBot;</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <b>EXACTLY</b>
    ///          </p>
    ///          <p>The value of the specified part of the web request must exactly match the value of <code>SearchString</code>.</p>
    ///          <p>
    ///             <b>STARTS_WITH</b>
    ///          </p>
    ///          <p>The value of <code>SearchString</code> must appear at the beginning of the specified part of the web request.</p>		
    ///          <p>
    ///             <b>ENDS_WITH</b>
    ///          </p>
    ///          <p>The value of <code>SearchString</code> must appear at the end of the specified part of the web request.</p>
    public let positionalConstraint: PositionalConstraint?
    /// <p>A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in <a>FieldToMatch</a>. The maximum length of the value is 50 bytes.</p>
    ///          <p>Valid values depend on the component that you specify for inspection in <code>FieldToMatch</code>:</p>		
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Method</code>: The HTTP method that you want AWS WAF to search for. This indicates the type of operation specified in the request. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UriPath</code>: The value that you want AWS WAF to search for in the URI path,
    ///                for example, <code>/images/daily-ad.jpg</code>. </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If <code>SearchString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
    ///          <p>
    ///             <b>If you're using the AWS WAF API</b>
    ///          </p>
    ///          <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
    ///          <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the
    ///          value of <code>Data</code> is <code>User-Agent</code>. If you want to search the
    ///          <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode
    ///          <code>BadBot</code> using MIME
    ///          base64-encoding
    ///          and include the resulting value, <code>QmFkQm90</code>, in the value of
    ///          <code>SearchString</code>.</p>
    ///          <p>
    ///             <b>If you're using the AWS CLI or one of the AWS SDKs</b>
    ///          </p>
    ///          <p>The value that you want AWS WAF to search for. The SDK automatically base64 encodes the value.</p>
    public let searchString: Data?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    ///          If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the
    ///          content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    public let textTransformations: [TextTransformation]?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        positionalConstraint: PositionalConstraint? = nil,
        searchString: Data? = nil,
        textTransformations: [TextTransformation]? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.positionalConstraint = positionalConstraint
        self.searchString = searchString
        self.textTransformations = textTransformations
    }
}

public struct CheckCapacityInputBodyMiddleware: Middleware {
    public let id: String = "CheckCapacityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckCapacityInput>
    public typealias MOutput = OperationOutput<CheckCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckCapacityOutputError>
}

extension CheckCapacityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckCapacityInput(rules: \(String(describing: rules)), scope: \(String(describing: scope)))"}
}

extension CheckCapacityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct CheckCapacityInputHeadersMiddleware: Middleware {
    public let id: String = "CheckCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckCapacityInput>
    public typealias MOutput = OperationOutput<CheckCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckCapacityOutputError>
}

public struct CheckCapacityInputQueryItemMiddleware: Middleware {
    public let id: String = "CheckCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CheckCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<CheckCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CheckCapacityInput>
    public typealias MOutput = OperationOutput<CheckCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CheckCapacityOutputError>
}

public struct CheckCapacityInput: Equatable {
    /// <p>An array of <a>Rule</a> that you're configuring to use in a rule group or web ACL. </p>
    public let rules: [Rule]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        rules: [Rule]? = nil,
        scope: Scope? = nil
    )
    {
        self.rules = rules
        self.scope = scope
    }
}

struct CheckCapacityInputBody: Equatable {
    public let scope: Scope?
    public let rules: [Rule]?
}

extension CheckCapacityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CheckCapacityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CheckCapacityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidResourceException" : self = .wAFInvalidResourceException(try WAFInvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CheckCapacityOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFInvalidResourceException(WAFInvalidResourceException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CheckCapacityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CheckCapacityOutputResponse(capacity: \(String(describing: capacity)))"}
}

extension CheckCapacityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CheckCapacityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capacity = output.capacity
        } else {
            self.capacity = 0
        }
    }
}

public struct CheckCapacityOutputResponse: Equatable {
    /// <p>The capacity required by the rules and scope.</p>
    public let capacity: Int

    public init (
        capacity: Int = 0
    )
    {
        self.capacity = capacity
    }
}

struct CheckCapacityOutputResponseBody: Equatable {
    public let capacity: Int
}

extension CheckCapacityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decode(Int.self, forKey: .capacity)
        capacity = capacityDecoded
    }
}

public enum ComparisonOperator {
    case eq
    case ge
    case gt
    case le
    case lt
    case ne
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .eq,
            .ge,
            .gt,
            .le,
            .lt,
            .ne,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eq: return "EQ"
        case .ge: return "GE"
        case .gt: return "GT"
        case .le: return "LE"
        case .lt: return "LT"
        case .ne: return "NE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionCondition = "ActionCondition"
        case labelNameCondition = "LabelNameCondition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionCondition = actionCondition {
            try encodeContainer.encode(actionCondition, forKey: .actionCondition)
        }
        if let labelNameCondition = labelNameCondition {
            try encodeContainer.encode(labelNameCondition, forKey: .labelNameCondition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionConditionDecoded = try containerValues.decodeIfPresent(ActionCondition.self, forKey: .actionCondition)
        actionCondition = actionConditionDecoded
        let labelNameConditionDecoded = try containerValues.decodeIfPresent(LabelNameCondition.self, forKey: .labelNameCondition)
        labelNameCondition = labelNameConditionDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(actionCondition: \(String(describing: actionCondition)), labelNameCondition: \(String(describing: labelNameCondition)))"}
}

/// <p>A single match condition for a <a>Filter</a>.</p>
public struct Condition: Equatable {
    /// <p>A single action condition.</p>
    public let actionCondition: ActionCondition?
    /// <p>A single label name condition.</p>
    public let labelNameCondition: LabelNameCondition?

    public init (
        actionCondition: ActionCondition? = nil,
        labelNameCondition: LabelNameCondition? = nil
    )
    {
        self.actionCondition = actionCondition
        self.labelNameCondition = labelNameCondition
    }
}

extension CountAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRequestHandling = "CustomRequestHandling"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRequestHandling = customRequestHandling {
            try encodeContainer.encode(customRequestHandling, forKey: .customRequestHandling)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRequestHandlingDecoded = try containerValues.decodeIfPresent(CustomRequestHandling.self, forKey: .customRequestHandling)
        customRequestHandling = customRequestHandlingDecoded
    }
}

extension CountAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CountAction(customRequestHandling: \(String(describing: customRequestHandling)))"}
}

/// <p>Specifies that AWS WAF should count the request. Optionally defines additional custom handling for the request.</p>
///            <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
public struct CountAction: Equatable {
    /// <p>Defines custom handling for the web request.</p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customRequestHandling: CustomRequestHandling?

    public init (
        customRequestHandling: CustomRequestHandling? = nil
    )
    {
        self.customRequestHandling = customRequestHandling
    }
}

public enum CountryCode {
    case ad
    case ae
    case af
    case ag
    case ai
    case al
    case am
    case ao
    case aq
    case ar
    case `as`
    case at
    case au
    case aw
    case ax
    case az
    case ba
    case bb
    case bd
    case be
    case bf
    case bg
    case bh
    case bi
    case bj
    case bl
    case bm
    case bn
    case bo
    case bq
    case br
    case bs
    case bt
    case bv
    case bw
    case by
    case bz
    case ca
    case cc
    case cd
    case cf
    case cg
    case ch
    case ci
    case ck
    case cl
    case cm
    case cn
    case co
    case cr
    case cu
    case cv
    case cw
    case cx
    case cy
    case cz
    case de
    case dj
    case dk
    case dm
    case `do`
    case dz
    case ec
    case ee
    case eg
    case eh
    case er
    case es
    case et
    case fi
    case fj
    case fk
    case fm
    case fo
    case fr
    case ga
    case gb
    case gd
    case ge
    case gf
    case gg
    case gh
    case gi
    case gl
    case gm
    case gn
    case gp
    case gq
    case gr
    case gs
    case gt
    case gu
    case gw
    case gy
    case hk
    case hm
    case hn
    case hr
    case ht
    case hu
    case id
    case ie
    case il
    case im
    case `in`
    case io
    case iq
    case ir
    case `is`
    case it
    case je
    case jm
    case jo
    case jp
    case ke
    case kg
    case kh
    case ki
    case km
    case kn
    case kp
    case kr
    case kw
    case ky
    case kz
    case la
    case lb
    case lc
    case li
    case lk
    case lr
    case ls
    case lt
    case lu
    case lv
    case ly
    case ma
    case mc
    case md
    case me
    case mf
    case mg
    case mh
    case mk
    case ml
    case mm
    case mn
    case mo
    case mp
    case mq
    case mr
    case ms
    case mt
    case mu
    case mv
    case mw
    case mx
    case my
    case mz
    case na
    case nc
    case ne
    case nf
    case ng
    case ni
    case nl
    case no
    case np
    case nr
    case nu
    case nz
    case om
    case pa
    case pe
    case pf
    case pg
    case ph
    case pk
    case pl
    case pm
    case pn
    case pr
    case ps
    case pt
    case pw
    case py
    case qa
    case re
    case ro
    case rs
    case ru
    case rw
    case sa
    case sb
    case sc
    case sd
    case se
    case sg
    case sh
    case si
    case sj
    case sk
    case sl
    case sm
    case sn
    case so
    case sr
    case ss
    case st
    case sv
    case sx
    case sy
    case sz
    case tc
    case td
    case tf
    case tg
    case th
    case tj
    case tk
    case tl
    case tm
    case tn
    case to
    case tr
    case tt
    case tv
    case tw
    case tz
    case ua
    case ug
    case um
    case us
    case uy
    case uz
    case va
    case vc
    case ve
    case vg
    case vi
    case vn
    case vu
    case wf
    case ws
    case ye
    case yt
    case za
    case zm
    case zw
    case sdkUnknown(String)
}

extension CountryCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CountryCode] {
        return [
            .ad,
            .ae,
            .af,
            .ag,
            .ai,
            .al,
            .am,
            .ao,
            .aq,
            .ar,
            .as,
            .at,
            .au,
            .aw,
            .ax,
            .az,
            .ba,
            .bb,
            .bd,
            .be,
            .bf,
            .bg,
            .bh,
            .bi,
            .bj,
            .bl,
            .bm,
            .bn,
            .bo,
            .bq,
            .br,
            .bs,
            .bt,
            .bv,
            .bw,
            .by,
            .bz,
            .ca,
            .cc,
            .cd,
            .cf,
            .cg,
            .ch,
            .ci,
            .ck,
            .cl,
            .cm,
            .cn,
            .co,
            .cr,
            .cu,
            .cv,
            .cw,
            .cx,
            .cy,
            .cz,
            .de,
            .dj,
            .dk,
            .dm,
            .do,
            .dz,
            .ec,
            .ee,
            .eg,
            .eh,
            .er,
            .es,
            .et,
            .fi,
            .fj,
            .fk,
            .fm,
            .fo,
            .fr,
            .ga,
            .gb,
            .gd,
            .ge,
            .gf,
            .gg,
            .gh,
            .gi,
            .gl,
            .gm,
            .gn,
            .gp,
            .gq,
            .gr,
            .gs,
            .gt,
            .gu,
            .gw,
            .gy,
            .hk,
            .hm,
            .hn,
            .hr,
            .ht,
            .hu,
            .id,
            .ie,
            .il,
            .im,
            .in,
            .io,
            .iq,
            .ir,
            .is,
            .it,
            .je,
            .jm,
            .jo,
            .jp,
            .ke,
            .kg,
            .kh,
            .ki,
            .km,
            .kn,
            .kp,
            .kr,
            .kw,
            .ky,
            .kz,
            .la,
            .lb,
            .lc,
            .li,
            .lk,
            .lr,
            .ls,
            .lt,
            .lu,
            .lv,
            .ly,
            .ma,
            .mc,
            .md,
            .me,
            .mf,
            .mg,
            .mh,
            .mk,
            .ml,
            .mm,
            .mn,
            .mo,
            .mp,
            .mq,
            .mr,
            .ms,
            .mt,
            .mu,
            .mv,
            .mw,
            .mx,
            .my,
            .mz,
            .na,
            .nc,
            .ne,
            .nf,
            .ng,
            .ni,
            .nl,
            .no,
            .np,
            .nr,
            .nu,
            .nz,
            .om,
            .pa,
            .pe,
            .pf,
            .pg,
            .ph,
            .pk,
            .pl,
            .pm,
            .pn,
            .pr,
            .ps,
            .pt,
            .pw,
            .py,
            .qa,
            .re,
            .ro,
            .rs,
            .ru,
            .rw,
            .sa,
            .sb,
            .sc,
            .sd,
            .se,
            .sg,
            .sh,
            .si,
            .sj,
            .sk,
            .sl,
            .sm,
            .sn,
            .so,
            .sr,
            .ss,
            .st,
            .sv,
            .sx,
            .sy,
            .sz,
            .tc,
            .td,
            .tf,
            .tg,
            .th,
            .tj,
            .tk,
            .tl,
            .tm,
            .tn,
            .to,
            .tr,
            .tt,
            .tv,
            .tw,
            .tz,
            .ua,
            .ug,
            .um,
            .us,
            .uy,
            .uz,
            .va,
            .vc,
            .ve,
            .vg,
            .vi,
            .vn,
            .vu,
            .wf,
            .ws,
            .ye,
            .yt,
            .za,
            .zm,
            .zw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ad: return "AD"
        case .ae: return "AE"
        case .af: return "AF"
        case .ag: return "AG"
        case .ai: return "AI"
        case .al: return "AL"
        case .am: return "AM"
        case .ao: return "AO"
        case .aq: return "AQ"
        case .ar: return "AR"
        case .as: return "AS"
        case .at: return "AT"
        case .au: return "AU"
        case .aw: return "AW"
        case .ax: return "AX"
        case .az: return "AZ"
        case .ba: return "BA"
        case .bb: return "BB"
        case .bd: return "BD"
        case .be: return "BE"
        case .bf: return "BF"
        case .bg: return "BG"
        case .bh: return "BH"
        case .bi: return "BI"
        case .bj: return "BJ"
        case .bl: return "BL"
        case .bm: return "BM"
        case .bn: return "BN"
        case .bo: return "BO"
        case .bq: return "BQ"
        case .br: return "BR"
        case .bs: return "BS"
        case .bt: return "BT"
        case .bv: return "BV"
        case .bw: return "BW"
        case .by: return "BY"
        case .bz: return "BZ"
        case .ca: return "CA"
        case .cc: return "CC"
        case .cd: return "CD"
        case .cf: return "CF"
        case .cg: return "CG"
        case .ch: return "CH"
        case .ci: return "CI"
        case .ck: return "CK"
        case .cl: return "CL"
        case .cm: return "CM"
        case .cn: return "CN"
        case .co: return "CO"
        case .cr: return "CR"
        case .cu: return "CU"
        case .cv: return "CV"
        case .cw: return "CW"
        case .cx: return "CX"
        case .cy: return "CY"
        case .cz: return "CZ"
        case .de: return "DE"
        case .dj: return "DJ"
        case .dk: return "DK"
        case .dm: return "DM"
        case .do: return "DO"
        case .dz: return "DZ"
        case .ec: return "EC"
        case .ee: return "EE"
        case .eg: return "EG"
        case .eh: return "EH"
        case .er: return "ER"
        case .es: return "ES"
        case .et: return "ET"
        case .fi: return "FI"
        case .fj: return "FJ"
        case .fk: return "FK"
        case .fm: return "FM"
        case .fo: return "FO"
        case .fr: return "FR"
        case .ga: return "GA"
        case .gb: return "GB"
        case .gd: return "GD"
        case .ge: return "GE"
        case .gf: return "GF"
        case .gg: return "GG"
        case .gh: return "GH"
        case .gi: return "GI"
        case .gl: return "GL"
        case .gm: return "GM"
        case .gn: return "GN"
        case .gp: return "GP"
        case .gq: return "GQ"
        case .gr: return "GR"
        case .gs: return "GS"
        case .gt: return "GT"
        case .gu: return "GU"
        case .gw: return "GW"
        case .gy: return "GY"
        case .hk: return "HK"
        case .hm: return "HM"
        case .hn: return "HN"
        case .hr: return "HR"
        case .ht: return "HT"
        case .hu: return "HU"
        case .id: return "ID"
        case .ie: return "IE"
        case .il: return "IL"
        case .im: return "IM"
        case .in: return "IN"
        case .io: return "IO"
        case .iq: return "IQ"
        case .ir: return "IR"
        case .is: return "IS"
        case .it: return "IT"
        case .je: return "JE"
        case .jm: return "JM"
        case .jo: return "JO"
        case .jp: return "JP"
        case .ke: return "KE"
        case .kg: return "KG"
        case .kh: return "KH"
        case .ki: return "KI"
        case .km: return "KM"
        case .kn: return "KN"
        case .kp: return "KP"
        case .kr: return "KR"
        case .kw: return "KW"
        case .ky: return "KY"
        case .kz: return "KZ"
        case .la: return "LA"
        case .lb: return "LB"
        case .lc: return "LC"
        case .li: return "LI"
        case .lk: return "LK"
        case .lr: return "LR"
        case .ls: return "LS"
        case .lt: return "LT"
        case .lu: return "LU"
        case .lv: return "LV"
        case .ly: return "LY"
        case .ma: return "MA"
        case .mc: return "MC"
        case .md: return "MD"
        case .me: return "ME"
        case .mf: return "MF"
        case .mg: return "MG"
        case .mh: return "MH"
        case .mk: return "MK"
        case .ml: return "ML"
        case .mm: return "MM"
        case .mn: return "MN"
        case .mo: return "MO"
        case .mp: return "MP"
        case .mq: return "MQ"
        case .mr: return "MR"
        case .ms: return "MS"
        case .mt: return "MT"
        case .mu: return "MU"
        case .mv: return "MV"
        case .mw: return "MW"
        case .mx: return "MX"
        case .my: return "MY"
        case .mz: return "MZ"
        case .na: return "NA"
        case .nc: return "NC"
        case .ne: return "NE"
        case .nf: return "NF"
        case .ng: return "NG"
        case .ni: return "NI"
        case .nl: return "NL"
        case .no: return "NO"
        case .np: return "NP"
        case .nr: return "NR"
        case .nu: return "NU"
        case .nz: return "NZ"
        case .om: return "OM"
        case .pa: return "PA"
        case .pe: return "PE"
        case .pf: return "PF"
        case .pg: return "PG"
        case .ph: return "PH"
        case .pk: return "PK"
        case .pl: return "PL"
        case .pm: return "PM"
        case .pn: return "PN"
        case .pr: return "PR"
        case .ps: return "PS"
        case .pt: return "PT"
        case .pw: return "PW"
        case .py: return "PY"
        case .qa: return "QA"
        case .re: return "RE"
        case .ro: return "RO"
        case .rs: return "RS"
        case .ru: return "RU"
        case .rw: return "RW"
        case .sa: return "SA"
        case .sb: return "SB"
        case .sc: return "SC"
        case .sd: return "SD"
        case .se: return "SE"
        case .sg: return "SG"
        case .sh: return "SH"
        case .si: return "SI"
        case .sj: return "SJ"
        case .sk: return "SK"
        case .sl: return "SL"
        case .sm: return "SM"
        case .sn: return "SN"
        case .so: return "SO"
        case .sr: return "SR"
        case .ss: return "SS"
        case .st: return "ST"
        case .sv: return "SV"
        case .sx: return "SX"
        case .sy: return "SY"
        case .sz: return "SZ"
        case .tc: return "TC"
        case .td: return "TD"
        case .tf: return "TF"
        case .tg: return "TG"
        case .th: return "TH"
        case .tj: return "TJ"
        case .tk: return "TK"
        case .tl: return "TL"
        case .tm: return "TM"
        case .tn: return "TN"
        case .to: return "TO"
        case .tr: return "TR"
        case .tt: return "TT"
        case .tv: return "TV"
        case .tw: return "TW"
        case .tz: return "TZ"
        case .ua: return "UA"
        case .ug: return "UG"
        case .um: return "UM"
        case .us: return "US"
        case .uy: return "UY"
        case .uz: return "UZ"
        case .va: return "VA"
        case .vc: return "VC"
        case .ve: return "VE"
        case .vg: return "VG"
        case .vi: return "VI"
        case .vn: return "VN"
        case .vu: return "VU"
        case .wf: return "WF"
        case .ws: return "WS"
        case .ye: return "YE"
        case .yt: return "YT"
        case .za: return "ZA"
        case .zm: return "ZM"
        case .zw: return "ZW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CountryCode(rawValue: rawValue) ?? CountryCode.sdkUnknown(rawValue)
    }
}

public struct CreateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

extension CreateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetInput(addresses: \(String(describing: addresses)), description: \(String(describing: description)), iPAddressVersion: \(String(describing: iPAddressVersion)), name: \(String(describing: name)), scope: \(String(describing: scope)), tags: \(String(describing: tags)))"}
}

extension CreateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case description = "Description"
        case iPAddressVersion = "IPAddressVersion"
        case name = "Name"
        case scope = "Scope"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for ipaddresses0 in addresses {
                try addressesContainer.encode(ipaddresses0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iPAddressVersion = iPAddressVersion {
            try encodeContainer.encode(iPAddressVersion.rawValue, forKey: .iPAddressVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInput: Equatable {
    /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. AWS WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    ///                <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let addresses: [String]?
    /// <p>A description of the IP set that helps with identification. </p>
    public let description: String?
    /// <p>Specify IPV4 or IPV6. </p>
    public let iPAddressVersion: IPAddressVersion?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>An array of key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        addresses: [String]? = nil,
        description: String? = nil,
        iPAddressVersion: IPAddressVersion? = nil,
        name: String? = nil,
        scope: Scope? = nil,
        tags: [Tag]? = nil
    )
    {
        self.addresses = addresses
        self.description = description
        self.iPAddressVersion = iPAddressVersion
        self.name = name
        self.scope = scope
        self.tags = tags
    }
}

struct CreateIPSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let description: String?
    public let iPAddressVersion: IPAddressVersion?
    public let addresses: [String]?
    public let tags: [Tag]?
}

extension CreateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case description = "Description"
        case iPAddressVersion = "IPAddressVersion"
        case name = "Name"
        case scope = "Scope"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let iPAddressVersionDecoded = try containerValues.decodeIfPresent(IPAddressVersion.self, forKey: .iPAddressVersion)
        iPAddressVersion = iPAddressVersionDecoded
        let addressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addresses)
        var addressesDecoded0:[String]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [String]()
            for string0 in addressesContainer {
                if let string0 = string0 {
                    addressesDecoded0?.append(string0)
                }
            }
        }
        addresses = addressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIPSetOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateIPSetOutputResponse: Equatable {
    /// <p>High-level information about an <a>IPSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <a>IPSetReferenceStatement</a> to use the address set in a <a>Rule</a>.</p>
    public let summary: IPSetSummary?

    public init (
        summary: IPSetSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateIPSetOutputResponseBody: Equatable {
    public let summary: IPSetSummary?
}

extension CreateIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary = "Summary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(IPSetSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct CreateRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

extension CreateRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexPatternSetInput(description: \(String(describing: description)), name: \(String(describing: name)), regularExpressionList: \(String(describing: regularExpressionList)), scope: \(String(describing: scope)), tags: \(String(describing: tags)))"}
}

extension CreateRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case regularExpressionList = "RegularExpressionList"
        case scope = "Scope"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regularExpressionList = regularExpressionList {
            var regularExpressionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regularExpressionList)
            for regularexpressionlist0 in regularExpressionList {
                try regularExpressionListContainer.encode(regularexpressionlist0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

public struct CreateRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

public struct CreateRegexPatternSetInput: Equatable {
    /// <p>A description of the set that helps with identification. </p>
    public let description: String?
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    public let name: String?
    /// <p>Array of regular expression strings. </p>
    public let regularExpressionList: [Regex]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>An array of key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        name: String? = nil,
        regularExpressionList: [Regex]? = nil,
        scope: Scope? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.regularExpressionList = regularExpressionList
        self.scope = scope
        self.tags = tags
    }
}

struct CreateRegexPatternSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let description: String?
    public let regularExpressionList: [Regex]?
    public let tags: [Tag]?
}

extension CreateRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case regularExpressionList = "RegularExpressionList"
        case scope = "Scope"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let regularExpressionListContainer = try containerValues.decodeIfPresent([Regex?].self, forKey: .regularExpressionList)
        var regularExpressionListDecoded0:[Regex]? = nil
        if let regularExpressionListContainer = regularExpressionListContainer {
            regularExpressionListDecoded0 = [Regex]()
            for structure0 in regularExpressionListContainer {
                if let structure0 = structure0 {
                    regularExpressionListDecoded0?.append(structure0)
                }
            }
        }
        regularExpressionList = regularExpressionListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegexPatternSetOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexPatternSetOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateRegexPatternSetOutputResponse: Equatable {
    /// <p>High-level information about a <a>RegexPatternSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <a>RegexPatternSetReferenceStatement</a> to use the pattern set in a <a>Rule</a>.</p>
    public let summary: RegexPatternSetSummary?

    public init (
        summary: RegexPatternSetSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateRegexPatternSetOutputResponseBody: Equatable {
    public let summary: RegexPatternSetSummary?
}

extension CreateRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary = "Summary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(RegexPatternSetSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct CreateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

extension CreateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupInput(capacity: \(String(describing: capacity)), customResponseBodies: \(String(describing: customResponseBodies)), description: \(String(describing: description)), name: \(String(describing: name)), rules: \(String(describing: rules)), scope: \(String(describing: scope)), tags: \(String(describing: tags)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

extension CreateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
        case customResponseBodies = "CustomResponseBodies"
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case tags = "Tags"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }
}

public struct CreateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInput: Equatable {
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    ///           <p>When you create your own rule group, you define this, and you cannot change it after creation.
    ///           When you add or modify the rules in a rule group, AWS WAF enforces this limit. You can check the capacity
    ///           for a set of rules using <a>CheckCapacity</a>.</p>
    ///           <p>AWS WAF uses WCUs to calculate and control the operating
    ///          resources that are used to run your rules, rule groups, and web ACLs. AWS WAF
    ///          calculates capacity differently for each rule type, to reflect the relative cost of each rule.
    ///          Simple rules that cost little to run use fewer WCUs than more complex rules
    /// 				that use more processing power.
    /// 				Rule group capacity is fixed at creation, which helps users plan their
    ///          web ACL WCU usage when they use a rule group.
    ///          The WCU limit for web ACLs is 1,500.  </p>
    public let capacity: Int
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>A description of the rule group that helps with identification. </p>
    public let description: String?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>An array of key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        capacity: Int = 0,
        customResponseBodies: [String:CustomResponseBody]? = nil,
        description: String? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        scope: Scope? = nil,
        tags: [Tag]? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.capacity = capacity
        self.customResponseBodies = customResponseBodies
        self.description = description
        self.name = name
        self.rules = rules
        self.scope = scope
        self.tags = tags
        self.visibilityConfig = visibilityConfig
    }
}

struct CreateRuleGroupInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let capacity: Int
    public let description: String?
    public let rules: [Rule]?
    public let visibilityConfig: VisibilityConfig?
    public let tags: [Tag]?
    public let customResponseBodies: [String:CustomResponseBody]?
}

extension CreateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
        case customResponseBodies = "CustomResponseBodies"
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case tags = "Tags"
        case visibilityConfig = "VisibilityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let capacityDecoded = try containerValues.decode(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
    }
}

extension CreateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleGroupOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateRuleGroupOutputResponse: Equatable {
    /// <p>High-level information about a <a>RuleGroup</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <a>RuleGroupReferenceStatement</a> to use the rule group in a <a>Rule</a>.</p>
    public let summary: RuleGroupSummary?

    public init (
        summary: RuleGroupSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateRuleGroupOutputResponseBody: Equatable {
    public let summary: RuleGroupSummary?
}

extension CreateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary = "Summary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(RuleGroupSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

public struct CreateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "CreateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

extension CreateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLInput(customResponseBodies: \(String(describing: customResponseBodies)), defaultAction: \(String(describing: defaultAction)), description: \(String(describing: description)), name: \(String(describing: name)), rules: \(String(describing: rules)), scope: \(String(describing: scope)), tags: \(String(describing: tags)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

extension CreateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case tags = "Tags"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }
}

public struct CreateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

public struct CreateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

public struct CreateWebACLInput: Equatable {
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    public let defaultAction: DefaultAction?
    /// <p>A description of the Web ACL that helps with identification. </p>
    public let description: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>An array of key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        customResponseBodies: [String:CustomResponseBody]? = nil,
        defaultAction: DefaultAction? = nil,
        description: String? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        scope: Scope? = nil,
        tags: [Tag]? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.customResponseBodies = customResponseBodies
        self.defaultAction = defaultAction
        self.description = description
        self.name = name
        self.rules = rules
        self.scope = scope
        self.tags = tags
        self.visibilityConfig = visibilityConfig
    }
}

struct CreateWebACLInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let defaultAction: DefaultAction?
    public let description: String?
    public let rules: [Rule]?
    public let visibilityConfig: VisibilityConfig?
    public let tags: [Tag]?
    public let customResponseBodies: [String:CustomResponseBody]?
}

extension CreateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case tags = "Tags"
        case visibilityConfig = "VisibilityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
    }
}

extension CreateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidResourceException" : self = .wAFInvalidResourceException(try WAFInvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebACLOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFInvalidResourceException(WAFInvalidResourceException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLOutputResponse(summary: \(String(describing: summary)))"}
}

extension CreateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.summary = output.summary
        } else {
            self.summary = nil
        }
    }
}

public struct CreateWebACLOutputResponse: Equatable {
    /// <p>High-level information about a <a>WebACL</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <a>AssociateWebACL</a>.</p>
    public let summary: WebACLSummary?

    public init (
        summary: WebACLSummary? = nil
    )
    {
        self.summary = summary
    }
}

struct CreateWebACLOutputResponseBody: Equatable {
    public let summary: WebACLSummary?
}

extension CreateWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summary = "Summary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(WebACLSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension CustomHTTPHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CustomHTTPHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomHTTPHeader(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>A custom header for custom request and response handling. This is used in <a>CustomResponse</a> and <a>CustomRequestHandling</a>.</p>
public struct CustomHTTPHeader: Equatable {
    /// <p>The name of the custom header. </p>
    ///          <p>For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name <code>x-amzn-waf-</code>, to avoid confusion with the headers that are already in the request. For example, for the header name <code>sample</code>, AWS WAF inserts the header <code>x-amzn-waf-sample</code>.</p>
    public let name: String?
    /// <p>The value of the custom header.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension CustomRequestHandling: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insertHeaders = "InsertHeaders"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insertHeaders = insertHeaders {
            var insertHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insertHeaders)
            for customhttpheaders0 in insertHeaders {
                try insertHeadersContainer.encode(customhttpheaders0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insertHeadersContainer = try containerValues.decodeIfPresent([CustomHTTPHeader?].self, forKey: .insertHeaders)
        var insertHeadersDecoded0:[CustomHTTPHeader]? = nil
        if let insertHeadersContainer = insertHeadersContainer {
            insertHeadersDecoded0 = [CustomHTTPHeader]()
            for structure0 in insertHeadersContainer {
                if let structure0 = structure0 {
                    insertHeadersDecoded0?.append(structure0)
                }
            }
        }
        insertHeaders = insertHeadersDecoded0
    }
}

extension CustomRequestHandling: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRequestHandling(insertHeaders: \(String(describing: insertHeaders)))"}
}

/// <p>Custom request handling behavior that inserts custom headers into a web request. You can add custom request handling for the rule actions allow and count. </p>
///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
public struct CustomRequestHandling: Equatable {
    /// <p>The HTTP headers to insert into the request. Duplicate header names are not allowed. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let insertHeaders: [CustomHTTPHeader]?

    public init (
        insertHeaders: [CustomHTTPHeader]? = nil
    )
    {
        self.insertHeaders = insertHeaders
    }
}

extension CustomResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customResponseBodyKey = "CustomResponseBodyKey"
        case responseCode = "ResponseCode"
        case responseHeaders = "ResponseHeaders"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponseBodyKey = customResponseBodyKey {
            try encodeContainer.encode(customResponseBodyKey, forKey: .customResponseBodyKey)
        }
        if let responseCode = responseCode {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let responseHeaders = responseHeaders {
            var responseHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseHeaders)
            for customhttpheaders0 in responseHeaders {
                try responseHeadersContainer.encode(customhttpheaders0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseCodeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let customResponseBodyKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customResponseBodyKey)
        customResponseBodyKey = customResponseBodyKeyDecoded
        let responseHeadersContainer = try containerValues.decodeIfPresent([CustomHTTPHeader?].self, forKey: .responseHeaders)
        var responseHeadersDecoded0:[CustomHTTPHeader]? = nil
        if let responseHeadersContainer = responseHeadersContainer {
            responseHeadersDecoded0 = [CustomHTTPHeader]()
            for structure0 in responseHeadersContainer {
                if let structure0 = structure0 {
                    responseHeadersDecoded0?.append(structure0)
                }
            }
        }
        responseHeaders = responseHeadersDecoded0
    }
}

extension CustomResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomResponse(customResponseBodyKey: \(String(describing: customResponseBodyKey)), responseCode: \(String(describing: responseCode)), responseHeaders: \(String(describing: responseHeaders)))"}
}

/// <p>A custom response to send to the client. You can define a custom response for rule actions and default web ACL actions that are set to <a>BlockAction</a>. </p>
///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
public struct CustomResponse: Equatable {
    /// <p>References the response body that you want AWS WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block. To do this, you first
    ///        define the response body key and value in the <code>CustomResponseBodies</code> setting for the <a>WebACL</a> or <a>RuleGroup</a> where you want to use it. Then, in the rule action or web ACL default action <code>BlockAction</code> setting, you reference
    ///        the response body using this key. </p>
    public let customResponseBodyKey: String?
    /// <p>The HTTP status code to return to the client. </p>
    ///          <p>For a list of status codes that you can use in your custom reqponses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported status codes for custom response</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let responseCode: Int?
    /// <p>The HTTP headers to use in the response. Duplicate header names are not allowed. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let responseHeaders: [CustomHTTPHeader]?

    public init (
        customResponseBodyKey: String? = nil,
        responseCode: Int? = nil,
        responseHeaders: [CustomHTTPHeader]? = nil
    )
    {
        self.customResponseBodyKey = customResponseBodyKey
        self.responseCode = responseCode
        self.responseHeaders = responseHeaders
    }
}

extension CustomResponseBody: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(ResponseContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension CustomResponseBody: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomResponseBody(content: \(String(describing: content)), contentType: \(String(describing: contentType)))"}
}

/// <p>The response body to use in a custom response to a web request. This is referenced by key from <a>CustomResponse</a>
///             <code>CustomResponseBodyKey</code>.</p>
public struct CustomResponseBody: Equatable {
    /// <p>The payload of the custom response. </p>
    ///          <p>You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the <code>ContentType</code> setting. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let content: String?
    /// <p>The type of content in the payload that you are defining in the <code>Content</code> string.</p>
    public let contentType: ResponseContentType?

    public init (
        content: String? = nil,
        contentType: ResponseContentType? = nil
    )
    {
        self.content = content
        self.contentType = contentType
    }
}

extension DefaultAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allow = "Allow"
        case block = "Block"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allow = allow {
            try encodeContainer.encode(allow, forKey: .allow)
        }
        if let block = block {
            try encodeContainer.encode(block, forKey: .block)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(BlockAction.self, forKey: .block)
        block = blockDecoded
        let allowDecoded = try containerValues.decodeIfPresent(AllowAction.self, forKey: .allow)
        allow = allowDecoded
    }
}

extension DefaultAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultAction(allow: \(String(describing: allow)), block: \(String(describing: block)))"}
}

/// <p>In a <a>WebACL</a>, this is the action that you want AWS WAF
///          to perform when a web request doesn't match any of the rules in the <code>WebACL</code>. The default action must be a terminating action, so you can't use count.</p>
public struct DefaultAction: Equatable {
    /// <p>Specifies that AWS WAF should allow requests by default.</p>
    public let allow: AllowAction?
    /// <p>Specifies that AWS WAF should block requests by default. </p>
    public let block: BlockAction?

    public init (
        allow: AllowAction? = nil,
        block: BlockAction? = nil
    )
    {
        self.allow = allow
        self.block = block
    }
}

public struct DeleteFirewallManagerRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallManagerRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>
    public typealias MOutput = OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallManagerRuleGroupsOutputError>
}

extension DeleteFirewallManagerRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallManagerRuleGroupsInput(webACLArn: \(String(describing: webACLArn)), webACLLockToken: \(String(describing: webACLLockToken)))"}
}

extension DeleteFirewallManagerRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case webACLArn = "WebACLArn"
        case webACLLockToken = "WebACLLockToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webACLArn = webACLArn {
            try encodeContainer.encode(webACLArn, forKey: .webACLArn)
        }
        if let webACLLockToken = webACLLockToken {
            try encodeContainer.encode(webACLLockToken, forKey: .webACLLockToken)
        }
    }
}

public struct DeleteFirewallManagerRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallManagerRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>
    public typealias MOutput = OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallManagerRuleGroupsOutputError>
}

public struct DeleteFirewallManagerRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallManagerRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallManagerRuleGroupsInput>
    public typealias MOutput = OperationOutput<DeleteFirewallManagerRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallManagerRuleGroupsOutputError>
}

public struct DeleteFirewallManagerRuleGroupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the web ACL.</p>
    public let webACLArn: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let webACLLockToken: String?

    public init (
        webACLArn: String? = nil,
        webACLLockToken: String? = nil
    )
    {
        self.webACLArn = webACLArn
        self.webACLLockToken = webACLLockToken
    }
}

struct DeleteFirewallManagerRuleGroupsInputBody: Equatable {
    public let webACLArn: String?
    public let webACLLockToken: String?
}

extension DeleteFirewallManagerRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webACLArn = "WebACLArn"
        case webACLLockToken = "WebACLLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLArn)
        webACLArn = webACLArnDecoded
        let webACLLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLLockToken)
        webACLLockToken = webACLLockTokenDecoded
    }
}

extension DeleteFirewallManagerRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallManagerRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallManagerRuleGroupsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallManagerRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallManagerRuleGroupsOutputResponse(nextWebACLLockToken: \(String(describing: nextWebACLLockToken)))"}
}

extension DeleteFirewallManagerRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallManagerRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextWebACLLockToken = output.nextWebACLLockToken
        } else {
            self.nextWebACLLockToken = nil
        }
    }
}

public struct DeleteFirewallManagerRuleGroupsOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let nextWebACLLockToken: String?

    public init (
        nextWebACLLockToken: String? = nil
    )
    {
        self.nextWebACLLockToken = nextWebACLLockToken
    }
}

struct DeleteFirewallManagerRuleGroupsOutputResponseBody: Equatable {
    public let nextWebACLLockToken: String?
}

extension DeleteFirewallManagerRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextWebACLLockToken = "NextWebACLLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextWebACLLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextWebACLLockToken)
        nextWebACLLockToken = nextWebACLLockTokenDecoded
    }
}

public struct DeleteIPSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

extension DeleteIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetInput(id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension DeleteIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct DeleteIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInput: Equatable {
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.scope = scope
    }
}

struct DeleteIPSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let lockToken: String?
}

extension DeleteIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension DeleteIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFAssociatedItemException" : self = .wAFAssociatedItemException(try WAFAssociatedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIPSetOutputError: Equatable {
    case wAFAssociatedItemException(WAFAssociatedItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetOutputResponse()"}
}

extension DeleteIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIPSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteIPSetOutputResponseBody: Equatable {
}

extension DeleteIPSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

extension DeleteLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggingConfigurationInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

public struct DeleteLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

public struct DeleteLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the web ACL from which you want to delete the <a>LoggingConfiguration</a>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteLoggingConfigurationInputBody: Equatable {
    public let resourceArn: String?
}

extension DeleteLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggingConfigurationOutputResponse()"}
}

extension DeleteLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoggingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoggingConfigurationOutputResponseBody: Equatable {
}

extension DeleteLoggingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

extension DeletePermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionPolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeletePermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeletePermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

public struct DeletePermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

public struct DeletePermissionPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group from which you want to delete the policy.</p>
    ///         <p>You must be the owner of the rule group to perform this operation.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeletePermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DeletePermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeletePermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionPolicyOutputResponse()"}
}

extension DeletePermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePermissionPolicyOutputResponseBody: Equatable {
}

extension DeletePermissionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

extension DeleteRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexPatternSetInput(id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension DeleteRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct DeleteRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

public struct DeleteRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

public struct DeleteRegexPatternSetInput: Equatable {
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.scope = scope
    }
}

struct DeleteRegexPatternSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let lockToken: String?
}

extension DeleteRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension DeleteRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFAssociatedItemException" : self = .wAFAssociatedItemException(try WAFAssociatedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegexPatternSetOutputError: Equatable {
    case wAFAssociatedItemException(WAFAssociatedItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexPatternSetOutputResponse()"}
}

extension DeleteRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRegexPatternSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteRegexPatternSetOutputResponseBody: Equatable {
}

extension DeleteRegexPatternSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

extension DeleteRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupInput(id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension DeleteRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct DeleteRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInput: Equatable {
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.scope = scope
    }
}

struct DeleteRuleGroupInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let lockToken: String?
}

extension DeleteRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension DeleteRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFAssociatedItemException" : self = .wAFAssociatedItemException(try WAFAssociatedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleGroupOutputError: Equatable {
    case wAFAssociatedItemException(WAFAssociatedItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupOutputResponse()"}
}

extension DeleteRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteRuleGroupOutputResponseBody: Equatable {
}

extension DeleteRuleGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWebACLInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

extension DeleteWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebACLInput(id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension DeleteWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct DeleteWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

public struct DeleteWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

public struct DeleteWebACLInput: Equatable {
    /// <p>The unique identifier for the Web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.scope = scope
    }
}

struct DeleteWebACLInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let lockToken: String?
}

extension DeleteWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension DeleteWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFAssociatedItemException" : self = .wAFAssociatedItemException(try WAFAssociatedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebACLOutputError: Equatable {
    case wAFAssociatedItemException(WAFAssociatedItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebACLOutputResponse()"}
}

extension DeleteWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWebACLOutputResponse: Equatable {

    public init() {}
}

struct DeleteWebACLOutputResponseBody: Equatable {
}

extension DeleteWebACLOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeManagedRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeManagedRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeManagedRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeManagedRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeManagedRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeManagedRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeManagedRuleGroupOutputError>
}

extension DescribeManagedRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeManagedRuleGroupInput(name: \(String(describing: name)), scope: \(String(describing: scope)), vendorName: \(String(describing: vendorName)))"}
}

extension DescribeManagedRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case scope = "Scope"
        case vendorName = "VendorName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let vendorName = vendorName {
            try encodeContainer.encode(vendorName, forKey: .vendorName)
        }
    }
}

public struct DescribeManagedRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeManagedRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeManagedRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeManagedRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeManagedRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeManagedRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeManagedRuleGroupOutputError>
}

public struct DescribeManagedRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeManagedRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeManagedRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeManagedRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeManagedRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeManagedRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeManagedRuleGroupOutputError>
}

public struct DescribeManagedRuleGroupInput: Equatable {
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    public let vendorName: String?

    public init (
        name: String? = nil,
        scope: Scope? = nil,
        vendorName: String? = nil
    )
    {
        self.name = name
        self.scope = scope
        self.vendorName = vendorName
    }
}

struct DescribeManagedRuleGroupInputBody: Equatable {
    public let vendorName: String?
    public let name: String?
    public let scope: Scope?
}

extension DescribeManagedRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case scope = "Scope"
        case vendorName = "VendorName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension DescribeManagedRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeManagedRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidResourceException" : self = .wAFInvalidResourceException(try WAFInvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeManagedRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFInvalidResourceException(WAFInvalidResourceException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeManagedRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeManagedRuleGroupOutputResponse(availableLabels: \(String(describing: availableLabels)), capacity: \(String(describing: capacity)), consumedLabels: \(String(describing: consumedLabels)), labelNamespace: \(String(describing: labelNamespace)), rules: \(String(describing: rules)))"}
}

extension DescribeManagedRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeManagedRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availableLabels = output.availableLabels
            self.capacity = output.capacity
            self.consumedLabels = output.consumedLabels
            self.labelNamespace = output.labelNamespace
            self.rules = output.rules
        } else {
            self.availableLabels = nil
            self.capacity = 0
            self.consumedLabels = nil
            self.labelNamespace = nil
            self.rules = nil
        }
    }
}

public struct DescribeManagedRuleGroupOutputResponse: Equatable {
    /// <p>The labels that one or more rules in this rule group add to matching web ACLs. These labels are defined in the <code>RuleLabels</code> for a <a>Rule</a>.</p>
    public let availableLabels: [LabelSummary]?
    /// <p>The web ACL capacity units (WCUs) required for this rule group.
    ///          AWS WAF uses web ACL capacity units (WCU) to calculate and control the operating
    ///          resources that are used to run your rules, rule groups, and web ACLs. AWS WAF
    ///          calculates capacity differently for each rule type, to reflect each rule's relative
    ///          cost. Rule group capacity is fixed at creation, so users can plan their
    ///          web ACL WCU usage when they use a rule group.
    ///          The WCU limit for web ACLs is 1,500.  </p>
    public let capacity: Int
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <a>Statement</a> definition of a rule.  </p>
    public let consumedLabels: [LabelSummary]?
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    ///          <ul>
    ///             <li>
    ///                <p>The syntax for the label namespace prefix for a managed rule group is the following: </p>
    ///                <p>
    ///                   <code>awswaf:managed:<vendor>:<rule group name></code>:</p>
    ///             </li>
    ///             <li>
    ///                <p>When a rule with a label matches a web request, AWS WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p>
    ///                <p>
    ///                   <code><label namespace>:<label from rule></code>
    ///                </p>
    ///
    ///             </li>
    ///          </ul>
    public let labelNamespace: String?
    /// <p></p>
    public let rules: [RuleSummary]?

    public init (
        availableLabels: [LabelSummary]? = nil,
        capacity: Int = 0,
        consumedLabels: [LabelSummary]? = nil,
        labelNamespace: String? = nil,
        rules: [RuleSummary]? = nil
    )
    {
        self.availableLabels = availableLabels
        self.capacity = capacity
        self.consumedLabels = consumedLabels
        self.labelNamespace = labelNamespace
        self.rules = rules
    }
}

struct DescribeManagedRuleGroupOutputResponseBody: Equatable {
    public let capacity: Int
    public let rules: [RuleSummary]?
    public let labelNamespace: String?
    public let availableLabels: [LabelSummary]?
    public let consumedLabels: [LabelSummary]?
}

extension DescribeManagedRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availableLabels = "AvailableLabels"
        case capacity = "Capacity"
        case consumedLabels = "ConsumedLabels"
        case labelNamespace = "LabelNamespace"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decode(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let rulesContainer = try containerValues.decodeIfPresent([RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let labelNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .labelNamespace)
        labelNamespace = labelNamespaceDecoded
        let availableLabelsContainer = try containerValues.decodeIfPresent([LabelSummary?].self, forKey: .availableLabels)
        var availableLabelsDecoded0:[LabelSummary]? = nil
        if let availableLabelsContainer = availableLabelsContainer {
            availableLabelsDecoded0 = [LabelSummary]()
            for structure0 in availableLabelsContainer {
                if let structure0 = structure0 {
                    availableLabelsDecoded0?.append(structure0)
                }
            }
        }
        availableLabels = availableLabelsDecoded0
        let consumedLabelsContainer = try containerValues.decodeIfPresent([LabelSummary?].self, forKey: .consumedLabels)
        var consumedLabelsDecoded0:[LabelSummary]? = nil
        if let consumedLabelsContainer = consumedLabelsContainer {
            consumedLabelsDecoded0 = [LabelSummary]()
            for structure0 in consumedLabelsContainer {
                if let structure0 = structure0 {
                    consumedLabelsDecoded0?.append(structure0)
                }
            }
        }
        consumedLabels = consumedLabelsDecoded0
    }
}

public struct DisassociateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebACLInput>
    public typealias MOutput = OperationOutput<DisassociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebACLOutputError>
}

extension DisassociateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebACLInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DisassociateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DisassociateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebACLInput>
    public typealias MOutput = OperationOutput<DisassociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebACLOutputError>
}

public struct DisassociateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebACLInput>
    public typealias MOutput = OperationOutput<DisassociateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebACLOutputError>
}

public struct DisassociateWebACLInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to disassociate from the web ACL. </p>
    ///
    ///          <p>The ARN must be in one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For an Application Load Balancer: <code>arn:aws:elasticloadbalancing:<i>region</i>:<i>account-id</i>:loadbalancer/app/<i>load-balancer-name</i>/<i>load-balancer-id</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an API Gateway REST API: <code>arn:aws:apigateway:<i>region</i>::/restapis/<i>api-id</i>/stages/<i>stage-name</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For an AppSync GraphQL API: <code>arn:aws:appsync:<i>region</i>:<i>account-id</i>:apis/<i>GraphQLApiId</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DisassociateWebACLInputBody: Equatable {
    public let resourceArn: String?
}

extension DisassociateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DisassociateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebACLOutputResponse()"}
}

extension DisassociateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebACLOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWebACLOutputResponseBody: Equatable {
}

extension DisassociateWebACLOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ExcludedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ExcludedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExcludedRule(name: \(String(describing: name)))"}
}

/// <p>Specifies a single rule to exclude from the rule group. Excluding a rule overrides
///          its action setting for the rule group in the web ACL, setting it to <code>COUNT</code>.
///          This effectively excludes the rule from acting on web requests.  </p>
public struct ExcludedRule: Equatable {
    /// <p>The name of the rule to exclude.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public enum FallbackBehavior {
    case match
    case noMatch
    case sdkUnknown(String)
}

extension FallbackBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FallbackBehavior] {
        return [
            .match,
            .noMatch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .match: return "MATCH"
        case .noMatch: return "NO_MATCH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FallbackBehavior(rawValue: rawValue) ?? FallbackBehavior.sdkUnknown(rawValue)
    }
}

extension FieldToMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allQueryArguments = "AllQueryArguments"
        case body = "Body"
        case jsonBody = "JsonBody"
        case method = "Method"
        case queryString = "QueryString"
        case singleHeader = "SingleHeader"
        case singleQueryArgument = "SingleQueryArgument"
        case uriPath = "UriPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allQueryArguments = allQueryArguments {
            try encodeContainer.encode(allQueryArguments, forKey: .allQueryArguments)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let jsonBody = jsonBody {
            try encodeContainer.encode(jsonBody, forKey: .jsonBody)
        }
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let singleHeader = singleHeader {
            try encodeContainer.encode(singleHeader, forKey: .singleHeader)
        }
        if let singleQueryArgument = singleQueryArgument {
            try encodeContainer.encode(singleQueryArgument, forKey: .singleQueryArgument)
        }
        if let uriPath = uriPath {
            try encodeContainer.encode(uriPath, forKey: .uriPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let singleHeaderDecoded = try containerValues.decodeIfPresent(SingleHeader.self, forKey: .singleHeader)
        singleHeader = singleHeaderDecoded
        let singleQueryArgumentDecoded = try containerValues.decodeIfPresent(SingleQueryArgument.self, forKey: .singleQueryArgument)
        singleQueryArgument = singleQueryArgumentDecoded
        let allQueryArgumentsDecoded = try containerValues.decodeIfPresent(AllQueryArguments.self, forKey: .allQueryArguments)
        allQueryArguments = allQueryArgumentsDecoded
        let uriPathDecoded = try containerValues.decodeIfPresent(UriPath.self, forKey: .uriPath)
        uriPath = uriPathDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(QueryString.self, forKey: .queryString)
        queryString = queryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Body.self, forKey: .body)
        body = bodyDecoded
        let methodDecoded = try containerValues.decodeIfPresent(Method.self, forKey: .method)
        method = methodDecoded
        let jsonBodyDecoded = try containerValues.decodeIfPresent(JsonBody.self, forKey: .jsonBody)
        jsonBody = jsonBodyDecoded
    }
}

extension FieldToMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldToMatch(allQueryArguments: \(String(describing: allQueryArguments)), body: \(String(describing: body)), jsonBody: \(String(describing: jsonBody)), method: \(String(describing: method)), queryString: \(String(describing: queryString)), singleHeader: \(String(describing: singleHeader)), singleQueryArgument: \(String(describing: singleQueryArgument)), uriPath: \(String(describing: uriPath)))"}
}

/// <p>The part of a web request that you want AWS WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of a web request, create a separate rule statement for each component.</p>
public struct FieldToMatch: Equatable {
    /// <p>Inspect all query arguments. </p>
    public let allQueryArguments: AllQueryArguments?
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any
    ///          additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    ///          <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to AWS WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <a>ByteMatchStatement</a> or <a>RegexPatternSetReferenceStatement</a>, with a <a>SizeConstraintStatement</a> that enforces an 8 KB size limit on the body of the request. AWS WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    public let body: Body?
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any
    ///          additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    ///          <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to AWS WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <a>ByteMatchStatement</a> or <a>RegexPatternSetReferenceStatement</a>, with a <a>SizeConstraintStatement</a> that enforces an 8 KB size limit on the body of the request. AWS WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    public let jsonBody: JsonBody?
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    public let method: Method?
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    public let queryString: QueryString?
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    ///          <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code>
    ///          </p>
    public let singleHeader: SingleHeader?
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    ///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
    ///          <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code>
    ///          </p>
    public let singleQueryArgument: SingleQueryArgument?
    /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    public let uriPath: UriPath?

    public init (
        allQueryArguments: AllQueryArguments? = nil,
        body: Body? = nil,
        jsonBody: JsonBody? = nil,
        method: Method? = nil,
        queryString: QueryString? = nil,
        singleHeader: SingleHeader? = nil,
        singleQueryArgument: SingleQueryArgument? = nil,
        uriPath: UriPath? = nil
    )
    {
        self.allQueryArguments = allQueryArguments
        self.body = body
        self.jsonBody = jsonBody
        self.method = method
        self.queryString = queryString
        self.singleHeader = singleHeader
        self.singleQueryArgument = singleQueryArgument
        self.uriPath = uriPath
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case behavior = "Behavior"
        case conditions = "Conditions"
        case requirement = "Requirement"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let behavior = behavior {
            try encodeContainer.encode(behavior.rawValue, forKey: .behavior)
        }
        if let conditions = conditions {
            var conditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditions)
            for conditions0 in conditions {
                try conditionsContainer.encode(conditions0)
            }
        }
        if let requirement = requirement {
            try encodeContainer.encode(requirement.rawValue, forKey: .requirement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let behaviorDecoded = try containerValues.decodeIfPresent(FilterBehavior.self, forKey: .behavior)
        behavior = behaviorDecoded
        let requirementDecoded = try containerValues.decodeIfPresent(FilterRequirement.self, forKey: .requirement)
        requirement = requirementDecoded
        let conditionsContainer = try containerValues.decodeIfPresent([Condition?].self, forKey: .conditions)
        var conditionsDecoded0:[Condition]? = nil
        if let conditionsContainer = conditionsContainer {
            conditionsDecoded0 = [Condition]()
            for structure0 in conditionsContainer {
                if let structure0 = structure0 {
                    conditionsDecoded0?.append(structure0)
                }
            }
        }
        conditions = conditionsDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(behavior: \(String(describing: behavior)), conditions: \(String(describing: conditions)), requirement: \(String(describing: requirement)))"}
}

/// <p>A single logging filter, used in <a>LoggingFilter</a>. </p>
public struct Filter: Equatable {
    /// <p>How to handle logs that satisfy the filter's conditions and requirement. </p>
    public let behavior: FilterBehavior?
    /// <p>Match conditions for the filter.</p>
    public let conditions: [Condition]?
    /// <p>Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.</p>
    public let requirement: FilterRequirement?

    public init (
        behavior: FilterBehavior? = nil,
        conditions: [Condition]? = nil,
        requirement: FilterRequirement? = nil
    )
    {
        self.behavior = behavior
        self.conditions = conditions
        self.requirement = requirement
    }
}

public enum FilterBehavior {
    case drop
    case keep
    case sdkUnknown(String)
}

extension FilterBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterBehavior] {
        return [
            .drop,
            .keep,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .drop: return "DROP"
        case .keep: return "KEEP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterBehavior(rawValue: rawValue) ?? FilterBehavior.sdkUnknown(rawValue)
    }
}

public enum FilterRequirement {
    case meetsAll
    case meetsAny
    case sdkUnknown(String)
}

extension FilterRequirement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterRequirement] {
        return [
            .meetsAll,
            .meetsAny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .meetsAll: return "MEETS_ALL"
        case .meetsAny: return "MEETS_ANY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterRequirement(rawValue: rawValue) ?? FilterRequirement.sdkUnknown(rawValue)
    }
}

extension FirewallManagerRuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallManagerStatement = "FirewallManagerStatement"
        case name = "Name"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallManagerStatement = firewallManagerStatement {
            try encodeContainer.encode(firewallManagerStatement, forKey: .firewallManagerStatement)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideAction = overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let firewallManagerStatementDecoded = try containerValues.decodeIfPresent(FirewallManagerStatement.self, forKey: .firewallManagerStatement)
        firewallManagerStatement = firewallManagerStatementDecoded
        let overrideActionDecoded = try containerValues.decodeIfPresent(OverrideAction.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
    }
}

extension FirewallManagerRuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallManagerRuleGroup(firewallManagerStatement: \(String(describing: firewallManagerStatement)), name: \(String(describing: name)), overrideAction: \(String(describing: overrideAction)), priority: \(String(describing: priority)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

/// <p>A rule group that's defined for an AWS Firewall Manager WAF policy.</p>
public struct FirewallManagerRuleGroup: Equatable {
    /// <p>The processing guidance for an AWS Firewall Manager rule. This is like a regular rule <a>Statement</a>, but it can only contain a rule group reference.</p>
    public let firewallManagerStatement: FirewallManagerStatement?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>The override action to apply to the rules in a rule group. Used only for rule statements that reference a rule group,
    ///            like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
    ///         <p>Set the override action to none to leave the rule actions in effect. Set it to count to only count matches, regardless of the rule action settings. </p>
    ///         <p>In a <a>Rule</a>, you must specify either this <code>OverrideAction</code> setting or the rule <code>Action</code> setting, but not both:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the rule statement references a rule group, use this override action setting and not the action setting.  </p>
    ///             </li>
    ///             <li>
    ///                <p>If the rule statement does not reference a rule group, use the rule action setting and not this rule override action setting. </p>
    ///             </li>
    ///          </ul>
    public let overrideAction: OverrideAction?
    /// <p>If you define more than one rule group in the first or last Firewall Manager rule groups,
    ///           AWS WAF evaluates each request against the rule groups in order, starting from the lowest priority setting.
    ///          The priorities don't need to be consecutive, but they must all be different.</p>
    public let priority: Int
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        firewallManagerStatement: FirewallManagerStatement? = nil,
        name: String? = nil,
        overrideAction: OverrideAction? = nil,
        priority: Int = 0,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.firewallManagerStatement = firewallManagerStatement
        self.name = name
        self.overrideAction = overrideAction
        self.priority = priority
        self.visibilityConfig = visibilityConfig
    }
}

extension FirewallManagerStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case managedRuleGroupStatement = "ManagedRuleGroupStatement"
        case ruleGroupReferenceStatement = "RuleGroupReferenceStatement"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managedRuleGroupStatement = managedRuleGroupStatement {
            try encodeContainer.encode(managedRuleGroupStatement, forKey: .managedRuleGroupStatement)
        }
        if let ruleGroupReferenceStatement = ruleGroupReferenceStatement {
            try encodeContainer.encode(ruleGroupReferenceStatement, forKey: .ruleGroupReferenceStatement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedRuleGroupStatementDecoded = try containerValues.decodeIfPresent(ManagedRuleGroupStatement.self, forKey: .managedRuleGroupStatement)
        managedRuleGroupStatement = managedRuleGroupStatementDecoded
        let ruleGroupReferenceStatementDecoded = try containerValues.decodeIfPresent(RuleGroupReferenceStatement.self, forKey: .ruleGroupReferenceStatement)
        ruleGroupReferenceStatement = ruleGroupReferenceStatementDecoded
    }
}

extension FirewallManagerStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallManagerStatement(managedRuleGroupStatement: \(String(describing: managedRuleGroupStatement)), ruleGroupReferenceStatement: \(String(describing: ruleGroupReferenceStatement)))"}
}

/// <p>The processing guidance for an AWS Firewall Manager rule. This is like a regular rule <a>Statement</a>, but it can only contain a rule group reference.</p>
public struct FirewallManagerStatement: Equatable {
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <a>ListAvailableManagedRuleGroups</a>.</p>
    ///          <p>You can't nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    public let managedRuleGroupStatement: ManagedRuleGroupStatement?
    /// <p>A rule statement used to run the rules that are defined in a <a>RuleGroup</a>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    ///          <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    public let ruleGroupReferenceStatement: RuleGroupReferenceStatement?

    public init (
        managedRuleGroupStatement: ManagedRuleGroupStatement? = nil,
        ruleGroupReferenceStatement: RuleGroupReferenceStatement? = nil
    )
    {
        self.managedRuleGroupStatement = managedRuleGroupStatement
        self.ruleGroupReferenceStatement = ruleGroupReferenceStatement
    }
}

extension ForwardedIPConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fallbackBehavior = "FallbackBehavior"
        case headerName = "HeaderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fallbackBehavior = fallbackBehavior {
            try encodeContainer.encode(fallbackBehavior.rawValue, forKey: .fallbackBehavior)
        }
        if let headerName = headerName {
            try encodeContainer.encode(headerName, forKey: .headerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let fallbackBehaviorDecoded = try containerValues.decodeIfPresent(FallbackBehavior.self, forKey: .fallbackBehavior)
        fallbackBehavior = fallbackBehaviorDecoded
    }
}

extension ForwardedIPConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForwardedIPConfig(fallbackBehavior: \(String(describing: fallbackBehavior)), headerName: \(String(describing: headerName)))"}
}

/// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p>
///
///          <note>
///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
///          </note>
///
///
///          <p>This configuration is used for <a>GeoMatchStatement</a> and <a>RateBasedStatement</a>.
///            For <a>IPSetReferenceStatement</a>, use <a>IPSetForwardedIPConfig</a> instead.  </p>
///          <p>AWS WAF only evaluates the first IP address found in the specified HTTP header. </p>
public struct ForwardedIPConfig: Equatable {
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    ///
    ///          <p>You can specify the following fallback behaviors:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>MATCH</code> - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p>
    ///             </li>
    ///          </ul>
    public let fallbackBehavior: FallbackBehavior?
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    public let headerName: String?

    public init (
        fallbackBehavior: FallbackBehavior? = nil,
        headerName: String? = nil
    )
    {
        self.fallbackBehavior = fallbackBehavior
        self.headerName = headerName
    }
}

public enum ForwardedIPPosition {
    case any
    case first
    case last
    case sdkUnknown(String)
}

extension ForwardedIPPosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ForwardedIPPosition] {
        return [
            .any,
            .first,
            .last,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .any: return "ANY"
        case .first: return "FIRST"
        case .last: return "LAST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ForwardedIPPosition(rawValue: rawValue) ?? ForwardedIPPosition.sdkUnknown(rawValue)
    }
}

extension GeoMatchStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countryCodes = "CountryCodes"
        case forwardedIPConfig = "ForwardedIPConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCodes = countryCodes {
            var countryCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .countryCodes)
            for countrycodes0 in countryCodes {
                try countryCodesContainer.encode(countrycodes0.rawValue)
            }
        }
        if let forwardedIPConfig = forwardedIPConfig {
            try encodeContainer.encode(forwardedIPConfig, forKey: .forwardedIPConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodesContainer = try containerValues.decodeIfPresent([CountryCode?].self, forKey: .countryCodes)
        var countryCodesDecoded0:[CountryCode]? = nil
        if let countryCodesContainer = countryCodesContainer {
            countryCodesDecoded0 = [CountryCode]()
            for string0 in countryCodesContainer {
                if let string0 = string0 {
                    countryCodesDecoded0?.append(string0)
                }
            }
        }
        countryCodes = countryCodesDecoded0
        let forwardedIPConfigDecoded = try containerValues.decodeIfPresent(ForwardedIPConfig.self, forKey: .forwardedIPConfig)
        forwardedIPConfig = forwardedIPConfigDecoded
    }
}

extension GeoMatchStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoMatchStatement(countryCodes: \(String(describing: countryCodes)), forwardedIPConfig: \(String(describing: forwardedIPConfig)))"}
}

/// <p>A rule statement used to identify web requests based on country of origin.  </p>
public struct GeoMatchStatement: Equatable {
    /// <p>An array of two-character country codes, for example, <code>[ "US", "CN" ]</code>, from the alpha-2 country ISO codes of the ISO 3166 international standard. </p>
    public let countryCodes: [CountryCode]?
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    public let forwardedIPConfig: ForwardedIPConfig?

    public init (
        countryCodes: [CountryCode]? = nil,
        forwardedIPConfig: ForwardedIPConfig? = nil
    )
    {
        self.countryCodes = countryCodes
        self.forwardedIPConfig = forwardedIPConfig
    }
}

public struct GetIPSetInputBodyMiddleware: Middleware {
    public let id: String = "GetIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

extension GetIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetInput(id: \(String(describing: id)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension GetIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct GetIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInput: Equatable {
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.name = name
        self.scope = scope
    }
}

struct GetIPSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
}

extension GetIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIPSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetOutputResponse(iPSet: \(String(describing: iPSet)), lockToken: \(String(describing: lockToken)))"}
}

extension GetIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iPSet = output.iPSet
            self.lockToken = output.lockToken
        } else {
            self.iPSet = nil
            self.lockToken = nil
        }
    }
}

public struct GetIPSetOutputResponse: Equatable {
    /// <p></p>
    public let iPSet: IPSet?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?

    public init (
        iPSet: IPSet? = nil,
        lockToken: String? = nil
    )
    {
        self.iPSet = iPSet
        self.lockToken = lockToken
    }
}

struct GetIPSetOutputResponseBody: Equatable {
    public let iPSet: IPSet?
    public let lockToken: String?
}

extension GetIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iPSet = "IPSet"
        case lockToken = "LockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetDecoded = try containerValues.decodeIfPresent(IPSet.self, forKey: .iPSet)
        iPSet = iPSetDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

public struct GetLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

extension GetLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingConfigurationInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

public struct GetLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

public struct GetLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the web ACL for which you want to get the <a>LoggingConfiguration</a>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetLoggingConfigurationInputBody: Equatable {
    public let resourceArn: String?
}

extension GetLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingConfigurationOutputResponse(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension GetLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetLoggingConfigurationOutputResponse: Equatable {
    /// <p>The <a>LoggingConfiguration</a> for the specified web ACL.</p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetLoggingConfigurationOutputResponseBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension GetLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct GetPermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

extension GetPermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionPolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetPermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetPermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

public struct GetPermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

public struct GetPermissionPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group for which you want to get the policy.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetPermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension GetPermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetPermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetPermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPermissionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetPermissionPolicyOutputResponse: Equatable {
    /// <p>The IAM policy that is attached to the specified rule group.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPermissionPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetPermissionPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct GetRateBasedStatementManagedKeysInputBodyMiddleware: Middleware {
    public let id: String = "GetRateBasedStatementManagedKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedStatementManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedStatementManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedStatementManagedKeysOutputError>
}

extension GetRateBasedStatementManagedKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedStatementManagedKeysInput(ruleName: \(String(describing: ruleName)), scope: \(String(describing: scope)), webACLId: \(String(describing: webACLId)), webACLName: \(String(describing: webACLName)))"}
}

extension GetRateBasedStatementManagedKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleName = "RuleName"
        case scope = "Scope"
        case webACLId = "WebACLId"
        case webACLName = "WebACLName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
        if let webACLName = webACLName {
            try encodeContainer.encode(webACLName, forKey: .webACLName)
        }
    }
}

public struct GetRateBasedStatementManagedKeysInputHeadersMiddleware: Middleware {
    public let id: String = "GetRateBasedStatementManagedKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedStatementManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedStatementManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedStatementManagedKeysOutputError>
}

public struct GetRateBasedStatementManagedKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRateBasedStatementManagedKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedStatementManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedStatementManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedStatementManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedStatementManagedKeysOutputError>
}

public struct GetRateBasedStatementManagedKeysInput: Equatable {
    /// <p>The name of the rate-based rule to get the keys for.</p>
    public let ruleName: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>The unique identifier for the Web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let webACLId: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let webACLName: String?

    public init (
        ruleName: String? = nil,
        scope: Scope? = nil,
        webACLId: String? = nil,
        webACLName: String? = nil
    )
    {
        self.ruleName = ruleName
        self.scope = scope
        self.webACLId = webACLId
        self.webACLName = webACLName
    }
}

struct GetRateBasedStatementManagedKeysInputBody: Equatable {
    public let scope: Scope?
    public let webACLName: String?
    public let webACLId: String?
    public let ruleName: String?
}

extension GetRateBasedStatementManagedKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleName = "RuleName"
        case scope = "Scope"
        case webACLId = "WebACLId"
        case webACLName = "WebACLName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let webACLNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLName)
        webACLName = webACLNameDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
    }
}

extension GetRateBasedStatementManagedKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRateBasedStatementManagedKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRateBasedStatementManagedKeysOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRateBasedStatementManagedKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedStatementManagedKeysOutputResponse(managedKeysIPV4: \(String(describing: managedKeysIPV4)), managedKeysIPV6: \(String(describing: managedKeysIPV6)))"}
}

extension GetRateBasedStatementManagedKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRateBasedStatementManagedKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managedKeysIPV4 = output.managedKeysIPV4
            self.managedKeysIPV6 = output.managedKeysIPV6
        } else {
            self.managedKeysIPV4 = nil
            self.managedKeysIPV6 = nil
        }
    }
}

public struct GetRateBasedStatementManagedKeysOutputResponse: Equatable {
    /// <p>The keys that are of Internet Protocol version 4 (IPv4). </p>
    public let managedKeysIPV4: RateBasedStatementManagedKeysIPSet?
    /// <p>The keys that are of Internet Protocol version 6 (IPv6). </p>
    public let managedKeysIPV6: RateBasedStatementManagedKeysIPSet?

    public init (
        managedKeysIPV4: RateBasedStatementManagedKeysIPSet? = nil,
        managedKeysIPV6: RateBasedStatementManagedKeysIPSet? = nil
    )
    {
        self.managedKeysIPV4 = managedKeysIPV4
        self.managedKeysIPV6 = managedKeysIPV6
    }
}

struct GetRateBasedStatementManagedKeysOutputResponseBody: Equatable {
    public let managedKeysIPV4: RateBasedStatementManagedKeysIPSet?
    public let managedKeysIPV6: RateBasedStatementManagedKeysIPSet?
}

extension GetRateBasedStatementManagedKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managedKeysIPV4 = "ManagedKeysIPV4"
        case managedKeysIPV6 = "ManagedKeysIPV6"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedKeysIPV4Decoded = try containerValues.decodeIfPresent(RateBasedStatementManagedKeysIPSet.self, forKey: .managedKeysIPV4)
        managedKeysIPV4 = managedKeysIPV4Decoded
        let managedKeysIPV6Decoded = try containerValues.decodeIfPresent(RateBasedStatementManagedKeysIPSet.self, forKey: .managedKeysIPV6)
        managedKeysIPV6 = managedKeysIPV6Decoded
    }
}

public struct GetRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

extension GetRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexPatternSetInput(id: \(String(describing: id)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension GetRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct GetRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

public struct GetRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

public struct GetRegexPatternSetInput: Equatable {
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.name = name
        self.scope = scope
    }
}

struct GetRegexPatternSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
}

extension GetRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegexPatternSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexPatternSetOutputResponse(lockToken: \(String(describing: lockToken)), regexPatternSet: \(String(describing: regexPatternSet)))"}
}

extension GetRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lockToken = output.lockToken
            self.regexPatternSet = output.regexPatternSet
        } else {
            self.lockToken = nil
            self.regexPatternSet = nil
        }
    }
}

public struct GetRegexPatternSetOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p></p>
    public let regexPatternSet: RegexPatternSet?

    public init (
        lockToken: String? = nil,
        regexPatternSet: RegexPatternSet? = nil
    )
    {
        self.lockToken = lockToken
        self.regexPatternSet = regexPatternSet
    }
}

struct GetRegexPatternSetOutputResponseBody: Equatable {
    public let regexPatternSet: RegexPatternSet?
    public let lockToken: String?
}

extension GetRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lockToken = "LockToken"
        case regexPatternSet = "RegexPatternSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetDecoded = try containerValues.decodeIfPresent(RegexPatternSet.self, forKey: .regexPatternSet)
        regexPatternSet = regexPatternSetDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

public struct GetRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

extension GetRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleGroupInput(id: \(String(describing: id)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension GetRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct GetRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

public struct GetRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

public struct GetRuleGroupInput: Equatable {
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.name = name
        self.scope = scope
    }
}

struct GetRuleGroupInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
}

extension GetRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleGroupOutputResponse(lockToken: \(String(describing: lockToken)), ruleGroup: \(String(describing: ruleGroup)))"}
}

extension GetRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lockToken = output.lockToken
            self.ruleGroup = output.ruleGroup
        } else {
            self.lockToken = nil
            self.ruleGroup = nil
        }
    }
}

public struct GetRuleGroupOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p></p>
    public let ruleGroup: RuleGroup?

    public init (
        lockToken: String? = nil,
        ruleGroup: RuleGroup? = nil
    )
    {
        self.lockToken = lockToken
        self.ruleGroup = ruleGroup
    }
}

struct GetRuleGroupOutputResponseBody: Equatable {
    public let ruleGroup: RuleGroup?
    public let lockToken: String?
}

extension GetRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lockToken = "LockToken"
        case ruleGroup = "RuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

public struct GetSampledRequestsInputBodyMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

extension GetSampledRequestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampledRequestsInput(maxItems: \(String(describing: maxItems)), ruleMetricName: \(String(describing: ruleMetricName)), scope: \(String(describing: scope)), timeWindow: \(String(describing: timeWindow)), webAclArn: \(String(describing: webAclArn)))"}
}

extension GetSampledRequestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxItems = "MaxItems"
        case ruleMetricName = "RuleMetricName"
        case scope = "Scope"
        case timeWindow = "TimeWindow"
        case webAclArn = "WebAclArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxItems != 0 {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let ruleMetricName = ruleMetricName {
            try encodeContainer.encode(ruleMetricName, forKey: .ruleMetricName)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let timeWindow = timeWindow {
            try encodeContainer.encode(timeWindow, forKey: .timeWindow)
        }
        if let webAclArn = webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }
}

public struct GetSampledRequestsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

public struct GetSampledRequestsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

public struct GetSampledRequestsInput: Equatable {
    /// <p>The number of requests that you want AWS WAF to return from among the first 5,000 requests that your AWS resource received
    ///          during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code>
    ///          returns information about all of them. </p>
    public let maxItems: Int
    /// <p>The metric name assigned to the <code>Rule</code> or <code>RuleGroup</code> for which you want a sample of requests.</p>
    public let ruleMetricName: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a
    ///           sample of requests. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours. If you specify a start time that's earlier than three hours ago, AWS WAF sets it to three hours ago.</p>
    public let timeWindow: TimeWindow?
    /// <p>The Amazon resource name (ARN) of the <code>WebACL</code> for which you want a sample of requests.</p>
    public let webAclArn: String?

    public init (
        maxItems: Int = 0,
        ruleMetricName: String? = nil,
        scope: Scope? = nil,
        timeWindow: TimeWindow? = nil,
        webAclArn: String? = nil
    )
    {
        self.maxItems = maxItems
        self.ruleMetricName = ruleMetricName
        self.scope = scope
        self.timeWindow = timeWindow
        self.webAclArn = webAclArn
    }
}

struct GetSampledRequestsInputBody: Equatable {
    public let webAclArn: String?
    public let ruleMetricName: String?
    public let scope: Scope?
    public let timeWindow: TimeWindow?
    public let maxItems: Int
}

extension GetSampledRequestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxItems = "MaxItems"
        case ruleMetricName = "RuleMetricName"
        case scope = "Scope"
        case timeWindow = "TimeWindow"
        case webAclArn = "WebAclArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let ruleMetricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleMetricName)
        ruleMetricName = ruleMetricNameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let timeWindowDecoded = try containerValues.decodeIfPresent(TimeWindow.self, forKey: .timeWindow)
        timeWindow = timeWindowDecoded
        let maxItemsDecoded = try containerValues.decode(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension GetSampledRequestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSampledRequestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSampledRequestsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSampledRequestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampledRequestsOutputResponse(populationSize: \(String(describing: populationSize)), sampledRequests: \(String(describing: sampledRequests)), timeWindow: \(String(describing: timeWindow)))"}
}

extension GetSampledRequestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSampledRequestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.populationSize = output.populationSize
            self.sampledRequests = output.sampledRequests
            self.timeWindow = output.timeWindow
        } else {
            self.populationSize = 0
            self.sampledRequests = nil
            self.timeWindow = nil
        }
    }
}

public struct GetSampledRequestsOutputResponse: Equatable {
    /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests.
    ///          If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your AWS resource
    ///          received during the specified time range.</p>
    public let populationSize: Int
    /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
    public let sampledRequests: [SampledHTTPRequest]?
    /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request.
    ///             However, if your AWS resource received more than 5,000 requests during the time range that you specified in the request,
    ///          <code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
    public let timeWindow: TimeWindow?

    public init (
        populationSize: Int = 0,
        sampledRequests: [SampledHTTPRequest]? = nil,
        timeWindow: TimeWindow? = nil
    )
    {
        self.populationSize = populationSize
        self.sampledRequests = sampledRequests
        self.timeWindow = timeWindow
    }
}

struct GetSampledRequestsOutputResponseBody: Equatable {
    public let sampledRequests: [SampledHTTPRequest]?
    public let populationSize: Int
    public let timeWindow: TimeWindow?
}

extension GetSampledRequestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case populationSize = "PopulationSize"
        case sampledRequests = "SampledRequests"
        case timeWindow = "TimeWindow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampledRequestsContainer = try containerValues.decodeIfPresent([SampledHTTPRequest?].self, forKey: .sampledRequests)
        var sampledRequestsDecoded0:[SampledHTTPRequest]? = nil
        if let sampledRequestsContainer = sampledRequestsContainer {
            sampledRequestsDecoded0 = [SampledHTTPRequest]()
            for structure0 in sampledRequestsContainer {
                if let structure0 = structure0 {
                    sampledRequestsDecoded0?.append(structure0)
                }
            }
        }
        sampledRequests = sampledRequestsDecoded0
        let populationSizeDecoded = try containerValues.decode(Int.self, forKey: .populationSize)
        populationSize = populationSizeDecoded
        let timeWindowDecoded = try containerValues.decodeIfPresent(TimeWindow.self, forKey: .timeWindow)
        timeWindow = timeWindowDecoded
    }
}

public struct GetWebACLForResourceInputBodyMiddleware: Middleware {
    public let id: String = "GetWebACLForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLForResourceInput>
    public typealias MOutput = OperationOutput<GetWebACLForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLForResourceOutputError>
}

extension GetWebACLForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetWebACLForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetWebACLForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetWebACLForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLForResourceInput>
    public typealias MOutput = OperationOutput<GetWebACLForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLForResourceOutputError>
}

public struct GetWebACLForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWebACLForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLForResourceInput>
    public typealias MOutput = OperationOutput<GetWebACLForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLForResourceOutputError>
}

public struct GetWebACLForResourceInput: Equatable {
    /// <p>The ARN (Amazon Resource Name) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetWebACLForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension GetWebACLForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetWebACLForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWebACLForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWebACLForResourceOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWebACLForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLForResourceOutputResponse(webACL: \(String(describing: webACL)))"}
}

extension GetWebACLForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWebACLForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webACL = output.webACL
        } else {
            self.webACL = nil
        }
    }
}

public struct GetWebACLForResourceOutputResponse: Equatable {
    /// <p>The Web ACL that is associated with the resource. If there is no associated resource, AWS WAF returns a null Web ACL.</p>
    public let webACL: WebACL?

    public init (
        webACL: WebACL? = nil
    )
    {
        self.webACL = webACL
    }
}

struct GetWebACLForResourceOutputResponseBody: Equatable {
    public let webACL: WebACL?
}

extension GetWebACLForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webACL = "WebACL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLDecoded = try containerValues.decodeIfPresent(WebACL.self, forKey: .webACL)
        webACL = webACLDecoded
    }
}

public struct GetWebACLInputBodyMiddleware: Middleware {
    public let id: String = "GetWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

extension GetWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLInput(id: \(String(describing: id)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension GetWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct GetWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "GetWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

public struct GetWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

public struct GetWebACLInput: Equatable {
    /// <p>The unique identifier for the Web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        id: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.id = id
        self.name = name
        self.scope = scope
    }
}

struct GetWebACLInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
}

extension GetWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GetWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLOutputResponse(lockToken: \(String(describing: lockToken)), webACL: \(String(describing: webACL)))"}
}

extension GetWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lockToken = output.lockToken
            self.webACL = output.webACL
        } else {
            self.lockToken = nil
            self.webACL = nil
        }
    }
}

public struct GetWebACLOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The Web ACL specification. You can modify the settings in this Web ACL and use it to update this Web ACL or create a new one.</p>
    public let webACL: WebACL?

    public init (
        lockToken: String? = nil,
        webACL: WebACL? = nil
    )
    {
        self.lockToken = lockToken
        self.webACL = webACL
    }
}

struct GetWebACLOutputResponseBody: Equatable {
    public let webACL: WebACL?
    public let lockToken: String?
}

extension GetWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lockToken = "LockToken"
        case webACL = "WebACL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLDecoded = try containerValues.decodeIfPresent(WebACL.self, forKey: .webACL)
        webACL = webACLDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension HTTPHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HTTPHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HTTPHeader(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Part of the response from <a>GetSampledRequests</a>. This is a complex type that
///          appears as <code>Headers</code> in the response syntax. <code>HTTPHeader</code> contains the names and values of
///          all of the headers that appear in one of the web requests. </p>
public struct HTTPHeader: Equatable {
    /// <p>The name of the HTTP header.</p>
    public let name: String?
    /// <p>The value of the HTTP header.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension HTTPRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientIP = "ClientIP"
        case country = "Country"
        case hTTPVersion = "HTTPVersion"
        case headers = "Headers"
        case method = "Method"
        case uRI = "URI"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIP = clientIP {
            try encodeContainer.encode(clientIP, forKey: .clientIP)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let hTTPVersion = hTTPVersion {
            try encodeContainer.encode(hTTPVersion, forKey: .hTTPVersion)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httpheaders0 in headers {
                try headersContainer.encode(httpheaders0)
            }
        }
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientIP)
        clientIP = clientIPDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRI)
        uRI = uRIDecoded
        let methodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .method)
        method = methodDecoded
        let hTTPVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hTTPVersion)
        hTTPVersion = hTTPVersionDecoded
        let headersContainer = try containerValues.decodeIfPresent([HTTPHeader?].self, forKey: .headers)
        var headersDecoded0:[HTTPHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [HTTPHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
    }
}

extension HTTPRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HTTPRequest(clientIP: \(String(describing: clientIP)), country: \(String(describing: country)), hTTPVersion: \(String(describing: hTTPVersion)), headers: \(String(describing: headers)), method: \(String(describing: method)), uRI: \(String(describing: uRI)))"}
}

/// <p>Part of the response from <a>GetSampledRequests</a>.  This is a complex type that
///          appears as <code>Request</code> in the response syntax. <code>HTTPRequest</code> contains information about
///          one of the web requests. </p>
public struct HTTPRequest: Equatable {
    /// <p>The IP address that the request originated from. If the web ACL is associated with a CloudFront distribution,
    ///          this is the value of one of the following fields in CloudFront access logs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p>
    ///             </li>
    ///          </ul>
    public let clientIP: String?
    /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes,
    ///          see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
    public let country: String?
    /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
    public let hTTPVersion: String?
    /// <p>A complex type that contains the name and value for each header in the sampled web request.</p>
    public let headers: [HTTPHeader]?
    /// <p>The HTTP method specified in the sampled web request. </p>
    public let method: String?
    /// <p>The URI path of the request, which identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    public let uRI: String?

    public init (
        clientIP: String? = nil,
        country: String? = nil,
        hTTPVersion: String? = nil,
        headers: [HTTPHeader]? = nil,
        method: String? = nil,
        uRI: String? = nil
    )
    {
        self.clientIP = clientIP
        self.country = country
        self.hTTPVersion = hTTPVersion
        self.headers = headers
        self.method = method
        self.uRI = uRI
    }
}

public enum IPAddressVersion {
    case ipv4
    case ipv6
    case sdkUnknown(String)
}

extension IPAddressVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IPAddressVersion] {
        return [
            .ipv4,
            .ipv6,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ipv4: return "IPV4"
        case .ipv6: return "IPV6"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IPAddressVersion(rawValue: rawValue) ?? IPAddressVersion.sdkUnknown(rawValue)
    }
}

extension IPSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case addresses = "Addresses"
        case description = "Description"
        case iPAddressVersion = "IPAddressVersion"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for ipaddresses0 in addresses {
                try addressesContainer.encode(ipaddresses0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iPAddressVersion = iPAddressVersion {
            try encodeContainer.encode(iPAddressVersion.rawValue, forKey: .iPAddressVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let iPAddressVersionDecoded = try containerValues.decodeIfPresent(IPAddressVersion.self, forKey: .iPAddressVersion)
        iPAddressVersion = iPAddressVersionDecoded
        let addressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addresses)
        var addressesDecoded0:[String]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [String]()
            for string0 in addressesContainer {
                if let string0 = string0 {
                    addressesDecoded0?.append(string0)
                }
            }
        }
        addresses = addressesDecoded0
    }
}

extension IPSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSet(aRN: \(String(describing: aRN)), addresses: \(String(describing: addresses)), description: \(String(describing: description)), iPAddressVersion: \(String(describing: iPAddressVersion)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Contains one or more IP addresses or blocks of IP addresses specified in Classless Inter-Domain Routing (CIDR) notation. AWS WAF supports all IPv4 and IPv6 CIDR ranges except for /0. For information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
///             Inter-Domain Routing</a>. </p>
///          <p>AWS WAF assigns an ARN to each <code>IPSet</code> that you create. To use an IP set in a rule, you provide the ARN to the <a>Rule</a> statement <a>IPSetReferenceStatement</a>. </p>
public struct IPSet: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. AWS WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    ///                <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let addresses: [String]?
    /// <p>A description of the IP set that helps with identification. </p>
    public let description: String?
    /// <p>Specify IPV4 or IPV6. </p>
    public let iPAddressVersion: IPAddressVersion?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        addresses: [String]? = nil,
        description: String? = nil,
        iPAddressVersion: IPAddressVersion? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.addresses = addresses
        self.description = description
        self.iPAddressVersion = iPAddressVersion
        self.id = id
        self.name = name
    }
}

extension IPSetForwardedIPConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fallbackBehavior = "FallbackBehavior"
        case headerName = "HeaderName"
        case position = "Position"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fallbackBehavior = fallbackBehavior {
            try encodeContainer.encode(fallbackBehavior.rawValue, forKey: .fallbackBehavior)
        }
        if let headerName = headerName {
            try encodeContainer.encode(headerName, forKey: .headerName)
        }
        if let position = position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let fallbackBehaviorDecoded = try containerValues.decodeIfPresent(FallbackBehavior.self, forKey: .fallbackBehavior)
        fallbackBehavior = fallbackBehaviorDecoded
        let positionDecoded = try containerValues.decodeIfPresent(ForwardedIPPosition.self, forKey: .position)
        position = positionDecoded
    }
}

extension IPSetForwardedIPConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetForwardedIPConfig(fallbackBehavior: \(String(describing: fallbackBehavior)), headerName: \(String(describing: headerName)), position: \(String(describing: position)))"}
}

/// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p>
///
///          <note>
///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
///          </note>
///
///
///          <p>This configuration is used only for <a>IPSetReferenceStatement</a>. For <a>GeoMatchStatement</a> and <a>RateBasedStatement</a>, use <a>ForwardedIPConfig</a> instead.  </p>
public struct IPSetForwardedIPConfig: Equatable {
    /// <p>The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.</p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    ///
    ///          <p>You can specify the following fallback behaviors:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>MATCH</code> - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NO_MATCH</code> - Treat the web request as not matching the rule statement.</p>
    ///             </li>
    ///          </ul>
    public let fallbackBehavior: FallbackBehavior?
    /// <p>The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to <code>X-Forwarded-For</code>.</p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    public let headerName: String?
    /// <p>The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be <code>10.1.1.1, 127.0.0.0, 10.10.10.10</code> where the first IP address identifies the original client and the rest identify proxies that the request went through. </p>
    ///          <p>The options for this setting are the following: </p>
    ///          <ul>
    ///             <li>
    ///                <p>FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.</p>
    ///             </li>
    ///             <li>
    ///                <p>LAST - Inspect the last IP address in the list of IP addresses in the header.</p>
    ///             </li>
    ///             <li>
    ///                <p>ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.</p>
    ///             </li>
    ///          </ul>
    public let position: ForwardedIPPosition?

    public init (
        fallbackBehavior: FallbackBehavior? = nil,
        headerName: String? = nil,
        position: ForwardedIPPosition? = nil
    )
    {
        self.fallbackBehavior = fallbackBehavior
        self.headerName = headerName
        self.position = position
    }
}

extension IPSetReferenceStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case iPSetForwardedIPConfig = "IPSetForwardedIPConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let iPSetForwardedIPConfig = iPSetForwardedIPConfig {
            try encodeContainer.encode(iPSetForwardedIPConfig, forKey: .iPSetForwardedIPConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let iPSetForwardedIPConfigDecoded = try containerValues.decodeIfPresent(IPSetForwardedIPConfig.self, forKey: .iPSetForwardedIPConfig)
        iPSetForwardedIPConfig = iPSetForwardedIPConfigDecoded
    }
}

extension IPSetReferenceStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetReferenceStatement(aRN: \(String(describing: aRN)), iPSetForwardedIPConfig: \(String(describing: iPSetForwardedIPConfig)))"}
}

/// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <a>IPSet</a> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <a>CreateIPSet</a>.</p>
///          <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.</p>
public struct IPSetReferenceStatement: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a>IPSet</a> that this statement references.</p>
    public let aRN: String?
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    public let iPSetForwardedIPConfig: IPSetForwardedIPConfig?

    public init (
        aRN: String? = nil,
        iPSetForwardedIPConfig: IPSetForwardedIPConfig? = nil
    )
    {
        self.aRN = aRN
        self.iPSetForwardedIPConfig = iPSetForwardedIPConfig
    }
}

extension IPSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension IPSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetSummary(aRN: \(String(describing: aRN)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)))"}
}

/// <p>High-level information about an <a>IPSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage an <code>IPSet</code>, and the ARN, that you provide to the <a>IPSetReferenceStatement</a> to use the address set in a <a>Rule</a>.</p>
public struct IPSetSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>A description of the IP set that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
    }
}

extension JsonBody: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invalidFallbackBehavior = "InvalidFallbackBehavior"
        case matchPattern = "MatchPattern"
        case matchScope = "MatchScope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invalidFallbackBehavior = invalidFallbackBehavior {
            try encodeContainer.encode(invalidFallbackBehavior.rawValue, forKey: .invalidFallbackBehavior)
        }
        if let matchPattern = matchPattern {
            try encodeContainer.encode(matchPattern, forKey: .matchPattern)
        }
        if let matchScope = matchScope {
            try encodeContainer.encode(matchScope.rawValue, forKey: .matchScope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchPatternDecoded = try containerValues.decodeIfPresent(JsonMatchPattern.self, forKey: .matchPattern)
        matchPattern = matchPatternDecoded
        let matchScopeDecoded = try containerValues.decodeIfPresent(JsonMatchScope.self, forKey: .matchScope)
        matchScope = matchScopeDecoded
        let invalidFallbackBehaviorDecoded = try containerValues.decodeIfPresent(BodyParsingFallbackBehavior.self, forKey: .invalidFallbackBehavior)
        invalidFallbackBehavior = invalidFallbackBehaviorDecoded
    }
}

extension JsonBody: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonBody(invalidFallbackBehavior: \(String(describing: invalidFallbackBehavior)), matchPattern: \(String(describing: matchPattern)), matchScope: \(String(describing: matchScope)))"}
}

/// <p>The body of a web request, inspected as JSON. The body immediately follows the request headers. This is used in the <a>FieldToMatch</a> specification.</p>
///          <p>Use the specifications in this object to indicate which parts of the JSON body to inspect using the rule's inspection criteria. AWS WAF inspects only the parts of the JSON that result from the matches that you indicate.  </p>
public struct JsonBody: Equatable {
    /// <p>What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:</p>
    ///           <ul>
    ///             <li>
    ///           		   <p>
    ///                   <code>EVALUATE_AS_STRING</code> - Inspect the body as
    ///           			plain text. AWS WAF applies the text transformations and
    ///           			inspection criteria that you defined for the JSON inspection to
    ///           			the body text string.</p>
    ///           	</li>
    ///             <li>
    ///           		   <p>
    ///                   <code>MATCH</code> - Treat the web request as matching
    ///           			the rule statement. AWS WAF applies the rule action to the
    ///           			request.</p>
    ///           	</li>
    ///             <li>
    ///           		   <p>
    ///                   <code>NO_MATCH</code> - Treat the web request as not
    ///           			matching the rule statement.</p>
    ///           	</li>
    ///          </ul>
    ///           <p>If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters. </p>
    ///           <p>AWS WAF does its best to parse the entire JSON body, but might be forced
    ///           	to stop for reasons such as invalid characters, duplicate keys,
    ///           	truncation, and any content whose root node isn't an object or an array. </p>
    ///           <p>AWS WAF parses the JSON in the following examples as two valid key,
    ///           	value pairs: </p>
    ///           <ul>
    ///             <li>
    ///           		   <p>Missing comma:
    ///           			<code>{"key1":"value1""key2":"value2"}</code>
    ///                </p>
    ///           	</li>
    ///             <li>
    ///           		   <p>Missing colon:
    ///           			<code>{"key1":"value1","key2""value2"}</code>
    ///                </p>
    ///           	</li>
    ///             <li>
    ///           		   <p>Extra colons:
    ///           			<code>{"key1"::"value1","key2""value2"}</code>
    ///                </p>
    ///           	</li>
    ///          </ul>
    public let invalidFallbackBehavior: BodyParsingFallbackBehavior?
    /// <p>The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. </p>
    public let matchPattern: JsonMatchPattern?
    /// <p>The parts of the JSON to match against using the <code>MatchPattern</code>. If you specify <code>All</code>, AWS WAF matches against keys and values. </p>
    public let matchScope: JsonMatchScope?

    public init (
        invalidFallbackBehavior: BodyParsingFallbackBehavior? = nil,
        matchPattern: JsonMatchPattern? = nil,
        matchScope: JsonMatchScope? = nil
    )
    {
        self.invalidFallbackBehavior = invalidFallbackBehavior
        self.matchPattern = matchPattern
        self.matchScope = matchScope
    }
}

extension JsonMatchPattern: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case all = "All"
        case includedPaths = "IncludedPaths"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let all = all {
            try encodeContainer.encode(all, forKey: .all)
        }
        if let includedPaths = includedPaths {
            var includedPathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includedPaths)
            for jsonpointerpaths0 in includedPaths {
                try includedPathsContainer.encode(jsonpointerpaths0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allDecoded = try containerValues.decodeIfPresent(All.self, forKey: .all)
        all = allDecoded
        let includedPathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .includedPaths)
        var includedPathsDecoded0:[String]? = nil
        if let includedPathsContainer = includedPathsContainer {
            includedPathsDecoded0 = [String]()
            for string0 in includedPathsContainer {
                if let string0 = string0 {
                    includedPathsDecoded0?.append(string0)
                }
            }
        }
        includedPaths = includedPathsDecoded0
    }
}

extension JsonMatchPattern: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JsonMatchPattern(all: \(String(describing: all)), includedPaths: \(String(describing: includedPaths)))"}
}

/// <p>The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. This is used with the <a>FieldToMatch</a> option <code>JsonBody</code>. </p>
public struct JsonMatchPattern: Equatable {
    /// <p>Match all of the elements. See also <code>MatchScope</code> in <a>JsonBody</a>. </p>
    ///         <p>You must specify either this setting or the <code>IncludedPaths</code> setting, but not both.</p>
    public let all: All?
    /// <p>Match only the specified include paths. See also <code>MatchScope</code> in <a>JsonBody</a>. </p>
    ///          <p>Provide the include paths using JSON Pointer syntax. For example, <code>"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]</code>. For information about this syntax, see the Internet Engineering Task Force (IETF) documentation
    ///        <a href="https://tools.ietf.org/html/rfc6901">JavaScript Object Notation (JSON) Pointer</a>. </p>
    ///          <p>You must specify either this setting or the <code>All</code> setting, but not both.</p>
    ///          <note>
    ///             <p>Don't use this option to include all paths. Instead, use the <code>All</code> setting. </p>
    ///          </note>
    public let includedPaths: [String]?

    public init (
        all: All? = nil,
        includedPaths: [String]? = nil
    )
    {
        self.all = all
        self.includedPaths = includedPaths
    }
}

public enum JsonMatchScope {
    case all
    case key
    case value
    case sdkUnknown(String)
}

extension JsonMatchScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JsonMatchScope] {
        return [
            .all,
            .key,
            .value,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .key: return "KEY"
        case .value: return "VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JsonMatchScope(rawValue: rawValue) ?? JsonMatchScope.sdkUnknown(rawValue)
    }
}

extension Label: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Label: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Label(name: \(String(describing: name)))"}
}

/// <p>A single label container. This is used as an element of a label array in multiple contexts, for example, in <code>RuleLabels</code> inside a <a>Rule</a> and in <code>Labels</code> inside a <a>SampledHTTPRequest</a>. </p>
public struct Label: Equatable {
    /// <p>The label string. </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public enum LabelMatchScope {
    case label
    case namespace
    case sdkUnknown(String)
}

extension LabelMatchScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LabelMatchScope] {
        return [
            .label,
            .namespace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .label: return "LABEL"
        case .namespace: return "NAMESPACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LabelMatchScope(rawValue: rawValue) ?? LabelMatchScope.sdkUnknown(rawValue)
    }
}

extension LabelMatchStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(LabelMatchScope.self, forKey: .scope)
        scope = scopeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension LabelMatchStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelMatchStatement(key: \(String(describing: key)), scope: \(String(describing: scope)))"}
}

/// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
///          <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.  If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement. </p>
public struct LabelMatchStatement: Equatable {
    /// <p>The string to match against. The setting you provide for this depends on the match statement's <code>Scope</code> settings: </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the <code>Scope</code> indicates <code>LABEL</code>, then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name. </p>
    ///             </li>
    ///             <li>
    ///                <p>If the <code>Scope</code> indicates <code>NAMESPACE</code>, then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Labels are case sensitive and components of a label must be separated by colon, for example <code>NS1:NS2:name</code>.</p>
    public let key: String?
    /// <p>Specify whether you want to match using the label name or just the namespace. </p>
    public let scope: LabelMatchScope?

    public init (
        key: String? = nil,
        scope: LabelMatchScope? = nil
    )
    {
        self.key = key
        self.scope = scope
    }
}

extension LabelNameCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case labelName = "LabelName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelName = labelName {
            try encodeContainer.encode(labelName, forKey: .labelName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .labelName)
        labelName = labelNameDecoded
    }
}

extension LabelNameCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelNameCondition(labelName: \(String(describing: labelName)))"}
}

/// <p>A single label name condition for a <a>Condition</a> in a logging filter.</p>
public struct LabelNameCondition: Equatable {
    /// <p>The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.  </p>
    public let labelName: String?

    public init (
        labelName: String? = nil
    )
    {
        self.labelName = labelName
    }
}

extension LabelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension LabelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelSummary(name: \(String(describing: name)))"}
}

/// <p>List of labels used by one or more of the rules of a <a>RuleGroup</a>. This summary object is used for the following rule group lists: </p>
///          <ul>
///             <li>
///                <p>
///                   <code>AvailableLabels</code> - Labels that rules add to matching requests. These labels are defined in the <code>RuleLabels</code> for a <a>Rule</a>. </p>
///             </li>
///             <li>
///                <p>
///                   <code>ConsumedLabels</code> - Labels that rules match against. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <a>Statement</a> definition of a rule.  </p>
///             </li>
///          </ul>
public struct LabelSummary: Equatable {
    /// <p>An individual label specification.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

public struct ListAvailableManagedRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListAvailableManagedRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagedRuleGroupsOutputError>
}

extension ListAvailableManagedRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableManagedRuleGroupsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListAvailableManagedRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListAvailableManagedRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAvailableManagedRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagedRuleGroupsOutputError>
}

public struct ListAvailableManagedRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAvailableManagedRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAvailableManagedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAvailableManagedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListAvailableManagedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAvailableManagedRuleGroupsOutputError>
}

public struct ListAvailableManagedRuleGroupsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListAvailableManagedRuleGroupsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListAvailableManagedRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListAvailableManagedRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableManagedRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableManagedRuleGroupsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableManagedRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAvailableManagedRuleGroupsOutputResponse(managedRuleGroups: \(String(describing: managedRuleGroups)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListAvailableManagedRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAvailableManagedRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managedRuleGroups = output.managedRuleGroups
            self.nextMarker = output.nextMarker
        } else {
            self.managedRuleGroups = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAvailableManagedRuleGroupsOutputResponse: Equatable {
    /// <p></p>
    public let managedRuleGroups: [ManagedRuleGroupSummary]?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?

    public init (
        managedRuleGroups: [ManagedRuleGroupSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.managedRuleGroups = managedRuleGroups
        self.nextMarker = nextMarker
    }
}

struct ListAvailableManagedRuleGroupsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let managedRuleGroups: [ManagedRuleGroupSummary]?
}

extension ListAvailableManagedRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managedRuleGroups = "ManagedRuleGroups"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let managedRuleGroupsContainer = try containerValues.decodeIfPresent([ManagedRuleGroupSummary?].self, forKey: .managedRuleGroups)
        var managedRuleGroupsDecoded0:[ManagedRuleGroupSummary]? = nil
        if let managedRuleGroupsContainer = managedRuleGroupsContainer {
            managedRuleGroupsDecoded0 = [ManagedRuleGroupSummary]()
            for structure0 in managedRuleGroupsContainer {
                if let structure0 = structure0 {
                    managedRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        managedRuleGroups = managedRuleGroupsDecoded0
    }
}

public struct ListIPSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListIPSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

extension ListIPSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListIPSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListIPSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIPSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIPSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListIPSetsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListIPSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListIPSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIPSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIPSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIPSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsOutputResponse(iPSets: \(String(describing: iPSets)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListIPSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIPSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iPSets = output.iPSets
            self.nextMarker = output.nextMarker
        } else {
            self.iPSets = nil
            self.nextMarker = nil
        }
    }
}

public struct ListIPSetsOutputResponse: Equatable {
    /// <p>Array of IPSets. This may not be the full list of IPSets that you have defined. See the <code>Limit</code> specification for this request.</p>
    public let iPSets: [IPSetSummary]?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?

    public init (
        iPSets: [IPSetSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.iPSets = iPSets
        self.nextMarker = nextMarker
    }
}

struct ListIPSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let iPSets: [IPSetSummary]?
}

extension ListIPSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iPSets = "IPSets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let iPSetsContainer = try containerValues.decodeIfPresent([IPSetSummary?].self, forKey: .iPSets)
        var iPSetsDecoded0:[IPSetSummary]? = nil
        if let iPSetsContainer = iPSetsContainer {
            iPSetsDecoded0 = [IPSetSummary]()
            for structure0 in iPSetsContainer {
                if let structure0 = structure0 {
                    iPSetsDecoded0?.append(structure0)
                }
            }
        }
        iPSets = iPSetsDecoded0
    }
}

public struct ListLoggingConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

extension ListLoggingConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggingConfigurationsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListLoggingConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListLoggingConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

public struct ListLoggingConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

public struct ListLoggingConfigurationsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListLoggingConfigurationsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListLoggingConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListLoggingConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggingConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLoggingConfigurationsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggingConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggingConfigurationsOutputResponse(loggingConfigurations: \(String(describing: loggingConfigurations)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListLoggingConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLoggingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfigurations = output.loggingConfigurations
            self.nextMarker = output.nextMarker
        } else {
            self.loggingConfigurations = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLoggingConfigurationsOutputResponse: Equatable {
    /// <p></p>
    public let loggingConfigurations: [LoggingConfiguration]?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?

    public init (
        loggingConfigurations: [LoggingConfiguration]? = nil,
        nextMarker: String? = nil
    )
    {
        self.loggingConfigurations = loggingConfigurations
        self.nextMarker = nextMarker
    }
}

struct ListLoggingConfigurationsOutputResponseBody: Equatable {
    public let loggingConfigurations: [LoggingConfiguration]?
    public let nextMarker: String?
}

extension ListLoggingConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfigurations = "LoggingConfigurations"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationsContainer = try containerValues.decodeIfPresent([LoggingConfiguration?].self, forKey: .loggingConfigurations)
        var loggingConfigurationsDecoded0:[LoggingConfiguration]? = nil
        if let loggingConfigurationsContainer = loggingConfigurationsContainer {
            loggingConfigurationsDecoded0 = [LoggingConfiguration]()
            for structure0 in loggingConfigurationsContainer {
                if let structure0 = structure0 {
                    loggingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loggingConfigurations = loggingConfigurationsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct ListRegexPatternSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

extension ListRegexPatternSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexPatternSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListRegexPatternSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListRegexPatternSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

public struct ListRegexPatternSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

public struct ListRegexPatternSetsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListRegexPatternSetsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListRegexPatternSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRegexPatternSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegexPatternSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegexPatternSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegexPatternSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexPatternSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), regexPatternSets: \(String(describing: regexPatternSets)))"}
}

extension ListRegexPatternSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegexPatternSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.regexPatternSets = output.regexPatternSets
        } else {
            self.nextMarker = nil
            self.regexPatternSets = nil
        }
    }
}

public struct ListRegexPatternSetsOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p></p>
    public let regexPatternSets: [RegexPatternSetSummary]?

    public init (
        nextMarker: String? = nil,
        regexPatternSets: [RegexPatternSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.regexPatternSets = regexPatternSets
    }
}

struct ListRegexPatternSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let regexPatternSets: [RegexPatternSetSummary]?
}

extension ListRegexPatternSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case regexPatternSets = "RegexPatternSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let regexPatternSetsContainer = try containerValues.decodeIfPresent([RegexPatternSetSummary?].self, forKey: .regexPatternSets)
        var regexPatternSetsDecoded0:[RegexPatternSetSummary]? = nil
        if let regexPatternSetsContainer = regexPatternSetsContainer {
            regexPatternSetsDecoded0 = [RegexPatternSetSummary]()
            for structure0 in regexPatternSetsContainer {
                if let structure0 = structure0 {
                    regexPatternSetsDecoded0?.append(structure0)
                }
            }
        }
        regexPatternSets = regexPatternSetsDecoded0
    }
}

public struct ListResourcesForWebACLInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesForWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesForWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesForWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesForWebACLInput>
    public typealias MOutput = OperationOutput<ListResourcesForWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesForWebACLOutputError>
}

extension ListResourcesForWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesForWebACLInput(resourceType: \(String(describing: resourceType)), webACLArn: \(String(describing: webACLArn)))"}
}

extension ListResourcesForWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case webACLArn = "WebACLArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let webACLArn = webACLArn {
            try encodeContainer.encode(webACLArn, forKey: .webACLArn)
        }
    }
}

public struct ListResourcesForWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesForWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesForWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesForWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesForWebACLInput>
    public typealias MOutput = OperationOutput<ListResourcesForWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesForWebACLOutputError>
}

public struct ListResourcesForWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesForWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesForWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesForWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesForWebACLInput>
    public typealias MOutput = OperationOutput<ListResourcesForWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesForWebACLOutputError>
}

public struct ListResourcesForWebACLInput: Equatable {
    /// <p>Used for web ACLs that are scoped for regional applications. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API. </p>
    public let resourceType: ResourceType?
    /// <p>The Amazon Resource Name (ARN) of the Web ACL.</p>
    public let webACLArn: String?

    public init (
        resourceType: ResourceType? = nil,
        webACLArn: String? = nil
    )
    {
        self.resourceType = resourceType
        self.webACLArn = webACLArn
    }
}

struct ListResourcesForWebACLInputBody: Equatable {
    public let webACLArn: String?
    public let resourceType: ResourceType?
}

extension ListResourcesForWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceType = "ResourceType"
        case webACLArn = "WebACLArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLArn)
        webACLArn = webACLArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListResourcesForWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesForWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesForWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesForWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesForWebACLOutputResponse(resourceArns: \(String(describing: resourceArns)))"}
}

extension ListResourcesForWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesForWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceArns = output.resourceArns
        } else {
            self.resourceArns = nil
        }
    }
}

public struct ListResourcesForWebACLOutputResponse: Equatable {
    /// <p>The array of Amazon Resource Names (ARNs) of the associated resources.</p>
    public let resourceArns: [String]?

    public init (
        resourceArns: [String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

struct ListResourcesForWebACLOutputResponseBody: Equatable {
    public let resourceArns: [String]?
}

extension ListResourcesForWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArns = "ResourceArns"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
    }
}

public struct ListRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

extension ListRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListRuleGroupsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleGroupsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsOutputResponse(nextMarker: \(String(describing: nextMarker)), ruleGroups: \(String(describing: ruleGroups)))"}
}

extension ListRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.ruleGroups = output.ruleGroups
        } else {
            self.nextMarker = nil
            self.ruleGroups = nil
        }
    }
}

public struct ListRuleGroupsOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p></p>
    public let ruleGroups: [RuleGroupSummary]?

    public init (
        nextMarker: String? = nil,
        ruleGroups: [RuleGroupSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.ruleGroups = ruleGroups
    }
}

struct ListRuleGroupsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let ruleGroups: [RuleGroupSummary]?
}

extension ListRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case ruleGroups = "RuleGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let ruleGroupsContainer = try containerValues.decodeIfPresent([RuleGroupSummary?].self, forKey: .ruleGroups)
        var ruleGroupsDecoded0:[RuleGroupSummary]? = nil
        if let ruleGroupsContainer = ruleGroupsContainer {
            ruleGroupsDecoded0 = [RuleGroupSummary]()
            for structure0 in ruleGroupsContainer {
                if let structure0 = structure0 {
                    ruleGroupsDecoded0?.append(structure0)
                }
            }
        }
        ruleGroups = ruleGroupsDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceARN: String?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int?
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextMarker: \(String(describing: nextMarker)), tagInfoForResource: \(String(describing: tagInfoForResource)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.tagInfoForResource = output.tagInfoForResource
        } else {
            self.nextMarker = nil
            self.tagInfoForResource = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>The collection of tagging definitions for the resource. </p>
    public let tagInfoForResource: TagInfoForResource?

    public init (
        nextMarker: String? = nil,
        tagInfoForResource: TagInfoForResource? = nil
    )
    {
        self.nextMarker = nextMarker
        self.tagInfoForResource = tagInfoForResource
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let tagInfoForResource: TagInfoForResource?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case tagInfoForResource = "TagInfoForResource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let tagInfoForResourceDecoded = try containerValues.decodeIfPresent(TagInfoForResource.self, forKey: .tagInfoForResource)
        tagInfoForResource = tagInfoForResourceDecoded
    }
}

public struct ListWebACLsInputBodyMiddleware: Middleware {
    public let id: String = "ListWebACLsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

extension ListWebACLsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebACLsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), scope: \(String(describing: scope)))"}
}

extension ListWebACLsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct ListWebACLsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebACLsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

public struct ListWebACLsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebACLsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

public struct ListWebACLsInput: Equatable {
    /// <p>The maximum number of objects that you want AWS WAF to return for this request. If more
    ///           objects are available, in the response, AWS WAF provides a
    ///          <code>NextMarker</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let limit: Int?
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        limit: Int? = nil,
        nextMarker: String? = nil,
        scope: Scope? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.scope = scope
    }
}

struct ListWebACLsInputBody: Equatable {
    public let scope: Scope?
    public let nextMarker: String?
    public let limit: Int?
}

extension ListWebACLsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListWebACLsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebACLsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebACLsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebACLsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebACLsOutputResponse(nextMarker: \(String(describing: nextMarker)), webACLs: \(String(describing: webACLs)))"}
}

extension ListWebACLsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWebACLsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.webACLs = output.webACLs
        } else {
            self.nextMarker = nil
            self.webACLs = nil
        }
    }
}

public struct ListWebACLsOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>Limit</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the limit, AWS WAF returns a <code>NextMarker</code>
    ///          value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextMarker: String?
    /// <p></p>
    public let webACLs: [WebACLSummary]?

    public init (
        nextMarker: String? = nil,
        webACLs: [WebACLSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.webACLs = webACLs
    }
}

struct ListWebACLsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let webACLs: [WebACLSummary]?
}

extension ListWebACLsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case webACLs = "WebACLs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let webACLsContainer = try containerValues.decodeIfPresent([WebACLSummary?].self, forKey: .webACLs)
        var webACLsDecoded0:[WebACLSummary]? = nil
        if let webACLsContainer = webACLsContainer {
            webACLsDecoded0 = [WebACLSummary]()
            for structure0 in webACLsContainer {
                if let structure0 = structure0 {
                    webACLsDecoded0?.append(structure0)
                }
            }
        }
        webACLs = webACLsDecoded0
    }
}

extension LoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logDestinationConfigs = "LogDestinationConfigs"
        case loggingFilter = "LoggingFilter"
        case managedByFirewallManager = "ManagedByFirewallManager"
        case redactedFields = "RedactedFields"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logDestinationConfigs = logDestinationConfigs {
            var logDestinationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logDestinationConfigs)
            for logdestinationconfigs0 in logDestinationConfigs {
                try logDestinationConfigsContainer.encode(logdestinationconfigs0)
            }
        }
        if let loggingFilter = loggingFilter {
            try encodeContainer.encode(loggingFilter, forKey: .loggingFilter)
        }
        if managedByFirewallManager != false {
            try encodeContainer.encode(managedByFirewallManager, forKey: .managedByFirewallManager)
        }
        if let redactedFields = redactedFields {
            var redactedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redactedFields)
            for redactedfields0 in redactedFields {
                try redactedFieldsContainer.encode(redactedfields0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let logDestinationConfigsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logDestinationConfigs)
        var logDestinationConfigsDecoded0:[String]? = nil
        if let logDestinationConfigsContainer = logDestinationConfigsContainer {
            logDestinationConfigsDecoded0 = [String]()
            for string0 in logDestinationConfigsContainer {
                if let string0 = string0 {
                    logDestinationConfigsDecoded0?.append(string0)
                }
            }
        }
        logDestinationConfigs = logDestinationConfigsDecoded0
        let redactedFieldsContainer = try containerValues.decodeIfPresent([FieldToMatch?].self, forKey: .redactedFields)
        var redactedFieldsDecoded0:[FieldToMatch]? = nil
        if let redactedFieldsContainer = redactedFieldsContainer {
            redactedFieldsDecoded0 = [FieldToMatch]()
            for structure0 in redactedFieldsContainer {
                if let structure0 = structure0 {
                    redactedFieldsDecoded0?.append(structure0)
                }
            }
        }
        redactedFields = redactedFieldsDecoded0
        let managedByFirewallManagerDecoded = try containerValues.decode(Bool.self, forKey: .managedByFirewallManager)
        managedByFirewallManager = managedByFirewallManagerDecoded
        let loggingFilterDecoded = try containerValues.decodeIfPresent(LoggingFilter.self, forKey: .loggingFilter)
        loggingFilter = loggingFilterDecoded
    }
}

extension LoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfiguration(logDestinationConfigs: \(String(describing: logDestinationConfigs)), loggingFilter: \(String(describing: loggingFilter)), managedByFirewallManager: \(String(describing: managedByFirewallManager)), redactedFields: \(String(describing: redactedFields)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>Defines an association between Amazon Kinesis Data Firehose destinations and a web ACL resource, for
///          logging from AWS WAF.
///       As part of the association, you can specify parts of the standard logging fields to keep out of the logs and you
///       can specify filters so that you log only a subset of the logging records. </p>
public struct LoggingConfiguration: Equatable {
    /// <p>The Amazon Kinesis Data Firehose Amazon Resource Name (ARNs) that you want to associate with the web ACL.</p>
    public let logDestinationConfigs: [String]?
    /// <p>Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.  </p>
    public let loggingFilter: LoggingFilter?
    /// <p>Indicates whether the logging configuration was created by AWS Firewall Manager, as part of an AWS WAF policy configuration. If true, only
    ///    Firewall Manager can modify or delete the configuration. </p>
    public let managedByFirewallManager: Bool
    /// <p>The parts of the request that you want to keep out of the logs. For
    ///           example, if you redact the <code>HEADER</code> field, the <code>HEADER</code> field in the firehose will be <code>xxx</code>. </p>
    ///          <note>
    ///            <p>You must use one of the following values: <code>URI</code>, <code>QUERY_STRING</code>, <code>HEADER</code>, or <code>METHOD</code>.</p>
    ///         </note>
    public let redactedFields: [FieldToMatch]?
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with
    ///          <code>LogDestinationConfigs</code>.</p>
    public let resourceArn: String?

    public init (
        logDestinationConfigs: [String]? = nil,
        loggingFilter: LoggingFilter? = nil,
        managedByFirewallManager: Bool = false,
        redactedFields: [FieldToMatch]? = nil,
        resourceArn: String? = nil
    )
    {
        self.logDestinationConfigs = logDestinationConfigs
        self.loggingFilter = loggingFilter
        self.managedByFirewallManager = managedByFirewallManager
        self.redactedFields = redactedFields
        self.resourceArn = resourceArn
    }
}

extension LoggingFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultBehavior = "DefaultBehavior"
        case filters = "Filters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultBehavior = defaultBehavior {
            try encodeContainer.encode(defaultBehavior.rawValue, forKey: .defaultBehavior)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let defaultBehaviorDecoded = try containerValues.decodeIfPresent(FilterBehavior.self, forKey: .defaultBehavior)
        defaultBehavior = defaultBehaviorDecoded
    }
}

extension LoggingFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingFilter(defaultBehavior: \(String(describing: defaultBehavior)), filters: \(String(describing: filters)))"}
}

/// <p>Filtering that specifies which web requests are kept in the logs and which are dropped, defined for a web ACL's <a>LoggingConfiguration</a>. </p>
///          <p>You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.  </p>
public struct LoggingFilter: Equatable {
    /// <p>Default handling for logs that don't match any of the specified filtering conditions. </p>
    public let defaultBehavior: FilterBehavior?
    /// <p>The filters that you want to apply to the logs. </p>
    public let filters: [Filter]?

    public init (
        defaultBehavior: FilterBehavior? = nil,
        filters: [Filter]? = nil
    )
    {
        self.defaultBehavior = defaultBehavior
        self.filters = filters
    }
}

extension ManagedRuleGroupStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case excludedRules = "ExcludedRules"
        case name = "Name"
        case scopeDownStatement = "ScopeDownStatement"
        case vendorName = "VendorName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excludedRules = excludedRules {
            var excludedRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedRules)
            for excludedrules0 in excludedRules {
                try excludedRulesContainer.encode(excludedrules0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scopeDownStatement = scopeDownStatement {
            try encodeContainer.encode(scopeDownStatement.value, forKey: .scopeDownStatement)
        }
        if let vendorName = vendorName {
            try encodeContainer.encode(vendorName, forKey: .vendorName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let excludedRulesContainer = try containerValues.decodeIfPresent([ExcludedRule?].self, forKey: .excludedRules)
        var excludedRulesDecoded0:[ExcludedRule]? = nil
        if let excludedRulesContainer = excludedRulesContainer {
            excludedRulesDecoded0 = [ExcludedRule]()
            for structure0 in excludedRulesContainer {
                if let structure0 = structure0 {
                    excludedRulesDecoded0?.append(structure0)
                }
            }
        }
        excludedRules = excludedRulesDecoded0
        let scopeDownStatementDecoded = try containerValues.decodeIfPresent(Box<Statement>.self, forKey: .scopeDownStatement)
        scopeDownStatement = scopeDownStatementDecoded
    }
}

extension ManagedRuleGroupStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedRuleGroupStatement(excludedRules: \(String(describing: excludedRules)), name: \(String(describing: name)), scopeDownStatement: \(String(describing: scopeDownStatement)), vendorName: \(String(describing: vendorName)))"}
}

/// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <a>ListAvailableManagedRuleGroups</a>.</p>
///          <p>You can't nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
public struct ManagedRuleGroupStatement: Equatable {
    /// <p>The rules whose actions are set to <code>COUNT</code> by the web ACL, regardless of the action that is set on the rule. This effectively excludes the rule from acting on web requests.  </p>
    public let excludedRules: [ExcludedRule]?
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    public let name: String?
    /// <p>The processing guidance for a <a>Rule</a>, used by AWS WAF to determine whether a web request matches the rule. </p>
    public let scopeDownStatement: Box<Statement>?
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    public let vendorName: String?

    public init (
        excludedRules: [ExcludedRule]? = nil,
        name: String? = nil,
        scopeDownStatement: Box<Statement>? = nil,
        vendorName: String? = nil
    )
    {
        self.excludedRules = excludedRules
        self.name = name
        self.scopeDownStatement = scopeDownStatement
        self.vendorName = vendorName
    }
}

extension ManagedRuleGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case vendorName = "VendorName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let vendorName = vendorName {
            try encodeContainer.encode(vendorName, forKey: .vendorName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ManagedRuleGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedRuleGroupSummary(description: \(String(describing: description)), name: \(String(describing: name)), vendorName: \(String(describing: vendorName)))"}
}

/// <p>High-level information about a managed rule group, returned by <a>ListAvailableManagedRuleGroups</a>. This provides information like the name and vendor name, that you provide when you add a <a>ManagedRuleGroupStatement</a> to a web ACL. Managed rule groups include AWS Managed Rules rule groups, which are free of charge to AWS WAF customers, and AWS Marketplace managed rule groups, which you can subscribe to through AWS Marketplace. </p>
public struct ManagedRuleGroupSummary: Equatable {
    /// <p>The description of the managed rule group, provided by AWS Managed Rules or the AWS Marketplace seller who manages it.</p>
    public let description: String?
    /// <p>The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.</p>
    public let name: String?
    /// <p>The name of the managed rule group vendor. You use this, along with the rule group name, to identify the rule group.</p>
    public let vendorName: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        vendorName: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.vendorName = vendorName
    }
}

extension Method: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension Method: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Method()"}
}

/// <p>The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform. </p>
///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct Method: Equatable {

    public init() {}
}

extension NoneAction: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension NoneAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoneAction()"}
}

/// <p>Specifies that AWS WAF should do nothing. This is generally used to try out a rule without performing any actions. You set the <code>OverrideAction</code> on the <a>Rule</a>. </p>
///            <p>This is used in the context of other settings, for example to specify values for <a>RuleAction</a> and web ACL <a>DefaultAction</a>. </p>
public struct NoneAction: Equatable {

    public init() {}
}

extension NotStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statement = "Statement"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statement = statement {
            try encodeContainer.encode(statement.value, forKey: .statement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(Box<Statement>.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension NotStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotStatement(statement: \(String(describing: statement)))"}
}

/// <p>A logical rule statement used to negate the results of another rule statement. You provide one <a>Statement</a> within the <code>NotStatement</code>.</p>
public struct NotStatement: Equatable {
    /// <p>The statement to negate. You can use any statement that can be nested.</p>
    public let statement: Box<Statement>?

    public init (
        statement: Box<Statement>? = nil
    )
    {
        self.statement = statement
    }
}

extension OrStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statements = "Statements"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statements = statements {
            var statementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statements)
            for statements0 in statements {
                try statementsContainer.encode(statements0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([Statement?].self, forKey: .statements)
        var statementsDecoded0:[Statement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [Statement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension OrStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrStatement(statements: \(String(describing: statements)))"}
}

/// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <a>Statement</a> within the <code>OrStatement</code>. </p>
public struct OrStatement: Equatable {
    /// <p>The statements to combine with OR logic. You can use any statements that can be nested.</p>
    public let statements: [Statement]?

    public init (
        statements: [Statement]? = nil
    )
    {
        self.statements = statements
    }
}

extension OverrideAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case `none` = "None"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let `none` = `none` {
            try encodeContainer.encode(`none`, forKey: .`none`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(CountAction.self, forKey: .count)
        count = countDecoded
        let noneDecoded = try containerValues.decodeIfPresent(NoneAction.self, forKey: .none)
        `none` = noneDecoded
    }
}

extension OverrideAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverrideAction(count: \(String(describing: count)), none: \(String(describing: `none`)))"}
}

/// <p>The override action to apply to the rules in a rule group. Used only for rule statements that reference a rule group,
///            like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
///         <p>Set the override action to none to leave the rule actions in effect. Set it to count to only count matches, regardless of the rule action settings. </p>
///         <p>In a <a>Rule</a>, you must specify either this <code>OverrideAction</code> setting or the rule <code>Action</code> setting, but not both:</p>
///          <ul>
///             <li>
///                <p>If the rule statement references a rule group, use this override action setting and not the action setting.  </p>
///             </li>
///             <li>
///                <p>If the rule statement does not reference a rule group, use the rule action setting and not this rule override action setting. </p>
///             </li>
///          </ul>
public struct OverrideAction: Equatable {
    /// <p>Don't override the rule action setting.</p>
    public let `none`: NoneAction?
    /// <p>Override the rule action setting to count.</p>
    public let count: CountAction?

    public init (
        `none`: NoneAction? = nil,
        count: CountAction? = nil
    )
    {
        self.`none` = `none`
        self.count = count
    }
}

public enum ParameterExceptionField {
    case andStatement
    case bodyParsingFallbackBehavior
    case byteMatchStatement
    case customRequestHandling
    case customResponse
    case customResponseBody
    case defaultAction
    case entityLimit
    case excludedRule
    case fallbackBehavior
    case fieldToMatch
    case filterCondition
    case firewallManagerStatement
    case forwardedIpConfig
    case geoMatchStatement
    case headerName
    case ipAddress
    case ipAddressVersion
    case ipSet
    case ipSetForwardedIpConfig
    case ipSetReferenceStatement
    case jsonMatchPattern
    case jsonMatchScope
    case labelMatchStatement
    case loggingFilter
    case managedRuleSet
    case managedRuleSetStatement
    case metricName
    case notStatement
    case orStatement
    case overrideAction
    case position
    case rateBasedStatement
    case regexPatternReferenceStatement
    case regexPatternSet
    case resourceArn
    case resourceType
    case responseContentType
    case rule
    case ruleAction
    case ruleGroup
    case ruleGroupReferenceStatement
    case scopeValue
    case singleHeader
    case singleQueryArgument
    case sizeConstraintStatement
    case sqliMatchStatement
    case statement
    case tags
    case tagKeys
    case textTransformation
    case webAcl
    case xssMatchStatement
    case sdkUnknown(String)
}

extension ParameterExceptionField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterExceptionField] {
        return [
            .andStatement,
            .bodyParsingFallbackBehavior,
            .byteMatchStatement,
            .customRequestHandling,
            .customResponse,
            .customResponseBody,
            .defaultAction,
            .entityLimit,
            .excludedRule,
            .fallbackBehavior,
            .fieldToMatch,
            .filterCondition,
            .firewallManagerStatement,
            .forwardedIpConfig,
            .geoMatchStatement,
            .headerName,
            .ipAddress,
            .ipAddressVersion,
            .ipSet,
            .ipSetForwardedIpConfig,
            .ipSetReferenceStatement,
            .jsonMatchPattern,
            .jsonMatchScope,
            .labelMatchStatement,
            .loggingFilter,
            .managedRuleSet,
            .managedRuleSetStatement,
            .metricName,
            .notStatement,
            .orStatement,
            .overrideAction,
            .position,
            .rateBasedStatement,
            .regexPatternReferenceStatement,
            .regexPatternSet,
            .resourceArn,
            .resourceType,
            .responseContentType,
            .rule,
            .ruleAction,
            .ruleGroup,
            .ruleGroupReferenceStatement,
            .scopeValue,
            .singleHeader,
            .singleQueryArgument,
            .sizeConstraintStatement,
            .sqliMatchStatement,
            .statement,
            .tags,
            .tagKeys,
            .textTransformation,
            .webAcl,
            .xssMatchStatement,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .andStatement: return "AND_STATEMENT"
        case .bodyParsingFallbackBehavior: return "BODY_PARSING_FALLBACK_BEHAVIOR"
        case .byteMatchStatement: return "BYTE_MATCH_STATEMENT"
        case .customRequestHandling: return "CUSTOM_REQUEST_HANDLING"
        case .customResponse: return "CUSTOM_RESPONSE"
        case .customResponseBody: return "CUSTOM_RESPONSE_BODY"
        case .defaultAction: return "DEFAULT_ACTION"
        case .entityLimit: return "ENTITY_LIMIT"
        case .excludedRule: return "EXCLUDED_RULE"
        case .fallbackBehavior: return "FALLBACK_BEHAVIOR"
        case .fieldToMatch: return "FIELD_TO_MATCH"
        case .filterCondition: return "FILTER_CONDITION"
        case .firewallManagerStatement: return "FIREWALL_MANAGER_STATEMENT"
        case .forwardedIpConfig: return "FORWARDED_IP_CONFIG"
        case .geoMatchStatement: return "GEO_MATCH_STATEMENT"
        case .headerName: return "HEADER_NAME"
        case .ipAddress: return "IP_ADDRESS"
        case .ipAddressVersion: return "IP_ADDRESS_VERSION"
        case .ipSet: return "IP_SET"
        case .ipSetForwardedIpConfig: return "IP_SET_FORWARDED_IP_CONFIG"
        case .ipSetReferenceStatement: return "IP_SET_REFERENCE_STATEMENT"
        case .jsonMatchPattern: return "JSON_MATCH_PATTERN"
        case .jsonMatchScope: return "JSON_MATCH_SCOPE"
        case .labelMatchStatement: return "LABEL_MATCH_STATEMENT"
        case .loggingFilter: return "LOGGING_FILTER"
        case .managedRuleSet: return "MANAGED_RULE_SET"
        case .managedRuleSetStatement: return "MANAGED_RULE_SET_STATEMENT"
        case .metricName: return "METRIC_NAME"
        case .notStatement: return "NOT_STATEMENT"
        case .orStatement: return "OR_STATEMENT"
        case .overrideAction: return "OVERRIDE_ACTION"
        case .position: return "POSITION"
        case .rateBasedStatement: return "RATE_BASED_STATEMENT"
        case .regexPatternReferenceStatement: return "REGEX_PATTERN_REFERENCE_STATEMENT"
        case .regexPatternSet: return "REGEX_PATTERN_SET"
        case .resourceArn: return "RESOURCE_ARN"
        case .resourceType: return "RESOURCE_TYPE"
        case .responseContentType: return "RESPONSE_CONTENT_TYPE"
        case .rule: return "RULE"
        case .ruleAction: return "RULE_ACTION"
        case .ruleGroup: return "RULE_GROUP"
        case .ruleGroupReferenceStatement: return "RULE_GROUP_REFERENCE_STATEMENT"
        case .scopeValue: return "SCOPE_VALUE"
        case .singleHeader: return "SINGLE_HEADER"
        case .singleQueryArgument: return "SINGLE_QUERY_ARGUMENT"
        case .sizeConstraintStatement: return "SIZE_CONSTRAINT_STATEMENT"
        case .sqliMatchStatement: return "SQLI_MATCH_STATEMENT"
        case .statement: return "STATEMENT"
        case .tags: return "TAGS"
        case .tagKeys: return "TAG_KEYS"
        case .textTransformation: return "TEXT_TRANSFORMATION"
        case .webAcl: return "WEB_ACL"
        case .xssMatchStatement: return "XSS_MATCH_STATEMENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterExceptionField(rawValue: rawValue) ?? ParameterExceptionField.sdkUnknown(rawValue)
    }
}

public enum PositionalConstraint {
    case contains
    case containsWord
    case endsWith
    case exactly
    case startsWith
    case sdkUnknown(String)
}

extension PositionalConstraint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PositionalConstraint] {
        return [
            .contains,
            .containsWord,
            .endsWith,
            .exactly,
            .startsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CONTAINS"
        case .containsWord: return "CONTAINS_WORD"
        case .endsWith: return "ENDS_WITH"
        case .exactly: return "EXACTLY"
        case .startsWith: return "STARTS_WITH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PositionalConstraint(rawValue: rawValue) ?? PositionalConstraint.sdkUnknown(rawValue)
    }
}

public struct PutLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

extension PutLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingConfigurationInput(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension PutLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

public struct PutLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

public struct PutLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

public struct PutLoggingConfigurationInput: Equatable {
    /// <p></p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutLoggingConfigurationInputBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension PutLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFServiceLinkedRoleErrorException" : self = .wAFServiceLinkedRoleErrorException(try WAFServiceLinkedRoleErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFServiceLinkedRoleErrorException(WAFServiceLinkedRoleErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingConfigurationOutputResponse(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension PutLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutLoggingConfigurationOutputResponse: Equatable {
    /// <p></p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutLoggingConfigurationOutputResponseBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension PutLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct PutPermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

extension PutPermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionPolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutPermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutPermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

public struct PutPermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

public struct PutPermissionPolicyInput: Equatable {
    /// <p>The policy to attach to the specified rule group. </p>
    ///
    ///          <p>The policy specifications must conform to the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The policy must be composed using IAM Policy version 2012-10-17 or version 2015-01-01.</p>
    ///             </li>
    ///             <li>
    ///                <p>The policy must include specifications for <code>Effect</code>, <code>Action</code>, and <code>Principal</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Effect</code> must specify <code>Allow</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Action</code> must specify <code>wafv2:CreateWebACL</code>, <code>wafv2:UpdateWebACL</code>, and <code>wafv2:PutFirewallManagerRuleGroups</code>. AWS WAF rejects any extra actions or wildcard actions in the policy.</p>
    ///             </li>
    ///             <li>
    ///                <p>The policy must not include a <code>Resource</code> parameter.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a>.  </p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the <a>RuleGroup</a> to which you want to attach the policy.</p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutPermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
}

extension PutPermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidPermissionPolicyException" : self = .wAFInvalidPermissionPolicyException(try WAFInvalidPermissionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFInvalidPermissionPolicyException(WAFInvalidPermissionPolicyException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionPolicyOutputResponse()"}
}

extension PutPermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPermissionPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutPermissionPolicyOutputResponseBody: Equatable {
}

extension PutPermissionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension QueryString: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension QueryString: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryString()"}
}

/// <p>The query string of a web request. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct QueryString: Equatable {

    public init() {}
}

extension RateBasedStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aggregateKeyType = "AggregateKeyType"
        case forwardedIPConfig = "ForwardedIPConfig"
        case limit = "Limit"
        case scopeDownStatement = "ScopeDownStatement"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateKeyType = aggregateKeyType {
            try encodeContainer.encode(aggregateKeyType.rawValue, forKey: .aggregateKeyType)
        }
        if let forwardedIPConfig = forwardedIPConfig {
            try encodeContainer.encode(forwardedIPConfig, forKey: .forwardedIPConfig)
        }
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let scopeDownStatement = scopeDownStatement {
            try encodeContainer.encode(scopeDownStatement.value, forKey: .scopeDownStatement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let aggregateKeyTypeDecoded = try containerValues.decodeIfPresent(RateBasedStatementAggregateKeyType.self, forKey: .aggregateKeyType)
        aggregateKeyType = aggregateKeyTypeDecoded
        let scopeDownStatementDecoded = try containerValues.decodeIfPresent(Box<Statement>.self, forKey: .scopeDownStatement)
        scopeDownStatement = scopeDownStatementDecoded
        let forwardedIPConfigDecoded = try containerValues.decodeIfPresent(ForwardedIPConfig.self, forKey: .forwardedIPConfig)
        forwardedIPConfig = forwardedIPConfigDecoded
    }
}

extension RateBasedStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateBasedStatement(aggregateKeyType: \(String(describing: aggregateKeyType)), forwardedIPConfig: \(String(describing: forwardedIPConfig)), limit: \(String(describing: limit)), scopeDownStatement: \(String(describing: scopeDownStatement)))"}
}

/// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests.</p>
///          <p>When the rule action triggers, AWS WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
///          <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
///          <ul>
///             <li>
///                <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p>
///             </li>
///             <li>
///                <p>A string match statement that searches in the User-Agent header for the string BadBot.</p>
///             </li>
///          </ul>
///          <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
///          <p>You cannot nest a <code>RateBasedStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
public struct RateBasedStatement: Equatable {
    /// <p>Setting that indicates how to aggregate the request counts. The options are the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>IP - Aggregate the request counts on the IP address from the web request origin.</p>
    ///             </li>
    ///             <li>
    ///                <p>FORWARDED_IP - Aggregate the request counts on the first IP address in an HTTP header. If you use this, configure the <code>ForwardedIPConfig</code>, to specify the header to use. </p>
    ///             </li>
    ///          </ul>
    public let aggregateKeyType: RateBasedStatementAggregateKeyType?
    /// <p>The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name. </p>
    ///
    ///          <note>
    ///             <p>If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.</p>
    ///          </note>
    ///
    ///
    ///          <p>This is required if <code>AggregateKeyType</code> is set to <code>FORWARDED_IP</code>.</p>
    public let forwardedIPConfig: ForwardedIPConfig?
    /// <p>The limit on requests per 5-minute period for a single originating IP address. If the statement includes a <code>ScopeDownStatement</code>, this limit is applied only to the requests that match the statement.</p>
    public let limit: Int
    /// <p>An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement.</p>
    public let scopeDownStatement: Box<Statement>?

    public init (
        aggregateKeyType: RateBasedStatementAggregateKeyType? = nil,
        forwardedIPConfig: ForwardedIPConfig? = nil,
        limit: Int = 0,
        scopeDownStatement: Box<Statement>? = nil
    )
    {
        self.aggregateKeyType = aggregateKeyType
        self.forwardedIPConfig = forwardedIPConfig
        self.limit = limit
        self.scopeDownStatement = scopeDownStatement
    }
}

public enum RateBasedStatementAggregateKeyType {
    case forwardedIp
    case ip
    case sdkUnknown(String)
}

extension RateBasedStatementAggregateKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RateBasedStatementAggregateKeyType] {
        return [
            .forwardedIp,
            .ip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .forwardedIp: return "FORWARDED_IP"
        case .ip: return "IP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RateBasedStatementAggregateKeyType(rawValue: rawValue) ?? RateBasedStatementAggregateKeyType.sdkUnknown(rawValue)
    }
}

extension RateBasedStatementManagedKeysIPSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case iPAddressVersion = "IPAddressVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for ipaddresses0 in addresses {
                try addressesContainer.encode(ipaddresses0)
            }
        }
        if let iPAddressVersion = iPAddressVersion {
            try encodeContainer.encode(iPAddressVersion.rawValue, forKey: .iPAddressVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPAddressVersionDecoded = try containerValues.decodeIfPresent(IPAddressVersion.self, forKey: .iPAddressVersion)
        iPAddressVersion = iPAddressVersionDecoded
        let addressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addresses)
        var addressesDecoded0:[String]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [String]()
            for string0 in addressesContainer {
                if let string0 = string0 {
                    addressesDecoded0?.append(string0)
                }
            }
        }
        addresses = addressesDecoded0
    }
}

extension RateBasedStatementManagedKeysIPSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateBasedStatementManagedKeysIPSet(addresses: \(String(describing: addresses)), iPAddressVersion: \(String(describing: iPAddressVersion)))"}
}

/// <p>The set of IP addresses that are currently blocked for a rate-based statement.</p>
public struct RateBasedStatementManagedKeysIPSet: Equatable {
    /// <p>The IP addresses that are currently blocked.</p>
    public let addresses: [String]?
    public let iPAddressVersion: IPAddressVersion?

    public init (
        addresses: [String]? = nil,
        iPAddressVersion: IPAddressVersion? = nil
    )
    {
        self.addresses = addresses
        self.iPAddressVersion = iPAddressVersion
    }
}

extension Regex: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regexString = "RegexString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regexString = regexString {
            try encodeContainer.encode(regexString, forKey: .regexString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexString)
        regexString = regexStringDecoded
    }
}

extension Regex: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Regex(regexString: \(String(describing: regexString)))"}
}

/// <p>A single regular expression. This is used in a <a>RegexPatternSet</a>.</p>
public struct Regex: Equatable {
    /// <p>The string representing the regular expression.</p>
    public let regexString: String?

    public init (
        regexString: String? = nil
    )
    {
        self.regexString = regexString
    }
}

extension RegexPatternSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case regularExpressionList = "RegularExpressionList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regularExpressionList = regularExpressionList {
            var regularExpressionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regularExpressionList)
            for regularexpressionlist0 in regularExpressionList {
                try regularExpressionListContainer.encode(regularexpressionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let regularExpressionListContainer = try containerValues.decodeIfPresent([Regex?].self, forKey: .regularExpressionList)
        var regularExpressionListDecoded0:[Regex]? = nil
        if let regularExpressionListContainer = regularExpressionListContainer {
            regularExpressionListDecoded0 = [Regex]()
            for structure0 in regularExpressionListContainer {
                if let structure0 = structure0 {
                    regularExpressionListDecoded0?.append(structure0)
                }
            }
        }
        regularExpressionList = regularExpressionListDecoded0
    }
}

extension RegexPatternSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSet(aRN: \(String(describing: aRN)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), regularExpressionList: \(String(describing: regularExpressionList)))"}
}

/// <p>Contains one or more regular expressions. </p>
///          <p>AWS WAF assigns an ARN to each <code>RegexPatternSet</code> that you create. To use a set in a rule, you provide the ARN to the <a>Rule</a> statement <a>RegexPatternSetReferenceStatement</a>. </p>
public struct RegexPatternSet: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>A description of the set that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    public let name: String?
    /// <p>The regular expression patterns in the set.</p>
    public let regularExpressionList: [Regex]?

    public init (
        aRN: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        regularExpressionList: [Regex]? = nil
    )
    {
        self.aRN = aRN
        self.description = description
        self.id = id
        self.name = name
        self.regularExpressionList = regularExpressionList
    }
}

extension RegexPatternSetReferenceStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case fieldToMatch = "FieldToMatch"
        case textTransformations = "TextTransformations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let textTransformations = textTransformations {
            var textTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textTransformations)
            for texttransformations0 in textTransformations {
                try textTransformationsContainer.encode(texttransformations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationsContainer = try containerValues.decodeIfPresent([TextTransformation?].self, forKey: .textTransformations)
        var textTransformationsDecoded0:[TextTransformation]? = nil
        if let textTransformationsContainer = textTransformationsContainer {
            textTransformationsDecoded0 = [TextTransformation]()
            for structure0 in textTransformationsContainer {
                if let structure0 = structure0 {
                    textTransformationsDecoded0?.append(structure0)
                }
            }
        }
        textTransformations = textTransformationsDecoded0
    }
}

extension RegexPatternSetReferenceStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSetReferenceStatement(aRN: \(String(describing: aRN)), fieldToMatch: \(String(describing: fieldToMatch)), textTransformations: \(String(describing: textTransformations)))"}
}

/// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <a>RegexPatternSet</a> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <a>CreateRegexPatternSet</a>.</p>
///          <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.</p>
public struct RegexPatternSetReferenceStatement: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a>RegexPatternSet</a> that this statement references.</p>
    public let aRN: String?
    /// <p>The part of a web request that you want AWS WAF to inspect. For more information, see <a>FieldToMatch</a>. </p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    ///          If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the
    ///          content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    public let textTransformations: [TextTransformation]?

    public init (
        aRN: String? = nil,
        fieldToMatch: FieldToMatch? = nil,
        textTransformations: [TextTransformation]? = nil
    )
    {
        self.aRN = aRN
        self.fieldToMatch = fieldToMatch
        self.textTransformations = textTransformations
    }
}

extension RegexPatternSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension RegexPatternSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSetSummary(aRN: \(String(describing: aRN)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a <a>RegexPatternSet</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RegexPatternSet</code>, and the ARN, that you provide to the <a>RegexPatternSetReferenceStatement</a> to use the pattern set in a <a>Rule</a>.</p>
public struct RegexPatternSetSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>A description of the set that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
    }
}

public enum ResourceType {
    case apiGateway
    case applicationLoadBalancer
    case appsync
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .apiGateway,
            .applicationLoadBalancer,
            .appsync,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .apiGateway: return "API_GATEWAY"
        case .applicationLoadBalancer: return "APPLICATION_LOAD_BALANCER"
        case .appsync: return "APPSYNC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public enum ResponseContentType {
    case applicationJson
    case textHtml
    case textPlain
    case sdkUnknown(String)
}

extension ResponseContentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResponseContentType] {
        return [
            .applicationJson,
            .textHtml,
            .textPlain,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applicationJson: return "APPLICATION_JSON"
        case .textHtml: return "TEXT_HTML"
        case .textPlain: return "TEXT_PLAIN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResponseContentType(rawValue: rawValue) ?? ResponseContentType.sdkUnknown(rawValue)
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case name = "Name"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case ruleLabels = "RuleLabels"
        case statement = "Statement"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideAction = overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleLabels = ruleLabels {
            var ruleLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleLabels)
            for labels0 in ruleLabels {
                try ruleLabelsContainer.encode(labels0)
            }
        }
        if let statement = statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Statement.self, forKey: .statement)
        statement = statementDecoded
        let actionDecoded = try containerValues.decodeIfPresent(RuleAction.self, forKey: .action)
        action = actionDecoded
        let overrideActionDecoded = try containerValues.decodeIfPresent(OverrideAction.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let ruleLabelsContainer = try containerValues.decodeIfPresent([Label?].self, forKey: .ruleLabels)
        var ruleLabelsDecoded0:[Label]? = nil
        if let ruleLabelsContainer = ruleLabelsContainer {
            ruleLabelsDecoded0 = [Label]()
            for structure0 in ruleLabelsContainer {
                if let structure0 = structure0 {
                    ruleLabelsDecoded0?.append(structure0)
                }
            }
        }
        ruleLabels = ruleLabelsDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(action: \(String(describing: action)), name: \(String(describing: name)), overrideAction: \(String(describing: overrideAction)), priority: \(String(describing: priority)), ruleLabels: \(String(describing: ruleLabels)), statement: \(String(describing: statement)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

/// <p>A single rule, which you can use in a <a>WebACL</a> or <a>RuleGroup</a> to identify
///          web requests that you want to allow, block, or count.
///          Each rule includes one top-level <a>Statement</a> that AWS WAF uses to identify matching
///          web requests, and parameters that govern how AWS WAF handles them. </p>
public struct Rule: Equatable {
    /// <p>The action that AWS WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting. </p>
    ///         <p>This is used only for rules whose statements do not reference a rule group. Rule statements that reference a rule group include <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
    ///          <p>You must specify either this <code>Action</code> setting or the rule <code>OverrideAction</code> setting, but not both:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the rule statement does not reference a rule group, use this rule action setting and not the rule override action setting. </p>
    ///             </li>
    ///             <li>
    ///                <p>If the rule statement references a rule group, use the override action setting and not this action setting.  </p>
    ///             </li>
    ///          </ul>
    public let action: RuleAction?
    /// <p>The name of the rule. You can't change the name of a <code>Rule</code> after you create it. </p>
    public let name: String?
    /// <p>The override action to apply to the rules in a rule group. Used only for rule statements that reference a rule group,
    ///            like <code>RuleGroupReferenceStatement</code> and <code>ManagedRuleGroupStatement</code>. </p>
    ///         <p>Set the override action to none to leave the rule actions in effect. Set it to count to only count matches, regardless of the rule action settings. </p>
    ///         <p>In a <a>Rule</a>, you must specify either this <code>OverrideAction</code> setting or the rule <code>Action</code> setting, but not both:</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the rule statement references a rule group, use this override action setting and not the action setting.  </p>
    ///             </li>
    ///             <li>
    ///                <p>If the rule statement does not reference a rule group, use the rule action setting and not this rule override action setting. </p>
    ///             </li>
    ///          </ul>
    public let overrideAction: OverrideAction?
    /// <p>If you define more than one <code>Rule</code> in a
    ///          <code>WebACL</code>, AWS WAF evaluates each request against the <code>Rules</code>
    ///          in order based on the value of <code>Priority</code>.
    ///          AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.</p>
    public let priority: Int
    /// <p>Labels to apply to web requests that match the rule match statement. AWS WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    ///          <p>Rules that run after this rule in the web ACL can match against these labels using a <code>LabelMatchStatement</code>.</p>
    ///          <p>For each label, provide a case-sensitive string containing optional namespaces and a label name, according to the following guidelines:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Separate each component of the label with a colon. </p>
    ///             </li>
    ///             <li>
    ///                <p>Each namespace or name can have up to 128 characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>You can specify up to 5 namespaces in a label.</p>
    ///             </li>
    ///             <li>
    ///                <p>Don't use the following reserved words in your label specification: <code>aws</code>, <code>waf</code>, <code>managed</code>, <code>rulegroup</code>, <code>webacl</code>, <code>regexpatternset</code>, or <code>ipset</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, <code>myLabelName</code> or <code>nameSpace1:nameSpace2:myLabelName</code>.  </p>
    public let ruleLabels: [Label]?
    /// <p>The AWS WAF processing statement for the rule, for example <a>ByteMatchStatement</a> or <a>SizeConstraintStatement</a>. </p>
    public let statement: Statement?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        action: RuleAction? = nil,
        name: String? = nil,
        overrideAction: OverrideAction? = nil,
        priority: Int = 0,
        ruleLabels: [Label]? = nil,
        statement: Statement? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.action = action
        self.name = name
        self.overrideAction = overrideAction
        self.priority = priority
        self.ruleLabels = ruleLabels
        self.statement = statement
        self.visibilityConfig = visibilityConfig
    }
}

extension RuleAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allow = "Allow"
        case block = "Block"
        case count = "Count"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allow = allow {
            try encodeContainer.encode(allow, forKey: .allow)
        }
        if let block = block {
            try encodeContainer.encode(block, forKey: .block)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(BlockAction.self, forKey: .block)
        block = blockDecoded
        let allowDecoded = try containerValues.decodeIfPresent(AllowAction.self, forKey: .allow)
        allow = allowDecoded
        let countDecoded = try containerValues.decodeIfPresent(CountAction.self, forKey: .count)
        count = countDecoded
    }
}

extension RuleAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleAction(allow: \(String(describing: allow)), block: \(String(describing: block)), count: \(String(describing: count)))"}
}

/// <p>The action that AWS WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
public struct RuleAction: Equatable {
    /// <p>Instructs AWS WAF to allow the web request.</p>
    public let allow: AllowAction?
    /// <p>Instructs AWS WAF to block the web request.</p>
    public let block: BlockAction?
    /// <p>Instructs AWS WAF to count the web request and allow it.</p>
    public let count: CountAction?

    public init (
        allow: AllowAction? = nil,
        block: BlockAction? = nil,
        count: CountAction? = nil
    )
    {
        self.allow = allow
        self.block = block
        self.count = count
    }
}

extension RuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case availableLabels = "AvailableLabels"
        case capacity = "Capacity"
        case consumedLabels = "ConsumedLabels"
        case customResponseBodies = "CustomResponseBodies"
        case description = "Description"
        case id = "Id"
        case labelNamespace = "LabelNamespace"
        case name = "Name"
        case rules = "Rules"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let availableLabels = availableLabels {
            var availableLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableLabels)
            for labelsummaries0 in availableLabels {
                try availableLabelsContainer.encode(labelsummaries0)
            }
        }
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let consumedLabels = consumedLabels {
            var consumedLabelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .consumedLabels)
            for labelsummaries0 in consumedLabels {
                try consumedLabelsContainer.encode(labelsummaries0)
            }
        }
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labelNamespace = labelNamespace {
            try encodeContainer.encode(labelNamespace, forKey: .labelNamespace)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let capacityDecoded = try containerValues.decode(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let labelNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .labelNamespace)
        labelNamespace = labelNamespaceDecoded
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
        let availableLabelsContainer = try containerValues.decodeIfPresent([LabelSummary?].self, forKey: .availableLabels)
        var availableLabelsDecoded0:[LabelSummary]? = nil
        if let availableLabelsContainer = availableLabelsContainer {
            availableLabelsDecoded0 = [LabelSummary]()
            for structure0 in availableLabelsContainer {
                if let structure0 = structure0 {
                    availableLabelsDecoded0?.append(structure0)
                }
            }
        }
        availableLabels = availableLabelsDecoded0
        let consumedLabelsContainer = try containerValues.decodeIfPresent([LabelSummary?].self, forKey: .consumedLabels)
        var consumedLabelsDecoded0:[LabelSummary]? = nil
        if let consumedLabelsContainer = consumedLabelsContainer {
            consumedLabelsDecoded0 = [LabelSummary]()
            for structure0 in consumedLabelsContainer {
                if let structure0 = structure0 {
                    consumedLabelsDecoded0?.append(structure0)
                }
            }
        }
        consumedLabels = consumedLabelsDecoded0
    }
}

extension RuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroup(aRN: \(String(describing: aRN)), availableLabels: \(String(describing: availableLabels)), capacity: \(String(describing: capacity)), consumedLabels: \(String(describing: consumedLabels)), customResponseBodies: \(String(describing: customResponseBodies)), description: \(String(describing: description)), id: \(String(describing: id)), labelNamespace: \(String(describing: labelNamespace)), name: \(String(describing: name)), rules: \(String(describing: rules)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

/// <p> A rule group defines a collection of rules to inspect and control web requests that you can use in a <a>WebACL</a>. When you create a rule group, you define an immutable capacity limit. If you update a rule group, you must stay within the capacity. This allows others to reuse the rule group with confidence in its capacity requirements. </p>
public struct RuleGroup: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>The labels that one or more rules in this rule group add to matching web ACLs. These labels are defined in the <code>RuleLabels</code> for a <a>Rule</a>.</p>
    public let availableLabels: [LabelSummary]?
    /// <p>The web ACL capacity units (WCUs) required for this rule group.</p>
    ///           <p>When you create your own rule group, you define this, and you cannot change it after creation.
    ///           When you add or modify the rules in a rule group, AWS WAF enforces this limit. You can check the capacity
    ///           for a set of rules using <a>CheckCapacity</a>.</p>
    ///           <p>AWS WAF uses WCUs to calculate and control the operating
    ///          resources that are used to run your rules, rule groups, and web ACLs. AWS WAF
    ///          calculates capacity differently for each rule type, to reflect the relative cost of each rule.
    ///          Simple rules that cost little to run use fewer WCUs than more complex rules
    /// 				that use more processing power.
    /// 				Rule group capacity is fixed at creation, which helps users plan their
    ///          web ACL WCU usage when they use a rule group.
    ///          The WCU limit for web ACLs is 1,500.  </p>
    public let capacity: Int
    /// <p>The labels that one or more rules in this rule group match against in label match statements. These labels are defined in a <code>LabelMatchStatement</code> specification, in the <a>Statement</a> definition of a rule.  </p>
    public let consumedLabels: [LabelSummary]?
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>A description of the rule group that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>The label namespace prefix for this rule group. All labels added by rules in this rule group have this prefix. </p>
    ///          <ul>
    ///             <li>
    ///                <p>The syntax for the label namespace prefix for your rule groups is the following: </p>
    ///                <p>
    ///                   <code>awswaf:<account ID>:rulegroup:<rule group name>:</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>When a rule with a label matches a web request, AWS WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p>
    ///                <p>
    ///                   <code><label namespace>:<label from rule></code>
    ///                </p>
    ///
    ///             </li>
    ///          </ul>
    public let labelNamespace: String?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        aRN: String? = nil,
        availableLabels: [LabelSummary]? = nil,
        capacity: Int = 0,
        consumedLabels: [LabelSummary]? = nil,
        customResponseBodies: [String:CustomResponseBody]? = nil,
        description: String? = nil,
        id: String? = nil,
        labelNamespace: String? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.aRN = aRN
        self.availableLabels = availableLabels
        self.capacity = capacity
        self.consumedLabels = consumedLabels
        self.customResponseBodies = customResponseBodies
        self.description = description
        self.id = id
        self.labelNamespace = labelNamespace
        self.name = name
        self.rules = rules
        self.visibilityConfig = visibilityConfig
    }
}

extension RuleGroupReferenceStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case excludedRules = "ExcludedRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let excludedRules = excludedRules {
            var excludedRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedRules)
            for excludedrules0 in excludedRules {
                try excludedRulesContainer.encode(excludedrules0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let excludedRulesContainer = try containerValues.decodeIfPresent([ExcludedRule?].self, forKey: .excludedRules)
        var excludedRulesDecoded0:[ExcludedRule]? = nil
        if let excludedRulesContainer = excludedRulesContainer {
            excludedRulesDecoded0 = [ExcludedRule]()
            for structure0 in excludedRulesContainer {
                if let structure0 = structure0 {
                    excludedRulesDecoded0?.append(structure0)
                }
            }
        }
        excludedRules = excludedRulesDecoded0
    }
}

extension RuleGroupReferenceStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupReferenceStatement(aRN: \(String(describing: aRN)), excludedRules: \(String(describing: excludedRules)))"}
}

/// <p>A rule statement used to run the rules that are defined in a <a>RuleGroup</a>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
///          <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
public struct RuleGroupReferenceStatement: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>The names of rules that are in the referenced rule group, but that you want AWS WAF to exclude from processing for this rule statement. </p>
    public let excludedRules: [ExcludedRule]?

    public init (
        aRN: String? = nil,
        excludedRules: [ExcludedRule]? = nil
    )
    {
        self.aRN = aRN
        self.excludedRules = excludedRules
    }
}

extension RuleGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension RuleGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupSummary(aRN: \(String(describing: aRN)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a <a>RuleGroup</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <a>RuleGroupReferenceStatement</a> to use the rule group in a <a>Rule</a>.</p>
public struct RuleGroupSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>A description of the rule group that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the data type instance. You cannot change the name after you create the instance.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
    }
}

extension RuleSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension RuleSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleSummary(action: \(String(describing: action)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a <a>Rule</a>, returned by operations like <a>DescribeManagedRuleGroup</a>. This provides information like the ID, that you can use to retrieve and manage a <code>RuleGroup</code>, and the ARN, that you provide to the <a>RuleGroupReferenceStatement</a> to use the rule group in a <a>Rule</a>.</p>
public struct RuleSummary: Equatable {
    /// <p>The action that AWS WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting. </p>
    public let action: RuleAction?
    /// <p>The name of the rule. </p>
    public let name: String?

    public init (
        action: RuleAction? = nil,
        name: String? = nil
    )
    {
        self.action = action
        self.name = name
    }
}

extension SampledHTTPRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case labels = "Labels"
        case request = "Request"
        case requestHeadersInserted = "RequestHeadersInserted"
        case responseCodeSent = "ResponseCodeSent"
        case ruleNameWithinRuleGroup = "RuleNameWithinRuleGroup"
        case timestamp = "Timestamp"
        case weight = "Weight"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for labels0 in labels {
                try labelsContainer.encode(labels0)
            }
        }
        if let request = request {
            try encodeContainer.encode(request, forKey: .request)
        }
        if let requestHeadersInserted = requestHeadersInserted {
            var requestHeadersInsertedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestHeadersInserted)
            for httpheaders0 in requestHeadersInserted {
                try requestHeadersInsertedContainer.encode(httpheaders0)
            }
        }
        if let responseCodeSent = responseCodeSent {
            try encodeContainer.encode(responseCodeSent, forKey: .responseCodeSent)
        }
        if let ruleNameWithinRuleGroup = ruleNameWithinRuleGroup {
            try encodeContainer.encode(ruleNameWithinRuleGroup, forKey: .ruleNameWithinRuleGroup)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(HTTPRequest.self, forKey: .request)
        request = requestDecoded
        let weightDecoded = try containerValues.decode(Int.self, forKey: .weight)
        weight = weightDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let ruleNameWithinRuleGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleNameWithinRuleGroup)
        ruleNameWithinRuleGroup = ruleNameWithinRuleGroupDecoded
        let requestHeadersInsertedContainer = try containerValues.decodeIfPresent([HTTPHeader?].self, forKey: .requestHeadersInserted)
        var requestHeadersInsertedDecoded0:[HTTPHeader]? = nil
        if let requestHeadersInsertedContainer = requestHeadersInsertedContainer {
            requestHeadersInsertedDecoded0 = [HTTPHeader]()
            for structure0 in requestHeadersInsertedContainer {
                if let structure0 = structure0 {
                    requestHeadersInsertedDecoded0?.append(structure0)
                }
            }
        }
        requestHeadersInserted = requestHeadersInsertedDecoded0
        let responseCodeSentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .responseCodeSent)
        responseCodeSent = responseCodeSentDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Label?].self, forKey: .labels)
        var labelsDecoded0:[Label]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Label]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension SampledHTTPRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampledHTTPRequest(action: \(String(describing: action)), labels: \(String(describing: labels)), request: \(String(describing: request)), requestHeadersInserted: \(String(describing: requestHeadersInserted)), responseCodeSent: \(String(describing: responseCodeSent)), ruleNameWithinRuleGroup: \(String(describing: ruleNameWithinRuleGroup)), timestamp: \(String(describing: timestamp)), weight: \(String(describing: weight)))"}
}

/// <p>Represents a single sampled web request. The response from <a>GetSampledRequests</a> includes a <code>SampledHTTPRequests</code> complex type that
///          appears as <code>SampledRequests</code> in the response syntax. <code>SampledHTTPRequests</code> contains an array of <code>SampledHTTPRequest</code> objects.</p>
public struct SampledHTTPRequest: Equatable {
    /// <p>The action for the <code>Rule</code> that the request matched: <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p>
    public let action: String?
    /// <p>Labels applied to the web request by matching rules. AWS WAF applies fully qualified labels to matching web requests. A fully qualified label is the concatenation of a label namespace and a rule label. The rule's rule group or web ACL defines the label namespace. </p>
    ///          <p>For example, <code>awswaf:111122223333:myRuleGroup:testRules:testNS1:testNS2:labelNameA</code> or <code>awswaf:managed:aws:managed-rule-set:header:encoding:utf8</code>.  </p>
    public let labels: [Label]?
    /// <p>A complex type that contains detailed information about the request.</p>
    public let request: HTTPRequest?
    /// <p>Custom request headers inserted by AWS WAF into the request, according to the custom request configuration for the matching rule action.</p>
    public let requestHeadersInserted: [HTTPHeader]?
    /// <p>The response code that was sent for the request.</p>
    public let responseCodeSent: Int?
    /// <p>The name of the <code>Rule</code> that the request matched. For managed rule groups, the format for this name is <code><vendor name>#<managed rule group name>#<rule name></code>. For your own rule
    ///          groups, the format for this name is <code><rule group name>#<rule name></code>. If the rule is not in a rule group, this field is absent. </p>
    public let ruleNameWithinRuleGroup: String?
    /// <p>The time at which AWS WAF received the request from your AWS resource, in Unix time format (in seconds).</p>
    public let timestamp: Date?
    /// <p>A value that indicates how one result in the response relates
    ///          proportionally to other results in the response.
    ///          For example, a result that has a weight of <code>2</code> represents roughly twice
    ///          as many web requests as a result
    ///          that has a weight of <code>1</code>.</p>
    public let weight: Int

    public init (
        action: String? = nil,
        labels: [Label]? = nil,
        request: HTTPRequest? = nil,
        requestHeadersInserted: [HTTPHeader]? = nil,
        responseCodeSent: Int? = nil,
        ruleNameWithinRuleGroup: String? = nil,
        timestamp: Date? = nil,
        weight: Int = 0
    )
    {
        self.action = action
        self.labels = labels
        self.request = request
        self.requestHeadersInserted = requestHeadersInserted
        self.responseCodeSent = responseCodeSent
        self.ruleNameWithinRuleGroup = ruleNameWithinRuleGroup
        self.timestamp = timestamp
        self.weight = weight
    }
}

public enum Scope {
    case cloudfront
    case regional
    case sdkUnknown(String)
}

extension Scope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Scope] {
        return [
            .cloudfront,
            .regional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudfront: return "CLOUDFRONT"
        case .regional: return "REGIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Scope(rawValue: rawValue) ?? Scope.sdkUnknown(rawValue)
    }
}

extension SingleHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SingleHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingleHeader(name: \(String(describing: name)))"}
}

/// <p>One of the headers in a web request, identified by name, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct SingleHeader: Equatable {
    /// <p>The name of the query header to inspect.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension SingleQueryArgument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SingleQueryArgument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SingleQueryArgument(name: \(String(describing: name)))"}
}

/// <p>One query argument in a web request, identified by name, for example <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
public struct SingleQueryArgument: Equatable {
    /// <p>The name of the query argument to inspect.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension SizeConstraintStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case fieldToMatch = "FieldToMatch"
        case size = "Size"
        case textTransformations = "TextTransformations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let textTransformations = textTransformations {
            var textTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textTransformations)
            for texttransformations0 in textTransformations {
                try textTransformationsContainer.encode(texttransformations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
        let textTransformationsContainer = try containerValues.decodeIfPresent([TextTransformation?].self, forKey: .textTransformations)
        var textTransformationsDecoded0:[TextTransformation]? = nil
        if let textTransformationsContainer = textTransformationsContainer {
            textTransformationsDecoded0 = [TextTransformation]()
            for structure0 in textTransformationsContainer {
                if let structure0 = structure0 {
                    textTransformationsDecoded0?.append(structure0)
                }
            }
        }
        textTransformations = textTransformationsDecoded0
    }
}

extension SizeConstraintStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SizeConstraintStatement(comparisonOperator: \(String(describing: comparisonOperator)), fieldToMatch: \(String(describing: fieldToMatch)), size: \(String(describing: size)), textTransformations: \(String(describing: textTransformations)))"}
}

/// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
///          <p>If you configure AWS WAF to inspect the request body, AWS WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
///          <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
public struct SizeConstraintStatement: Equatable {
    /// <p>The operator to use to compare the request part to the size setting. </p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>The part of a web request that you want AWS WAF to inspect. For more information, see <a>FieldToMatch</a>. </p>
    public let fieldToMatch: FieldToMatch?
    /// <p>The size, in byte, to compare to the request part, after any transformations.</p>
    public let size: Int
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    ///          If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the
    ///          content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    public let textTransformations: [TextTransformation]?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        fieldToMatch: FieldToMatch? = nil,
        size: Int = 0,
        textTransformations: [TextTransformation]? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.fieldToMatch = fieldToMatch
        self.size = size
        self.textTransformations = textTransformations
    }
}

extension SqliMatchStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case textTransformations = "TextTransformations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let textTransformations = textTransformations {
            var textTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textTransformations)
            for texttransformations0 in textTransformations {
                try textTransformationsContainer.encode(texttransformations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationsContainer = try containerValues.decodeIfPresent([TextTransformation?].self, forKey: .textTransformations)
        var textTransformationsDecoded0:[TextTransformation]? = nil
        if let textTransformationsContainer = textTransformationsContainer {
            textTransformationsDecoded0 = [TextTransformation]()
            for structure0 in textTransformationsContainer {
                if let structure0 = structure0 {
                    textTransformationsDecoded0?.append(structure0)
                }
            }
        }
        textTransformations = textTransformationsDecoded0
    }
}

extension SqliMatchStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqliMatchStatement(fieldToMatch: \(String(describing: fieldToMatch)), textTransformations: \(String(describing: textTransformations)))"}
}

/// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
public struct SqliMatchStatement: Equatable {
    /// <p>The part of a web request that you want AWS WAF to inspect. For more information, see <a>FieldToMatch</a>. </p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    ///          If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the
    ///          content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    public let textTransformations: [TextTransformation]?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        textTransformations: [TextTransformation]? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.textTransformations = textTransformations
    }
}

extension Statement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case andStatement = "AndStatement"
        case byteMatchStatement = "ByteMatchStatement"
        case geoMatchStatement = "GeoMatchStatement"
        case iPSetReferenceStatement = "IPSetReferenceStatement"
        case labelMatchStatement = "LabelMatchStatement"
        case managedRuleGroupStatement = "ManagedRuleGroupStatement"
        case notStatement = "NotStatement"
        case orStatement = "OrStatement"
        case rateBasedStatement = "RateBasedStatement"
        case regexPatternSetReferenceStatement = "RegexPatternSetReferenceStatement"
        case ruleGroupReferenceStatement = "RuleGroupReferenceStatement"
        case sizeConstraintStatement = "SizeConstraintStatement"
        case sqliMatchStatement = "SqliMatchStatement"
        case xssMatchStatement = "XssMatchStatement"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let andStatement = andStatement {
            try encodeContainer.encode(andStatement, forKey: .andStatement)
        }
        if let byteMatchStatement = byteMatchStatement {
            try encodeContainer.encode(byteMatchStatement, forKey: .byteMatchStatement)
        }
        if let geoMatchStatement = geoMatchStatement {
            try encodeContainer.encode(geoMatchStatement, forKey: .geoMatchStatement)
        }
        if let iPSetReferenceStatement = iPSetReferenceStatement {
            try encodeContainer.encode(iPSetReferenceStatement, forKey: .iPSetReferenceStatement)
        }
        if let labelMatchStatement = labelMatchStatement {
            try encodeContainer.encode(labelMatchStatement, forKey: .labelMatchStatement)
        }
        if let managedRuleGroupStatement = managedRuleGroupStatement {
            try encodeContainer.encode(managedRuleGroupStatement, forKey: .managedRuleGroupStatement)
        }
        if let notStatement = notStatement {
            try encodeContainer.encode(notStatement, forKey: .notStatement)
        }
        if let orStatement = orStatement {
            try encodeContainer.encode(orStatement, forKey: .orStatement)
        }
        if let rateBasedStatement = rateBasedStatement {
            try encodeContainer.encode(rateBasedStatement, forKey: .rateBasedStatement)
        }
        if let regexPatternSetReferenceStatement = regexPatternSetReferenceStatement {
            try encodeContainer.encode(regexPatternSetReferenceStatement, forKey: .regexPatternSetReferenceStatement)
        }
        if let ruleGroupReferenceStatement = ruleGroupReferenceStatement {
            try encodeContainer.encode(ruleGroupReferenceStatement, forKey: .ruleGroupReferenceStatement)
        }
        if let sizeConstraintStatement = sizeConstraintStatement {
            try encodeContainer.encode(sizeConstraintStatement, forKey: .sizeConstraintStatement)
        }
        if let sqliMatchStatement = sqliMatchStatement {
            try encodeContainer.encode(sqliMatchStatement, forKey: .sqliMatchStatement)
        }
        if let xssMatchStatement = xssMatchStatement {
            try encodeContainer.encode(xssMatchStatement, forKey: .xssMatchStatement)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchStatementDecoded = try containerValues.decodeIfPresent(ByteMatchStatement.self, forKey: .byteMatchStatement)
        byteMatchStatement = byteMatchStatementDecoded
        let sqliMatchStatementDecoded = try containerValues.decodeIfPresent(SqliMatchStatement.self, forKey: .sqliMatchStatement)
        sqliMatchStatement = sqliMatchStatementDecoded
        let xssMatchStatementDecoded = try containerValues.decodeIfPresent(XssMatchStatement.self, forKey: .xssMatchStatement)
        xssMatchStatement = xssMatchStatementDecoded
        let sizeConstraintStatementDecoded = try containerValues.decodeIfPresent(SizeConstraintStatement.self, forKey: .sizeConstraintStatement)
        sizeConstraintStatement = sizeConstraintStatementDecoded
        let geoMatchStatementDecoded = try containerValues.decodeIfPresent(GeoMatchStatement.self, forKey: .geoMatchStatement)
        geoMatchStatement = geoMatchStatementDecoded
        let ruleGroupReferenceStatementDecoded = try containerValues.decodeIfPresent(RuleGroupReferenceStatement.self, forKey: .ruleGroupReferenceStatement)
        ruleGroupReferenceStatement = ruleGroupReferenceStatementDecoded
        let iPSetReferenceStatementDecoded = try containerValues.decodeIfPresent(IPSetReferenceStatement.self, forKey: .iPSetReferenceStatement)
        iPSetReferenceStatement = iPSetReferenceStatementDecoded
        let regexPatternSetReferenceStatementDecoded = try containerValues.decodeIfPresent(RegexPatternSetReferenceStatement.self, forKey: .regexPatternSetReferenceStatement)
        regexPatternSetReferenceStatement = regexPatternSetReferenceStatementDecoded
        let rateBasedStatementDecoded = try containerValues.decodeIfPresent(RateBasedStatement.self, forKey: .rateBasedStatement)
        rateBasedStatement = rateBasedStatementDecoded
        let andStatementDecoded = try containerValues.decodeIfPresent(AndStatement.self, forKey: .andStatement)
        andStatement = andStatementDecoded
        let orStatementDecoded = try containerValues.decodeIfPresent(OrStatement.self, forKey: .orStatement)
        orStatement = orStatementDecoded
        let notStatementDecoded = try containerValues.decodeIfPresent(NotStatement.self, forKey: .notStatement)
        notStatement = notStatementDecoded
        let managedRuleGroupStatementDecoded = try containerValues.decodeIfPresent(ManagedRuleGroupStatement.self, forKey: .managedRuleGroupStatement)
        managedRuleGroupStatement = managedRuleGroupStatementDecoded
        let labelMatchStatementDecoded = try containerValues.decodeIfPresent(LabelMatchStatement.self, forKey: .labelMatchStatement)
        labelMatchStatement = labelMatchStatementDecoded
    }
}

extension Statement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Statement(andStatement: \(String(describing: andStatement)), byteMatchStatement: \(String(describing: byteMatchStatement)), geoMatchStatement: \(String(describing: geoMatchStatement)), iPSetReferenceStatement: \(String(describing: iPSetReferenceStatement)), labelMatchStatement: \(String(describing: labelMatchStatement)), managedRuleGroupStatement: \(String(describing: managedRuleGroupStatement)), notStatement: \(String(describing: notStatement)), orStatement: \(String(describing: orStatement)), rateBasedStatement: \(String(describing: rateBasedStatement)), regexPatternSetReferenceStatement: \(String(describing: regexPatternSetReferenceStatement)), ruleGroupReferenceStatement: \(String(describing: ruleGroupReferenceStatement)), sizeConstraintStatement: \(String(describing: sizeConstraintStatement)), sqliMatchStatement: \(String(describing: sqliMatchStatement)), xssMatchStatement: \(String(describing: xssMatchStatement)))"}
}

/// <p>The processing guidance for a <a>Rule</a>, used by AWS WAF to determine whether a web request matches the rule. </p>
public struct Statement: Equatable {
    /// <p>A logical rule statement used to combine other rule statements with AND logic. You provide more than one <a>Statement</a> within the <code>AndStatement</code>. </p>
    public let andStatement: AndStatement?
    /// <p>A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is refered to as a string match statement.</p>
    public let byteMatchStatement: ByteMatchStatement?
    /// <p>A rule statement used to identify web requests based on country of origin.  </p>
    public let geoMatchStatement: GeoMatchStatement?
    /// <p>A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an <a>IPSet</a> that specifies the addresses you want to detect, then use the ARN of that set in this statement. To create an IP set, see <a>CreateIPSet</a>.</p>
    ///          <p>Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.</p>
    public let iPSetReferenceStatement: IPSetReferenceStatement?
    /// <p>A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. </p>
    ///          <p>The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.  If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement. </p>
    public let labelMatchStatement: LabelMatchStatement?
    /// <p>A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names by calling <a>ListAvailableManagedRuleGroups</a>.</p>
    ///          <p>You can't nest a <code>ManagedRuleGroupStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    public let managedRuleGroupStatement: ManagedRuleGroupStatement?
    /// <p>A logical rule statement used to negate the results of another rule statement. You provide one <a>Statement</a> within the <code>NotStatement</code>.</p>
    public let notStatement: NotStatement?
    /// <p>A logical rule statement used to combine other rule statements with OR logic. You provide more than one <a>Statement</a> within the <code>OrStatement</code>. </p>
    public let orStatement: OrStatement?
    /// <p>A rate-based rule tracks the rate of requests for each originating IP address, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any 5-minute time span. You can use this to put a temporary block on requests from an IP address that is sending excessive requests.</p>
    ///          <p>When the rule action triggers, AWS WAF blocks additional requests from the IP address until the request rate falls below the limit.</p>
    ///          <p>You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts requests that match the nested statement. For example, based on recent requests that you have seen from an attacker, you might create a rate-based rule with a nested AND rule statement that contains the following nested statements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An IP match statement with an IP set that specified the address 192.0.2.44.</p>
    ///             </li>
    ///             <li>
    ///                <p>A string match statement that searches in the User-Agent header for the string BadBot.</p>
    ///             </li>
    ///          </ul>
    ///          <p>In this rate-based rule, you also define a rate limit. For this example, the rate limit is 1,000. Requests that meet both of the conditions in the statements are counted. If the count exceeds 1,000 requests per five minutes, the rule action triggers. Requests that do not meet both conditions are not counted towards the rate limit and are not affected by this rule.</p>
    ///          <p>You cannot nest a <code>RateBasedStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    public let rateBasedStatement: RateBasedStatement?
    /// <p>A rule statement used to search web request components for matches with regular expressions. To use this, create a <a>RegexPatternSet</a> that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set. To create a regex pattern set, see <a>CreateRegexPatternSet</a>.</p>
    ///          <p>Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.</p>
    public let regexPatternSetReferenceStatement: RegexPatternSetReferenceStatement?
    /// <p>A rule statement used to run the rules that are defined in a <a>RuleGroup</a>. To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.</p>
    ///          <p>You cannot nest a <code>RuleGroupReferenceStatement</code>, for example for use inside a <code>NotStatement</code> or <code>OrStatement</code>. It can only be referenced as a top-level statement within a rule.</p>
    public let ruleGroupReferenceStatement: RuleGroupReferenceStatement?
    /// <p>A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes. </p>
    ///          <p>If you configure AWS WAF to inspect the request body, AWS WAF inspects only the first 8192 bytes (8 KB). If the request body for your web requests never exceeds 8192 bytes, you can create a size constraint condition and block requests that have a request body greater than 8192 bytes.</p>
    ///          <p>If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
    public let sizeConstraintStatement: SizeConstraintStatement?
    /// <p>Attackers sometimes insert malicious SQL code into web requests in an effort to extract data from your database. To allow or block web requests that appear to contain malicious SQL code, create one or more SQL injection match conditions. An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. Later in the process, when you create a web ACL, you specify whether to allow or block requests that appear to contain malicious SQL code.</p>
    public let sqliMatchStatement: SqliMatchStatement?
    /// <p>A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests.
    ///          XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious
    ///          client-site scripts into other legitimate web browsers.
    ///          The XSS match statement provides the location in requests that you want AWS WAF to search and text transformations
    ///          to use on the search area before AWS WAF searches for character sequences that are likely to be malicious strings. </p>
    public let xssMatchStatement: XssMatchStatement?

    public init (
        andStatement: AndStatement? = nil,
        byteMatchStatement: ByteMatchStatement? = nil,
        geoMatchStatement: GeoMatchStatement? = nil,
        iPSetReferenceStatement: IPSetReferenceStatement? = nil,
        labelMatchStatement: LabelMatchStatement? = nil,
        managedRuleGroupStatement: ManagedRuleGroupStatement? = nil,
        notStatement: NotStatement? = nil,
        orStatement: OrStatement? = nil,
        rateBasedStatement: RateBasedStatement? = nil,
        regexPatternSetReferenceStatement: RegexPatternSetReferenceStatement? = nil,
        ruleGroupReferenceStatement: RuleGroupReferenceStatement? = nil,
        sizeConstraintStatement: SizeConstraintStatement? = nil,
        sqliMatchStatement: SqliMatchStatement? = nil,
        xssMatchStatement: XssMatchStatement? = nil
    )
    {
        self.andStatement = andStatement
        self.byteMatchStatement = byteMatchStatement
        self.geoMatchStatement = geoMatchStatement
        self.iPSetReferenceStatement = iPSetReferenceStatement
        self.labelMatchStatement = labelMatchStatement
        self.managedRuleGroupStatement = managedRuleGroupStatement
        self.notStatement = notStatement
        self.orStatement = orStatement
        self.rateBasedStatement = rateBasedStatement
        self.regexPatternSetReferenceStatement = regexPatternSetReferenceStatement
        self.ruleGroupReferenceStatement = ruleGroupReferenceStatement
        self.sizeConstraintStatement = sizeConstraintStatement
        self.sqliMatchStatement = sqliMatchStatement
        self.xssMatchStatement = xssMatchStatement
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag associated with an AWS resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a
///   specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each AWS resource, up to 50 tags for a resource.</p>
///         <p>You can tag the AWS resources that you manage through AWS WAF: web ACLs, rule groups, IP
///   sets, and regex pattern sets. You can't manage or view tags through the AWS WAF console. </p>
public struct Tag: Equatable {
    /// <p>Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.</p>
    public let key: String?
    /// <p>Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagInfoForResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagInfoForResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagInfoForResource(resourceARN: \(String(describing: resourceARN)), tagList: \(String(describing: tagList)))"}
}

/// <p>The collection of tagging definitions for an AWS resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a
///   specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each AWS resource, up to 50 tags for a resource.</p>
///         <p>You can tag the AWS resources that you manage through AWS WAF: web ACLs, rule groups, IP
///   sets, and regex pattern sets. You can't manage or view tags through the AWS WAF console. </p>
public struct TagInfoForResource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceARN: String?
    /// <p>The array of <a>Tag</a> objects defined for the resource. </p>
    public let tagList: [Tag]?

    public init (
        resourceARN: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagList = tagList
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceARN: String?
    /// <p>An array of key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TextTransformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority = "Priority"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TextTransformationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension TextTransformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TextTransformation(priority: \(String(describing: priority)), type: \(String(describing: type)))"}
}

/// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
///          </p>
public struct TextTransformation: Equatable {
    /// <p>Sets the relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all
    ///          transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different. </p>
    public let priority: Int
    /// <p>You can specify the following transformation types:</p>
    ///          <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    ///          <p>When you're concerned that attackers are injecting an operating system command line
    ///          command and using unusual formatting to disguise some or all of the command, use this
    ///          option to perform the following transformations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    ///          <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    ///          <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    ///          <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    ///          <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    ///          the following operations:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    ///                characters</p>
    ///             </li>
    ///          </ul>		
    ///          <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    ///          <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    ///          <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    ///          <p>Use this option to decode a URL-encoded value.</p>		
    ///          <p>
    ///             <b>NONE</b>
    ///          </p>
    ///          <p>Specify <code>NONE</code> if you don't want any text transformations.</p>
    public let type: TextTransformationType?

    public init (
        priority: Int = 0,
        type: TextTransformationType? = nil
    )
    {
        self.priority = priority
        self.type = type
    }
}

public enum TextTransformationType {
    case cmdLine
    case compressWhiteSpace
    case htmlEntityDecode
    case lowercase
    case `none`
    case urlDecode
    case sdkUnknown(String)
}

extension TextTransformationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TextTransformationType] {
        return [
            .cmdLine,
            .compressWhiteSpace,
            .htmlEntityDecode,
            .lowercase,
            .none,
            .urlDecode,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cmdLine: return "CMD_LINE"
        case .compressWhiteSpace: return "COMPRESS_WHITE_SPACE"
        case .htmlEntityDecode: return "HTML_ENTITY_DECODE"
        case .lowercase: return "LOWERCASE"
        case .none: return "NONE"
        case .urlDecode: return "URL_DECODE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TextTransformationType(rawValue: rawValue) ?? TextTransformationType.sdkUnknown(rawValue)
    }
}

extension TimeWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension TimeWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeWindow(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <p>In a <a>GetSampledRequests</a> request, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range
///          for which you want AWS WAF to return a sample of web requests.</p>
///          <p>You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
///          <p>In a <a>GetSampledRequests</a> response, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range
///          for which AWS WAF actually returned a sample of web requests. AWS WAF gets the specified number of requests from among the first
///          5,000 requests that your AWS resource receives during the specified time period. If your resource receives more than 5,000
///          requests during that period, AWS WAF stops sampling after the 5,000th request. In that case, <code>EndTime</code>
///          is the time that AWS WAF received the 5,000th request.</p>
public struct TimeWindow: Equatable {
    /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your
    ///          AWS resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    public let endTime: Date?
    /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the requests that your
    ///          AWS resource received. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceARN: String?
    /// <p>An array of keys identifying the tags to disassociate from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

extension UpdateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetInput(addresses: \(String(describing: addresses)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), scope: \(String(describing: scope)))"}
}

extension UpdateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for ipaddresses0 in addresses {
                try addressesContainer.encode(ipaddresses0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct UpdateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInput: Equatable {
    /// <p>Contains an array of strings that specify one or more IP addresses or blocks of IP addresses in Classless Inter-Domain Routing (CIDR) notation. AWS WAF supports all IPv4 and IPv6 CIDR ranges except for /0. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    ///                <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let addresses: [String]?
    /// <p>A description of the IP set that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the IP set. You cannot change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        addresses: [String]? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        scope: Scope? = nil
    )
    {
        self.addresses = addresses
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.scope = scope
    }
}

struct UpdateIPSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let description: String?
    public let addresses: [String]?
    public let lockToken: String?
}

extension UpdateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let addressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addresses)
        var addressesDecoded0:[String]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [String]()
            for string0 in addressesContainer {
                if let string0 = string0 {
                    addressesDecoded0?.append(string0)
                }
            }
        }
        addresses = addressesDecoded0
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension UpdateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIPSetOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetOutputResponse(nextLockToken: \(String(describing: nextLockToken)))"}
}

extension UpdateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextLockToken = output.nextLockToken
        } else {
            self.nextLockToken = nil
        }
    }
}

public struct UpdateIPSetOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns this token to your update requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    public let nextLockToken: String?

    public init (
        nextLockToken: String? = nil
    )
    {
        self.nextLockToken = nextLockToken
    }
}

struct UpdateIPSetOutputResponseBody: Equatable {
    public let nextLockToken: String?
}

extension UpdateIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextLockToken = "NextLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextLockToken)
        nextLockToken = nextLockTokenDecoded
    }
}

public struct UpdateRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

extension UpdateRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexPatternSetInput(description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), regularExpressionList: \(String(describing: regularExpressionList)), scope: \(String(describing: scope)))"}
}

extension UpdateRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case regularExpressionList = "RegularExpressionList"
        case scope = "Scope"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regularExpressionList = regularExpressionList {
            var regularExpressionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regularExpressionList)
            for regularexpressionlist0 in regularExpressionList {
                try regularExpressionListContainer.encode(regularexpressionlist0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }
}

public struct UpdateRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

public struct UpdateRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

public struct UpdateRegexPatternSetInput: Equatable {
    /// <p>A description of the set that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the set. You cannot change the name after you create the set.</p>
    public let name: String?
    /// <p></p>
    public let regularExpressionList: [Regex]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?

    public init (
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        regularExpressionList: [Regex]? = nil,
        scope: Scope? = nil
    )
    {
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.regularExpressionList = regularExpressionList
        self.scope = scope
    }
}

struct UpdateRegexPatternSetInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let description: String?
    public let regularExpressionList: [Regex]?
    public let lockToken: String?
}

extension UpdateRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case regularExpressionList = "RegularExpressionList"
        case scope = "Scope"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let regularExpressionListContainer = try containerValues.decodeIfPresent([Regex?].self, forKey: .regularExpressionList)
        var regularExpressionListDecoded0:[Regex]? = nil
        if let regularExpressionListContainer = regularExpressionListContainer {
            regularExpressionListDecoded0 = [Regex]()
            for structure0 in regularExpressionListContainer {
                if let structure0 = structure0 {
                    regularExpressionListDecoded0?.append(structure0)
                }
            }
        }
        regularExpressionList = regularExpressionListDecoded0
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
    }
}

extension UpdateRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegexPatternSetOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexPatternSetOutputResponse(nextLockToken: \(String(describing: nextLockToken)))"}
}

extension UpdateRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextLockToken = output.nextLockToken
        } else {
            self.nextLockToken = nil
        }
    }
}

public struct UpdateRegexPatternSetOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns this token to your update requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    public let nextLockToken: String?

    public init (
        nextLockToken: String? = nil
    )
    {
        self.nextLockToken = nextLockToken
    }
}

struct UpdateRegexPatternSetOutputResponseBody: Equatable {
    public let nextLockToken: String?
}

extension UpdateRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextLockToken = "NextLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextLockToken)
        nextLockToken = nextLockTokenDecoded
    }
}

public struct UpdateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

extension UpdateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupInput(customResponseBodies: \(String(describing: customResponseBodies)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), rules: \(String(describing: rules)), scope: \(String(describing: scope)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

extension UpdateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }
}

public struct UpdateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInput: Equatable {
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the rule group, and then use them in the rules that you define in the rule group. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>A description of the rule group that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the rule group. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the rule group. You cannot change the name of a rule group after you create it.</p>
    public let name: String?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        customResponseBodies: [String:CustomResponseBody]? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        scope: Scope? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.customResponseBodies = customResponseBodies
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.rules = rules
        self.scope = scope
        self.visibilityConfig = visibilityConfig
    }
}

struct UpdateRuleGroupInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let description: String?
    public let rules: [Rule]?
    public let visibilityConfig: VisibilityConfig?
    public let lockToken: String?
    public let customResponseBodies: [String:CustomResponseBody]?
}

extension UpdateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case visibilityConfig = "VisibilityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
    }
}

extension UpdateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleGroupOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupOutputResponse(nextLockToken: \(String(describing: nextLockToken)))"}
}

extension UpdateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextLockToken = output.nextLockToken
        } else {
            self.nextLockToken = nil
        }
    }
}

public struct UpdateRuleGroupOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns this token to your update requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    public let nextLockToken: String?

    public init (
        nextLockToken: String? = nil
    )
    {
        self.nextLockToken = nextLockToken
    }
}

struct UpdateRuleGroupOutputResponseBody: Equatable {
    public let nextLockToken: String?
}

extension UpdateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextLockToken = "NextLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextLockToken)
        nextLockToken = nextLockTokenDecoded
    }
}

public struct UpdateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

extension UpdateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebACLInput(customResponseBodies: \(String(describing: customResponseBodies)), defaultAction: \(String(describing: defaultAction)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)), rules: \(String(describing: rules)), scope: \(String(describing: scope)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

extension UpdateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }
}

public struct UpdateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

public struct UpdateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

public struct UpdateWebACLInput: Equatable {
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    public let defaultAction: DefaultAction?
    /// <p>A description of the Web ACL that helps with identification. </p>
    public let description: String?
    /// <p>The unique identifier for the Web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Specifies whether this is for an AWS CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an API Gateway REST API, or an AppSync GraphQL API.  </p>
    ///          <p>To work with CloudFront, you must also specify the Region US East (N. Virginia) as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>CLI - Specify the Region when you use the CloudFront scope: <code>--scope=CLOUDFRONT --region=us-east-1</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>API and SDKs - For all calls, use the Region endpoint us-east-1. </p>
    ///             </li>
    ///          </ul>
    public let scope: Scope?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        customResponseBodies: [String:CustomResponseBody]? = nil,
        defaultAction: DefaultAction? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil,
        rules: [Rule]? = nil,
        scope: Scope? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.customResponseBodies = customResponseBodies
        self.defaultAction = defaultAction
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
        self.rules = rules
        self.scope = scope
        self.visibilityConfig = visibilityConfig
    }
}

struct UpdateWebACLInputBody: Equatable {
    public let name: String?
    public let scope: Scope?
    public let id: String?
    public let defaultAction: DefaultAction?
    public let description: String?
    public let rules: [Rule]?
    public let visibilityConfig: VisibilityConfig?
    public let lockToken: String?
    public let customResponseBodies: [String:CustomResponseBody]?
}

extension UpdateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customResponseBodies = "CustomResponseBodies"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case visibilityConfig = "VisibilityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
    }
}

extension UpdateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDuplicateItemException" : self = .wAFDuplicateItemException(try WAFDuplicateItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidResourceException" : self = .wAFInvalidResourceException(try WAFInvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFOptimisticLockException" : self = .wAFOptimisticLockException(try WAFOptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFUnavailableEntityException" : self = .wAFUnavailableEntityException(try WAFUnavailableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWebACLOutputError: Equatable {
    case wAFDuplicateItemException(WAFDuplicateItemException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFInvalidResourceException(WAFInvalidResourceException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFOptimisticLockException(WAFOptimisticLockException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case wAFUnavailableEntityException(WAFUnavailableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebACLOutputResponse(nextLockToken: \(String(describing: nextLockToken)))"}
}

extension UpdateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextLockToken = output.nextLockToken
        } else {
            self.nextLockToken = nil
        }
    }
}

public struct UpdateWebACLOutputResponse: Equatable {
    /// <p>A token used for optimistic locking. AWS WAF returns this token to your update requests. You use <code>NextLockToken</code> in the same manner as you use <code>LockToken</code>. </p>
    public let nextLockToken: String?

    public init (
        nextLockToken: String? = nil
    )
    {
        self.nextLockToken = nextLockToken
    }
}

struct UpdateWebACLOutputResponseBody: Equatable {
    public let nextLockToken: String?
}

extension UpdateWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextLockToken = "NextLockToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextLockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextLockToken)
        nextLockToken = nextLockTokenDecoded
    }
}

extension UriPath: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension UriPath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UriPath()"}
}

/// <p>The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
///          <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
public struct UriPath: Equatable {

    public init() {}
}

extension VisibilityConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case metricName = "MetricName"
        case sampledRequestsEnabled = "SampledRequestsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudWatchMetricsEnabled != false {
            try encodeContainer.encode(cloudWatchMetricsEnabled, forKey: .cloudWatchMetricsEnabled)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if sampledRequestsEnabled != false {
            try encodeContainer.encode(sampledRequestsEnabled, forKey: .sampledRequestsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampledRequestsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .sampledRequestsEnabled)
        sampledRequestsEnabled = sampledRequestsEnabledDecoded
        let cloudWatchMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cloudWatchMetricsEnabled)
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
    }
}

extension VisibilityConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VisibilityConfig(cloudWatchMetricsEnabled: \(String(describing: cloudWatchMetricsEnabled)), metricName: \(String(describing: metricName)), sampledRequestsEnabled: \(String(describing: sampledRequestsEnabled)))"}
}

/// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
public struct VisibilityConfig: Equatable {
    /// <p>A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">AWS WAF Metrics</a>.</p>
    public let cloudWatchMetricsEnabled: Bool
    /// <p>A name of the CloudWatch metric. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, for example "All" and "Default_Action." </p>
    public let metricName: String?
    /// <p>A boolean indicating whether AWS WAF should store a sampling of the web
    ///            requests that match the rules. You can view the sampled requests through the
    ///            AWS WAF console. </p>
    public let sampledRequestsEnabled: Bool

    public init (
        cloudWatchMetricsEnabled: Bool = false,
        metricName: String? = nil,
        sampledRequestsEnabled: Bool = false
    )
    {
        self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
        self.metricName = metricName
        self.sampledRequestsEnabled = sampledRequestsEnabled
    }
}

extension WAFAssociatedItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFAssociatedItemException(message: \(String(describing: message)))"}
}

extension WAFAssociatedItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFAssociatedItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform the operation because your resource is being used by another resource or its associated with another resource. </p>
public struct WAFAssociatedItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFAssociatedItemExceptionBody: Equatable {
    public let message: String?
}

extension WAFAssociatedItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFDuplicateItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFDuplicateItemException(message: \(String(describing: message)))"}
}

extension WAFDuplicateItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFDuplicateItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform the operation because the resource that you tried to save is a duplicate of an existing one.</p>
public struct WAFDuplicateItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFDuplicateItemExceptionBody: Equatable {
    public let message: String?
}

extension WAFDuplicateItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInternalErrorException(message: \(String(describing: message)))"}
}

extension WAFInternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request is valid, but AWS WAF couldnt perform the operation because of a system problem. Retry your request. </p>
public struct WAFInternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFInternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidOperationException(message: \(String(describing: message)))"}
}

extension WAFInvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation isn't valid. </p>
public struct WAFInvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidParameterException(field: \(String(describing: field)), parameter: \(String(describing: parameter)), reason: \(String(describing: reason)), message: \(String(describing: message)))"}
}

extension WAFInvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.field = output.field
            self.message = output.message
            self.parameter = output.parameter
            self.reason = output.reason
        } else {
            self.field = nil
            self.parameter = nil
            self.reason = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example: </p>
///          <ul>
///             <li>
///                <p>You specified an invalid parameter name or value.</p>
///             </li>
///             <li>
///                <p>Your nested statement isn't valid. You might have tried to nest a statement that cant be nested. </p>
///             </li>
///             <li>
///                <p>You tried to update a <code>WebACL</code> with a <code>DefaultAction</code> that isn't among the types
///                available at <a>DefaultAction</a>.</p>
///             </li>
///             <li>
///                <p>Your request references an ARN that is malformed, or corresponds to a resource with which a Web ACL cannot be associated.</p>
///             </li>
///          </ul>
public struct WAFInvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var field: ParameterExceptionField?
    public var message: String?
    public var parameter: String?
    public var reason: String?

    public init (
        field: ParameterExceptionField? = nil,
        message: String? = nil,
        parameter: String? = nil,
        reason: String? = nil
    )
    {
        self.field = field
        self.message = message
        self.parameter = parameter
        self.reason = reason
    }
}

struct WAFInvalidParameterExceptionBody: Equatable {
    public let message: String?
    public let field: ParameterExceptionField?
    public let parameter: String?
    public let reason: String?
}

extension WAFInvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case field = "Field"
        case parameter = "Parameter"
        case reason = "Reason"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(ParameterExceptionField.self, forKey: .field)
        field = fieldDecoded
        let parameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameter)
        parameter = parameterDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WAFInvalidPermissionPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidPermissionPolicyException(message: \(String(describing: message)))"}
}

extension WAFInvalidPermissionPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidPermissionPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because the specified policy isn't in the proper format. </p>
///
///          <p>The policy specifications must conform to the following:</p>
///          <ul>
///             <li>
///                <p>The policy must be composed using IAM Policy version 2012-10-17 or version 2015-01-01.</p>
///             </li>
///             <li>
///                <p>The policy must include specifications for <code>Effect</code>, <code>Action</code>, and <code>Principal</code>.</p>
///             </li>
///             <li>
///                <p>
///                   <code>Effect</code> must specify <code>Allow</code>.</p>
///             </li>
///             <li>
///                <p>
///                   <code>Action</code> must specify <code>wafv2:CreateWebACL</code>, <code>wafv2:UpdateWebACL</code>, and <code>wafv2:PutFirewallManagerRuleGroups</code>. AWS WAF rejects any extra actions or wildcard actions in the policy.</p>
///             </li>
///             <li>
///                <p>The policy must not include a <code>Resource</code> parameter.</p>
///             </li>
///          </ul>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a>.  </p>
public struct WAFInvalidPermissionPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidPermissionPolicyExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidPermissionPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidResourceException(message: \(String(describing: message)))"}
}

extension WAFInvalidResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidResourceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform the operation because the resource that you requested isnt valid. Check the resource, and try again.</p>
public struct WAFInvalidResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidResourceExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFLimitsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFLimitsExceededException(message: \(String(describing: message)))"}
}

extension WAFLimitsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFLimitsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform the operation because you exceeded your resource limit. For example, the maximum number of <code>WebACL</code> objects that you can create
///          for an AWS account. For more information, see
///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
public struct WAFLimitsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFLimitsExceededExceptionBody: Equatable {
    public let message: String?
}

extension WAFLimitsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFNonexistentItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFNonexistentItemException(message: \(String(describing: message)))"}
}

extension WAFNonexistentItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFNonexistentItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform the operation because your resource doesnt exist. </p>
public struct WAFNonexistentItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFNonexistentItemExceptionBody: Equatable {
    public let message: String?
}

extension WAFNonexistentItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFOptimisticLockException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFOptimisticLockException(message: \(String(describing: message)))"}
}

extension WAFOptimisticLockException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFOptimisticLockExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt save your changes because you tried to update or delete a resource that has changed since you last retrieved it. Get the resource again, make any changes you need to make to the new copy, and retry your operation. </p>
public struct WAFOptimisticLockException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFOptimisticLockExceptionBody: Equatable {
    public let message: String?
}

extension WAFOptimisticLockExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFServiceLinkedRoleErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFServiceLinkedRoleErrorException(message: \(String(describing: message)))"}
}

extension WAFServiceLinkedRoleErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFServiceLinkedRoleErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF is not able to access the service linked role. This can be caused by a previous <code>PutLoggingConfiguration</code> request, which can lock the service linked role for about 20 seconds. Please try your request again. The service linked role can also be locked by a previous <code>DeleteServiceLinkedRole</code> request, which can lock the role for 15 minutes or more. If you recently made a call to <code>DeleteServiceLinkedRole</code>, wait at least 15 minutes and try the request again. If you receive this same exception again, you will have to wait additional time until the role is unlocked.</p>
public struct WAFServiceLinkedRoleErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFServiceLinkedRoleErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFServiceLinkedRoleErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFSubscriptionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFSubscriptionNotFoundException(message: \(String(describing: message)))"}
}

extension WAFSubscriptionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFSubscriptionNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You tried to use a managed rule group that's available by subscription, but you aren't subscribed to it yet. </p>
public struct WAFSubscriptionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFSubscriptionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension WAFSubscriptionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFTagOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFTagOperationException(message: \(String(describing: message)))"}
}

extension WAFTagOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFTagOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred during the tagging operation. Retry your request.</p>
public struct WAFTagOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFTagOperationExceptionBody: Equatable {
    public let message: String?
}

extension WAFTagOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFTagOperationInternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFTagOperationInternalErrorException(message: \(String(describing: message)))"}
}

extension WAFTagOperationInternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFTagOperationInternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt perform your tagging operation because of an internal error. Retry your request.</p>
public struct WAFTagOperationInternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFTagOperationInternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFTagOperationInternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFUnavailableEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFUnavailableEntityException(message: \(String(describing: message)))"}
}

extension WAFUnavailableEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFUnavailableEntityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF couldnt retrieve the resource that you requested. Retry your request.</p>
public struct WAFUnavailableEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFUnavailableEntityExceptionBody: Equatable {
    public let message: String?
}

extension WAFUnavailableEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WebACL: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case capacity = "Capacity"
        case customResponseBodies = "CustomResponseBodies"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case id = "Id"
        case labelNamespace = "LabelNamespace"
        case managedByFirewallManager = "ManagedByFirewallManager"
        case name = "Name"
        case postProcessFirewallManagerRuleGroups = "PostProcessFirewallManagerRuleGroups"
        case preProcessFirewallManagerRuleGroups = "PreProcessFirewallManagerRuleGroups"
        case rules = "Rules"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let customResponseBodies = customResponseBodies {
            var customResponseBodiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .customResponseBodies)
            for (dictKey0, customresponsebodies0) in customResponseBodies {
                try customResponseBodiesContainer.encode(customresponsebodies0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labelNamespace = labelNamespace {
            try encodeContainer.encode(labelNamespace, forKey: .labelNamespace)
        }
        if managedByFirewallManager != false {
            try encodeContainer.encode(managedByFirewallManager, forKey: .managedByFirewallManager)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let postProcessFirewallManagerRuleGroups = postProcessFirewallManagerRuleGroups {
            var postProcessFirewallManagerRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .postProcessFirewallManagerRuleGroups)
            for firewallmanagerrulegroups0 in postProcessFirewallManagerRuleGroups {
                try postProcessFirewallManagerRuleGroupsContainer.encode(firewallmanagerrulegroups0)
            }
        }
        if let preProcessFirewallManagerRuleGroups = preProcessFirewallManagerRuleGroups {
            var preProcessFirewallManagerRuleGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .preProcessFirewallManagerRuleGroups)
            for firewallmanagerrulegroups0 in preProcessFirewallManagerRuleGroups {
                try preProcessFirewallManagerRuleGroupsContainer.encode(firewallmanagerrulegroups0)
            }
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rules0 in rules {
                try rulesContainer.encode(rules0)
            }
        }
        if let visibilityConfig = visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(VisibilityConfig.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
        let capacityDecoded = try containerValues.decode(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let preProcessFirewallManagerRuleGroupsContainer = try containerValues.decodeIfPresent([FirewallManagerRuleGroup?].self, forKey: .preProcessFirewallManagerRuleGroups)
        var preProcessFirewallManagerRuleGroupsDecoded0:[FirewallManagerRuleGroup]? = nil
        if let preProcessFirewallManagerRuleGroupsContainer = preProcessFirewallManagerRuleGroupsContainer {
            preProcessFirewallManagerRuleGroupsDecoded0 = [FirewallManagerRuleGroup]()
            for structure0 in preProcessFirewallManagerRuleGroupsContainer {
                if let structure0 = structure0 {
                    preProcessFirewallManagerRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        preProcessFirewallManagerRuleGroups = preProcessFirewallManagerRuleGroupsDecoded0
        let postProcessFirewallManagerRuleGroupsContainer = try containerValues.decodeIfPresent([FirewallManagerRuleGroup?].self, forKey: .postProcessFirewallManagerRuleGroups)
        var postProcessFirewallManagerRuleGroupsDecoded0:[FirewallManagerRuleGroup]? = nil
        if let postProcessFirewallManagerRuleGroupsContainer = postProcessFirewallManagerRuleGroupsContainer {
            postProcessFirewallManagerRuleGroupsDecoded0 = [FirewallManagerRuleGroup]()
            for structure0 in postProcessFirewallManagerRuleGroupsContainer {
                if let structure0 = structure0 {
                    postProcessFirewallManagerRuleGroupsDecoded0?.append(structure0)
                }
            }
        }
        postProcessFirewallManagerRuleGroups = postProcessFirewallManagerRuleGroupsDecoded0
        let managedByFirewallManagerDecoded = try containerValues.decode(Bool.self, forKey: .managedByFirewallManager)
        managedByFirewallManager = managedByFirewallManagerDecoded
        let labelNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .labelNamespace)
        labelNamespace = labelNamespaceDecoded
        let customResponseBodiesContainer = try containerValues.decodeIfPresent([String: CustomResponseBody?].self, forKey: .customResponseBodies)
        var customResponseBodiesDecoded0: [String:CustomResponseBody]? = nil
        if let customResponseBodiesContainer = customResponseBodiesContainer {
            customResponseBodiesDecoded0 = [String:CustomResponseBody]()
            for (key0, customresponsebody0) in customResponseBodiesContainer {
                if let customresponsebody0 = customresponsebody0 {
                    customResponseBodiesDecoded0?[key0] = customresponsebody0
                }
            }
        }
        customResponseBodies = customResponseBodiesDecoded0
    }
}

extension WebACL: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebACL(aRN: \(String(describing: aRN)), capacity: \(String(describing: capacity)), customResponseBodies: \(String(describing: customResponseBodies)), defaultAction: \(String(describing: defaultAction)), description: \(String(describing: description)), id: \(String(describing: id)), labelNamespace: \(String(describing: labelNamespace)), managedByFirewallManager: \(String(describing: managedByFirewallManager)), name: \(String(describing: name)), postProcessFirewallManagerRuleGroups: \(String(describing: postProcessFirewallManagerRuleGroups)), preProcessFirewallManagerRuleGroups: \(String(describing: preProcessFirewallManagerRuleGroups)), rules: \(String(describing: rules)), visibilityConfig: \(String(describing: visibilityConfig)))"}
}

/// <p> A Web ACL defines a collection of rules to use to inspect and control web requests. Each rule has an action defined (allow, block, or count) for requests that match the statement of the rule. In the Web ACL, you assign a default action to take (allow, block) for any request that does not match any of the rules. The rules in a Web ACL can be a combination of the types <a>Rule</a>, <a>RuleGroup</a>, and managed rule group. You can associate a Web ACL with one or more AWS resources to protect. The resources can be Amazon CloudFront, an Amazon API Gateway REST API, an Application Load Balancer, or an AWS AppSync GraphQL API.  </p>
public struct WebACL: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Web ACL that you want to associate with the resource.</p>
    public let aRN: String?
    /// <p>The web ACL capacity units (WCUs) currently being used by this web ACL. </p>
    ///          <p>AWS WAF uses WCUs to calculate and control the operating
    ///          resources that are used to run your rules, rule groups, and web ACLs. AWS WAF
    ///          calculates capacity differently for each rule type, to reflect the relative cost of each rule.
    ///          Simple rules that cost little to run use fewer WCUs than more complex rules
    /// 				that use more processing power.
    /// 				Rule group capacity is fixed at creation, which helps users plan their
    ///          web ACL WCU usage when they use a rule group.
    ///          The WCU limit for web ACLs is 1,500.  </p>
    public let capacity: Int
    /// <p>A map of custom response keys and content bodies. When you create a rule with a block action, you can send a custom response to the web request. You define these for the web ACL, and then use them in the rules and default actions that you define in the web ACL. </p>
    ///          <p>For information about customizing web requests and responses, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing web requests and responses in AWS WAF</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    ///          <p>For information about the limits on count and size for custom request and response settings, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">AWS WAF quotas</a> in the
    ///          <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. </p>
    public let customResponseBodies: [String:CustomResponseBody]?
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. </p>
    public let defaultAction: DefaultAction?
    /// <p>A description of the Web ACL that helps with identification. </p>
    public let description: String?
    /// <p>A unique identifier for the <code>WebACL</code>. This ID is returned in the responses to create and list commands. You use this ID to do things like get, update, and delete a <code>WebACL</code>.</p>
    public let id: String?
    /// <p>The label namespace prefix for this web ACL. All labels added by rules in this web ACL have this prefix. </p>
    ///          <ul>
    ///             <li>
    ///                <p>The syntax for the label namespace prefix for a web ACL is the following: </p>
    ///                <p>
    ///                   <code>awswaf:<account ID>:webacl:<web ACL name>:</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>When a rule with a label matches a web request, AWS WAF adds the fully qualified label to the request. A fully qualified label is made up of the label namespace from the rule group or web ACL where the rule is defined and the label from the rule, separated by a colon: </p>
    ///                <p>
    ///                   <code><label namespace>:<label from rule></code>
    ///                </p>
    ///
    ///             </li>
    ///          </ul>
    public let labelNamespace: String?
    /// <p>Indicates whether this web ACL is managed by AWS Firewall Manager. If true, then only AWS Firewall Manager can delete the web ACL or any Firewall Manager rule groups in the web ACL. </p>
    public let managedByFirewallManager: Bool
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?
    /// <p>The last set of rules for AWS WAF to process in the web ACL. This is defined in an AWS Firewall Manager WAF policy and
    ///            contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are
    ///            prioritized before these. </p>
    ///          <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL
    ///            and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to
    ///           determine their relative processing order.</p>
    public let postProcessFirewallManagerRuleGroups: [FirewallManagerRuleGroup]?
    /// <p>The first set of rules for AWS WAF to process in the web ACL. This is defined in an AWS Firewall Manager WAF policy and
    ///            contains only rule group references. You can't alter these. Any rules and rule groups that you define for the web ACL are
    ///            prioritized after these. </p>
    ///          <p>In the Firewall Manager WAF policy, the Firewall Manager administrator can define a set of rule groups to run first in the web ACL
    ///            and a set of rule groups to run last. Within each set, the administrator prioritizes the rule groups, to
    ///           determine their relative processing order.</p>
    public let preProcessFirewallManagerRuleGroups: [FirewallManagerRuleGroup]?
    /// <p>The <a>Rule</a> statements used to identify the web requests that you
    ///          want to allow, block, or count. Each rule includes one top-level statement that AWS WAF uses to identify matching
    ///          web requests, and parameters that govern how AWS WAF handles them.
    ///       </p>
    public let rules: [Rule]?
    /// <p>Defines and enables Amazon CloudWatch metrics and web request sample collection.  </p>
    public let visibilityConfig: VisibilityConfig?

    public init (
        aRN: String? = nil,
        capacity: Int = 0,
        customResponseBodies: [String:CustomResponseBody]? = nil,
        defaultAction: DefaultAction? = nil,
        description: String? = nil,
        id: String? = nil,
        labelNamespace: String? = nil,
        managedByFirewallManager: Bool = false,
        name: String? = nil,
        postProcessFirewallManagerRuleGroups: [FirewallManagerRuleGroup]? = nil,
        preProcessFirewallManagerRuleGroups: [FirewallManagerRuleGroup]? = nil,
        rules: [Rule]? = nil,
        visibilityConfig: VisibilityConfig? = nil
    )
    {
        self.aRN = aRN
        self.capacity = capacity
        self.customResponseBodies = customResponseBodies
        self.defaultAction = defaultAction
        self.description = description
        self.id = id
        self.labelNamespace = labelNamespace
        self.managedByFirewallManager = managedByFirewallManager
        self.name = name
        self.postProcessFirewallManagerRuleGroups = postProcessFirewallManagerRuleGroups
        self.preProcessFirewallManagerRuleGroups = preProcessFirewallManagerRuleGroups
        self.rules = rules
        self.visibilityConfig = visibilityConfig
    }
}

extension WebACLSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case description = "Description"
        case id = "Id"
        case lockToken = "LockToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lockToken = lockToken {
            try encodeContainer.encode(lockToken, forKey: .lockToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lockToken)
        lockToken = lockTokenDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension WebACLSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebACLSummary(aRN: \(String(describing: aRN)), description: \(String(describing: description)), id: \(String(describing: id)), lockToken: \(String(describing: lockToken)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a <a>WebACL</a>, returned by operations like create and list. This provides information like the ID, that you can use to retrieve and manage a <code>WebACL</code>, and the ARN, that you provide to operations like <a>AssociateWebACL</a>.</p>
public struct WebACLSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the entity.</p>
    public let aRN: String?
    /// <p>A description of the Web ACL that helps with identification. </p>
    public let description: String?
    /// <p>The unique identifier for the Web ACL. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.</p>
    public let id: String?
    /// <p>A token used for optimistic locking. AWS WAF returns a token to your get and list requests, to mark the state of the entity at the time of the request. To make changes to the entity associated with the token, you provide the token to operations like update and delete. AWS WAF uses the token to ensure that no changes have been made to the entity since you last retrieved it. If a change has been made, the update fails with a <code>WAFOptimisticLockException</code>. If this happens, perform another get, and use the new token returned by that operation. </p>
    public let lockToken: String?
    /// <p>The name of the Web ACL. You cannot change the name of a Web ACL after you create it.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lockToken: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.description = description
        self.id = id
        self.lockToken = lockToken
        self.name = name
    }
}

extension XssMatchStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case textTransformations = "TextTransformations"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let textTransformations = textTransformations {
            var textTransformationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textTransformations)
            for texttransformations0 in textTransformations {
                try textTransformationsContainer.encode(texttransformations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationsContainer = try containerValues.decodeIfPresent([TextTransformation?].self, forKey: .textTransformations)
        var textTransformationsDecoded0:[TextTransformation]? = nil
        if let textTransformationsContainer = textTransformationsContainer {
            textTransformationsDecoded0 = [TextTransformation]()
            for structure0 in textTransformationsContainer {
                if let structure0 = structure0 {
                    textTransformationsDecoded0?.append(structure0)
                }
            }
        }
        textTransformations = textTransformationsDecoded0
    }
}

extension XssMatchStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XssMatchStatement(fieldToMatch: \(String(describing: fieldToMatch)), textTransformations: \(String(describing: textTransformations)))"}
}

/// <p>A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests.
///          XSS attacks are those where the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious
///          client-site scripts into other legitimate web browsers.
///          The XSS match statement provides the location in requests that you want AWS WAF to search and text transformations
///          to use on the search area before AWS WAF searches for character sequences that are likely to be malicious strings. </p>
public struct XssMatchStatement: Equatable {
    /// <p>The part of a web request that you want AWS WAF to inspect. For more information, see <a>FieldToMatch</a>. </p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
    ///          If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the
    ///          content of the request component identified by <code>FieldToMatch</code>, starting from the lowest priority setting, before inspecting the content for a match.</p>
    public let textTransformations: [TextTransformation]?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        textTransformations: [TextTransformation]? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.textTransformations = textTransformations
    }
}
