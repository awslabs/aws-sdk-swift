// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>The part of a web request that you want AWS WAF to inspect. Include the single <code>FieldToMatch</code> type that you want to inspect, with additional specifications as needed, according to the type. You specify a single request component in <code>FieldToMatch</code> for each rule statement that requires it. To inspect more than one component of a web request, create a separate rule statement for each component.</p>
public struct FieldToMatch: Equatable {
    /// <p>Inspect all query arguments. </p>
    public let allQueryArguments: AllQueryArguments?
    /// <p>Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any
    ///          additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    ///          <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to AWS WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <a>ByteMatchStatement</a> or <a>RegexPatternSetReferenceStatement</a>, with a <a>SizeConstraintStatement</a> that enforces an 8 KB size limit on the body of the request. AWS WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    public let body: Body?
    /// <p>Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any
    ///          additional data that you want to send to your web server as the HTTP request body, such as data from a form. </p>
    ///          <p>Note that only the first 8 KB (8192 bytes) of the request body are forwarded to AWS WAF for inspection by the underlying host service. If you don't need to inspect more than 8 KB, you can guarantee that you don't allow additional bytes in by combining a statement that inspects the body of the web request, such as <a>ByteMatchStatement</a> or <a>RegexPatternSetReferenceStatement</a>, with a <a>SizeConstraintStatement</a> that enforces an 8 KB size limit on the body of the request. AWS WAF doesn't support inspecting the entire contents of web requests whose bodies exceed the 8 KB limit.</p>
    public let jsonBody: JsonBody?
    /// <p>Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. </p>
    public let method: Method?
    /// <p>Inspect the query string. This is the part of a URL that appears after a <code>?</code> character, if any.</p>
    public let queryString: QueryString?
    /// <p>Inspect a single header. Provide the name of the header to inspect, for example, <code>User-Agent</code> or <code>Referer</code>. This setting isn't case sensitive.</p>
    ///          <p>Example JSON: <code>"SingleHeader": { "Name": "haystack" }</code>
    ///          </p>
    public let singleHeader: SingleHeader?
    /// <p>Inspect a single query argument. Provide the name of the query argument to inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The name can be up to 30 characters long and isn't case sensitive. </p>
    ///            <p>This is used only to indicate the web request component for AWS WAF to inspect, in the <a>FieldToMatch</a> specification. </p>
    ///          <p>Example JSON: <code>"SingleQueryArgument": { "Name": "myArgument" }</code>
    ///          </p>
    public let singleQueryArgument: SingleQueryArgument?
    /// <p>Inspect the request URI path. This is the part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    public let uriPath: UriPath?

    public init (
        allQueryArguments: AllQueryArguments? = nil,
        body: Body? = nil,
        jsonBody: JsonBody? = nil,
        method: Method? = nil,
        queryString: QueryString? = nil,
        singleHeader: SingleHeader? = nil,
        singleQueryArgument: SingleQueryArgument? = nil,
        uriPath: UriPath? = nil
    )
    {
        self.allQueryArguments = allQueryArguments
        self.body = body
        self.jsonBody = jsonBody
        self.method = method
        self.queryString = queryString
        self.singleHeader = singleHeader
        self.singleQueryArgument = singleQueryArgument
        self.uriPath = uriPath
    }
}

extension FieldToMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldToMatch(allQueryArguments: \(String(describing: allQueryArguments)), body: \(String(describing: body)), jsonBody: \(String(describing: jsonBody)), method: \(String(describing: method)), queryString: \(String(describing: queryString)), singleHeader: \(String(describing: singleHeader)), singleQueryArgument: \(String(describing: singleQueryArgument)), uriPath: \(String(describing: uriPath)))"}
}
