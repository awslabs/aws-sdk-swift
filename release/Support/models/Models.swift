// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddAttachmentsToSetInputBodyMiddleware: Middleware {
    public let id: String = "AddAttachmentsToSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttachmentsToSetOutputError>
}

extension AddAttachmentsToSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddAttachmentsToSetInput(attachmentSetId: \(String(describing: attachmentSetId)), attachments: \(String(describing: attachments)))"}
}

extension AddAttachmentsToSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case attachments
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
    }
}

public struct AddAttachmentsToSetInputHeadersMiddleware: Middleware {
    public let id: String = "AddAttachmentsToSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInputQueryItemMiddleware: Middleware {
    public let id: String = "AddAttachmentsToSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInput: Equatable {
    /// <p>The ID of the attachment set. If an <code>attachmentSetId</code> is not specified, a
    ///             new attachment set is created, and the ID of the set is returned in the response. If an
    ///                 <code>attachmentSetId</code> is specified, the attachments are added to the
    ///             specified set, if it exists.</p>
    public let attachmentSetId: String?
    /// <p>One or more attachments to add to the set. You can add up to three attachments per
    ///             set. The size limit is 5 MB per attachment.</p>
    ///         <p>In the <code>Attachment</code> object, use the <code>data</code> parameter to specify
    ///             the contents of the attachment file. In the previous request syntax, the value for
    ///                 <code>data</code> appear as <code>blob</code>, which is represented as a
    ///             base64-encoded string. The value for <code>fileName</code> is the name of the
    ///             attachment, such as <code>troubleshoot-screenshot.png</code>.</p>
    public let attachments: [Attachment]?

    public init (
        attachmentSetId: String? = nil,
        attachments: [Attachment]? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.attachments = attachments
    }
}

struct AddAttachmentsToSetInputBody: Equatable {
    public let attachmentSetId: String?
    public let attachments: [Attachment]?
}

extension AddAttachmentsToSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case attachments
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension AddAttachmentsToSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddAttachmentsToSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AttachmentLimitExceeded" : self = .attachmentLimitExceeded(try AttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetSizeLimitExceeded" : self = .attachmentSetSizeLimitExceeded(try AttachmentSetSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddAttachmentsToSetOutputError: Swift.Error, Equatable {
    case attachmentLimitExceeded(AttachmentLimitExceeded)
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case attachmentSetSizeLimitExceeded(AttachmentSetSizeLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddAttachmentsToSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddAttachmentsToSetOutputResponse(attachmentSetId: \(String(describing: attachmentSetId)), expiryTime: \(String(describing: expiryTime)))"}
}

extension AddAttachmentsToSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddAttachmentsToSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentSetId = output.attachmentSetId
            self.expiryTime = output.expiryTime
        } else {
            self.attachmentSetId = nil
            self.expiryTime = nil
        }
    }
}

/// <p>The ID and expiry time of the attachment set returned by the <a>AddAttachmentsToSet</a> operation.</p>
public struct AddAttachmentsToSetOutputResponse: Equatable {
    /// <p>The ID of the attachment set. If an <code>attachmentSetId</code> was not specified, a
    ///             new attachment set is created, and the ID of the set is returned in the response. If an
    ///                 <code>attachmentSetId</code> was specified, the attachments are added to the
    ///             specified set, if it exists.</p>
    public let attachmentSetId: String?
    /// <p>The time and date when the attachment set expires.</p>
    public let expiryTime: String?

    public init (
        attachmentSetId: String? = nil,
        expiryTime: String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.expiryTime = expiryTime
    }
}

struct AddAttachmentsToSetOutputResponseBody: Equatable {
    public let attachmentSetId: String?
    public let expiryTime: String?
}

extension AddAttachmentsToSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case expiryTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let expiryTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
    }
}

public struct AddCommunicationToCaseInputBodyMiddleware: Middleware {
    public let id: String = "AddCommunicationToCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCommunicationToCaseOutputError>
}

extension AddCommunicationToCaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCommunicationToCaseInput(attachmentSetId: \(String(describing: attachmentSetId)), caseId: \(String(describing: caseId)), ccEmailAddresses: \(String(describing: ccEmailAddresses)), communicationBody: \(String(describing: communicationBody)))"}
}

extension AddCommunicationToCaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
    }
}

public struct AddCommunicationToCaseInputHeadersMiddleware: Middleware {
    public let id: String = "AddCommunicationToCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInputQueryItemMiddleware: Middleware {
    public let id: String = "AddCommunicationToCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInput: Equatable {
    /// <p>The ID of a set of one or more attachments for the communication to add to the case.
    ///             Create the set by calling <a>AddAttachmentsToSet</a>
    ///         </p>
    public let attachmentSetId: String?
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?
    /// <p>The email addresses in the CC line of an email to be added to the support case.</p>
    public let ccEmailAddresses: [String]?
    /// <p>The body of an email communication to add to the support case.</p>
    public let communicationBody: String?

    public init (
        attachmentSetId: String? = nil,
        caseId: String? = nil,
        ccEmailAddresses: [String]? = nil,
        communicationBody: String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.caseId = caseId
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
    }
}

struct AddCommunicationToCaseInputBody: Equatable {
    public let caseId: String?
    public let communicationBody: String?
    public let ccEmailAddresses: [String]?
    public let attachmentSetId: String?
}

extension AddCommunicationToCaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension AddCommunicationToCaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCommunicationToCaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCommunicationToCaseOutputError: Swift.Error, Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCommunicationToCaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddCommunicationToCaseOutputResponse(result: \(String(describing: result)))"}
}

extension AddCommunicationToCaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddCommunicationToCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

/// <p>The result of the <a>AddCommunicationToCase</a> operation.</p>
public struct AddCommunicationToCaseOutputResponse: Equatable {
    /// <p>True if <a>AddCommunicationToCase</a> succeeds. Otherwise, returns an
    ///             error.</p>
    public let result: Bool

    public init (
        result: Bool = false
    )
    {
        self.result = result
    }
}

struct AddCommunicationToCaseOutputResponseBody: Equatable {
    public let result: Bool
}

extension AddCommunicationToCaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case result
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decode(Bool.self, forKey: .result)
        result = resultDecoded
    }
}

extension Attachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data
        case fileName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension Attachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attachment(data: \(String(describing: data)), fileName: \(String(describing: fileName)))"}
}

/// <p>An attachment to a case communication. The attachment consists of the file name and
///             the content of the file.</p>
public struct Attachment: Equatable {
    /// <p>The content of the attachment file.</p>
    public let data: Data?
    /// <p>The name of the attachment file.</p>
    public let fileName: String?

    public init (
        data: Data? = nil,
        fileName: String? = nil
    )
    {
        self.data = data
        self.fileName = fileName
    }
}

extension AttachmentDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentId
        case fileName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension AttachmentDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentDetails(attachmentId: \(String(describing: attachmentId)), fileName: \(String(describing: fileName)))"}
}

/// <p>The file name and ID of an attachment to a case communication. You can use the ID to
///             retrieve the attachment with the <a>DescribeAttachment</a> operation.</p>
public struct AttachmentDetails: Equatable {
    /// <p>The ID of the attachment.</p>
    public let attachmentId: String?
    /// <p>The file name of the attachment.</p>
    public let fileName: String?

    public init (
        attachmentId: String? = nil,
        fileName: String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.fileName = fileName
    }
}

extension AttachmentIdNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentIdNotFound(message: \(String(describing: message)))"}
}

extension AttachmentIdNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attachment with the specified ID could not be found.</p>
public struct AttachmentIdNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>An attachment with the specified ID could not be found.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentIdNotFoundBody: Equatable {
    public let message: String?
}

extension AttachmentIdNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentLimitExceeded(message: \(String(describing: message)))"}
}

extension AttachmentLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit for the number of attachment sets created in a short period of time has been
///             exceeded.</p>
public struct AttachmentLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The limit for the number of attachment sets created in a short period of time has been
    ///             exceeded.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentLimitExceededBody: Equatable {
    public let message: String?
}

extension AttachmentLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetExpired: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentSetExpired(message: \(String(describing: message)))"}
}

extension AttachmentSetExpired: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetExpiredBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The expiration time of the attachment set has passed. The set expires 1 hour after it
///             is created.</p>
public struct AttachmentSetExpired: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The expiration time of the attachment set has passed. The set expires one hour after
    ///             it is created.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetExpiredBody: Equatable {
    public let message: String?
}

extension AttachmentSetExpiredBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetIdNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentSetIdNotFound(message: \(String(describing: message)))"}
}

extension AttachmentSetIdNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An attachment set with the specified ID could not be found.</p>
public struct AttachmentSetIdNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>An attachment set with the specified ID could not be found.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetIdNotFoundBody: Equatable {
    public let message: String?
}

extension AttachmentSetIdNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetSizeLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttachmentSetSizeLimitExceeded(message: \(String(describing: message)))"}
}

extension AttachmentSetSizeLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetSizeLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A limit for the size of an attachment set has been exceeded. The limits are three
///             attachments and 5 MB per attachment.</p>
public struct AttachmentSetSizeLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A limit for the size of an attachment set has been exceeded. The limits are three
    ///             attachments and 5 MB per attachment.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetSizeLimitExceededBody: Equatable {
    public let message: String?
}

extension AttachmentSetSizeLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CaseCreationLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CaseCreationLimitExceeded(message: \(String(describing: message)))"}
}

extension CaseCreationLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseCreationLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The case creation limit for the account has been exceeded.</p>
public struct CaseCreationLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>An error message that indicates that you have exceeded the number of cases you can
    ///             have open.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CaseCreationLimitExceededBody: Equatable {
    public let message: String?
}

extension CaseCreationLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CaseDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseId
        case categoryCode
        case ccEmailAddresses
        case displayId
        case language
        case recentCommunications
        case serviceCode
        case severityCode
        case status
        case subject
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let recentCommunications = recentCommunications {
            try encodeContainer.encode(recentCommunications, forKey: .recentCommunications)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let displayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let recentCommunicationsDecoded = try containerValues.decodeIfPresent(RecentCaseCommunications.self, forKey: .recentCommunications)
        recentCommunications = recentCommunicationsDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
    }
}

extension CaseDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CaseDetails(caseId: \(String(describing: caseId)), categoryCode: \(String(describing: categoryCode)), ccEmailAddresses: \(String(describing: ccEmailAddresses)), displayId: \(String(describing: displayId)), language: \(String(describing: language)), recentCommunications: \(String(describing: recentCommunications)), serviceCode: \(String(describing: serviceCode)), severityCode: \(String(describing: severityCode)), status: \(String(describing: status)), subject: \(String(describing: subject)), submittedBy: \(String(describing: submittedBy)), timeCreated: \(String(describing: timeCreated)))"}
}

/// <p>A JSON-formatted object that contains the metadata for a support case. It is contained
///             in the response from a <a>DescribeCases</a> request. <b>CaseDetails</b> contains the following fields:</p>
///         <ul>
///             <li>
///                 <p>
///                     <b>caseId</b> - The support case ID requested or
///                     returned in the call. The case ID is an alphanumeric string formatted as shown
///                     in this example:
///                     case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>categoryCode</b> - The category of problem for the
///                     support case. Corresponds to the <code>CategoryCode</code> values returned by a call to
///                         <a>DescribeServices</a>.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>displayId</b> - The identifier for the case on pages
///                     in the AWS Support Center.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>language</b> - The ISO 639-1 code for the language
///                     in which AWS provides support. AWS Support currently supports English ("en") and
///                     Japanese ("ja"). Language parameters must be passed explicitly for operations
///                     that take them.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>nextToken</b> - A resumption point for
///                     pagination.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>recentCommunications</b> - One or more <a>Communication</a> objects. Fields of these objects are
///                         <code>attachments</code>, <code>body</code>, <code>caseId</code>,
///                         <code>submittedBy</code>, and <code>timeCreated</code>.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>serviceCode</b> - The identifier for the AWS service
///                     that corresponds to the service code defined in the call to <a>DescribeServices</a>.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>severityCode</b> - The severity code assigned to the
///                     case. Contains one of the values returned by the call to <a>DescribeSeverityLevels</a>. The possible values are:
///                         <code>low</code>, <code>normal</code>, <code>high</code>,
///                         <code>urgent</code>, and <code>critical</code>.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>status</b> - The status of the case in the AWS Support Center. Valid values:</p>
///                 <ul>
///                   <li>
///                         <p>
///                         <code>opened</code>
///                      </p>
///                     </li>
///                   <li>
///                         <p>
///                         <code>pending-customer-action</code>
///                      </p>
///                     </li>
///                   <li>
///                         <p>
///                         <code>reopened</code>
///                      </p>
///                     </li>
///                   <li>
///                         <p>
///                         <code>resolved</code>
///                      </p>
///                     </li>
///                   <li>
///                         <p>
///                         <code>unassigned</code>
///                      </p>
///                     </li>
///                   <li>
///                         <p>
///                         <code>work-in-progress</code>
///                      </p>
///                     </li>
///                </ul>
///             </li>
///             <li>
///                 <p>
///                     <b>subject</b> - The subject line of the case.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>submittedBy</b> - The email address of the account
///                     that submitted the case.</p>
///             </li>
///             <li>
///                 <p>
///                     <b>timeCreated</b> - The time the case was created, in
///                     ISO-8601 format.</p>
///             </li>
///          </ul>
public struct CaseDetails: Equatable {
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?
    /// <p>The category of problem for the support case.</p>
    public let categoryCode: String?
    /// <p>The email addresses that receive copies of communication about the case.</p>
    public let ccEmailAddresses: [String]?
    /// <p>The ID displayed for the case in the AWS Support Center. This is a numeric
    ///             string.</p>
    public let displayId: String?
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?
    /// <p>The five most recent communications between you and AWS Support Center, including the
    ///             IDs of any attachments to the communications. Also includes a <code>nextToken</code>
    ///             that you can use to retrieve earlier communications.</p>
    public let recentCommunications: RecentCaseCommunications?
    /// <p>The code for the AWS service. You can get a list of codes and the corresponding
    ///             service names by calling <a>DescribeServices</a>.</p>
    public let serviceCode: String?
    /// <p>The code for the severity level returned by the call to <a>DescribeSeverityLevels</a>.</p>
    public let severityCode: String?
    /// <p>The status of the case.</p>
    ///         <p>Valid values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>opened</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>pending-customer-action</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>reopened</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>resolved</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>unassigned</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>work-in-progress</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The subject line for the case in the AWS Support Center.</p>
    public let subject: String?
    /// <p>The email address of the account that submitted the case.</p>
    public let submittedBy: String?
    /// <p>The time that the case was created in the AWS Support Center.</p>
    public let timeCreated: String?

    public init (
        caseId: String? = nil,
        categoryCode: String? = nil,
        ccEmailAddresses: [String]? = nil,
        displayId: String? = nil,
        language: String? = nil,
        recentCommunications: RecentCaseCommunications? = nil,
        serviceCode: String? = nil,
        severityCode: String? = nil,
        status: String? = nil,
        subject: String? = nil,
        submittedBy: String? = nil,
        timeCreated: String? = nil
    )
    {
        self.caseId = caseId
        self.categoryCode = categoryCode
        self.ccEmailAddresses = ccEmailAddresses
        self.displayId = displayId
        self.language = language
        self.recentCommunications = recentCommunications
        self.serviceCode = serviceCode
        self.severityCode = severityCode
        self.status = status
        self.subject = subject
        self.submittedBy = submittedBy
        self.timeCreated = timeCreated
    }
}

extension CaseIdNotFound: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CaseIdNotFound(message: \(String(describing: message)))"}
}

extension CaseIdNotFound: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested <code>caseId</code> couldn't be located.</p>
public struct CaseIdNotFound: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The requested <code>CaseId</code> could not be located.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CaseIdNotFoundBody: Equatable {
    public let message: String?
}

extension CaseIdNotFoundBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Category: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension Category: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Category(code: \(String(describing: code)), name: \(String(describing: name)))"}
}

/// <p>A JSON-formatted name/value pair that represents the category name and category code
///             of the problem, selected from the <a>DescribeServices</a> response for each
///             AWS service.</p>
public struct Category: Equatable {
    /// <p>The category code for the support case.</p>
    public let code: String?
    /// <p>The category name for the support case.</p>
    public let name: String?

    public init (
        code: String? = nil,
        name: String? = nil
    )
    {
        self.code = code
        self.name = name
    }
}

extension Communication: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentSet
        case body
        case caseId
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSet = attachmentSet {
            var attachmentSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentSet)
            for attachmentset0 in attachmentSet {
                try attachmentSetContainer.encode(attachmentset0)
            }
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let attachmentSetContainer = try containerValues.decodeIfPresent([AttachmentDetails?].self, forKey: .attachmentSet)
        var attachmentSetDecoded0:[AttachmentDetails]? = nil
        if let attachmentSetContainer = attachmentSetContainer {
            attachmentSetDecoded0 = [AttachmentDetails]()
            for structure0 in attachmentSetContainer {
                if let structure0 = structure0 {
                    attachmentSetDecoded0?.append(structure0)
                }
            }
        }
        attachmentSet = attachmentSetDecoded0
    }
}

extension Communication: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Communication(attachmentSet: \(String(describing: attachmentSet)), body: \(String(describing: body)), caseId: \(String(describing: caseId)), submittedBy: \(String(describing: submittedBy)), timeCreated: \(String(describing: timeCreated)))"}
}

/// <p>A communication associated with a support case. The communication consists of the
///             case ID, the message body, attachment information, the submitter of the communication,
///             and the date and time of the communication.</p>
public struct Communication: Equatable {
    /// <p>Information about the attachments to the case communication.</p>
    public let attachmentSet: [AttachmentDetails]?
    /// <p>The text of the communication between the customer and AWS Support.</p>
    public let body: String?
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?
    /// <p>The identity of the account that submitted, or responded to, the support case.
    ///             Customer entries include the role or IAM user as well as the email address. For example,
    ///             "AdminRole (Role) <janedoe@example.com>. Entries from the AWS Support team display
    ///             "Amazon Web Services," and don't show an email address.
    ///             </p>
    public let submittedBy: String?
    /// <p>The time the communication was created.</p>
    public let timeCreated: String?

    public init (
        attachmentSet: [AttachmentDetails]? = nil,
        body: String? = nil,
        caseId: String? = nil,
        submittedBy: String? = nil,
        timeCreated: String? = nil
    )
    {
        self.attachmentSet = attachmentSet
        self.body = body
        self.caseId = caseId
        self.submittedBy = submittedBy
        self.timeCreated = timeCreated
    }
}

public struct CreateCaseInputBodyMiddleware: Middleware {
    public let id: String = "CreateCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCaseInput>
    public typealias MOutput = OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCaseOutputError>
}

extension CreateCaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCaseInput(attachmentSetId: \(String(describing: attachmentSetId)), categoryCode: \(String(describing: categoryCode)), ccEmailAddresses: \(String(describing: ccEmailAddresses)), communicationBody: \(String(describing: communicationBody)), issueType: \(String(describing: issueType)), language: \(String(describing: language)), serviceCode: \(String(describing: serviceCode)), severityCode: \(String(describing: severityCode)), subject: \(String(describing: subject)))"}
}

extension CreateCaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
        if let issueType = issueType {
            try encodeContainer.encode(issueType, forKey: .issueType)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

public struct CreateCaseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCaseInput>
    public typealias MOutput = OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCaseOutputError>
}

public struct CreateCaseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCaseInput>
    public typealias MOutput = OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCaseOutputError>
}

public struct CreateCaseInput: Equatable {
    /// <p>The ID of a set of one or more attachments for the case. Create the set by using the
    ///                 <a>AddAttachmentsToSet</a> operation.</p>
    public let attachmentSetId: String?
    /// <p>The category of problem for the support case. You also use the <a>DescribeServices</a> operation to get the category code for a service. Each
    ///             AWS service defines its own set of category codes.</p>
    public let categoryCode: String?
    /// <p>A list of email addresses that AWS Support copies on case correspondence. AWS Support
    ///             identifies the account that creates the case when you specify your AWS credentials in an
    ///             HTTP POST method or use the <a href="http://aws.amazon.com/tools/">AWS SDKs</a>.
    ///         </p>
    public let ccEmailAddresses: [String]?
    /// <p>The communication body text that describes the issue. This text appears in the
    ///                 <b>Description</b> field on the AWS Support Center <a href="https://console.aws.amazon.com/support/home#/case/create">Create Case</a> page.</p>
    public let communicationBody: String?
    /// <p>The type of issue for the case. You can specify <code>customer-service</code> or
    ///                 <code>technical</code>. If you don't specify a value, the default is
    ///                 <code>technical</code>.</p>
    public let issueType: String?
    /// <p>The language in which AWS Support handles the case. You must specify the ISO 639-1
    ///             code for the <code>language</code> parameter if you want support in that language.
    ///             Currently, English ("en") and Japanese ("ja") are supported.</p>
    public let language: String?
    /// <p>The code for the AWS service. You can use the <a>DescribeServices</a>
    ///             operation to get the possible <code>serviceCode</code> values.</p>
    public let serviceCode: String?
    /// <p>A value that indicates the urgency of the case. This value determines the response
    ///             time according to your service level agreement with AWS Support. You can use the <a>DescribeSeverityLevels</a> operation to get the possible values for
    ///                 <code>severityCode</code>. </p>
    ///         <p>For more information, see <a>SeverityLevel</a> and <a href="https://docs.aws.amazon.com/awssupport/latest/user/getting-started.html#choosing-severity">Choosing a
    ///                 Severity</a> in the <i>AWS Support User Guide</i>.</p>
    ///         <note>
    ///             <p>The availability of severity levels depends on the support plan for the AWS
    ///                 account.</p>
    ///         </note>
    public let severityCode: String?
    /// <p>The title of the support case. The title appears in the <b>Subject</b> field on the AWS Support Center <a href="https://console.aws.amazon.com/support/home#/case/create">Create Case</a> page.</p>
    public let subject: String?

    public init (
        attachmentSetId: String? = nil,
        categoryCode: String? = nil,
        ccEmailAddresses: [String]? = nil,
        communicationBody: String? = nil,
        issueType: String? = nil,
        language: String? = nil,
        serviceCode: String? = nil,
        severityCode: String? = nil,
        subject: String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.categoryCode = categoryCode
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
        self.issueType = issueType
        self.language = language
        self.serviceCode = serviceCode
        self.severityCode = severityCode
        self.subject = subject
    }
}

struct CreateCaseInputBody: Equatable {
    public let subject: String?
    public let serviceCode: String?
    public let severityCode: String?
    public let categoryCode: String?
    public let communicationBody: String?
    public let ccEmailAddresses: [String]?
    public let language: String?
    public let issueType: String?
    public let attachmentSetId: String?
}

extension CreateCaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
        let issueTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issueType)
        issueType = issueTypeDecoded
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension CreateCaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseCreationLimitExceeded" : self = .caseCreationLimitExceeded(try CaseCreationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCaseOutputError: Swift.Error, Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseCreationLimitExceeded(CaseCreationLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCaseOutputResponse(caseId: \(String(describing: caseId)))"}
}

extension CreateCaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.caseId = output.caseId
        } else {
            self.caseId = nil
        }
    }
}

/// <p>The support case ID returned by a successful completion of the <a>CreateCase</a> operation.</p>
public struct CreateCaseOutputResponse: Equatable {
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string in the following format:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?

    public init (
        caseId: String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct CreateCaseOutputResponseBody: Equatable {
    public let caseId: String?
}

extension CreateCaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case caseId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

public struct DescribeAttachmentInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttachmentOutputError>
}

extension DescribeAttachmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttachmentInput(attachmentId: \(String(describing: attachmentId)))"}
}

extension DescribeAttachmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachmentId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

public struct DescribeAttachmentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInput: Equatable {
    /// <p>The ID of the attachment to return. Attachment IDs are returned by the <a>DescribeCommunications</a> operation.</p>
    public let attachmentId: String?

    public init (
        attachmentId: String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct DescribeAttachmentInputBody: Equatable {
    public let attachmentId: String?
}

extension DescribeAttachmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachmentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension DescribeAttachmentLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttachmentLimitExceeded(message: \(String(describing: message)))"}
}

extension DescribeAttachmentLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
///             period of time has been exceeded.</p>
public struct DescribeAttachmentLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The limit for the number of <a>DescribeAttachment</a> requests in a short
    ///             period of time has been exceeded.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DescribeAttachmentLimitExceededBody: Equatable {
    public let message: String?
}

extension DescribeAttachmentLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAttachmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttachmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AttachmentIdNotFound" : self = .attachmentIdNotFound(try AttachmentIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DescribeAttachmentLimitExceeded" : self = .describeAttachmentLimitExceeded(try DescribeAttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttachmentOutputError: Swift.Error, Equatable {
    case attachmentIdNotFound(AttachmentIdNotFound)
    case describeAttachmentLimitExceeded(DescribeAttachmentLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttachmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAttachmentOutputResponse(attachment: \(String(describing: attachment)))"}
}

extension DescribeAttachmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

/// <p>The content and file name of the attachment returned by the <a>DescribeAttachment</a> operation.</p>
public struct DescribeAttachmentOutputResponse: Equatable {
    /// <p>This object includes the attachment content and file name.</p>
    ///         <p>In the previous response syntax, the value for the <code>data</code> parameter appears
    ///             as <code>blob</code>, which is represented as a base64-encoded string. The value for
    ///                 <code>fileName</code> is the name of the attachment, such as
    ///                 <code>troubleshoot-screenshot.png</code>.</p>
    public let attachment: Attachment?

    public init (
        attachment: Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct DescribeAttachmentOutputResponseBody: Equatable {
    public let attachment: Attachment?
}

extension DescribeAttachmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attachment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

public struct DescribeCasesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCasesOutputError>
}

extension DescribeCasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCasesInput(afterTime: \(String(describing: afterTime)), beforeTime: \(String(describing: beforeTime)), caseIdList: \(String(describing: caseIdList)), displayId: \(String(describing: displayId)), includeCommunications: \(String(describing: includeCommunications)), includeResolvedCases: \(String(describing: includeResolvedCases)), language: \(String(describing: language)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseIdList = caseIdList {
            var caseIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .caseIdList)
            for caseidlist0 in caseIdList {
                try caseIdListContainer.encode(caseidlist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let includeCommunications = includeCommunications {
            try encodeContainer.encode(includeCommunications, forKey: .includeCommunications)
        }
        if includeResolvedCases != false {
            try encodeContainer.encode(includeResolvedCases, forKey: .includeResolvedCases)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCasesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInput: Equatable {
    /// <p>The start date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let afterTime: String?
    /// <p>The end date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let beforeTime: String?
    /// <p>A list of ID numbers of the support cases you want returned. The maximum number of
    ///             cases is 100.</p>
    public let caseIdList: [String]?
    /// <p>The ID displayed for a case in the AWS Support Center user interface.</p>
    public let displayId: String?
    /// <p>Specifies whether to include communications in the <code>DescribeCases</code>
    ///             response. By default, communications are included.</p>
    public let includeCommunications: Bool?
    /// <p>Specifies whether to include resolved support cases in the <code>DescribeCases</code>
    ///             response. By default, resolved cases aren't included.</p>
    public let includeResolvedCases: Bool
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?
    /// <p>The maximum number of results to return before paginating.</p>
    public let maxResults: Int?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: String?

    public init (
        afterTime: String? = nil,
        beforeTime: String? = nil,
        caseIdList: [String]? = nil,
        displayId: String? = nil,
        includeCommunications: Bool? = nil,
        includeResolvedCases: Bool = false,
        language: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseIdList = caseIdList
        self.displayId = displayId
        self.includeCommunications = includeCommunications
        self.includeResolvedCases = includeResolvedCases
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCasesInputBody: Equatable {
    public let caseIdList: [String]?
    public let displayId: String?
    public let afterTime: String?
    public let beforeTime: String?
    public let includeResolvedCases: Bool
    public let nextToken: String?
    public let maxResults: Int?
    public let language: String?
    public let includeCommunications: Bool?
}

extension DescribeCasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .caseIdList)
        var caseIdListDecoded0:[String]? = nil
        if let caseIdListContainer = caseIdListContainer {
            caseIdListDecoded0 = [String]()
            for string0 in caseIdListContainer {
                if let string0 = string0 {
                    caseIdListDecoded0?.append(string0)
                }
            }
        }
        caseIdList = caseIdListDecoded0
        let displayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let includeResolvedCasesDecoded = try containerValues.decode(Bool.self, forKey: .includeResolvedCases)
        includeResolvedCases = includeResolvedCasesDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
        let includeCommunicationsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeCommunications)
        includeCommunications = includeCommunicationsDecoded
    }
}

extension DescribeCasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCasesOutputError: Swift.Error, Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCasesOutputResponse(cases: \(String(describing: cases)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

/// <p>Returns an array of <a href="https://docs.aws.amazon.com/awssupport/latest/APIReference/API_CaseDetails.html">CaseDetails</a>
///             objects and a <code>nextToken</code> that defines a point for pagination in the result
///             set.</p>
public struct DescribeCasesOutputResponse: Equatable {
    /// <p>The details for the cases that match the request.</p>
    public let cases: [CaseDetails]?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: String?

    public init (
        cases: [CaseDetails]? = nil,
        nextToken: String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct DescribeCasesOutputResponseBody: Equatable {
    public let cases: [CaseDetails]?
    public let nextToken: String?
}

extension DescribeCasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cases
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let casesContainer = try containerValues.decodeIfPresent([CaseDetails?].self, forKey: .cases)
        var casesDecoded0:[CaseDetails]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [CaseDetails]()
            for structure0 in casesContainer {
                if let structure0 = structure0 {
                    casesDecoded0?.append(structure0)
                }
            }
        }
        cases = casesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeCommunicationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCommunicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommunicationsOutputError>
}

extension DescribeCommunicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommunicationsInput(afterTime: \(String(describing: afterTime)), beforeTime: \(String(describing: beforeTime)), caseId: \(String(describing: caseId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCommunicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCommunicationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCommunicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCommunicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInput: Equatable {
    /// <p>The start date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let afterTime: String?
    /// <p>The end date for a filtered date search on support case communications. Case
    ///             communications are available for 12 months after creation.</p>
    public let beforeTime: String?
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?
    /// <p>The maximum number of results to return before paginating.</p>
    public let maxResults: Int?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: String?

    public init (
        afterTime: String? = nil,
        beforeTime: String? = nil,
        caseId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsInputBody: Equatable {
    public let caseId: String?
    public let beforeTime: String?
    public let afterTime: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeCommunicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCommunicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommunicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommunicationsOutputError: Swift.Error, Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommunicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCommunicationsOutputResponse(communications: \(String(describing: communications)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCommunicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCommunicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.communications = output.communications
            self.nextToken = output.nextToken
        } else {
            self.communications = nil
            self.nextToken = nil
        }
    }
}

/// <p>The communications returned by the <a>DescribeCommunications</a>
///             operation.</p>
public struct DescribeCommunicationsOutputResponse: Equatable {
    /// <p>The communications for the case.</p>
    public let communications: [Communication]?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: String?

    public init (
        communications: [Communication]? = nil,
        nextToken: String? = nil
    )
    {
        self.communications = communications
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsOutputResponseBody: Equatable {
    public let communications: [Communication]?
    public let nextToken: String?
}

extension DescribeCommunicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case communications
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([Communication?].self, forKey: .communications)
        var communicationsDecoded0:[Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServicesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

extension DescribeServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServicesInput(language: \(String(describing: language)), serviceCodeList: \(String(describing: serviceCodeList)))"}
}

extension DescribeServicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case language
        case serviceCodeList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCodeList = serviceCodeList {
            var serviceCodeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodeList)
            for servicecodelist0 in serviceCodeList {
                try serviceCodeListContainer.encode(servicecodelist0)
            }
        }
    }
}

public struct DescribeServicesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInput: Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?
    /// <p>A JSON-formatted list of service codes available for AWS services.</p>
    public let serviceCodeList: [String]?

    public init (
        language: String? = nil,
        serviceCodeList: [String]? = nil
    )
    {
        self.language = language
        self.serviceCodeList = serviceCodeList
    }
}

struct DescribeServicesInputBody: Equatable {
    public let serviceCodeList: [String]?
    public let language: String?
}

extension DescribeServicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case language
        case serviceCodeList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .serviceCodeList)
        var serviceCodeListDecoded0:[String]? = nil
        if let serviceCodeListContainer = serviceCodeListContainer {
            serviceCodeListDecoded0 = [String]()
            for string0 in serviceCodeListContainer {
                if let string0 = string0 {
                    serviceCodeListDecoded0?.append(string0)
                }
            }
        }
        serviceCodeList = serviceCodeListDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServicesOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServicesOutputResponse(services: \(String(describing: services)))"}
}

extension DescribeServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.services = output.services
        } else {
            self.services = nil
        }
    }
}

/// <p>The list of AWS services returned by the <a>DescribeServices</a>
///             operation.</p>
public struct DescribeServicesOutputResponse: Equatable {
    /// <p>A JSON-formatted list of AWS services.</p>
    public let services: [Service]?

    public init (
        services: [Service]? = nil
    )
    {
        self.services = services
    }
}

struct DescribeServicesOutputResponseBody: Equatable {
    public let services: [Service]?
}

extension DescribeServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case services
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([Service?].self, forKey: .services)
        var servicesDecoded0:[Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

public struct DescribeSeverityLevelsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSeverityLevelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSeverityLevelsOutputError>
}

extension DescribeSeverityLevelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSeverityLevelsInput(language: \(String(describing: language)))"}
}

extension DescribeSeverityLevelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case language
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeSeverityLevelsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSeverityLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSeverityLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInput: Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?

    public init (
        language: String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeSeverityLevelsInputBody: Equatable {
    public let language: String?
}

extension DescribeSeverityLevelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case language
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeSeverityLevelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSeverityLevelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSeverityLevelsOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSeverityLevelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSeverityLevelsOutputResponse(severityLevels: \(String(describing: severityLevels)))"}
}

extension DescribeSeverityLevelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSeverityLevelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.severityLevels = output.severityLevels
        } else {
            self.severityLevels = nil
        }
    }
}

/// <p>The list of severity levels returned by the <a>DescribeSeverityLevels</a>
///             operation.</p>
public struct DescribeSeverityLevelsOutputResponse: Equatable {
    /// <p>The available severity levels for the support case. Available severity levels are
    ///             defined by your service level agreement with AWS.</p>
    public let severityLevels: [SeverityLevel]?

    public init (
        severityLevels: [SeverityLevel]? = nil
    )
    {
        self.severityLevels = severityLevels
    }
}

struct DescribeSeverityLevelsOutputResponseBody: Equatable {
    public let severityLevels: [SeverityLevel]?
}

extension DescribeSeverityLevelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case severityLevels
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityLevelsContainer = try containerValues.decodeIfPresent([SeverityLevel?].self, forKey: .severityLevels)
        var severityLevelsDecoded0:[SeverityLevel]? = nil
        if let severityLevelsContainer = severityLevelsContainer {
            severityLevelsDecoded0 = [SeverityLevel]()
            for structure0 in severityLevelsContainer {
                if let structure0 = structure0 {
                    severityLevelsDecoded0?.append(structure0)
                }
            }
        }
        severityLevels = severityLevelsDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckRefreshStatusesInput(checkIds: \(String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInput: Equatable {
    /// <p>The IDs of the Trusted Advisor checks to get the status.</p>
    ///         <note>
    ///             <p>If you specify the check ID of a check that is automatically refreshed, you might
    ///                 see an <code>InvalidParameterValue</code> error.</p>
    ///         </note>
    public let checkIds: [String]?

    public init (
        checkIds: [String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Equatable {
    public let checkIds: [String]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckRefreshStatusesOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse(statuses: \(String(describing: statuses)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statuses = output.statuses
        } else {
            self.statuses = nil
        }
    }
}

/// <p>The statuses of the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorCheckRefreshStatuses</a> operation.</p>
public struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: Equatable {
    /// <p>The refresh status of the specified Trusted Advisor checks.</p>
    public let statuses: [TrustedAdvisorCheckRefreshStatus]?

    public init (
        statuses: [TrustedAdvisorCheckRefreshStatus]? = nil
    )
    {
        self.statuses = statuses
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Equatable {
    public let statuses: [TrustedAdvisorCheckRefreshStatus]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statuses
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusesContainer = try containerValues.decodeIfPresent([TrustedAdvisorCheckRefreshStatus?].self, forKey: .statuses)
        var statusesDecoded0:[TrustedAdvisorCheckRefreshStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [TrustedAdvisorCheckRefreshStatus]()
            for structure0 in statusesContainer {
                if let structure0 = structure0 {
                    statusesDecoded0?.append(structure0)
                }
            }
        }
        statuses = statusesDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckResultInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

extension DescribeTrustedAdvisorCheckResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckResultInput(checkId: \(String(describing: checkId)), language: \(String(describing: language)))"}
}

extension DescribeTrustedAdvisorCheckResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkId
        case language
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorCheckResultInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

public struct DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

/// <p></p>
public struct DescribeTrustedAdvisorCheckResultInput: Equatable {
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let checkId: String?
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?

    public init (
        checkId: String? = nil,
        language: String? = nil
    )
    {
        self.checkId = checkId
        self.language = language
    }
}

struct DescribeTrustedAdvisorCheckResultInputBody: Equatable {
    public let checkId: String?
    public let language: String?
}

extension DescribeTrustedAdvisorCheckResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkId
        case language
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckResultOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckResultOutputResponse(result: \(String(describing: result)))"}
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckResultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

/// <p>The result of the Trusted Advisor check returned by the <a>DescribeTrustedAdvisorCheckResult</a> operation.</p>
public struct DescribeTrustedAdvisorCheckResultOutputResponse: Equatable {
    /// <p>The detailed results of the Trusted Advisor check.</p>
    public let result: TrustedAdvisorCheckResult?

    public init (
        result: TrustedAdvisorCheckResult? = nil
    )
    {
        self.result = result
    }
}

struct DescribeTrustedAdvisorCheckResultOutputResponseBody: Equatable {
    public let result: TrustedAdvisorCheckResult?
}

extension DescribeTrustedAdvisorCheckResultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case result
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(TrustedAdvisorCheckResult.self, forKey: .result)
        result = resultDecoded
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

extension DescribeTrustedAdvisorCheckSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckSummariesInput(checkIds: \(String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInput: Equatable {
    /// <p>The IDs of the Trusted Advisor checks.</p>
    public let checkIds: [String]?

    public init (
        checkIds: [String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckSummariesInputBody: Equatable {
    public let checkIds: [String]?
}

extension DescribeTrustedAdvisorCheckSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckSummariesOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorCheckSummariesOutputResponse(summaries: \(String(describing: summaries)))"}
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summaries = output.summaries
        } else {
            self.summaries = nil
        }
    }
}

/// <p>The summaries of the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorCheckSummaries</a> operation.</p>
public struct DescribeTrustedAdvisorCheckSummariesOutputResponse: Equatable {
    /// <p>The summary information for the requested Trusted Advisor checks.</p>
    public let summaries: [TrustedAdvisorCheckSummary]?

    public init (
        summaries: [TrustedAdvisorCheckSummary]? = nil
    )
    {
        self.summaries = summaries
    }
}

struct DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Equatable {
    public let summaries: [TrustedAdvisorCheckSummary]?
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case summaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorCheckSummary?].self, forKey: .summaries)
        var summariesDecoded0:[TrustedAdvisorCheckSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [TrustedAdvisorCheckSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct DescribeTrustedAdvisorChecksInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorChecksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorChecksOutputError>
}

extension DescribeTrustedAdvisorChecksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorChecksInput(language: \(String(describing: language)))"}
}

extension DescribeTrustedAdvisorChecksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case language
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorChecksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorChecksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrustedAdvisorChecksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInput: Equatable {
    /// <p>The ISO 639-1 code for the language in which AWS provides support. AWS Support
    ///             currently supports English ("en") and Japanese ("ja"). Language parameters must be
    ///             passed explicitly for operations that take them.</p>
    public let language: String?

    public init (
        language: String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeTrustedAdvisorChecksInputBody: Equatable {
    public let language: String?
}

extension DescribeTrustedAdvisorChecksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case language
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorChecksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorChecksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorChecksOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorChecksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrustedAdvisorChecksOutputResponse(checks: \(String(describing: checks)))"}
}

extension DescribeTrustedAdvisorChecksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorChecksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.checks = output.checks
        } else {
            self.checks = nil
        }
    }
}

/// <p>Information about the Trusted Advisor checks returned by the <a>DescribeTrustedAdvisorChecks</a> operation.</p>
public struct DescribeTrustedAdvisorChecksOutputResponse: Equatable {
    /// <p>Information about all available Trusted Advisor checks.</p>
    public let checks: [TrustedAdvisorCheckDescription]?

    public init (
        checks: [TrustedAdvisorCheckDescription]? = nil
    )
    {
        self.checks = checks
    }
}

struct DescribeTrustedAdvisorChecksOutputResponseBody: Equatable {
    public let checks: [TrustedAdvisorCheckDescription]?
}

extension DescribeTrustedAdvisorChecksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checksContainer = try containerValues.decodeIfPresent([TrustedAdvisorCheckDescription?].self, forKey: .checks)
        var checksDecoded0:[TrustedAdvisorCheckDescription]? = nil
        if let checksContainer = checksContainer {
            checksDecoded0 = [TrustedAdvisorCheckDescription]()
            for structure0 in checksContainer {
                if let structure0 = structure0 {
                    checksDecoded0?.append(structure0)
                }
            }
        }
        checks = checksDecoded0
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>An internal server error occurred.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RecentCaseCommunications: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case communications
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let communications = communications {
            var communicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .communications)
            for communicationlist0 in communications {
                try communicationsContainer.encode(communicationlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([Communication?].self, forKey: .communications)
        var communicationsDecoded0:[Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RecentCaseCommunications: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecentCaseCommunications(communications: \(String(describing: communications)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>The five most recent communications associated with the case.</p>
public struct RecentCaseCommunications: Equatable {
    /// <p>The five most recent communications associated with the case.</p>
    public let communications: [Communication]?
    /// <p>A resumption point for pagination.</p>
    public let nextToken: String?

    public init (
        communications: [Communication]? = nil,
        nextToken: String? = nil
    )
    {
        self.communications = communications
        self.nextToken = nextToken
    }
}

public struct RefreshTrustedAdvisorCheckInputBodyMiddleware: Middleware {
    public let id: String = "RefreshTrustedAdvisorCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshTrustedAdvisorCheckOutputError>
}

extension RefreshTrustedAdvisorCheckInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshTrustedAdvisorCheckInput(checkId: \(String(describing: checkId)))"}
}

extension RefreshTrustedAdvisorCheckInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
    }
}

public struct RefreshTrustedAdvisorCheckInputHeadersMiddleware: Middleware {
    public let id: String = "RefreshTrustedAdvisorCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshTrustedAdvisorCheckOutputError>
}

public struct RefreshTrustedAdvisorCheckInputQueryItemMiddleware: Middleware {
    public let id: String = "RefreshTrustedAdvisorCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RefreshTrustedAdvisorCheckOutputError>
}

/// <p></p>
public struct RefreshTrustedAdvisorCheckInput: Equatable {
    /// <p>The unique identifier for the Trusted Advisor check to refresh.</p>
    ///             <note>
    ///                 <p>Specifying the check ID of a check that is automatically refreshed
    ///                     causes an <code>InvalidParameterValue</code> error.</p>
    ///             </note>
    public let checkId: String?

    public init (
        checkId: String? = nil
    )
    {
        self.checkId = checkId
    }
}

struct RefreshTrustedAdvisorCheckInputBody: Equatable {
    public let checkId: String?
}

extension RefreshTrustedAdvisorCheckInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case checkId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkId)
        checkId = checkIdDecoded
    }
}

extension RefreshTrustedAdvisorCheckOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshTrustedAdvisorCheckOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshTrustedAdvisorCheckOutputError: Swift.Error, Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshTrustedAdvisorCheckOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RefreshTrustedAdvisorCheckOutputResponse(status: \(String(describing: status)))"}
}

extension RefreshTrustedAdvisorCheckOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshTrustedAdvisorCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>The current refresh status of a Trusted Advisor check.</p>
public struct RefreshTrustedAdvisorCheckOutputResponse: Equatable {
    /// <p>The current refresh status for a check, including the amount of time until the check
    ///             is eligible for refresh.</p>
    public let status: TrustedAdvisorCheckRefreshStatus?

    public init (
        status: TrustedAdvisorCheckRefreshStatus? = nil
    )
    {
        self.status = status
    }
}

struct RefreshTrustedAdvisorCheckOutputResponseBody: Equatable {
    public let status: TrustedAdvisorCheckRefreshStatus?
}

extension RefreshTrustedAdvisorCheckOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorCheckRefreshStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct ResolveCaseInputBodyMiddleware: Middleware {
    public let id: String = "ResolveCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCaseOutputError>
}

extension ResolveCaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveCaseInput(caseId: \(String(describing: caseId)))"}
}

extension ResolveCaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
    }
}

public struct ResolveCaseInputHeadersMiddleware: Middleware {
    public let id: String = "ResolveCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInputQueryItemMiddleware: Middleware {
    public let id: String = "ResolveCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInput: Equatable {
    /// <p>The support case ID requested or returned in the call. The case ID is an
    ///             alphanumeric string formatted as shown in this example:
    ///                 case-<i>12345678910-2013-c4c1d2bf33c5cf47</i>
    ///         </p>
    public let caseId: String?

    public init (
        caseId: String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct ResolveCaseInputBody: Equatable {
    public let caseId: String?
}

extension ResolveCaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case caseId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

extension ResolveCaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveCaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveCaseOutputError: Swift.Error, Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveCaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResolveCaseOutputResponse(finalCaseStatus: \(String(describing: finalCaseStatus)), initialCaseStatus: \(String(describing: initialCaseStatus)))"}
}

extension ResolveCaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.finalCaseStatus = output.finalCaseStatus
            self.initialCaseStatus = output.initialCaseStatus
        } else {
            self.finalCaseStatus = nil
            self.initialCaseStatus = nil
        }
    }
}

/// <p>The status of the case returned by the <a>ResolveCase</a> operation.</p>
public struct ResolveCaseOutputResponse: Equatable {
    /// <p>The status of the case after the <a>ResolveCase</a> request was
    ///             processed.</p>
    public let finalCaseStatus: String?
    /// <p>The status of the case when the <a>ResolveCase</a> request was sent.</p>
    public let initialCaseStatus: String?

    public init (
        finalCaseStatus: String? = nil,
        initialCaseStatus: String? = nil
    )
    {
        self.finalCaseStatus = finalCaseStatus
        self.initialCaseStatus = initialCaseStatus
    }
}

struct ResolveCaseOutputResponseBody: Equatable {
    public let initialCaseStatus: String?
    public let finalCaseStatus: String?
}

extension ResolveCaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case finalCaseStatus
        case initialCaseStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialCaseStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initialCaseStatus)
        initialCaseStatus = initialCaseStatusDecoded
        let finalCaseStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .finalCaseStatus)
        finalCaseStatus = finalCaseStatusDecoded
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categories
        case code
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for categorylist0 in categories {
                try categoriesContainer.encode(categorylist0)
            }
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([Category?].self, forKey: .categories)
        var categoriesDecoded0:[Category]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [Category]()
            for structure0 in categoriesContainer {
                if let structure0 = structure0 {
                    categoriesDecoded0?.append(structure0)
                }
            }
        }
        categories = categoriesDecoded0
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(categories: \(String(describing: categories)), code: \(String(describing: code)), name: \(String(describing: name)))"}
}

/// <p>Information about an AWS service returned by the <a>DescribeServices</a>
///             operation.</p>
public struct Service: Equatable {
    /// <p>A list of categories that describe the type of support issue a case describes.
    ///             Categories consist of a category name and a category code. Category names and codes are
    ///             passed to AWS Support when you call <a>CreateCase</a>.</p>
    public let categories: [Category]?
    /// <p>The code for an AWS service returned by the <a>DescribeServices</a>
    ///             response. The <code>name</code> element contains the corresponding friendly name.</p>
    public let code: String?
    /// <p>The friendly name for an AWS service. The <code>code</code> element contains the
    ///             corresponding code.</p>
    public let name: String?

    public init (
        categories: [Category]? = nil,
        code: String? = nil,
        name: String? = nil
    )
    {
        self.categories = categories
        self.code = code
        self.name = name
    }
}

extension SeverityLevel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SeverityLevel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SeverityLevel(code: \(String(describing: code)), name: \(String(describing: name)))"}
}

/// <p>A code and name pair that represents the severity level of a support case. The
///             available values depend on the support plan for the account. For more information, see
///                 <a href="https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity">Choosing a
///                 severity</a> in the <i>AWS Support User Guide</i>.</p>
public struct SeverityLevel: Equatable {
    /// <p>The code for case severity level.</p>
    ///         <p>Valid values: <code>low</code> | <code>normal</code> | <code>high</code> |
    ///                 <code>urgent</code> | <code>critical</code>
    ///          </p>
    public let code: String?
    /// <p>The name of the severity level that corresponds to the severity level code.</p>
    ///         <note>
    ///             <p>The values returned by the API are different from the values that appear in the
    ///                 AWS Support Center. For example, the API uses the code <code>low</code>, but the name
    ///                 appears as General guidance in Support Center. </p>
    ///             <p>The following are the API code names and how they appear in the console:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>
    ///                      <code>low</code> - General guidance</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <code>normal</code> - System impaired</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <code>high</code> - Production system impaired</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <code>urgent</code> - Production system down</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <code>critical</code> - Business-critical system down</p>
    ///                 </li>
    ///             </ul>
    ///         </note>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity">Choosing a
    ///                 severity</a> in the <i>AWS Support User Guide</i>.</p>
    public let name: String?

    public init (
        code: String? = nil,
        name: String? = nil
    )
    {
        self.code = code
        self.name = name
    }
}

extension TrustedAdvisorCategorySpecificSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costOptimizing
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costOptimizing = costOptimizing {
            try encodeContainer.encode(costOptimizing, forKey: .costOptimizing)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costOptimizingDecoded = try containerValues.decodeIfPresent(TrustedAdvisorCostOptimizingSummary.self, forKey: .costOptimizing)
        costOptimizing = costOptimizingDecoded
    }
}

extension TrustedAdvisorCategorySpecificSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCategorySpecificSummary(costOptimizing: \(String(describing: costOptimizing)))"}
}

/// <p>The container for summary information that relates to the category of the Trusted Advisor check.</p>
public struct TrustedAdvisorCategorySpecificSummary: Equatable {
    /// <p>The summary information about cost savings for a Trusted Advisor check that is in the
    ///             Cost Optimizing category.</p>
    public let costOptimizing: TrustedAdvisorCostOptimizingSummary?

    public init (
        costOptimizing: TrustedAdvisorCostOptimizingSummary? = nil
    )
    {
        self.costOptimizing = costOptimizing
    }
}

extension TrustedAdvisorCheckDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case description
        case id
        case metadata
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metadata)
        var metadataDecoded0:[String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension TrustedAdvisorCheckDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCheckDescription(category: \(String(describing: category)), description: \(String(describing: description)), id: \(String(describing: id)), metadata: \(String(describing: metadata)), name: \(String(describing: name)))"}
}

/// <p>The description and metadata for a Trusted Advisor check.</p>
public struct TrustedAdvisorCheckDescription: Equatable {
    /// <p>The category of the Trusted Advisor check.</p>
    public let category: String?
    /// <p>The description of the Trusted Advisor check, which includes the alert criteria and
    ///             recommended operations (contains HTML markup).</p>
    public let description: String?
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let id: String?
    /// <p>The column headings for the data returned by the Trusted Advisor check. The order of
    ///             the headings corresponds to the order of the data in the <b>Metadata</b> element of the <a>TrustedAdvisorResourceDetail</a>
    ///             for the check. <b>Metadata</b> contains all the data that is
    ///             shown in the Excel download, even in those cases where the UI shows just summary data.
    ///         </p>
    public let metadata: [String]?
    /// <p>The display name for the Trusted Advisor check.</p>
    public let name: String?

    public init (
        category: String? = nil,
        description: String? = nil,
        id: String? = nil,
        metadata: [String]? = nil,
        name: String? = nil
    )
    {
        self.category = category
        self.description = description
        self.id = id
        self.metadata = metadata
        self.name = name
    }
}

extension TrustedAdvisorCheckRefreshStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkId
        case millisUntilNextRefreshable
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if millisUntilNextRefreshable != 0 {
            try encodeContainer.encode(millisUntilNextRefreshable, forKey: .millisUntilNextRefreshable)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let millisUntilNextRefreshableDecoded = try containerValues.decode(Int.self, forKey: .millisUntilNextRefreshable)
        millisUntilNextRefreshable = millisUntilNextRefreshableDecoded
    }
}

extension TrustedAdvisorCheckRefreshStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCheckRefreshStatus(checkId: \(String(describing: checkId)), millisUntilNextRefreshable: \(String(describing: millisUntilNextRefreshable)), status: \(String(describing: status)))"}
}

/// <p>The refresh status of a Trusted Advisor check.</p>
public struct TrustedAdvisorCheckRefreshStatus: Equatable {
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let checkId: String?
    /// <p>The amount of time, in milliseconds, until the Trusted Advisor check is eligible for
    ///             refresh.</p>
    public let millisUntilNextRefreshable: Int
    /// <p>The status of the Trusted Advisor check for which a refresh has been requested:
    ///             </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>none</code> - The check is not refreshed or the non-success status
    ///                     exceeds the timeout</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>enqueued</code> - The check refresh requests has entered the refresh
    ///                     queue</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>processing</code> - The check refresh request is picked up by the rule
    ///                     processing engine</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>success</code> - The check is successfully refreshed</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>abandoned</code> - The check refresh has failed</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        checkId: String? = nil,
        millisUntilNextRefreshable: Int = 0,
        status: String? = nil
    )
    {
        self.checkId = checkId
        self.millisUntilNextRefreshable = millisUntilNextRefreshable
        self.status = status
    }
}

extension TrustedAdvisorCheckResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categorySpecificSummary
        case checkId
        case flaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let flaggedResources = flaggedResources {
            var flaggedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flaggedResources)
            for trustedadvisorresourcedetaillist0 in flaggedResources {
                try flaggedResourcesContainer.encode(trustedadvisorresourcedetaillist0)
            }
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
        let flaggedResourcesContainer = try containerValues.decodeIfPresent([TrustedAdvisorResourceDetail?].self, forKey: .flaggedResources)
        var flaggedResourcesDecoded0:[TrustedAdvisorResourceDetail]? = nil
        if let flaggedResourcesContainer = flaggedResourcesContainer {
            flaggedResourcesDecoded0 = [TrustedAdvisorResourceDetail]()
            for structure0 in flaggedResourcesContainer {
                if let structure0 = structure0 {
                    flaggedResourcesDecoded0?.append(structure0)
                }
            }
        }
        flaggedResources = flaggedResourcesDecoded0
    }
}

extension TrustedAdvisorCheckResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCheckResult(categorySpecificSummary: \(String(describing: categorySpecificSummary)), checkId: \(String(describing: checkId)), flaggedResources: \(String(describing: flaggedResources)), resourcesSummary: \(String(describing: resourcesSummary)), status: \(String(describing: status)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>The results of a Trusted Advisor check returned by <a>DescribeTrustedAdvisorCheckResult</a>.</p>
public struct TrustedAdvisorCheckResult: Equatable {
    /// <p>Summary information that relates to the category of the check. Cost Optimizing is the
    ///             only category that is currently supported.</p>
    public let categorySpecificSummary: TrustedAdvisorCategorySpecificSummary?
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let checkId: String?
    /// <p>The details about each resource listed in the check result.</p>
    public let flaggedResources: [TrustedAdvisorResourceDetail]?
    /// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
    public let resourcesSummary: TrustedAdvisorResourcesSummary?
    /// <p>The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or
    ///             "not_available".</p>
    public let status: String?
    /// <p>The time of the last refresh of the check.</p>
    public let timestamp: String?

    public init (
        categorySpecificSummary: TrustedAdvisorCategorySpecificSummary? = nil,
        checkId: String? = nil,
        flaggedResources: [TrustedAdvisorResourceDetail]? = nil,
        resourcesSummary: TrustedAdvisorResourcesSummary? = nil,
        status: String? = nil,
        timestamp: String? = nil
    )
    {
        self.categorySpecificSummary = categorySpecificSummary
        self.checkId = checkId
        self.flaggedResources = flaggedResources
        self.resourcesSummary = resourcesSummary
        self.status = status
        self.timestamp = timestamp
    }
}

extension TrustedAdvisorCheckSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categorySpecificSummary
        case checkId
        case hasFlaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if hasFlaggedResources != false {
            try encodeContainer.encode(hasFlaggedResources, forKey: .hasFlaggedResources)
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let hasFlaggedResourcesDecoded = try containerValues.decode(Bool.self, forKey: .hasFlaggedResources)
        hasFlaggedResources = hasFlaggedResourcesDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
    }
}

extension TrustedAdvisorCheckSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCheckSummary(categorySpecificSummary: \(String(describing: categorySpecificSummary)), checkId: \(String(describing: checkId)), hasFlaggedResources: \(String(describing: hasFlaggedResources)), resourcesSummary: \(String(describing: resourcesSummary)), status: \(String(describing: status)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>A summary of a Trusted Advisor check result, including the alert status, last refresh,
///             and number of resources examined.</p>
public struct TrustedAdvisorCheckSummary: Equatable {
    /// <p>Summary information that relates to the category of the check. Cost Optimizing is the
    ///             only category that is currently supported.</p>
    public let categorySpecificSummary: TrustedAdvisorCategorySpecificSummary?
    /// <p>The unique identifier for the Trusted Advisor check.</p>
    public let checkId: String?
    /// <p>Specifies whether the Trusted Advisor check has flagged resources.</p>
    public let hasFlaggedResources: Bool
    /// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
    public let resourcesSummary: TrustedAdvisorResourcesSummary?
    /// <p>The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or
    ///             "not_available".</p>
    public let status: String?
    /// <p>The time of the last refresh of the check.</p>
    public let timestamp: String?

    public init (
        categorySpecificSummary: TrustedAdvisorCategorySpecificSummary? = nil,
        checkId: String? = nil,
        hasFlaggedResources: Bool = false,
        resourcesSummary: TrustedAdvisorResourcesSummary? = nil,
        status: String? = nil,
        timestamp: String? = nil
    )
    {
        self.categorySpecificSummary = categorySpecificSummary
        self.checkId = checkId
        self.hasFlaggedResources = hasFlaggedResources
        self.resourcesSummary = resourcesSummary
        self.status = status
        self.timestamp = timestamp
    }
}

extension TrustedAdvisorCostOptimizingSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case estimatedMonthlySavings
        case estimatedPercentMonthlySavings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimatedMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if estimatedPercentMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedPercentMonthlySavings, forKey: .estimatedPercentMonthlySavings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decode(Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedPercentMonthlySavingsDecoded = try containerValues.decode(Double.self, forKey: .estimatedPercentMonthlySavings)
        estimatedPercentMonthlySavings = estimatedPercentMonthlySavingsDecoded
    }
}

extension TrustedAdvisorCostOptimizingSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorCostOptimizingSummary(estimatedMonthlySavings: \(String(describing: estimatedMonthlySavings)), estimatedPercentMonthlySavings: \(String(describing: estimatedPercentMonthlySavings)))"}
}

/// <p>The estimated cost savings that might be realized if the recommended operations are
///             taken.</p>
public struct TrustedAdvisorCostOptimizingSummary: Equatable {
    /// <p>The estimated monthly savings that might be realized if the recommended operations are
    ///             taken.</p>
    public let estimatedMonthlySavings: Double
    /// <p>The estimated percentage of savings that might be realized if the recommended
    ///             operations are taken.</p>
    public let estimatedPercentMonthlySavings: Double

    public init (
        estimatedMonthlySavings: Double = 0.0,
        estimatedPercentMonthlySavings: Double = 0.0
    )
    {
        self.estimatedMonthlySavings = estimatedMonthlySavings
        self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
    }
}

extension TrustedAdvisorResourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isSuppressed
        case metadata
        case region
        case resourceId
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isSuppressed != false {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let isSuppressedDecoded = try containerValues.decode(Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metadata)
        var metadataDecoded0:[String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension TrustedAdvisorResourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorResourceDetail(isSuppressed: \(String(describing: isSuppressed)), metadata: \(String(describing: metadata)), region: \(String(describing: region)), resourceId: \(String(describing: resourceId)), status: \(String(describing: status)))"}
}

/// <p>Contains information about a resource identified by a Trusted Advisor check.</p>
public struct TrustedAdvisorResourceDetail: Equatable {
    /// <p>Specifies whether the AWS resource was ignored by Trusted Advisor because it was
    ///             marked as suppressed by the user.</p>
    public let isSuppressed: Bool
    /// <p>Additional information about the identified resource. The exact metadata and its order
    ///             can be obtained by inspecting the <a>TrustedAdvisorCheckDescription</a>
    ///             object returned by the call to <a>DescribeTrustedAdvisorChecks</a>. <b>Metadata</b> contains all the data that is shown in the Excel
    ///             download, even in those cases where the UI shows just summary data.</p>
    public let metadata: [String]?
    /// <p>The AWS Region in which the identified resource is located.</p>
    public let region: String?
    /// <p>The unique identifier for the identified resource.</p>
    public let resourceId: String?
    /// <p>The status code for the resource identified in the Trusted Advisor check.</p>
    public let status: String?

    public init (
        isSuppressed: Bool = false,
        metadata: [String]? = nil,
        region: String? = nil,
        resourceId: String? = nil,
        status: String? = nil
    )
    {
        self.isSuppressed = isSuppressed
        self.metadata = metadata
        self.region = region
        self.resourceId = resourceId
        self.status = status
    }
}

extension TrustedAdvisorResourcesSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourcesFlagged
        case resourcesIgnored
        case resourcesProcessed
        case resourcesSuppressed
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if resourcesFlagged != 0 {
            try encodeContainer.encode(resourcesFlagged, forKey: .resourcesFlagged)
        }
        if resourcesIgnored != 0 {
            try encodeContainer.encode(resourcesIgnored, forKey: .resourcesIgnored)
        }
        if resourcesProcessed != 0 {
            try encodeContainer.encode(resourcesProcessed, forKey: .resourcesProcessed)
        }
        if resourcesSuppressed != 0 {
            try encodeContainer.encode(resourcesSuppressed, forKey: .resourcesSuppressed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesProcessedDecoded = try containerValues.decode(Int.self, forKey: .resourcesProcessed)
        resourcesProcessed = resourcesProcessedDecoded
        let resourcesFlaggedDecoded = try containerValues.decode(Int.self, forKey: .resourcesFlagged)
        resourcesFlagged = resourcesFlaggedDecoded
        let resourcesIgnoredDecoded = try containerValues.decode(Int.self, forKey: .resourcesIgnored)
        resourcesIgnored = resourcesIgnoredDecoded
        let resourcesSuppressedDecoded = try containerValues.decode(Int.self, forKey: .resourcesSuppressed)
        resourcesSuppressed = resourcesSuppressedDecoded
    }
}

extension TrustedAdvisorResourcesSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedAdvisorResourcesSummary(resourcesFlagged: \(String(describing: resourcesFlagged)), resourcesIgnored: \(String(describing: resourcesIgnored)), resourcesProcessed: \(String(describing: resourcesProcessed)), resourcesSuppressed: \(String(describing: resourcesSuppressed)))"}
}

/// <p>Details about AWS resources that were analyzed in a call to Trusted Advisor <a>DescribeTrustedAdvisorCheckSummaries</a>.</p>
public struct TrustedAdvisorResourcesSummary: Equatable {
    /// <p>The number of AWS resources that were flagged (listed) by the Trusted Advisor
    ///             check.</p>
    public let resourcesFlagged: Int
    /// <p>The number of AWS resources ignored by Trusted Advisor because information was
    ///             unavailable.</p>
    public let resourcesIgnored: Int
    /// <p>The number of AWS resources that were analyzed by the Trusted Advisor check.</p>
    public let resourcesProcessed: Int
    /// <p>The number of AWS resources ignored by Trusted Advisor because they were marked as
    ///             suppressed by the user.</p>
    public let resourcesSuppressed: Int

    public init (
        resourcesFlagged: Int = 0,
        resourcesIgnored: Int = 0,
        resourcesProcessed: Int = 0,
        resourcesSuppressed: Int = 0
    )
    {
        self.resourcesFlagged = resourcesFlagged
        self.resourcesIgnored = resourcesIgnored
        self.resourcesProcessed = resourcesProcessed
        self.resourcesSuppressed = resourcesSuppressed
    }
}
