// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension App: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appArn
        case appId
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case createTime
        case customHeaders
        case customRules
        case defaultDomain
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case platform
        case productionBranch
        case repository
        case tags
        case updateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let autoBranchCreationConfig = autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpatterns0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpatterns0)
            }
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let customHeaders = customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrules0 in customRules {
                try customRulesContainer.encode(customrules0)
            }
        }
        if let defaultDomain = defaultDomain {
            try encodeContainer.encode(defaultDomain, forKey: .defaultDomain)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let productionBranch = productionBranch {
            try encodeContainer.encode(productionBranch, forKey: .productionBranch)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repository)
        repository = repositoryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let defaultDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultDomain)
        defaultDomain = defaultDomainDecoded
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let productionBranchDecoded = try containerValues.decodeIfPresent(ProductionBranch.self, forKey: .productionBranch)
        productionBranch = productionBranchDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
    }
}

extension App: CustomDebugStringConvertible {
    public var debugDescription: String {
        "App(appArn: \(String(describing: appArn)), appId: \(String(describing: appId)), autoBranchCreationConfig: \(String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(String(describing: autoBranchCreationPatterns)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), buildSpec: \(String(describing: buildSpec)), createTime: \(String(describing: createTime)), customHeaders: \(String(describing: customHeaders)), customRules: \(String(describing: customRules)), defaultDomain: \(String(describing: defaultDomain)), description: \(String(describing: description)), enableAutoBranchCreation: \(String(describing: enableAutoBranchCreation)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableBranchAutoBuild: \(String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(String(describing: enableBranchAutoDeletion)), environmentVariables: \(String(describing: environmentVariables)), iamServiceRoleArn: \(String(describing: iamServiceRoleArn)), name: \(String(describing: name)), platform: \(String(describing: platform)), productionBranch: \(String(describing: productionBranch)), repository: \(String(describing: repository)), tags: \(String(describing: tags)), updateTime: \(String(describing: updateTime)))"}
}

/// <p> Represents the different branches of a repository for building, deploying, and
///             hosting an Amplify app. </p>
public struct App: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the Amplify app. </p>
    public let appArn: String?
    /// <p> The unique ID of the Amplify app. </p>
    public let appId: String?
    /// <p> Describes the automated branch creation configuration for the Amplify app. </p>
    public let autoBranchCreationConfig: AutoBranchCreationConfig?
    /// <p> Describes the automated branch creation glob patterns for the Amplify app. </p>
    public let autoBranchCreationPatterns: [String]?
    /// <p> The basic authorization credentials for branches for the Amplify app. </p>
    public let basicAuthCredentials: String?
    /// <p> Describes the content of the build specification (build spec) for the Amplify app.
    ///         </p>
    public let buildSpec: String?
    /// <p> Creates a date and time for the Amplify app. </p>
    public let createTime: Date?
    /// <p>Describes the custom HTTP headers for the Amplify app.</p>
    public let customHeaders: String?
    /// <p> Describes the custom redirect and rewrite rules for the Amplify app. </p>
    public let customRules: [CustomRule]?
    /// <p> The default domain for the Amplify app. </p>
    public let defaultDomain: String?
    /// <p> The description for the Amplify app. </p>
    public let description: String?
    /// <p> Enables automated branch creation for the Amplify app. </p>
    public let enableAutoBranchCreation: Bool?
    /// <p> Enables basic authorization for the Amplify app's branches. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables the auto-building of branches for the Amplify app. </p>
    public let enableBranchAutoBuild: Bool?
    /// <p> Automatically disconnect a branch in the Amplify Console when you delete a branch
    ///             from your Git repository. </p>
    public let enableBranchAutoDeletion: Bool?
    /// <p> The environment variables for the Amplify app. </p>
    public let environmentVariables: [String:String]?
    /// <p> The AWS Identity and Access Management (IAM) service role for the Amazon Resource
    ///             Name (ARN) of the Amplify app. </p>
    public let iamServiceRoleArn: String?
    /// <p> The name for the Amplify app. </p>
    public let name: String?
    /// <p> The platform for the Amplify app. </p>
    public let platform: Platform?
    /// <p> Describes the information about a production branch of the Amplify app. </p>
    public let productionBranch: ProductionBranch?
    /// <p> The repository for the Amplify app. </p>
    public let repository: String?
    /// <p> The tag for the Amplify app. </p>
    public let tags: [String:String]?
    /// <p> Updates the date and time for the Amplify app. </p>
    public let updateTime: Date?

    public init (
        appArn: String? = nil,
        appId: String? = nil,
        autoBranchCreationConfig: AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [String]? = nil,
        basicAuthCredentials: String? = nil,
        buildSpec: String? = nil,
        createTime: Date? = nil,
        customHeaders: String? = nil,
        customRules: [CustomRule]? = nil,
        defaultDomain: String? = nil,
        description: String? = nil,
        enableAutoBranchCreation: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableBranchAutoBuild: Bool? = nil,
        enableBranchAutoDeletion: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        iamServiceRoleArn: String? = nil,
        name: String? = nil,
        platform: Platform? = nil,
        productionBranch: ProductionBranch? = nil,
        repository: String? = nil,
        tags: [String:String]? = nil,
        updateTime: Date? = nil
    )
    {
        self.appArn = appArn
        self.appId = appId
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.createTime = createTime
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.defaultDomain = defaultDomain
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.platform = platform
        self.productionBranch = productionBranch
        self.repository = repository
        self.tags = tags
        self.updateTime = updateTime
    }
}

extension Artifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactFileName
        case artifactId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactFileName = artifactFileName {
            try encodeContainer.encode(artifactFileName, forKey: .artifactFileName)
        }
        if let artifactId = artifactId {
            try encodeContainer.encode(artifactId, forKey: .artifactId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactFileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactFileName)
        artifactFileName = artifactFileNameDecoded
        let artifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
    }
}

extension Artifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Artifact(artifactFileName: \(String(describing: artifactFileName)), artifactId: \(String(describing: artifactId)))"}
}

/// <p> Describes an artifact. </p>
public struct Artifact: Equatable {
    /// <p> The file name for the artifact. </p>
    public let artifactFileName: String?
    /// <p> The unique ID for the artifact. </p>
    public let artifactId: String?

    public init (
        artifactFileName: String? = nil,
        artifactId: String? = nil
    )
    {
        self.artifactFileName = artifactFileName
        self.artifactId = artifactId
    }
}

extension AutoBranchCreationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case basicAuthCredentials
        case buildSpec
        case enableAutoBuild
        case enableBasicAuth
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let enableAutoBuild = enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enablePerformanceMode = enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(Stage.self, forKey: .stage)
        stage = stageDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .framework)
        framework = frameworkDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
    }
}

extension AutoBranchCreationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutoBranchCreationConfig(basicAuthCredentials: \(String(describing: basicAuthCredentials)), buildSpec: \(String(describing: buildSpec)), enableAutoBuild: \(String(describing: enableAutoBuild)), enableBasicAuth: \(String(describing: enableBasicAuth)), enablePerformanceMode: \(String(describing: enablePerformanceMode)), enablePullRequestPreview: \(String(describing: enablePullRequestPreview)), environmentVariables: \(String(describing: environmentVariables)), framework: \(String(describing: framework)), pullRequestEnvironmentName: \(String(describing: pullRequestEnvironmentName)), stage: \(String(describing: stage)))"}
}

/// <p> Describes the automated branch creation configuration. </p>
public struct AutoBranchCreationConfig: Equatable {
    /// <p> The basic authorization credentials for the autocreated branch. </p>
    public let basicAuthCredentials: String?
    /// <p> The build specification (build spec) for the autocreated branch. </p>
    public let buildSpec: String?
    /// <p> Enables auto building for the autocreated branch. </p>
    public let enableAutoBuild: Bool?
    /// <p> Enables basic authorization for the autocreated branch. </p>
    public let enableBasicAuth: Bool?
    /// <p>Enables performance mode for the branch.</p>
    ///         <p>Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out. </p>
    public let enablePerformanceMode: Bool?
    /// <p> Enables pull request previews for the autocreated branch. </p>
    public let enablePullRequestPreview: Bool?
    /// <p> The environment variables for the autocreated branch. </p>
    public let environmentVariables: [String:String]?
    /// <p> The framework for the autocreated branch. </p>
    public let framework: String?
    /// <p> The Amplify environment name for the pull request. </p>
    public let pullRequestEnvironmentName: String?
    /// <p> Describes the current stage for the autocreated branch. </p>
    public let stage: Stage?

    public init (
        basicAuthCredentials: String? = nil,
        buildSpec: String? = nil,
        enableAutoBuild: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enablePerformanceMode: Bool? = nil,
        enablePullRequestPreview: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        framework: String? = nil,
        pullRequestEnvironmentName: String? = nil,
        stage: Stage? = nil
    )
    {
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
    }
}

extension BackendEnvironment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case createTime
        case deploymentArtifacts
        case environmentName
        case stackName
        case updateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let deploymentArtifacts = deploymentArtifacts {
            try encodeContainer.encode(deploymentArtifacts, forKey: .deploymentArtifacts)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let deploymentArtifactsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArtifacts)
        deploymentArtifacts = deploymentArtifactsDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension BackendEnvironment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendEnvironment(backendEnvironmentArn: \(String(describing: backendEnvironmentArn)), createTime: \(String(describing: createTime)), deploymentArtifacts: \(String(describing: deploymentArtifacts)), environmentName: \(String(describing: environmentName)), stackName: \(String(describing: stackName)), updateTime: \(String(describing: updateTime)))"}
}

/// <p> Describes the backend environment for an Amplify app. </p>
public struct BackendEnvironment: Equatable {
    /// <p> The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify
    ///             app. </p>
    public let backendEnvironmentArn: String?
    /// <p> The creation date and time for a backend environment that is part of an Amplify app.
    ///         </p>
    public let createTime: Date?
    /// <p> The name of deployment artifacts. </p>
    public let deploymentArtifacts: String?
    /// <p> The name for a backend environment that is part of an Amplify app. </p>
    public let environmentName: String?
    /// <p> The AWS CloudFormation stack name of a backend environment. </p>
    public let stackName: String?
    /// <p> The last updated date and time for a backend environment that is part of an Amplify
    ///             app. </p>
    public let updateTime: Date?

    public init (
        backendEnvironmentArn: String? = nil,
        createTime: Date? = nil,
        deploymentArtifacts: String? = nil,
        environmentName: String? = nil,
        stackName: String? = nil,
        updateTime: Date? = nil
    )
    {
        self.backendEnvironmentArn = backendEnvironmentArn
        self.createTime = createTime
        self.deploymentArtifacts = deploymentArtifacts
        self.environmentName = environmentName
        self.stackName = stackName
        self.updateTime = updateTime
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> A request contains unexpected data. </p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Branch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeJobId
        case associatedResources
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchArn
        case branchName
        case buildSpec
        case createTime
        case customDomains
        case description
        case destinationBranch
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case sourceBranch
        case stage
        case tags
        case thumbnailUrl
        case totalNumberOfJobs
        case ttl
        case updateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeJobId = activeJobId {
            try encodeContainer.encode(activeJobId, forKey: .activeJobId)
        }
        if let associatedResources = associatedResources {
            var associatedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResources)
            for associatedresources0 in associatedResources {
                try associatedResourcesContainer.encode(associatedresources0)
            }
        }
        if let backendEnvironmentArn = backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let branchArn = branchArn {
            try encodeContainer.encode(branchArn, forKey: .branchArn)
        }
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let customDomains = customDomains {
            var customDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customDomains)
            for customdomains0 in customDomains {
                try customDomainsContainer.encode(customdomains0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationBranch = destinationBranch {
            try encodeContainer.encode(destinationBranch, forKey: .destinationBranch)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let sourceBranch = sourceBranch {
            try encodeContainer.encode(sourceBranch, forKey: .sourceBranch)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let thumbnailUrl = thumbnailUrl {
            try encodeContainer.encode(thumbnailUrl, forKey: .thumbnailUrl)
        }
        if let totalNumberOfJobs = totalNumberOfJobs {
            try encodeContainer.encode(totalNumberOfJobs, forKey: .totalNumberOfJobs)
        }
        if let ttl = ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchArn)
        branchArn = branchArnDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let stageDecoded = try containerValues.decodeIfPresent(Stage.self, forKey: .stage)
        stage = stageDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .customDomains)
        var customDomainsDecoded0:[String]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [String]()
            for string0 in customDomainsContainer {
                if let string0 = string0 {
                    customDomainsDecoded0?.append(string0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let frameworkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .framework)
        framework = frameworkDecoded
        let activeJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activeJobId)
        activeJobId = activeJobIdDecoded
        let totalNumberOfJobsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalNumberOfJobs)
        totalNumberOfJobs = totalNumberOfJobsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let thumbnailUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thumbnailUrl)
        thumbnailUrl = thumbnailUrlDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ttl)
        ttl = ttlDecoded
        let associatedResourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .associatedResources)
        var associatedResourcesDecoded0:[String]? = nil
        if let associatedResourcesContainer = associatedResourcesContainer {
            associatedResourcesDecoded0 = [String]()
            for string0 in associatedResourcesContainer {
                if let string0 = string0 {
                    associatedResourcesDecoded0?.append(string0)
                }
            }
        }
        associatedResources = associatedResourcesDecoded0
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let destinationBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationBranch)
        destinationBranch = destinationBranchDecoded
        let sourceBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBranch)
        sourceBranch = sourceBranchDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension Branch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Branch(activeJobId: \(String(describing: activeJobId)), associatedResources: \(String(describing: associatedResources)), backendEnvironmentArn: \(String(describing: backendEnvironmentArn)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), branchArn: \(String(describing: branchArn)), branchName: \(String(describing: branchName)), buildSpec: \(String(describing: buildSpec)), createTime: \(String(describing: createTime)), customDomains: \(String(describing: customDomains)), description: \(String(describing: description)), destinationBranch: \(String(describing: destinationBranch)), displayName: \(String(describing: displayName)), enableAutoBuild: \(String(describing: enableAutoBuild)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableNotification: \(String(describing: enableNotification)), enablePerformanceMode: \(String(describing: enablePerformanceMode)), enablePullRequestPreview: \(String(describing: enablePullRequestPreview)), environmentVariables: \(String(describing: environmentVariables)), framework: \(String(describing: framework)), pullRequestEnvironmentName: \(String(describing: pullRequestEnvironmentName)), sourceBranch: \(String(describing: sourceBranch)), stage: \(String(describing: stage)), tags: \(String(describing: tags)), thumbnailUrl: \(String(describing: thumbnailUrl)), totalNumberOfJobs: \(String(describing: totalNumberOfJobs)), ttl: \(String(describing: ttl)), updateTime: \(String(describing: updateTime)))"}
}

/// <p> The branch for an Amplify app, which maps to a third-party repository branch. </p>
public struct Branch: Equatable {
    /// <p> The ID of the active job for a branch of an Amplify app. </p>
    public let activeJobId: String?
    /// <p> A list of custom resources that are linked to this branch. </p>
    public let associatedResources: [String]?
    /// <p> The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify
    ///             app. </p>
    public let backendEnvironmentArn: String?
    /// <p> The basic authorization credentials for a branch of an Amplify app. </p>
    public let basicAuthCredentials: String?
    /// <p> The Amazon Resource Name (ARN) for a branch that is part of an Amplify app. </p>
    public let branchArn: String?
    /// <p> The name for the branch that is part of an Amplify app. </p>
    public let branchName: String?
    /// <p> The build specification (build spec) content for the branch of an Amplify app.
    ///         </p>
    public let buildSpec: String?
    /// <p> The creation date and time for a branch that is part of an Amplify app. </p>
    public let createTime: Date?
    /// <p> The custom domains for a branch of an Amplify app. </p>
    public let customDomains: [String]?
    /// <p> The description for the branch that is part of an Amplify app. </p>
    public let description: String?
    /// <p> The destination branch if the branch is a pull request branch. </p>
    public let destinationBranch: String?
    /// <p> The display name for the branch. This is used as the default domain prefix. </p>
    public let displayName: String?
    /// <p> Enables auto-building on push for a branch of an Amplify app. </p>
    public let enableAutoBuild: Bool?
    /// <p> Enables basic authorization for a branch of an Amplify app. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables notifications for a branch that is part of an Amplify app. </p>
    public let enableNotification: Bool?
    /// <p>Enables performance mode for the branch.</p>
    ///         <p>Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out. </p>
    public let enablePerformanceMode: Bool?
    /// <p> Enables pull request previews for the branch. </p>
    public let enablePullRequestPreview: Bool?
    /// <p> The environment variables specific to a branch of an Amplify app. </p>
    public let environmentVariables: [String:String]?
    /// <p> The framework for a branch of an Amplify app. </p>
    public let framework: String?
    /// <p> The Amplify environment name for the pull request. </p>
    public let pullRequestEnvironmentName: String?
    /// <p> The source branch if the branch is a pull request branch. </p>
    public let sourceBranch: String?
    /// <p> The current stage for the branch that is part of an Amplify app. </p>
    public let stage: Stage?
    /// <p> The tag for the branch of an Amplify app. </p>
    public let tags: [String:String]?
    /// <p> The thumbnail URL for the branch of an Amplify app. </p>
    public let thumbnailUrl: String?
    /// <p> The total number of jobs that are part of an Amplify app. </p>
    public let totalNumberOfJobs: String?
    /// <p> The content Time to Live (TTL) for the website in seconds. </p>
    public let ttl: String?
    /// <p> The last updated date and time for a branch that is part of an Amplify app. </p>
    public let updateTime: Date?

    public init (
        activeJobId: String? = nil,
        associatedResources: [String]? = nil,
        backendEnvironmentArn: String? = nil,
        basicAuthCredentials: String? = nil,
        branchArn: String? = nil,
        branchName: String? = nil,
        buildSpec: String? = nil,
        createTime: Date? = nil,
        customDomains: [String]? = nil,
        description: String? = nil,
        destinationBranch: String? = nil,
        displayName: String? = nil,
        enableAutoBuild: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableNotification: Bool? = nil,
        enablePerformanceMode: Bool? = nil,
        enablePullRequestPreview: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        framework: String? = nil,
        pullRequestEnvironmentName: String? = nil,
        sourceBranch: String? = nil,
        stage: Stage? = nil,
        tags: [String:String]? = nil,
        thumbnailUrl: String? = nil,
        totalNumberOfJobs: String? = nil,
        ttl: String? = nil,
        updateTime: Date? = nil
    )
    {
        self.activeJobId = activeJobId
        self.associatedResources = associatedResources
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchArn = branchArn
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.createTime = createTime
        self.customDomains = customDomains
        self.description = description
        self.destinationBranch = destinationBranch
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.sourceBranch = sourceBranch
        self.stage = stage
        self.tags = tags
        self.thumbnailUrl = thumbnailUrl
        self.totalNumberOfJobs = totalNumberOfJobs
        self.ttl = ttl
        self.updateTime = updateTime
    }
}

public struct CreateAppInputBodyMiddleware: Middleware {
    public let id: String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

extension CreateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppInput(accessToken: \(String(describing: accessToken)), autoBranchCreationConfig: \(String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(String(describing: autoBranchCreationPatterns)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), buildSpec: \(String(describing: buildSpec)), customHeaders: \(String(describing: customHeaders)), customRules: \(String(describing: customRules)), description: \(String(describing: description)), enableAutoBranchCreation: \(String(describing: enableAutoBranchCreation)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableBranchAutoBuild: \(String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(String(describing: enableBranchAutoDeletion)), environmentVariables: \(String(describing: environmentVariables)), iamServiceRoleArn: \(String(describing: iamServiceRoleArn)), name: \(String(describing: name)), oauthToken: \(String(describing: oauthToken)), platform: \(String(describing: platform)), repository: \(String(describing: repository)), tags: \(String(describing: tags)))"}
}

extension CreateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let autoBranchCreationConfig = autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpatterns0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpatterns0)
            }
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let customHeaders = customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrules0 in customRules {
                try customRulesContainer.encode(customrules0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oauthToken = oauthToken {
            try encodeContainer.encode(oauthToken, forKey: .oauthToken)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAppInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

/// <p> The request structure used to create apps in Amplify. </p>
public struct CreateAppInput: Equatable {
    /// <p> The personal access token for a third-party source control system for an Amplify app.
    ///             The personal access token is used to create a webhook and a read-only deploy key. The
    ///             token is not stored. </p>
    public let accessToken: String?
    /// <p> The automated branch creation configuration for an Amplify app. </p>
    public let autoBranchCreationConfig: AutoBranchCreationConfig?
    /// <p> The automated branch creation glob patterns for an Amplify app. </p>
    public let autoBranchCreationPatterns: [String]?
    /// <p> The credentials for basic authorization for an Amplify app. </p>
    public let basicAuthCredentials: String?
    /// <p> The build specification (build spec) for an Amplify app. </p>
    public let buildSpec: String?
    /// <p>The custom HTTP headers for an Amplify app.</p>
    public let customHeaders: String?
    /// <p> The custom rewrite and redirect rules for an Amplify app. </p>
    public let customRules: [CustomRule]?
    /// <p> The description for an Amplify app. </p>
    public let description: String?
    /// <p> Enables automated branch creation for an Amplify app. </p>
    public let enableAutoBranchCreation: Bool?
    /// <p> Enables basic authorization for an Amplify app. This will apply to all branches that
    ///             are part of this app. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables the auto building of branches for an Amplify app. </p>
    public let enableBranchAutoBuild: Bool?
    /// <p> Automatically disconnects a branch in the Amplify Console when you delete a branch
    ///             from your Git repository. </p>
    public let enableBranchAutoDeletion: Bool?
    /// <p> The environment variables map for an Amplify app. </p>
    public let environmentVariables: [String:String]?
    /// <p> The AWS Identity and Access Management (IAM) service role for an Amplify app. </p>
    public let iamServiceRoleArn: String?
    /// <p> The name for an Amplify app. </p>
    public let name: String?
    /// <p> The OAuth token for a third-party source control system for an Amplify app. The OAuth
    ///             token is used to create a webhook and a read-only deploy key. The OAuth token is not
    ///             stored. </p>
    public let oauthToken: String?
    /// <p> The platform or framework for an Amplify app. </p>
    public let platform: Platform?
    /// <p> The repository for an Amplify app. </p>
    public let repository: String?
    /// <p> The tag for an Amplify app. </p>
    public let tags: [String:String]?

    public init (
        accessToken: String? = nil,
        autoBranchCreationConfig: AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [String]? = nil,
        basicAuthCredentials: String? = nil,
        buildSpec: String? = nil,
        customHeaders: String? = nil,
        customRules: [CustomRule]? = nil,
        description: String? = nil,
        enableAutoBranchCreation: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableBranchAutoBuild: Bool? = nil,
        enableBranchAutoDeletion: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        iamServiceRoleArn: String? = nil,
        name: String? = nil,
        oauthToken: String? = nil,
        platform: Platform? = nil,
        repository: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessToken = accessToken
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
        self.tags = tags
    }
}

struct CreateAppInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let repository: String?
    public let platform: Platform?
    public let iamServiceRoleArn: String?
    public let oauthToken: String?
    public let accessToken: String?
    public let environmentVariables: [String:String]?
    public let enableBranchAutoBuild: Bool?
    public let enableBranchAutoDeletion: Bool?
    public let enableBasicAuth: Bool?
    public let basicAuthCredentials: String?
    public let customRules: [CustomRule]?
    public let tags: [String:String]?
    public let buildSpec: String?
    public let customHeaders: String?
    public let enableAutoBranchCreation: Bool?
    public let autoBranchCreationPatterns: [String]?
    public let autoBranchCreationConfig: AutoBranchCreationConfig?
}

extension CreateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repository)
        repository = repositoryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let oauthTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oauthToken)
        oauthToken = oauthTokenDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
    }
}

extension CreateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppOutputResponse(app: \(String(describing: app)))"}
}

extension CreateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct CreateAppOutputResponse: Equatable {
    /// <p> Represents the different branches of a repository for building, deploying, and
    ///             hosting an Amplify app. </p>
    public let app: App?

    public init (
        app: App? = nil
    )
    {
        self.app = app
    }
}

struct CreateAppOutputResponseBody: Equatable {
    public let app: App?
}

extension CreateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case app
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(App.self, forKey: .app)
        app = appDecoded
    }
}

public struct CreateBackendEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackendEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendEnvironmentOutputError>
}

extension CreateBackendEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendEnvironmentInput(appId: \(String(describing: appId)), deploymentArtifacts: \(String(describing: deploymentArtifacts)), environmentName: \(String(describing: environmentName)), stackName: \(String(describing: stackName)))"}
}

extension CreateBackendEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentArtifacts
        case environmentName
        case stackName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentArtifacts = deploymentArtifacts {
            try encodeContainer.encode(deploymentArtifacts, forKey: .deploymentArtifacts)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

public struct CreateBackendEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackendEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendEnvironmentOutputError>
}

public struct CreateBackendEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackendEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackendEnvironmentOutputError>
}

/// <p> The request structure for the backend environment create request. </p>
public struct CreateBackendEnvironmentInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of deployment artifacts. </p>
    public let deploymentArtifacts: String?
    /// <p> The name for the backend environment. </p>
    public let environmentName: String?
    /// <p> The AWS CloudFormation stack name of a backend environment. </p>
    public let stackName: String?

    public init (
        appId: String? = nil,
        deploymentArtifacts: String? = nil,
        environmentName: String? = nil,
        stackName: String? = nil
    )
    {
        self.appId = appId
        self.deploymentArtifacts = deploymentArtifacts
        self.environmentName = environmentName
        self.stackName = stackName
    }
}

struct CreateBackendEnvironmentInputBody: Equatable {
    public let environmentName: String?
    public let stackName: String?
    public let deploymentArtifacts: String?
}

extension CreateBackendEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentArtifacts
        case environmentName
        case stackName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let deploymentArtifactsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentArtifacts)
        deploymentArtifacts = deploymentArtifactsDecoded
    }
}

extension CreateBackendEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendEnvironmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackendEnvironmentOutputResponse(backendEnvironment: \(String(describing: backendEnvironment)))"}
}

extension CreateBackendEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackendEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// <p> The result structure for the create backend environment request. </p>
public struct CreateBackendEnvironmentOutputResponse: Equatable {
    /// <p> Describes the backend environment for an Amplify app. </p>
    public let backendEnvironment: BackendEnvironment?

    public init (
        backendEnvironment: BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct CreateBackendEnvironmentOutputResponseBody: Equatable {
    public let backendEnvironment: BackendEnvironment?
}

extension CreateBackendEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

public struct CreateBranchInputBodyMiddleware: Middleware {
    public let id: String = "CreateBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

extension CreateBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBranchInput(appId: \(String(describing: appId)), backendEnvironmentArn: \(String(describing: backendEnvironmentArn)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), branchName: \(String(describing: branchName)), buildSpec: \(String(describing: buildSpec)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), enableAutoBuild: \(String(describing: enableAutoBuild)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableNotification: \(String(describing: enableNotification)), enablePerformanceMode: \(String(describing: enablePerformanceMode)), enablePullRequestPreview: \(String(describing: enablePullRequestPreview)), environmentVariables: \(String(describing: environmentVariables)), framework: \(String(describing: framework)), pullRequestEnvironmentName: \(String(describing: pullRequestEnvironmentName)), stage: \(String(describing: stage)), tags: \(String(describing: tags)), ttl: \(String(describing: ttl)))"}
}

extension CreateBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchName
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case tags
        case ttl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ttl = ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

public struct CreateBranchInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

public struct CreateBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

/// <p> The request structure for the create branch request. </p>
public struct CreateBranchInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify
    ///             app. </p>
    public let backendEnvironmentArn: String?
    /// <p> The basic authorization credentials for the branch. </p>
    public let basicAuthCredentials: String?
    /// <p> The name for the branch. </p>
    public let branchName: String?
    /// <p> The build specification (build spec) for the branch. </p>
    public let buildSpec: String?
    /// <p> The description for the branch. </p>
    public let description: String?
    /// <p> The display name for a branch. This is used as the default domain prefix. </p>
    public let displayName: String?
    /// <p> Enables auto building for the branch. </p>
    public let enableAutoBuild: Bool?
    /// <p> Enables basic authorization for the branch. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables notifications for the branch. </p>
    public let enableNotification: Bool?
    /// <p>Enables performance mode for the branch.</p>
    ///         <p>Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out. </p>
    public let enablePerformanceMode: Bool?
    /// <p> Enables pull request previews for this branch. </p>
    public let enablePullRequestPreview: Bool?
    /// <p> The environment variables for the branch. </p>
    public let environmentVariables: [String:String]?
    /// <p> The framework for the branch. </p>
    public let framework: String?
    /// <p> The Amplify environment name for the pull request. </p>
    public let pullRequestEnvironmentName: String?
    /// <p> Describes the current stage for the branch. </p>
    public let stage: Stage?
    /// <p> The tag for the branch. </p>
    public let tags: [String:String]?
    /// <p> The content Time To Live (TTL) for the website in seconds. </p>
    public let ttl: String?

    public init (
        appId: String? = nil,
        backendEnvironmentArn: String? = nil,
        basicAuthCredentials: String? = nil,
        branchName: String? = nil,
        buildSpec: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        enableAutoBuild: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableNotification: Bool? = nil,
        enablePerformanceMode: Bool? = nil,
        enablePullRequestPreview: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        framework: String? = nil,
        pullRequestEnvironmentName: String? = nil,
        stage: Stage? = nil,
        tags: [String:String]? = nil,
        ttl: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.tags = tags
        self.ttl = ttl
    }
}

struct CreateBranchInputBody: Equatable {
    public let branchName: String?
    public let description: String?
    public let stage: Stage?
    public let framework: String?
    public let enableNotification: Bool?
    public let enableAutoBuild: Bool?
    public let environmentVariables: [String:String]?
    public let basicAuthCredentials: String?
    public let enableBasicAuth: Bool?
    public let enablePerformanceMode: Bool?
    public let tags: [String:String]?
    public let buildSpec: String?
    public let ttl: String?
    public let displayName: String?
    public let enablePullRequestPreview: Bool?
    public let pullRequestEnvironmentName: String?
    public let backendEnvironmentArn: String?
}

extension CreateBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchName
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case tags
        case ttl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Stage.self, forKey: .stage)
        stage = stageDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .framework)
        framework = frameworkDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ttl)
        ttl = ttlDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension CreateBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBranchOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBranchOutputResponse(branch: \(String(describing: branch)))"}
}

extension CreateBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// <p> The result structure for create branch request. </p>
public struct CreateBranchOutputResponse: Equatable {
    /// <p> Describes the branch for an Amplify app, which maps to a third-party repository
    ///             branch. </p>
    public let branch: Branch?

    public init (
        branch: Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct CreateBranchOutputResponseBody: Equatable {
    public let branch: Branch?
}

extension CreateBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

public struct CreateDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

extension CreateDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), fileMap: \(String(describing: fileMap)))"}
}

extension CreateDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileMap
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMap = fileMap {
            var fileMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .fileMap)
            for (dictKey0, filemap0) in fileMap {
                try fileMapContainer.encode(filemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

public struct CreateDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentInput>
    public typealias MOutput = OperationOutput<CreateDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentOutputError>
}

/// <p> The request structure for the create a new deployment request. </p>
public struct CreateDeploymentInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch, for the job. </p>
    public let branchName: String?
    /// <p> An optional file map that contains the file name as the key and the file content md5
    ///             hash as the value. If this argument is provided, the service will generate a unique
    ///             upload URL per file. Otherwise, the service will only generate a single upload URL for
    ///             the zipped files. </p>
    public let fileMap: [String:String]?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        fileMap: [String:String]? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.fileMap = fileMap
    }
}

struct CreateDeploymentInputBody: Equatable {
    public let fileMap: [String:String]?
}

extension CreateDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileMap
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .fileMap)
        var fileMapDecoded0: [String:String]? = nil
        if let fileMapContainer = fileMapContainer {
            fileMapDecoded0 = [String:String]()
            for (key0, md5hash0) in fileMapContainer {
                if let md5hash0 = md5hash0 {
                    fileMapDecoded0?[key0] = md5hash0
                }
            }
        }
        fileMap = fileMapDecoded0
    }
}

extension CreateDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentOutputResponse(fileUploadUrls: \(String(describing: fileUploadUrls)), jobId: \(String(describing: jobId)), zipUploadUrl: \(String(describing: zipUploadUrl)))"}
}

extension CreateDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fileUploadUrls = output.fileUploadUrls
            self.jobId = output.jobId
            self.zipUploadUrl = output.zipUploadUrl
        } else {
            self.fileUploadUrls = nil
            self.jobId = nil
            self.zipUploadUrl = nil
        }
    }
}

/// <p> The result structure for the create a new deployment request. </p>
public struct CreateDeploymentOutputResponse: Equatable {
    /// <p> When the <code>fileMap</code> argument is provided in the request,
    ///                 <code>fileUploadUrls</code> will contain a map of file names to upload URLs. </p>
    public let fileUploadUrls: [String:String]?
    /// <p> The job ID for this deployment. will supply to start deployment api. </p>
    public let jobId: String?
    /// <p> When the <code>fileMap</code> argument is not provided in the request, this
    ///                 <code>zipUploadUrl</code> is returned. </p>
    public let zipUploadUrl: String?

    public init (
        fileUploadUrls: [String:String]? = nil,
        jobId: String? = nil,
        zipUploadUrl: String? = nil
    )
    {
        self.fileUploadUrls = fileUploadUrls
        self.jobId = jobId
        self.zipUploadUrl = zipUploadUrl
    }
}

struct CreateDeploymentOutputResponseBody: Equatable {
    public let jobId: String?
    public let fileUploadUrls: [String:String]?
    public let zipUploadUrl: String?
}

extension CreateDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fileUploadUrls
        case jobId
        case zipUploadUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let fileUploadUrlsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .fileUploadUrls)
        var fileUploadUrlsDecoded0: [String:String]? = nil
        if let fileUploadUrlsContainer = fileUploadUrlsContainer {
            fileUploadUrlsDecoded0 = [String:String]()
            for (key0, uploadurl0) in fileUploadUrlsContainer {
                if let uploadurl0 = uploadurl0 {
                    fileUploadUrlsDecoded0?[key0] = uploadurl0
                }
            }
        }
        fileUploadUrls = fileUploadUrlsDecoded0
        let zipUploadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zipUploadUrl)
        zipUploadUrl = zipUploadUrlDecoded
    }
}

public struct CreateDomainAssociationInputBodyMiddleware: Middleware {
    public let id: String = "CreateDomainAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainAssociationInput>
    public typealias MOutput = OperationOutput<CreateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainAssociationOutputError>
}

extension CreateDomainAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainAssociationInput(appId: \(String(describing: appId)), autoSubDomainCreationPatterns: \(String(describing: autoSubDomainCreationPatterns)), autoSubDomainIAMRole: \(String(describing: autoSubDomainIAMRole)), domainName: \(String(describing: domainName)), enableAutoSubDomain: \(String(describing: enableAutoSubDomain)), subDomainSettings: \(String(describing: subDomainSettings)))"}
}

extension CreateDomainAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case domainName
        case enableAutoSubDomain
        case subDomainSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpatterns0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpatterns0)
            }
        }
        if let autoSubDomainIAMRole = autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableAutoSubDomain = enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let subDomainSettings = subDomainSettings {
            var subDomainSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomainSettings)
            for subdomainsettings0 in subDomainSettings {
                try subDomainSettingsContainer.encode(subdomainsettings0)
            }
        }
    }
}

public struct CreateDomainAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDomainAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainAssociationInput>
    public typealias MOutput = OperationOutput<CreateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainAssociationOutputError>
}

public struct CreateDomainAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDomainAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDomainAssociationInput>
    public typealias MOutput = OperationOutput<CreateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDomainAssociationOutputError>
}

/// <p> The request structure for the create domain association request. </p>
public struct CreateDomainAssociationInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> Sets the branch patterns for automatic subdomain creation. </p>
    public let autoSubDomainCreationPatterns: [String]?
    /// <p> The required AWS Identity and Access Management (IAM) service role for the Amazon
    ///             Resource Name (ARN) for automatically creating subdomains. </p>
    public let autoSubDomainIAMRole: String?
    /// <p> The domain name for the domain association. </p>
    public let domainName: String?
    /// <p> Enables the automated creation of subdomains for branches. </p>
    public let enableAutoSubDomain: Bool?
    /// <p> The setting for the subdomain. </p>
    public let subDomainSettings: [SubDomainSetting]?

    public init (
        appId: String? = nil,
        autoSubDomainCreationPatterns: [String]? = nil,
        autoSubDomainIAMRole: String? = nil,
        domainName: String? = nil,
        enableAutoSubDomain: Bool? = nil,
        subDomainSettings: [SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

struct CreateDomainAssociationInputBody: Equatable {
    public let domainName: String?
    public let enableAutoSubDomain: Bool?
    public let subDomainSettings: [SubDomainSetting]?
    public let autoSubDomainCreationPatterns: [String]?
    public let autoSubDomainIAMRole: String?
}

extension CreateDomainAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case domainName
        case enableAutoSubDomain
        case subDomainSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let subDomainSettingsContainer = try containerValues.decodeIfPresent([SubDomainSetting?].self, forKey: .subDomainSettings)
        var subDomainSettingsDecoded0:[SubDomainSetting]? = nil
        if let subDomainSettingsContainer = subDomainSettingsContainer {
            subDomainSettingsDecoded0 = [SubDomainSetting]()
            for structure0 in subDomainSettingsContainer {
                if let structure0 = structure0 {
                    subDomainSettingsDecoded0?.append(structure0)
                }
            }
        }
        subDomainSettings = subDomainSettingsDecoded0
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
    }
}

extension CreateDomainAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainAssociationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDomainAssociationOutputResponse(domainAssociation: \(String(describing: domainAssociation)))"}
}

extension CreateDomainAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDomainAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// <p> The result structure for the create domain association request. </p>
public struct CreateDomainAssociationOutputResponse: Equatable {
    /// <p> Describes the structure of a domain association, which associates a custom domain
    ///             with an Amplify app. </p>
    public let domainAssociation: DomainAssociation?

    public init (
        domainAssociation: DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct CreateDomainAssociationOutputResponseBody: Equatable {
    public let domainAssociation: DomainAssociation?
}

extension CreateDomainAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

public struct CreateWebhookInputBodyMiddleware: Middleware {
    public let id: String = "CreateWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

extension CreateWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebhookInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), description: \(String(describing: description)))"}
}

extension CreateWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct CreateWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

public struct CreateWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebhookInput>
    public typealias MOutput = OperationOutput<CreateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebhookOutputError>
}

/// <p> The request structure for the create webhook request. </p>
public struct CreateWebhookInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for a branch that is part of an Amplify app. </p>
    public let branchName: String?
    /// <p> The description for a webhook. </p>
    public let description: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        description: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.description = description
    }
}

struct CreateWebhookInputBody: Equatable {
    public let branchName: String?
    public let description: String?
}

extension CreateWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebhookOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension CreateWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// <p> The result structure for the create webhook request. </p>
public struct CreateWebhookOutputResponse: Equatable {
    /// <p> Describes a webhook that connects repository events to an Amplify app. </p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct CreateWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension CreateWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension CustomRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition
        case source
        case status
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension CustomRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomRule(condition: \(String(describing: condition)), source: \(String(describing: source)), status: \(String(describing: status)), target: \(String(describing: target)))"}
}

/// <p> Describes a custom rewrite or redirect rule. </p>
public struct CustomRule: Equatable {
    /// <p> The condition for a URL rewrite or redirect rule, such as a country code. </p>
    public let condition: String?
    /// <p> The source pattern for a URL rewrite or redirect rule. </p>
    public let source: String?
    /// <p> The status code for a URL rewrite or redirect rule. </p>
    ///
    ///         <dl>
    ///             <dt>200</dt>
    ///             <dd>
    ///                     <p>Represents a 200 rewrite rule.</p>
    ///                 </dd>
    ///             <dt>301</dt>
    ///             <dd>
    ///                     <p>Represents a 301 (moved pemanently) redirect rule. This and all future requests should be directed to the target URL. </p>
    ///                 </dd>
    ///             <dt>302</dt>
    ///             <dd>
    ///                     <p>Represents a 302 temporary redirect rule.</p>
    ///                 </dd>
    ///             <dt>404</dt>
    ///             <dd>
    ///                     <p>Represents a 404 redirect rule.</p>
    ///                 </dd>
    ///             <dt>404-200</dt>
    ///             <dd>
    ///                     <p>Represents a 404 rewrite rule.</p>
    ///                 </dd>
    ///          </dl>
    public let status: String?
    /// <p> The target pattern for a URL rewrite or redirect rule. </p>
    public let target: String?

    public init (
        condition: String? = nil,
        source: String? = nil,
        status: String? = nil,
        target: String? = nil
    )
    {
        self.condition = condition
        self.source = source
        self.status = status
        self.target = target
    }
}

extension DeleteAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppInput(appId: \(String(describing: appId)))"}
}

extension DeleteAppInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAppInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

/// <p> Describes the request structure for the delete app request. </p>
public struct DeleteAppInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppInputBody: Equatable {
}

extension DeleteAppInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppOutputResponse(app: \(String(describing: app)))"}
}

extension DeleteAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

/// <p> The result structure for the delete app request. </p>
public struct DeleteAppOutputResponse: Equatable {
    /// <p> Represents the different branches of a repository for building, deploying, and
    ///             hosting an Amplify app. </p>
    public let app: App?

    public init (
        app: App? = nil
    )
    {
        self.app = app
    }
}

struct DeleteAppOutputResponseBody: Equatable {
    public let app: App?
}

extension DeleteAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case app
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(App.self, forKey: .app)
        app = appDecoded
    }
}

extension DeleteBackendEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendEnvironmentInput(appId: \(String(describing: appId)), environmentName: \(String(describing: environmentName)))"}
}

extension DeleteBackendEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBackendEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackendEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendEnvironmentOutputError>
}

public struct DeleteBackendEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackendEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackendEnvironmentOutputError>
}

/// <p> The request structure for the delete backend environment request. </p>
public struct DeleteBackendEnvironmentInput: Equatable {
    /// <p> The unique ID of an Amplify app. </p>
    public let appId: String?
    /// <p> The name of a backend environment of an Amplify app. </p>
    public let environmentName: String?

    public init (
        appId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct DeleteBackendEnvironmentInputBody: Equatable {
}

extension DeleteBackendEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBackendEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendEnvironmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackendEnvironmentOutputResponse(backendEnvironment: \(String(describing: backendEnvironment)))"}
}

extension DeleteBackendEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBackendEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// <p> The result structure of the delete backend environment result. </p>
public struct DeleteBackendEnvironmentOutputResponse: Equatable {
    /// <p> Describes the backend environment for an Amplify app. </p>
    public let backendEnvironment: BackendEnvironment?

    public init (
        backendEnvironment: BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct DeleteBackendEnvironmentOutputResponseBody: Equatable {
    public let backendEnvironment: BackendEnvironment?
}

extension DeleteBackendEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

extension DeleteBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBranchInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)))"}
}

extension DeleteBranchInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBranchInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBranchInput>
    public typealias MOutput = OperationOutput<DeleteBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBranchOutputError>
}

public struct DeleteBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBranchInput>
    public typealias MOutput = OperationOutput<DeleteBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBranchOutputError>
}

/// <p> The request structure for the delete branch request. </p>
public struct DeleteBranchInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch. </p>
    public let branchName: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

struct DeleteBranchInputBody: Equatable {
}

extension DeleteBranchInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBranchOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBranchOutputResponse(branch: \(String(describing: branch)))"}
}

extension DeleteBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// <p> The result structure for the delete branch request. </p>
public struct DeleteBranchOutputResponse: Equatable {
    /// <p> The branch for an Amplify app, which maps to a third-party repository branch. </p>
    public let branch: Branch?

    public init (
        branch: Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct DeleteBranchOutputResponseBody: Equatable {
    public let branch: Branch?
}

extension DeleteBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension DeleteDomainAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainAssociationInput(appId: \(String(describing: appId)), domainName: \(String(describing: domainName)))"}
}

extension DeleteDomainAssociationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDomainAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDomainAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainAssociationInput>
    public typealias MOutput = OperationOutput<DeleteDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainAssociationOutputError>
}

public struct DeleteDomainAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDomainAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDomainAssociationInput>
    public typealias MOutput = OperationOutput<DeleteDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDomainAssociationOutputError>
}

/// <p> The request structure for the delete domain association request. </p>
public struct DeleteDomainAssociationInput: Equatable {
    /// <p> The unique id for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of the domain. </p>
    public let domainName: String?

    public init (
        appId: String? = nil,
        domainName: String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

struct DeleteDomainAssociationInputBody: Equatable {
}

extension DeleteDomainAssociationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDomainAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainAssociationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDomainAssociationOutputResponse(domainAssociation: \(String(describing: domainAssociation)))"}
}

extension DeleteDomainAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDomainAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

public struct DeleteDomainAssociationOutputResponse: Equatable {
    /// <p> Describes a domain association that associates a custom domain with an Amplify app.
    ///         </p>
    public let domainAssociation: DomainAssociation?

    public init (
        domainAssociation: DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct DeleteDomainAssociationOutputResponseBody: Equatable {
    public let domainAssociation: DomainAssociation?
}

extension DeleteDomainAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

extension DeleteJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), jobId: \(String(describing: jobId)))"}
}

extension DeleteJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

public struct DeleteJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJobInput>
    public typealias MOutput = OperationOutput<DeleteJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJobOutputError>
}

/// <p> The request structure for the delete job request. </p>
public struct DeleteJobInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch, for the job. </p>
    public let branchName: String?
    /// <p> The unique ID for the job. </p>
    public let jobId: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        jobId: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct DeleteJobInputBody: Equatable {
}

extension DeleteJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJobOutputResponse(jobSummary: \(String(describing: jobSummary)))"}
}

extension DeleteJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// <p> The result structure for the delete job request. </p>
public struct DeleteJobOutputResponse: Equatable {
    /// <p> Describes the summary for an execution job for an Amplify app. </p>
    public let jobSummary: JobSummary?

    public init (
        jobSummary: JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct DeleteJobOutputResponseBody: Equatable {
    public let jobSummary: JobSummary?
}

extension DeleteJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobSummary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

extension DeleteWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookInput(webhookId: \(String(describing: webhookId)))"}
}

extension DeleteWebhookInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

/// <p> The request structure for the delete webhook request. </p>
public struct DeleteWebhookInput: Equatable {
    /// <p> The unique ID for a webhook. </p>
    public let webhookId: String?

    public init (
        webhookId: String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

struct DeleteWebhookInputBody: Equatable {
}

extension DeleteWebhookInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebhookOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension DeleteWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// <p> The result structure for the delete webhook request. </p>
public struct DeleteWebhookOutputResponse: Equatable {
    /// <p> Describes a webhook that connects repository events to an Amplify app. </p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct DeleteWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension DeleteWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension DependentServiceFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DependentServiceFailureException(message: \(String(describing: message)))"}
}

extension DependentServiceFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DependentServiceFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> An operation failed because a dependent service threw an exception. </p>
public struct DependentServiceFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DependentServiceFailureExceptionBody: Equatable {
    public let message: String?
}

extension DependentServiceFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DomainAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case certificateVerificationDNSRecord
        case domainAssociationArn
        case domainName
        case domainStatus
        case enableAutoSubDomain
        case statusReason
        case subDomains
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpatterns0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpatterns0)
            }
        }
        if let autoSubDomainIAMRole = autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let certificateVerificationDNSRecord = certificateVerificationDNSRecord {
            try encodeContainer.encode(certificateVerificationDNSRecord, forKey: .certificateVerificationDNSRecord)
        }
        if let domainAssociationArn = domainAssociationArn {
            try encodeContainer.encode(domainAssociationArn, forKey: .domainAssociationArn)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let enableAutoSubDomain = enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subDomains = subDomains {
            var subDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomains)
            for subdomains0 in subDomains {
                try subDomainsContainer.encode(subdomains0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainAssociationArn)
        domainAssociationArn = domainAssociationArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let certificateVerificationDNSRecordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateVerificationDNSRecord)
        certificateVerificationDNSRecord = certificateVerificationDNSRecordDecoded
        let subDomainsContainer = try containerValues.decodeIfPresent([SubDomain?].self, forKey: .subDomains)
        var subDomainsDecoded0:[SubDomain]? = nil
        if let subDomainsContainer = subDomainsContainer {
            subDomainsDecoded0 = [SubDomain]()
            for structure0 in subDomainsContainer {
                if let structure0 = structure0 {
                    subDomainsDecoded0?.append(structure0)
                }
            }
        }
        subDomains = subDomainsDecoded0
    }
}

extension DomainAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainAssociation(autoSubDomainCreationPatterns: \(String(describing: autoSubDomainCreationPatterns)), autoSubDomainIAMRole: \(String(describing: autoSubDomainIAMRole)), certificateVerificationDNSRecord: \(String(describing: certificateVerificationDNSRecord)), domainAssociationArn: \(String(describing: domainAssociationArn)), domainName: \(String(describing: domainName)), domainStatus: \(String(describing: domainStatus)), enableAutoSubDomain: \(String(describing: enableAutoSubDomain)), statusReason: \(String(describing: statusReason)), subDomains: \(String(describing: subDomains)))"}
}

/// <p> Describes a domain association that associates a custom domain with an Amplify app.
///         </p>
public struct DomainAssociation: Equatable {
    /// <p> Sets branch patterns for automatic subdomain creation. </p>
    public let autoSubDomainCreationPatterns: [String]?
    /// <p> The required AWS Identity and Access Management (IAM) service role for the Amazon
    ///             Resource Name (ARN) for automatically creating subdomains. </p>
    public let autoSubDomainIAMRole: String?
    /// <p> The DNS record for certificate verification. </p>
    public let certificateVerificationDNSRecord: String?
    /// <p> The Amazon Resource Name (ARN) for the domain association. </p>
    public let domainAssociationArn: String?
    /// <p> The name of the domain. </p>
    public let domainName: String?
    /// <p> The current status of the domain association. </p>
    public let domainStatus: DomainStatus?
    /// <p> Enables the automated creation of subdomains for branches. </p>
    public let enableAutoSubDomain: Bool?
    /// <p> The reason for the current status of the domain association. </p>
    public let statusReason: String?
    /// <p> The subdomains for the domain association. </p>
    public let subDomains: [SubDomain]?

    public init (
        autoSubDomainCreationPatterns: [String]? = nil,
        autoSubDomainIAMRole: String? = nil,
        certificateVerificationDNSRecord: String? = nil,
        domainAssociationArn: String? = nil,
        domainName: String? = nil,
        domainStatus: DomainStatus? = nil,
        enableAutoSubDomain: Bool? = nil,
        statusReason: String? = nil,
        subDomains: [SubDomain]? = nil
    )
    {
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
        self.domainAssociationArn = domainAssociationArn
        self.domainName = domainName
        self.domainStatus = domainStatus
        self.enableAutoSubDomain = enableAutoSubDomain
        self.statusReason = statusReason
        self.subDomains = subDomains
    }
}

public enum DomainStatus {
    case available
    case creating
    case failed
    case inProgress
    case pendingDeployment
    case pendingVerification
    case requestingCertificate
    case updating
    case sdkUnknown(String)
}

extension DomainStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainStatus] {
        return [
            .available,
            .creating,
            .failed,
            .inProgress,
            .pendingDeployment,
            .pendingVerification,
            .requestingCertificate,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .pendingDeployment: return "PENDING_DEPLOYMENT"
        case .pendingVerification: return "PENDING_VERIFICATION"
        case .requestingCertificate: return "REQUESTING_CERTIFICATE"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
    }
}

public struct GenerateAccessLogsInputBodyMiddleware: Middleware {
    public let id: String = "GenerateAccessLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateAccessLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateAccessLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateAccessLogsInput>
    public typealias MOutput = OperationOutput<GenerateAccessLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateAccessLogsOutputError>
}

extension GenerateAccessLogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateAccessLogsInput(appId: \(String(describing: appId)), domainName: \(String(describing: domainName)), endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

extension GenerateAccessLogsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName
        case endTime
        case startTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GenerateAccessLogsInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateAccessLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateAccessLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateAccessLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateAccessLogsInput>
    public typealias MOutput = OperationOutput<GenerateAccessLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateAccessLogsOutputError>
}

public struct GenerateAccessLogsInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateAccessLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateAccessLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateAccessLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateAccessLogsInput>
    public typealias MOutput = OperationOutput<GenerateAccessLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateAccessLogsOutputError>
}

/// <p> The request structure for the generate access logs request. </p>
public struct GenerateAccessLogsInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of the domain. </p>
    public let domainName: String?
    /// <p> The time at which the logs should end. The time range specified is inclusive of the
    ///             end time. </p>
    public let endTime: Date?
    /// <p> The time at which the logs should start. The time range specified is inclusive of the
    ///             start time. </p>
    public let startTime: Date?

    public init (
        appId: String? = nil,
        domainName: String? = nil,
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
        self.endTime = endTime
        self.startTime = startTime
    }
}

struct GenerateAccessLogsInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let domainName: String?
}

extension GenerateAccessLogsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName
        case endTime
        case startTime
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension GenerateAccessLogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateAccessLogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateAccessLogsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateAccessLogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateAccessLogsOutputResponse(logUrl: \(String(describing: logUrl)))"}
}

extension GenerateAccessLogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateAccessLogsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logUrl = output.logUrl
        } else {
            self.logUrl = nil
        }
    }
}

/// <p> The result structure for the generate access logs request. </p>
public struct GenerateAccessLogsOutputResponse: Equatable {
    /// <p> The pre-signed URL for the requested access logs. </p>
    public let logUrl: String?

    public init (
        logUrl: String? = nil
    )
    {
        self.logUrl = logUrl
    }
}

struct GenerateAccessLogsOutputResponseBody: Equatable {
    public let logUrl: String?
}

extension GenerateAccessLogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
    }
}

extension GetAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppInput(appId: \(String(describing: appId)))"}
}

extension GetAppInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAppInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

public struct GetAppInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

/// <p> The request structure for the get app request. </p>
public struct GetAppInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppInputBody: Equatable {
}

extension GetAppInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppOutputResponse(app: \(String(describing: app)))"}
}

extension GetAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct GetAppOutputResponse: Equatable {
    /// <p> Represents the different branches of a repository for building, deploying, and
    ///             hosting an Amplify app. </p>
    public let app: App?

    public init (
        app: App? = nil
    )
    {
        self.app = app
    }
}

struct GetAppOutputResponseBody: Equatable {
    public let app: App?
}

extension GetAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case app
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(App.self, forKey: .app)
        app = appDecoded
    }
}

extension GetArtifactUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetArtifactUrlInput(artifactId: \(String(describing: artifactId)))"}
}

extension GetArtifactUrlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetArtifactUrlInputHeadersMiddleware: Middleware {
    public let id: String = "GetArtifactUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetArtifactUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetArtifactUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetArtifactUrlInput>
    public typealias MOutput = OperationOutput<GetArtifactUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetArtifactUrlOutputError>
}

public struct GetArtifactUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetArtifactUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetArtifactUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetArtifactUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetArtifactUrlInput>
    public typealias MOutput = OperationOutput<GetArtifactUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetArtifactUrlOutputError>
}

/// <p> Returns the request structure for the get artifact request. </p>
public struct GetArtifactUrlInput: Equatable {
    /// <p> The unique ID for an artifact. </p>
    public let artifactId: String?

    public init (
        artifactId: String? = nil
    )
    {
        self.artifactId = artifactId
    }
}

struct GetArtifactUrlInputBody: Equatable {
}

extension GetArtifactUrlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetArtifactUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArtifactUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetArtifactUrlOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArtifactUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetArtifactUrlOutputResponse(artifactId: \(String(describing: artifactId)), artifactUrl: \(String(describing: artifactUrl)))"}
}

extension GetArtifactUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetArtifactUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.artifactId = output.artifactId
            self.artifactUrl = output.artifactUrl
        } else {
            self.artifactId = nil
            self.artifactUrl = nil
        }
    }
}

/// <p> Returns the result structure for the get artifact request. </p>
public struct GetArtifactUrlOutputResponse: Equatable {
    /// <p> The unique ID for an artifact. </p>
    public let artifactId: String?
    /// <p> The presigned URL for the artifact. </p>
    public let artifactUrl: String?

    public init (
        artifactId: String? = nil,
        artifactUrl: String? = nil
    )
    {
        self.artifactId = artifactId
        self.artifactUrl = artifactUrl
    }
}

struct GetArtifactUrlOutputResponseBody: Equatable {
    public let artifactId: String?
    public let artifactUrl: String?
}

extension GetArtifactUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifactId
        case artifactUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactId)
        artifactId = artifactIdDecoded
        let artifactUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactUrl)
        artifactUrl = artifactUrlDecoded
    }
}

extension GetBackendEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendEnvironmentInput(appId: \(String(describing: appId)), environmentName: \(String(describing: environmentName)))"}
}

extension GetBackendEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBackendEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetBackendEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<GetBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendEnvironmentOutputError>
}

public struct GetBackendEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBackendEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBackendEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBackendEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBackendEnvironmentInput>
    public typealias MOutput = OperationOutput<GetBackendEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBackendEnvironmentOutputError>
}

/// <p> The request structure for the get backend environment request. </p>
public struct GetBackendEnvironmentInput: Equatable {
    /// <p> The unique id for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the backend environment. </p>
    public let environmentName: String?

    public init (
        appId: String? = nil,
        environmentName: String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct GetBackendEnvironmentInputBody: Equatable {
}

extension GetBackendEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBackendEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendEnvironmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBackendEnvironmentOutputResponse(backendEnvironment: \(String(describing: backendEnvironment)))"}
}

extension GetBackendEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBackendEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backendEnvironment = output.backendEnvironment
        } else {
            self.backendEnvironment = nil
        }
    }
}

/// <p> The result structure for the get backend environment result. </p>
public struct GetBackendEnvironmentOutputResponse: Equatable {
    /// <p> Describes the backend environment for an Amplify app. </p>
    public let backendEnvironment: BackendEnvironment?

    public init (
        backendEnvironment: BackendEnvironment? = nil
    )
    {
        self.backendEnvironment = backendEnvironment
    }
}

struct GetBackendEnvironmentOutputResponseBody: Equatable {
    public let backendEnvironment: BackendEnvironment?
}

extension GetBackendEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentDecoded = try containerValues.decodeIfPresent(BackendEnvironment.self, forKey: .backendEnvironment)
        backendEnvironment = backendEnvironmentDecoded
    }
}

extension GetBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBranchInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)))"}
}

extension GetBranchInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBranchInputHeadersMiddleware: Middleware {
    public let id: String = "GetBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBranchInput>
    public typealias MOutput = OperationOutput<GetBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBranchOutputError>
}

public struct GetBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBranchInput>
    public typealias MOutput = OperationOutput<GetBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBranchOutputError>
}

/// <p> The request structure for the get branch request. </p>
public struct GetBranchInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch. </p>
    public let branchName: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
    }
}

struct GetBranchInputBody: Equatable {
}

extension GetBranchInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBranchOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBranchOutputResponse(branch: \(String(describing: branch)))"}
}

extension GetBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

public struct GetBranchOutputResponse: Equatable {
    /// <p> The branch for an Amplify app, which maps to a third-party repository branch. </p>
    public let branch: Branch?

    public init (
        branch: Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct GetBranchOutputResponseBody: Equatable {
    public let branch: Branch?
}

extension GetBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

extension GetDomainAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainAssociationInput(appId: \(String(describing: appId)), domainName: \(String(describing: domainName)))"}
}

extension GetDomainAssociationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDomainAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "GetDomainAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainAssociationInput>
    public typealias MOutput = OperationOutput<GetDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainAssociationOutputError>
}

public struct GetDomainAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDomainAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDomainAssociationInput>
    public typealias MOutput = OperationOutput<GetDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDomainAssociationOutputError>
}

/// <p> The request structure for the get domain association request. </p>
public struct GetDomainAssociationInput: Equatable {
    /// <p> The unique id for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of the domain. </p>
    public let domainName: String?

    public init (
        appId: String? = nil,
        domainName: String? = nil
    )
    {
        self.appId = appId
        self.domainName = domainName
    }
}

struct GetDomainAssociationInputBody: Equatable {
}

extension GetDomainAssociationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDomainAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainAssociationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDomainAssociationOutputResponse(domainAssociation: \(String(describing: domainAssociation)))"}
}

extension GetDomainAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDomainAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// <p> The result structure for the get domain association request. </p>
public struct GetDomainAssociationOutputResponse: Equatable {
    /// <p> Describes the structure of a domain association, which associates a custom domain
    ///             with an Amplify app. </p>
    public let domainAssociation: DomainAssociation?

    public init (
        domainAssociation: DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct GetDomainAssociationOutputResponseBody: Equatable {
    public let domainAssociation: DomainAssociation?
}

extension GetDomainAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

extension GetJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), jobId: \(String(describing: jobId)))"}
}

extension GetJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

public struct GetJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobInput>
    public typealias MOutput = OperationOutput<GetJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputError>
}

/// <p> The request structure for the get job request. </p>
public struct GetJobInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The branch name for the job. </p>
    public let branchName: String?
    /// <p> The unique ID for the job. </p>
    public let jobId: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        jobId: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct GetJobInputBody: Equatable {
}

extension GetJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputResponse(job: \(String(describing: job)))"}
}

extension GetJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct GetJobOutputResponse: Equatable {
    /// <p> Describes an execution job for an Amplify app. </p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct GetJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension GetJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension GetWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebhookInput(webhookId: \(String(describing: webhookId)))"}
}

extension GetWebhookInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "GetWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebhookInput>
    public typealias MOutput = OperationOutput<GetWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebhookOutputError>
}

public struct GetWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebhookInput>
    public typealias MOutput = OperationOutput<GetWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebhookOutputError>
}

/// <p> The request structure for the get webhook request. </p>
public struct GetWebhookInput: Equatable {
    /// <p> The unique ID for a webhook. </p>
    public let webhookId: String?

    public init (
        webhookId: String? = nil
    )
    {
        self.webhookId = webhookId
    }
}

struct GetWebhookInputBody: Equatable {
}

extension GetWebhookInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWebhookOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension GetWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// <p> The result structure for the get webhook request. </p>
public struct GetWebhookOutputResponse: Equatable {
    /// <p> Describes the structure of a webhook. </p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct GetWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension GetWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The service failed to perform an operation due to an internal issue. </p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case steps
        case summary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for steps0 in steps {
                try stepsContainer.encode(steps0)
            }
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(JobSummary.self, forKey: .summary)
        summary = summaryDecoded
        let stepsContainer = try containerValues.decodeIfPresent([Step?].self, forKey: .steps)
        var stepsDecoded0:[Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(steps: \(String(describing: steps)), summary: \(String(describing: summary)))"}
}

/// <p> Describes an execution job for an Amplify app. </p>
public struct Job: Equatable {
    /// <p> The execution steps for an execution job, for an Amplify app. </p>
    public let steps: [Step]?
    /// <p> Describes the summary for an execution job for an Amplify app. </p>
    public let summary: JobSummary?

    public init (
        steps: [Step]? = nil,
        summary: JobSummary? = nil
    )
    {
        self.steps = steps
        self.summary = summary
    }
}

public enum JobStatus {
    case cancelled
    case cancelling
    case failed
    case pending
    case provisioning
    case running
    case succeed
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .cancelled,
            .cancelling,
            .failed,
            .pending,
            .provisioning,
            .running,
            .succeed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .provisioning: return "PROVISIONING"
        case .running: return "RUNNING"
        case .succeed: return "SUCCEED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case endTime
        case jobArn
        case jobId
        case jobType
        case startTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let commitTime = commitTime {
            try encodeContainer.encode(commitTime.timeIntervalSince1970, forKey: .commitTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let jobArn = jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let commitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .commitTime)
        commitTime = commitTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension JobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobSummary(commitId: \(String(describing: commitId)), commitMessage: \(String(describing: commitMessage)), commitTime: \(String(describing: commitTime)), endTime: \(String(describing: endTime)), jobArn: \(String(describing: jobArn)), jobId: \(String(describing: jobId)), jobType: \(String(describing: jobType)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// <p> Describes the summary for an execution job for an Amplify app. </p>
public struct JobSummary: Equatable {
    /// <p> The commit ID from a third-party repository provider for the job. </p>
    public let commitId: String?
    /// <p> The commit message from a third-party repository provider for the job. </p>
    public let commitMessage: String?
    /// <p> The commit date and time for the job. </p>
    public let commitTime: Date?
    /// <p> The end date and time for the job. </p>
    public let endTime: Date?
    /// <p> The Amazon Resource Name (ARN) for the job. </p>
    public let jobArn: String?
    /// <p> The unique ID for the job. </p>
    public let jobId: String?
    /// <p> The type for the job. If the value is <code>RELEASE</code>, the job was manually
    ///             released from its source by using the <code>StartJob</code> API. If the value is
    ///                 <code>RETRY</code>, the job was manually retried using the <code>StartJob</code>
    ///             API. If the value is <code>WEB_HOOK</code>, the job was automatically triggered by
    ///             webhooks. </p>
    public let jobType: JobType?
    /// <p> The start date and time for the job. </p>
    public let startTime: Date?
    /// <p> The current status for the job. </p>
    public let status: JobStatus?

    public init (
        commitId: String? = nil,
        commitMessage: String? = nil,
        commitTime: Date? = nil,
        endTime: Date? = nil,
        jobArn: String? = nil,
        jobId: String? = nil,
        jobType: JobType? = nil,
        startTime: Date? = nil,
        status: JobStatus? = nil
    )
    {
        self.commitId = commitId
        self.commitMessage = commitMessage
        self.commitTime = commitTime
        self.endTime = endTime
        self.jobArn = jobArn
        self.jobId = jobId
        self.jobType = jobType
        self.startTime = startTime
        self.status = status
    }
}

public enum JobType {
    case manual
    case release
    case retry
    case webHook
    case sdkUnknown(String)
}

extension JobType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobType] {
        return [
            .manual,
            .release,
            .retry,
            .webHook,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .manual: return "MANUAL"
        case .release: return "RELEASE"
        case .retry: return "RETRY"
        case .webHook: return "WEB_HOOK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> A resource could not be created because service quotas were exceeded. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAppsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsInput>
    public typealias MOutput = OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsOutputError>
}

public struct ListAppsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsInput>
    public typealias MOutput = OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsOutputError>
}

/// <p> The request structure for the list apps request. </p>
public struct ListAppsInput: Equatable {
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. If non-null, the pagination token is returned in a result. Pass
    ///             its value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Equatable {
}

extension ListAppsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAppsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsOutputResponse(apps: \(String(describing: apps)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

/// <p> The result structure for an Amplify app list request. </p>
public struct ListAppsOutputResponse: Equatable {
    /// <p> A list of Amplify apps. </p>
    public let apps: [App]?
    /// <p> A pagination token. Set to null to start listing apps from start. If non-null, the
    ///             pagination token is returned in a result. Pass its value in here to list more projects.
    ///         </p>
    public let nextToken: String?

    public init (
        apps: [App]? = nil,
        nextToken: String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Equatable {
    public let apps: [App]?
    public let nextToken: String?
}

extension ListAppsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apps
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([App?].self, forKey: .apps)
        var appsDecoded0:[App]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [App]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArtifactsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArtifactsInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), jobId: \(String(describing: jobId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArtifactsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListArtifactsInputHeadersMiddleware: Middleware {
    public let id: String = "ListArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArtifactsOutputError>
}

public struct ListArtifactsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArtifactsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArtifactsInput>
    public typealias MOutput = OperationOutput<ListArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArtifactsOutputError>
}

/// <p> Describes the request structure for the list artifacts request. </p>
public struct ListArtifactsInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of a branch that is part of an Amplify app. </p>
    public let branchName: String?
    /// <p> The unique ID for a job. </p>
    public let jobId: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing artifacts from start. If a non-null
    ///             pagination token is returned in a result, pass its value in here to list more artifacts.
    ///         </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        jobId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListArtifactsInputBody: Equatable {
}

extension ListArtifactsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListArtifactsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArtifactsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArtifactsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArtifactsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArtifactsOutputResponse(artifacts: \(String(describing: artifacts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArtifactsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.artifacts = output.artifacts
            self.nextToken = output.nextToken
        } else {
            self.artifacts = nil
            self.nextToken = nil
        }
    }
}

/// <p> The result structure for the list artifacts request. </p>
public struct ListArtifactsOutputResponse: Equatable {
    /// <p> A list of artifacts. </p>
    public let artifacts: [Artifact]?
    /// <p> A pagination token. If a non-null pagination token is returned in a result, pass its
    ///             value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        artifacts: [Artifact]? = nil,
        nextToken: String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

struct ListArtifactsOutputResponseBody: Equatable {
    public let artifacts: [Artifact]?
    public let nextToken: String?
}

extension ListArtifactsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifacts
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .artifacts)
        var artifactsDecoded0:[Artifact]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [Artifact]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBackendEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackendEnvironmentsInput(appId: \(String(describing: appId)), environmentName: \(String(describing: environmentName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackendEnvironmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBackendEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListBackendEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackendEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackendEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackendEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListBackendEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackendEnvironmentsOutputError>
}

public struct ListBackendEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBackendEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBackendEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBackendEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let environmentName = input.operationInput.environmentName {
            let environmentNameQueryItem = URLQueryItem(name: "environmentName".urlPercentEncoding(), value: String(environmentName).urlPercentEncoding())
            input.builder.withQueryItem(environmentNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBackendEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListBackendEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBackendEnvironmentsOutputError>
}

/// <p> The request structure for the list backend environments request. </p>
public struct ListBackendEnvironmentsInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name of the backend environment </p>
    public let environmentName: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing backend environments from the start.
    ///             If a non-null pagination token is returned in a result, pass its value in here to list
    ///             more backend environments. </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        environmentName: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackendEnvironmentsInputBody: Equatable {
}

extension ListBackendEnvironmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBackendEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackendEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackendEnvironmentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackendEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBackendEnvironmentsOutputResponse(backendEnvironments: \(String(describing: backendEnvironments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBackendEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBackendEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backendEnvironments = output.backendEnvironments
            self.nextToken = output.nextToken
        } else {
            self.backendEnvironments = nil
            self.nextToken = nil
        }
    }
}

/// <p> The result structure for the list backend environments result. </p>
public struct ListBackendEnvironmentsOutputResponse: Equatable {
    /// <p> The list of backend environments for an Amplify app. </p>
    public let backendEnvironments: [BackendEnvironment]?
    /// <p> A pagination token. If a non-null pagination token is returned in a result, pass its
    ///             value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        backendEnvironments: [BackendEnvironment]? = nil,
        nextToken: String? = nil
    )
    {
        self.backendEnvironments = backendEnvironments
        self.nextToken = nextToken
    }
}

struct ListBackendEnvironmentsOutputResponseBody: Equatable {
    public let backendEnvironments: [BackendEnvironment]?
    public let nextToken: String?
}

extension ListBackendEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironments
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentsContainer = try containerValues.decodeIfPresent([BackendEnvironment?].self, forKey: .backendEnvironments)
        var backendEnvironmentsDecoded0:[BackendEnvironment]? = nil
        if let backendEnvironmentsContainer = backendEnvironmentsContainer {
            backendEnvironmentsDecoded0 = [BackendEnvironment]()
            for structure0 in backendEnvironmentsContainer {
                if let structure0 = structure0 {
                    backendEnvironmentsDecoded0?.append(structure0)
                }
            }
        }
        backendEnvironments = backendEnvironmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBranchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBranchesInput(appId: \(String(describing: appId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBranchesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBranchesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBranchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBranchesInput>
    public typealias MOutput = OperationOutput<ListBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBranchesOutputError>
}

public struct ListBranchesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBranchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBranchesInput>
    public typealias MOutput = OperationOutput<ListBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBranchesOutputError>
}

/// <p> The request structure for the list branches request. </p>
public struct ListBranchesInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing branches from the start. If a
    ///             non-null pagination token is returned in a result, pass its value in here to list more
    ///             branches. </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBranchesInputBody: Equatable {
}

extension ListBranchesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBranchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBranchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBranchesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBranchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBranchesOutputResponse(branches: \(String(describing: branches)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBranchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBranchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branches = output.branches
            self.nextToken = output.nextToken
        } else {
            self.branches = nil
            self.nextToken = nil
        }
    }
}

/// <p> The result structure for the list branches request. </p>
public struct ListBranchesOutputResponse: Equatable {
    /// <p> A list of branches for an Amplify app. </p>
    public let branches: [Branch]?
    /// <p> A pagination token. If a non-null pagination token is returned in a result, pass its
    ///             value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        branches: [Branch]? = nil,
        nextToken: String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

struct ListBranchesOutputResponseBody: Equatable {
    public let branches: [Branch]?
    public let nextToken: String?
}

extension ListBranchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branches
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([Branch?].self, forKey: .branches)
        var branchesDecoded0:[Branch]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [Branch]()
            for structure0 in branchesContainer {
                if let structure0 = structure0 {
                    branchesDecoded0?.append(structure0)
                }
            }
        }
        branches = branchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainAssociationsInput(appId: \(String(describing: appId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDomainAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainAssociationsInput>
    public typealias MOutput = OperationOutput<ListDomainAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainAssociationsOutputError>
}

public struct ListDomainAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainAssociationsInput>
    public typealias MOutput = OperationOutput<ListDomainAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainAssociationsOutputError>
}

/// <p> The request structure for the list domain associations request. </p>
public struct ListDomainAssociationsInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing apps from the start. If non-null, a
    ///             pagination token is returned in a result. Pass its value in here to list more projects.
    ///         </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainAssociationsInputBody: Equatable {
}

extension ListDomainAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDomainAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainAssociationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainAssociationsOutputResponse(domainAssociations: \(String(describing: domainAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainAssociations = output.domainAssociations
            self.nextToken = output.nextToken
        } else {
            self.domainAssociations = nil
            self.nextToken = nil
        }
    }
}

/// <p> The result structure for the list domain association request. </p>
public struct ListDomainAssociationsOutputResponse: Equatable {
    /// <p> A list of domain associations. </p>
    public let domainAssociations: [DomainAssociation]?
    /// <p> A pagination token. If non-null, a pagination token is returned in a result. Pass its
    ///             value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        domainAssociations: [DomainAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.domainAssociations = domainAssociations
        self.nextToken = nextToken
    }
}

struct ListDomainAssociationsOutputResponseBody: Equatable {
    public let domainAssociations: [DomainAssociation]?
    public let nextToken: String?
}

extension ListDomainAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainAssociations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationsContainer = try containerValues.decodeIfPresent([DomainAssociation?].self, forKey: .domainAssociations)
        var domainAssociationsDecoded0:[DomainAssociation]? = nil
        if let domainAssociationsContainer = domainAssociationsContainer {
            domainAssociationsDecoded0 = [DomainAssociation]()
            for structure0 in domainAssociationsContainer {
                if let structure0 = structure0 {
                    domainAssociationsDecoded0?.append(structure0)
                }
            }
        }
        domainAssociations = domainAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

/// <p> The request structure for the list jobs request. </p>
public struct ListJobsInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for a branch. </p>
    public let branchName: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing steps from the start. If a non-null
    ///             pagination token is returned in a result, pass its value in here to list more steps.
    ///         </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobSummaries: \(String(describing: jobSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

/// <p> The maximum number of records to list in a single response. </p>
public struct ListJobsOutputResponse: Equatable {
    /// <p> The result structure for the list job result request. </p>
    public let jobSummaries: [JobSummary]?
    /// <p> A pagination token. If non-null the pagination token is returned in a result. Pass
    ///             its value in another request to retrieve more entries. </p>
    public let nextToken: String?

    public init (
        jobSummaries: [JobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobSummaries: [JobSummary]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([JobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[JobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [JobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p> The request structure to use to list tags for a resource. </p>
public struct ListTagsForResourceInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) to use to list tags. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p> The response for the list tags for resource request. </p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p> A list of tags for the specified The Amazon Resource Name (ARN). </p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWebhooksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebhooksInput(appId: \(String(describing: appId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWebhooksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWebhooksInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebhooksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebhooksOutputError>
}

public struct ListWebhooksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebhooksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebhooksOutputError>
}

/// <p> The request structure for the list webhooks request. </p>
public struct ListWebhooksInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The maximum number of records to list in a single response. </p>
    public let maxResults: Int
    /// <p> A pagination token. Set to null to start listing webhooks from the start. If
    ///             non-null,the pagination token is returned in a result. Pass its value in here to list
    ///             more webhooks. </p>
    public let nextToken: String?

    public init (
        appId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebhooksInputBody: Equatable {
}

extension ListWebhooksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWebhooksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebhooksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebhooksOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebhooksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebhooksOutputResponse(nextToken: \(String(describing: nextToken)), webhooks: \(String(describing: webhooks)))"}
}

extension ListWebhooksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWebhooksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.webhooks = output.webhooks
        } else {
            self.nextToken = nil
            self.webhooks = nil
        }
    }
}

/// <p> The result structure for the list webhooks request. </p>
public struct ListWebhooksOutputResponse: Equatable {
    /// <p> A pagination token. If non-null, the pagination token is returned in a result. Pass
    ///             its value in another request to retrieve more entries. </p>
    public let nextToken: String?
    /// <p> A list of webhooks. </p>
    public let webhooks: [Webhook]?

    public init (
        nextToken: String? = nil,
        webhooks: [Webhook]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhooks = webhooks
    }
}

struct ListWebhooksOutputResponseBody: Equatable {
    public let webhooks: [Webhook]?
    public let nextToken: String?
}

extension ListWebhooksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case webhooks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhooksContainer = try containerValues.decodeIfPresent([Webhook?].self, forKey: .webhooks)
        var webhooksDecoded0:[Webhook]? = nil
        if let webhooksContainer = webhooksContainer {
            webhooksDecoded0 = [Webhook]()
            for structure0 in webhooksContainer {
                if let structure0 = structure0 {
                    webhooksDecoded0?.append(structure0)
                }
            }
        }
        webhooks = webhooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> An entity was not found during an operation. </p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Platform {
    case web
    case sdkUnknown(String)
}

extension Platform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Platform] {
        return [
            .web,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .web: return "WEB"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
    }
}

extension ProductionBranch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case lastDeployTime
        case status
        case thumbnailUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let lastDeployTime = lastDeployTime {
            try encodeContainer.encode(lastDeployTime.timeIntervalSince1970, forKey: .lastDeployTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let thumbnailUrl = thumbnailUrl {
            try encodeContainer.encode(thumbnailUrl, forKey: .thumbnailUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastDeployTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastDeployTime)
        lastDeployTime = lastDeployTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let thumbnailUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thumbnailUrl)
        thumbnailUrl = thumbnailUrlDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension ProductionBranch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductionBranch(branchName: \(String(describing: branchName)), lastDeployTime: \(String(describing: lastDeployTime)), status: \(String(describing: status)), thumbnailUrl: \(String(describing: thumbnailUrl)))"}
}

/// <p> Describes the information about a production branch for an Amplify app. </p>
public struct ProductionBranch: Equatable {
    /// <p> The branch name for the production branch. </p>
    public let branchName: String?
    /// <p> The last deploy time of the production branch. </p>
    public let lastDeployTime: Date?
    /// <p> The status of the production branch. </p>
    public let status: String?
    /// <p> The thumbnail URL for the production branch. </p>
    public let thumbnailUrl: String?

    public init (
        branchName: String? = nil,
        lastDeployTime: Date? = nil,
        status: String? = nil,
        thumbnailUrl: String? = nil
    )
    {
        self.branchName = branchName
        self.lastDeployTime = lastDeployTime
        self.status = status
        self.thumbnailUrl = thumbnailUrl
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> An operation failed due to a non-existent resource. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let code: String?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Stage {
    case beta
    case development
    case experimental
    case production
    case pullRequest
    case sdkUnknown(String)
}

extension Stage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Stage] {
        return [
            .beta,
            .development,
            .experimental,
            .production,
            .pullRequest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .beta: return "BETA"
        case .development: return "DEVELOPMENT"
        case .experimental: return "EXPERIMENTAL"
        case .production: return "PRODUCTION"
        case .pullRequest: return "PULL_REQUEST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Stage(rawValue: rawValue) ?? Stage.sdkUnknown(rawValue)
    }
}

public struct StartDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), jobId: \(String(describing: jobId)), sourceUrl: \(String(describing: sourceUrl)))"}
}

extension StartDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
        case sourceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let sourceUrl = sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

/// <p> The request structure for the start a deployment request. </p>
public struct StartDeploymentInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch, for the job. </p>
    public let branchName: String?
    /// <p> The job ID for this deployment, generated by the create deployment request. </p>
    public let jobId: String?
    /// <p> The source URL for this deployment, used when calling start deployment without create
    ///             deployment. The source URL can be any HTTP GET URL that is publicly accessible and
    ///             downloads a single .zip file. </p>
    public let sourceUrl: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        jobId: String? = nil,
        sourceUrl: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
        self.sourceUrl = sourceUrl
    }
}

struct StartDeploymentInputBody: Equatable {
    public let jobId: String?
    public let sourceUrl: String?
}

extension StartDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case sourceUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
    }
}

extension StartDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentOutputResponse(jobSummary: \(String(describing: jobSummary)))"}
}

extension StartDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// <p> The result structure for the start a deployment request. </p>
public struct StartDeploymentOutputResponse: Equatable {
    /// <p> The summary for the job. </p>
    public let jobSummary: JobSummary?

    public init (
        jobSummary: JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StartDeploymentOutputResponseBody: Equatable {
    public let jobSummary: JobSummary?
}

extension StartDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobSummary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

public struct StartJobInputBodyMiddleware: Middleware {
    public let id: String = "StartJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobInput>
    public typealias MOutput = OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobOutputError>
}

extension StartJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), commitId: \(String(describing: commitId)), commitMessage: \(String(describing: commitMessage)), commitTime: \(String(describing: commitTime)), jobId: \(String(describing: jobId)), jobReason: \(String(describing: jobReason)), jobType: \(String(describing: jobType)))"}
}

extension StartJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case jobId
        case jobReason
        case jobType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let commitTime = commitTime {
            try encodeContainer.encode(commitTime.timeIntervalSince1970, forKey: .commitTime)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobReason = jobReason {
            try encodeContainer.encode(jobReason, forKey: .jobReason)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }
}

public struct StartJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobInput>
    public typealias MOutput = OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobOutputError>
}

public struct StartJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartJobInput>
    public typealias MOutput = OperationOutput<StartJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartJobOutputError>
}

/// <p> The request structure for the start job request. </p>
public struct StartJobInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The branch name for the job. </p>
    public let branchName: String?
    /// <p> The commit ID from a third-party repository provider for the job. </p>
    public let commitId: String?
    /// <p> The commit message from a third-party repository provider for the job. </p>
    public let commitMessage: String?
    /// <p> The commit date and time for the job. </p>
    public let commitTime: Date?
    /// <p> The unique ID for an existing job. This is required if the value of
    ///                 <code>jobType</code> is <code>RETRY</code>. </p>
    public let jobId: String?
    /// <p> A descriptive reason for starting this job. </p>
    public let jobReason: String?
    /// <p> Describes the type for the job. The job type <code>RELEASE</code> starts a new job
    ///             with the latest change from the specified branch. This value is available only for apps
    ///             that are connected to a repository. The job type <code>RETRY</code> retries an existing
    ///             job. If the job type value is <code>RETRY</code>, the <code>jobId</code> is also
    ///             required. </p>
    public let jobType: JobType?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        commitId: String? = nil,
        commitMessage: String? = nil,
        commitTime: Date? = nil,
        jobId: String? = nil,
        jobReason: String? = nil,
        jobType: JobType? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.commitId = commitId
        self.commitMessage = commitMessage
        self.commitTime = commitTime
        self.jobId = jobId
        self.jobReason = jobReason
        self.jobType = jobType
    }
}

struct StartJobInputBody: Equatable {
    public let jobId: String?
    public let jobType: JobType?
    public let jobReason: String?
    public let commitId: String?
    public let commitMessage: String?
    public let commitTime: Date?
}

extension StartJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case commitMessage
        case commitTime
        case jobId
        case jobReason
        case jobType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let jobReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobReason)
        jobReason = jobReasonDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let commitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .commitTime)
        commitTime = commitTimeDecoded
    }
}

extension StartJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartJobOutputResponse(jobSummary: \(String(describing: jobSummary)))"}
}

extension StartJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// <p> The result structure for the run job request. </p>
public struct StartJobOutputResponse: Equatable {
    /// <p> The summary for the job. </p>
    public let jobSummary: JobSummary?

    public init (
        jobSummary: JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StartJobOutputResponseBody: Equatable {
    public let jobSummary: JobSummary?
}

extension StartJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobSummary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

extension Step: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactsUrl
        case context
        case endTime
        case logUrl
        case screenshots
        case startTime
        case status
        case statusReason
        case stepName
        case testArtifactsUrl
        case testConfigUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsUrl = artifactsUrl {
            try encodeContainer.encode(artifactsUrl, forKey: .artifactsUrl)
        }
        if let context = context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let screenshots = screenshots {
            var screenshotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .screenshots)
            for (dictKey0, screenshots0) in screenshots {
                try screenshotsContainer.encode(screenshots0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let testArtifactsUrl = testArtifactsUrl {
            try encodeContainer.encode(testArtifactsUrl, forKey: .testArtifactsUrl)
        }
        if let testConfigUrl = testConfigUrl {
            try encodeContainer.encode(testConfigUrl, forKey: .testConfigUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let artifactsUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactsUrl)
        artifactsUrl = artifactsUrlDecoded
        let testArtifactsUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testArtifactsUrl)
        testArtifactsUrl = testArtifactsUrlDecoded
        let testConfigUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testConfigUrl)
        testConfigUrl = testConfigUrlDecoded
        let screenshotsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .screenshots)
        var screenshotsDecoded0: [String:String]? = nil
        if let screenshotsContainer = screenshotsContainer {
            screenshotsDecoded0 = [String:String]()
            for (key0, thumbnailurl0) in screenshotsContainer {
                if let thumbnailurl0 = thumbnailurl0 {
                    screenshotsDecoded0?[key0] = thumbnailurl0
                }
            }
        }
        screenshots = screenshotsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}

extension Step: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Step(artifactsUrl: \(String(describing: artifactsUrl)), context: \(String(describing: context)), endTime: \(String(describing: endTime)), logUrl: \(String(describing: logUrl)), screenshots: \(String(describing: screenshots)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), stepName: \(String(describing: stepName)), testArtifactsUrl: \(String(describing: testArtifactsUrl)), testConfigUrl: \(String(describing: testConfigUrl)))"}
}

/// <p> Describes an execution step, for an execution job, for an Amplify app. </p>
public struct Step: Equatable {
    /// <p> The URL to the artifact for the execution step. </p>
    public let artifactsUrl: String?
    /// <p> The context for the current step. Includes a build image if the step is build.
    ///         </p>
    public let context: String?
    /// <p> The end date and time of the execution step. </p>
    public let endTime: Date?
    /// <p> The URL to the logs for the execution step. </p>
    public let logUrl: String?
    /// <p> The list of screenshot URLs for the execution step, if relevant. </p>
    public let screenshots: [String:String]?
    /// <p> The start date and time of the execution step. </p>
    public let startTime: Date?
    /// <p> The status of the execution step. </p>
    public let status: JobStatus?
    /// <p> The reason for the current step status. </p>
    public let statusReason: String?
    /// <p> The name of the execution step. </p>
    public let stepName: String?
    /// <p> The URL to the test artifact for the execution step. </p>
    public let testArtifactsUrl: String?
    /// <p> The URL to the test configuration for the execution step. </p>
    public let testConfigUrl: String?

    public init (
        artifactsUrl: String? = nil,
        context: String? = nil,
        endTime: Date? = nil,
        logUrl: String? = nil,
        screenshots: [String:String]? = nil,
        startTime: Date? = nil,
        status: JobStatus? = nil,
        statusReason: String? = nil,
        stepName: String? = nil,
        testArtifactsUrl: String? = nil,
        testConfigUrl: String? = nil
    )
    {
        self.artifactsUrl = artifactsUrl
        self.context = context
        self.endTime = endTime
        self.logUrl = logUrl
        self.screenshots = screenshots
        self.startTime = startTime
        self.status = status
        self.statusReason = statusReason
        self.stepName = stepName
        self.testArtifactsUrl = testArtifactsUrl
        self.testConfigUrl = testConfigUrl
    }
}

extension StopJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobInput(appId: \(String(describing: appId)), branchName: \(String(describing: branchName)), jobId: \(String(describing: jobId)))"}
}

extension StopJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopJobInputHeadersMiddleware: Middleware {
    public let id: String = "StopJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobInput>
    public typealias MOutput = OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobOutputError>
}

public struct StopJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StopJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StopJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopJobInput>
    public typealias MOutput = OperationOutput<StopJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopJobOutputError>
}

/// <p> The request structure for the stop job request. </p>
public struct StopJobInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The name for the branch, for the job. </p>
    public let branchName: String?
    /// <p> The unique id for the job. </p>
    public let jobId: String?

    public init (
        appId: String? = nil,
        branchName: String? = nil,
        jobId: String? = nil
    )
    {
        self.appId = appId
        self.branchName = branchName
        self.jobId = jobId
    }
}

struct StopJobInputBody: Equatable {
}

extension StopJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopJobOutputResponse(jobSummary: \(String(describing: jobSummary)))"}
}

extension StopJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobSummary = output.jobSummary
        } else {
            self.jobSummary = nil
        }
    }
}

/// <p> The result structure for the stop job request. </p>
public struct StopJobOutputResponse: Equatable {
    /// <p> The summary for the job. </p>
    public let jobSummary: JobSummary?

    public init (
        jobSummary: JobSummary? = nil
    )
    {
        self.jobSummary = jobSummary
    }
}

struct StopJobOutputResponseBody: Equatable {
    public let jobSummary: JobSummary?
}

extension StopJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobSummary
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummaryDecoded = try containerValues.decodeIfPresent(JobSummary.self, forKey: .jobSummary)
        jobSummary = jobSummaryDecoded
    }
}

extension SubDomain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dnsRecord
        case subDomainSetting
        case verified
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsRecord = dnsRecord {
            try encodeContainer.encode(dnsRecord, forKey: .dnsRecord)
        }
        if let subDomainSetting = subDomainSetting {
            try encodeContainer.encode(subDomainSetting, forKey: .subDomainSetting)
        }
        if let verified = verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subDomainSettingDecoded = try containerValues.decodeIfPresent(SubDomainSetting.self, forKey: .subDomainSetting)
        subDomainSetting = subDomainSettingDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .verified)
        verified = verifiedDecoded
        let dnsRecordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dnsRecord)
        dnsRecord = dnsRecordDecoded
    }
}

extension SubDomain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubDomain(dnsRecord: \(String(describing: dnsRecord)), subDomainSetting: \(String(describing: subDomainSetting)), verified: \(String(describing: verified)))"}
}

/// <p> The subdomain for the domain association. </p>
public struct SubDomain: Equatable {
    /// <p> The DNS record for the subdomain. </p>
    public let dnsRecord: String?
    /// <p> Describes the settings for the subdomain. </p>
    public let subDomainSetting: SubDomainSetting?
    /// <p> The verified status of the subdomain </p>
    public let verified: Bool?

    public init (
        dnsRecord: String? = nil,
        subDomainSetting: SubDomainSetting? = nil,
        verified: Bool? = nil
    )
    {
        self.dnsRecord = dnsRecord
        self.subDomainSetting = subDomainSetting
        self.verified = verified
    }
}

extension SubDomainSetting: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension SubDomainSetting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubDomainSetting(branchName: \(String(describing: branchName)), prefix: \(String(describing: prefix)))"}
}

/// <p> Describes the settings for the subdomain. </p>
public struct SubDomainSetting: Equatable {
    /// <p> The branch name setting for the subdomain. </p>
    public let branchName: String?
    /// <p> The prefix setting for the subdomain. </p>
    public let prefix: String?

    public init (
        branchName: String? = nil,
        prefix: String? = nil
    )
    {
        self.branchName = branchName
        self.prefix = prefix
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p> The request structure to tag a resource with a tag key and value. </p>
public struct TagResourceInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) to use to tag a resource. </p>
    public let resourceArn: String?
    /// <p> The tags used to tag the resource. </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> The response for the tag resource request. </p>
public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> An operation failed due to a lack of access. </p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p> The request structure for the untag resource request. </p>
public struct UntagResourceInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) to use to untag a resource. </p>
    public let resourceArn: String?
    /// <p> The tag keys to use to untag a resource. </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p> The response for the untag resource request. </p>
public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAppInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

extension UpdateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppInput(accessToken: \(String(describing: accessToken)), appId: \(String(describing: appId)), autoBranchCreationConfig: \(String(describing: autoBranchCreationConfig)), autoBranchCreationPatterns: \(String(describing: autoBranchCreationPatterns)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), buildSpec: \(String(describing: buildSpec)), customHeaders: \(String(describing: customHeaders)), customRules: \(String(describing: customRules)), description: \(String(describing: description)), enableAutoBranchCreation: \(String(describing: enableAutoBranchCreation)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableBranchAutoBuild: \(String(describing: enableBranchAutoBuild)), enableBranchAutoDeletion: \(String(describing: enableBranchAutoDeletion)), environmentVariables: \(String(describing: environmentVariables)), iamServiceRoleArn: \(String(describing: iamServiceRoleArn)), name: \(String(describing: name)), oauthToken: \(String(describing: oauthToken)), platform: \(String(describing: platform)), repository: \(String(describing: repository)))"}
}

extension UpdateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let autoBranchCreationConfig = autoBranchCreationConfig {
            try encodeContainer.encode(autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
        }
        if let autoBranchCreationPatterns = autoBranchCreationPatterns {
            var autoBranchCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoBranchCreationPatterns)
            for autobranchcreationpatterns0 in autoBranchCreationPatterns {
                try autoBranchCreationPatternsContainer.encode(autobranchcreationpatterns0)
            }
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let customHeaders = customHeaders {
            try encodeContainer.encode(customHeaders, forKey: .customHeaders)
        }
        if let customRules = customRules {
            var customRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customRules)
            for customrules0 in customRules {
                try customRulesContainer.encode(customrules0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let enableAutoBranchCreation = enableAutoBranchCreation {
            try encodeContainer.encode(enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableBranchAutoBuild = enableBranchAutoBuild {
            try encodeContainer.encode(enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
        }
        if let enableBranchAutoDeletion = enableBranchAutoDeletion {
            try encodeContainer.encode(enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let iamServiceRoleArn = iamServiceRoleArn {
            try encodeContainer.encode(iamServiceRoleArn, forKey: .iamServiceRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oauthToken = oauthToken {
            try encodeContainer.encode(oauthToken, forKey: .oauthToken)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
    }
}

public struct UpdateAppInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

/// <p> The request structure for the update app request. </p>
public struct UpdateAppInput: Equatable {
    /// <p> The personal access token for a third-party source control system for an Amplify app.
    ///             The token is used to create webhook and a read-only deploy key. The token is not stored.
    ///         </p>
    public let accessToken: String?
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The automated branch creation configuration for an Amplify app. </p>
    public let autoBranchCreationConfig: AutoBranchCreationConfig?
    /// <p> Describes the automated branch creation glob patterns for an Amplify app. </p>
    public let autoBranchCreationPatterns: [String]?
    /// <p> The basic authorization credentials for an Amplify app. </p>
    public let basicAuthCredentials: String?
    /// <p> The build specification (build spec) for an Amplify app. </p>
    public let buildSpec: String?
    /// <p>The custom HTTP headers for an Amplify app.</p>
    public let customHeaders: String?
    /// <p> The custom redirect and rewrite rules for an Amplify app. </p>
    public let customRules: [CustomRule]?
    /// <p> The description for an Amplify app. </p>
    public let description: String?
    /// <p> Enables automated branch creation for an Amplify app. </p>
    public let enableAutoBranchCreation: Bool?
    /// <p> Enables basic authorization for an Amplify app. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables branch auto-building for an Amplify app. </p>
    public let enableBranchAutoBuild: Bool?
    /// <p> Automatically disconnects a branch in the Amplify Console when you delete a branch
    ///             from your Git repository. </p>
    public let enableBranchAutoDeletion: Bool?
    /// <p> The environment variables for an Amplify app. </p>
    public let environmentVariables: [String:String]?
    /// <p> The AWS Identity and Access Management (IAM) service role for an Amplify app. </p>
    public let iamServiceRoleArn: String?
    /// <p> The name for an Amplify app. </p>
    public let name: String?
    /// <p> The OAuth token for a third-party source control system for an Amplify app. The token
    ///             is used to create a webhook and a read-only deploy key. The OAuth token is not stored.
    ///         </p>
    public let oauthToken: String?
    /// <p> The platform for an Amplify app. </p>
    public let platform: Platform?
    /// <p> The name of the repository for an Amplify app </p>
    public let repository: String?

    public init (
        accessToken: String? = nil,
        appId: String? = nil,
        autoBranchCreationConfig: AutoBranchCreationConfig? = nil,
        autoBranchCreationPatterns: [String]? = nil,
        basicAuthCredentials: String? = nil,
        buildSpec: String? = nil,
        customHeaders: String? = nil,
        customRules: [CustomRule]? = nil,
        description: String? = nil,
        enableAutoBranchCreation: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableBranchAutoBuild: Bool? = nil,
        enableBranchAutoDeletion: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        iamServiceRoleArn: String? = nil,
        name: String? = nil,
        oauthToken: String? = nil,
        platform: Platform? = nil,
        repository: String? = nil
    )
    {
        self.accessToken = accessToken
        self.appId = appId
        self.autoBranchCreationConfig = autoBranchCreationConfig
        self.autoBranchCreationPatterns = autoBranchCreationPatterns
        self.basicAuthCredentials = basicAuthCredentials
        self.buildSpec = buildSpec
        self.customHeaders = customHeaders
        self.customRules = customRules
        self.description = description
        self.enableAutoBranchCreation = enableAutoBranchCreation
        self.enableBasicAuth = enableBasicAuth
        self.enableBranchAutoBuild = enableBranchAutoBuild
        self.enableBranchAutoDeletion = enableBranchAutoDeletion
        self.environmentVariables = environmentVariables
        self.iamServiceRoleArn = iamServiceRoleArn
        self.name = name
        self.oauthToken = oauthToken
        self.platform = platform
        self.repository = repository
    }
}

struct UpdateAppInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let platform: Platform?
    public let iamServiceRoleArn: String?
    public let environmentVariables: [String:String]?
    public let enableBranchAutoBuild: Bool?
    public let enableBranchAutoDeletion: Bool?
    public let enableBasicAuth: Bool?
    public let basicAuthCredentials: String?
    public let customRules: [CustomRule]?
    public let buildSpec: String?
    public let customHeaders: String?
    public let enableAutoBranchCreation: Bool?
    public let autoBranchCreationPatterns: [String]?
    public let autoBranchCreationConfig: AutoBranchCreationConfig?
    public let repository: String?
    public let oauthToken: String?
    public let accessToken: String?
}

extension UpdateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessToken
        case autoBranchCreationConfig
        case autoBranchCreationPatterns
        case basicAuthCredentials
        case buildSpec
        case customHeaders
        case customRules
        case description
        case enableAutoBranchCreation
        case enableBasicAuth
        case enableBranchAutoBuild
        case enableBranchAutoDeletion
        case environmentVariables
        case iamServiceRoleArn
        case name
        case oauthToken
        case platform
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let iamServiceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamServiceRoleArn)
        iamServiceRoleArn = iamServiceRoleArnDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let enableBranchAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoBuild)
        enableBranchAutoBuild = enableBranchAutoBuildDecoded
        let enableBranchAutoDeletionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBranchAutoDeletion)
        enableBranchAutoDeletion = enableBranchAutoDeletionDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let customRulesContainer = try containerValues.decodeIfPresent([CustomRule?].self, forKey: .customRules)
        var customRulesDecoded0:[CustomRule]? = nil
        if let customRulesContainer = customRulesContainer {
            customRulesDecoded0 = [CustomRule]()
            for structure0 in customRulesContainer {
                if let structure0 = structure0 {
                    customRulesDecoded0?.append(structure0)
                }
            }
        }
        customRules = customRulesDecoded0
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let enableAutoBranchCreationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBranchCreation)
        enableAutoBranchCreation = enableAutoBranchCreationDecoded
        let autoBranchCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoBranchCreationPatterns)
        var autoBranchCreationPatternsDecoded0:[String]? = nil
        if let autoBranchCreationPatternsContainer = autoBranchCreationPatternsContainer {
            autoBranchCreationPatternsDecoded0 = [String]()
            for string0 in autoBranchCreationPatternsContainer {
                if let string0 = string0 {
                    autoBranchCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoBranchCreationPatterns = autoBranchCreationPatternsDecoded0
        let autoBranchCreationConfigDecoded = try containerValues.decodeIfPresent(AutoBranchCreationConfig.self, forKey: .autoBranchCreationConfig)
        autoBranchCreationConfig = autoBranchCreationConfigDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repository)
        repository = repositoryDecoded
        let oauthTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oauthToken)
        oauthToken = oauthTokenDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
    }
}

extension UpdateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppOutputResponse(app: \(String(describing: app)))"}
}

extension UpdateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

/// <p> The result structure for an Amplify app update request. </p>
public struct UpdateAppOutputResponse: Equatable {
    /// <p> Represents the updated Amplify app. </p>
    public let app: App?

    public init (
        app: App? = nil
    )
    {
        self.app = app
    }
}

struct UpdateAppOutputResponseBody: Equatable {
    public let app: App?
}

extension UpdateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case app
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(App.self, forKey: .app)
        app = appDecoded
    }
}

public struct UpdateBranchInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBranchInput>
    public typealias MOutput = OperationOutput<UpdateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBranchOutputError>
}

extension UpdateBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBranchInput(appId: \(String(describing: appId)), backendEnvironmentArn: \(String(describing: backendEnvironmentArn)), basicAuthCredentials: \(String(describing: basicAuthCredentials)), branchName: \(String(describing: branchName)), buildSpec: \(String(describing: buildSpec)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), enableAutoBuild: \(String(describing: enableAutoBuild)), enableBasicAuth: \(String(describing: enableBasicAuth)), enableNotification: \(String(describing: enableNotification)), enablePerformanceMode: \(String(describing: enablePerformanceMode)), enablePullRequestPreview: \(String(describing: enablePullRequestPreview)), environmentVariables: \(String(describing: environmentVariables)), framework: \(String(describing: framework)), pullRequestEnvironmentName: \(String(describing: pullRequestEnvironmentName)), stage: \(String(describing: stage)), ttl: \(String(describing: ttl)))"}
}

extension UpdateBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case ttl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let ttl = ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

public struct UpdateBranchInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBranchInput>
    public typealias MOutput = OperationOutput<UpdateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBranchOutputError>
}

public struct UpdateBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBranchInput>
    public typealias MOutput = OperationOutput<UpdateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBranchOutputError>
}

/// <p> The request structure for the update branch request. </p>
public struct UpdateBranchInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify
    ///             app. </p>
    public let backendEnvironmentArn: String?
    /// <p> The basic authorization credentials for the branch. </p>
    public let basicAuthCredentials: String?
    /// <p> The name for the branch. </p>
    public let branchName: String?
    /// <p> The build specification (build spec) for the branch. </p>
    public let buildSpec: String?
    /// <p> The description for the branch. </p>
    public let description: String?
    /// <p> The display name for a branch. This is used as the default domain prefix. </p>
    public let displayName: String?
    /// <p> Enables auto building for the branch. </p>
    public let enableAutoBuild: Bool?
    /// <p> Enables basic authorization for the branch. </p>
    public let enableBasicAuth: Bool?
    /// <p> Enables notifications for the branch. </p>
    public let enableNotification: Bool?
    /// <p>Enables performance mode for the branch.</p>
    ///         <p>Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out. </p>
    public let enablePerformanceMode: Bool?
    /// <p> Enables pull request previews for this branch. </p>
    public let enablePullRequestPreview: Bool?
    /// <p> The environment variables for the branch. </p>
    public let environmentVariables: [String:String]?
    /// <p> The framework for the branch. </p>
    public let framework: String?
    /// <p> The Amplify environment name for the pull request. </p>
    public let pullRequestEnvironmentName: String?
    /// <p> Describes the current stage for the branch. </p>
    public let stage: Stage?
    /// <p> The content Time to Live (TTL) for the website in seconds. </p>
    public let ttl: String?

    public init (
        appId: String? = nil,
        backendEnvironmentArn: String? = nil,
        basicAuthCredentials: String? = nil,
        branchName: String? = nil,
        buildSpec: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        enableAutoBuild: Bool? = nil,
        enableBasicAuth: Bool? = nil,
        enableNotification: Bool? = nil,
        enablePerformanceMode: Bool? = nil,
        enablePullRequestPreview: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        framework: String? = nil,
        pullRequestEnvironmentName: String? = nil,
        stage: Stage? = nil,
        ttl: String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentArn = backendEnvironmentArn
        self.basicAuthCredentials = basicAuthCredentials
        self.branchName = branchName
        self.buildSpec = buildSpec
        self.description = description
        self.displayName = displayName
        self.enableAutoBuild = enableAutoBuild
        self.enableBasicAuth = enableBasicAuth
        self.enableNotification = enableNotification
        self.enablePerformanceMode = enablePerformanceMode
        self.enablePullRequestPreview = enablePullRequestPreview
        self.environmentVariables = environmentVariables
        self.framework = framework
        self.pullRequestEnvironmentName = pullRequestEnvironmentName
        self.stage = stage
        self.ttl = ttl
    }
}

struct UpdateBranchInputBody: Equatable {
    public let description: String?
    public let framework: String?
    public let stage: Stage?
    public let enableNotification: Bool?
    public let enableAutoBuild: Bool?
    public let environmentVariables: [String:String]?
    public let basicAuthCredentials: String?
    public let enableBasicAuth: Bool?
    public let enablePerformanceMode: Bool?
    public let buildSpec: String?
    public let ttl: String?
    public let displayName: String?
    public let enablePullRequestPreview: Bool?
    public let pullRequestEnvironmentName: String?
    public let backendEnvironmentArn: String?
}

extension UpdateBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case ttl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .framework)
        framework = frameworkDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Stage.self, forKey: .stage)
        stage = stageDecoded
        let enableNotificationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableNotification)
        enableNotification = enableNotificationDecoded
        let enableAutoBuildDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoBuild)
        enableAutoBuild = enableAutoBuildDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, envvalue0) in environmentVariablesContainer {
                if let envvalue0 = envvalue0 {
                    environmentVariablesDecoded0?[key0] = envvalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let enableBasicAuthDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableBasicAuth)
        enableBasicAuth = enableBasicAuthDecoded
        let enablePerformanceModeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePerformanceMode)
        enablePerformanceMode = enablePerformanceModeDecoded
        let buildSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .buildSpec)
        buildSpec = buildSpecDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ttl)
        ttl = ttlDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enablePullRequestPreviewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enablePullRequestPreview)
        enablePullRequestPreview = enablePullRequestPreviewDecoded
        let pullRequestEnvironmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestEnvironmentName)
        pullRequestEnvironmentName = pullRequestEnvironmentNameDecoded
        let backendEnvironmentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backendEnvironmentArn)
        backendEnvironmentArn = backendEnvironmentArnDecoded
    }
}

extension UpdateBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBranchOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBranchOutputResponse(branch: \(String(describing: branch)))"}
}

extension UpdateBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// <p> The result structure for the update branch request. </p>
public struct UpdateBranchOutputResponse: Equatable {
    /// <p> The branch for an Amplify app, which maps to a third-party repository branch. </p>
    public let branch: Branch?

    public init (
        branch: Branch? = nil
    )
    {
        self.branch = branch
    }
}

struct UpdateBranchOutputResponseBody: Equatable {
    public let branch: Branch?
}

extension UpdateBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(Branch.self, forKey: .branch)
        branch = branchDecoded
    }
}

public struct UpdateDomainAssociationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainAssociationOutputError>
}

extension UpdateDomainAssociationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainAssociationInput(appId: \(String(describing: appId)), autoSubDomainCreationPatterns: \(String(describing: autoSubDomainCreationPatterns)), autoSubDomainIAMRole: \(String(describing: autoSubDomainIAMRole)), domainName: \(String(describing: domainName)), enableAutoSubDomain: \(String(describing: enableAutoSubDomain)), subDomainSettings: \(String(describing: subDomainSettings)))"}
}

extension UpdateDomainAssociationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case enableAutoSubDomain
        case subDomainSettings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoSubDomainCreationPatterns = autoSubDomainCreationPatterns {
            var autoSubDomainCreationPatternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoSubDomainCreationPatterns)
            for autosubdomaincreationpatterns0 in autoSubDomainCreationPatterns {
                try autoSubDomainCreationPatternsContainer.encode(autosubdomaincreationpatterns0)
            }
        }
        if let autoSubDomainIAMRole = autoSubDomainIAMRole {
            try encodeContainer.encode(autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
        }
        if let enableAutoSubDomain = enableAutoSubDomain {
            try encodeContainer.encode(enableAutoSubDomain, forKey: .enableAutoSubDomain)
        }
        if let subDomainSettings = subDomainSettings {
            var subDomainSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subDomainSettings)
            for subdomainsettings0 in subDomainSettings {
                try subDomainSettingsContainer.encode(subdomainsettings0)
            }
        }
    }
}

public struct UpdateDomainAssociationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainAssociationOutputError>
}

public struct UpdateDomainAssociationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainAssociationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainAssociationInput>
    public typealias MOutput = OperationOutput<UpdateDomainAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainAssociationOutputError>
}

/// <p> The request structure for the update domain association request. </p>
public struct UpdateDomainAssociationInput: Equatable {
    /// <p> The unique ID for an Amplify app. </p>
    public let appId: String?
    /// <p> Sets the branch patterns for automatic subdomain creation. </p>
    public let autoSubDomainCreationPatterns: [String]?
    /// <p> The required AWS Identity and Access Management (IAM) service role for the Amazon
    ///             Resource Name (ARN) for automatically creating subdomains. </p>
    public let autoSubDomainIAMRole: String?
    /// <p> The name of the domain. </p>
    public let domainName: String?
    /// <p> Enables the automated creation of subdomains for branches. </p>
    public let enableAutoSubDomain: Bool?
    /// <p> Describes the settings for the subdomain. </p>
    public let subDomainSettings: [SubDomainSetting]?

    public init (
        appId: String? = nil,
        autoSubDomainCreationPatterns: [String]? = nil,
        autoSubDomainIAMRole: String? = nil,
        domainName: String? = nil,
        enableAutoSubDomain: Bool? = nil,
        subDomainSettings: [SubDomainSetting]? = nil
    )
    {
        self.appId = appId
        self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
        self.autoSubDomainIAMRole = autoSubDomainIAMRole
        self.domainName = domainName
        self.enableAutoSubDomain = enableAutoSubDomain
        self.subDomainSettings = subDomainSettings
    }
}

struct UpdateDomainAssociationInputBody: Equatable {
    public let enableAutoSubDomain: Bool?
    public let subDomainSettings: [SubDomainSetting]?
    public let autoSubDomainCreationPatterns: [String]?
    public let autoSubDomainIAMRole: String?
}

extension UpdateDomainAssociationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoSubDomainCreationPatterns
        case autoSubDomainIAMRole
        case enableAutoSubDomain
        case subDomainSettings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAutoSubDomainDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAutoSubDomain)
        enableAutoSubDomain = enableAutoSubDomainDecoded
        let subDomainSettingsContainer = try containerValues.decodeIfPresent([SubDomainSetting?].self, forKey: .subDomainSettings)
        var subDomainSettingsDecoded0:[SubDomainSetting]? = nil
        if let subDomainSettingsContainer = subDomainSettingsContainer {
            subDomainSettingsDecoded0 = [SubDomainSetting]()
            for structure0 in subDomainSettingsContainer {
                if let structure0 = structure0 {
                    subDomainSettingsDecoded0?.append(structure0)
                }
            }
        }
        subDomainSettings = subDomainSettingsDecoded0
        let autoSubDomainCreationPatternsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoSubDomainCreationPatterns)
        var autoSubDomainCreationPatternsDecoded0:[String]? = nil
        if let autoSubDomainCreationPatternsContainer = autoSubDomainCreationPatternsContainer {
            autoSubDomainCreationPatternsDecoded0 = [String]()
            for string0 in autoSubDomainCreationPatternsContainer {
                if let string0 = string0 {
                    autoSubDomainCreationPatternsDecoded0?.append(string0)
                }
            }
        }
        autoSubDomainCreationPatterns = autoSubDomainCreationPatternsDecoded0
        let autoSubDomainIAMRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoSubDomainIAMRole)
        autoSubDomainIAMRole = autoSubDomainIAMRoleDecoded
    }
}

extension UpdateDomainAssociationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainAssociationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainAssociationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainAssociationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainAssociationOutputResponse(domainAssociation: \(String(describing: domainAssociation)))"}
}

extension UpdateDomainAssociationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDomainAssociationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domainAssociation = output.domainAssociation
        } else {
            self.domainAssociation = nil
        }
    }
}

/// <p> The result structure for the update domain association request. </p>
public struct UpdateDomainAssociationOutputResponse: Equatable {
    /// <p> Describes a domain association, which associates a custom domain with an Amplify app.
    ///         </p>
    public let domainAssociation: DomainAssociation?

    public init (
        domainAssociation: DomainAssociation? = nil
    )
    {
        self.domainAssociation = domainAssociation
    }
}

struct UpdateDomainAssociationOutputResponseBody: Equatable {
    public let domainAssociation: DomainAssociation?
}

extension UpdateDomainAssociationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainAssociation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainAssociationDecoded = try containerValues.decodeIfPresent(DomainAssociation.self, forKey: .domainAssociation)
        domainAssociation = domainAssociationDecoded
    }
}

public struct UpdateWebhookInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

extension UpdateWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebhookInput(branchName: \(String(describing: branchName)), description: \(String(describing: description)), webhookId: \(String(describing: webhookId)))"}
}

extension UpdateWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

public struct UpdateWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebhookInput>
    public typealias MOutput = OperationOutput<UpdateWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebhookOutputError>
}

/// <p> The request structure for the update webhook request. </p>
public struct UpdateWebhookInput: Equatable {
    /// <p> The name for a branch that is part of an Amplify app. </p>
    public let branchName: String?
    /// <p> The description for a webhook. </p>
    public let description: String?
    /// <p> The unique ID for a webhook. </p>
    public let webhookId: String?

    public init (
        branchName: String? = nil,
        description: String? = nil,
        webhookId: String? = nil
    )
    {
        self.branchName = branchName
        self.description = description
        self.webhookId = webhookId
    }
}

struct UpdateWebhookInputBody: Equatable {
    public let branchName: String?
    public let description: String?
}

extension UpdateWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependentServiceFailureException" : self = .dependentServiceFailureException(try DependentServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWebhookOutputError: Equatable {
    case badRequestException(BadRequestException)
    case dependentServiceFailureException(DependentServiceFailureException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension UpdateWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWebhookOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

/// <p> The result structure for the update webhook request. </p>
public struct UpdateWebhookOutputResponse: Equatable {
    /// <p> Describes a webhook that connects repository events to an Amplify app. </p>
    public let webhook: Webhook?

    public init (
        webhook: Webhook? = nil
    )
    {
        self.webhook = webhook
    }
}

struct UpdateWebhookOutputResponseBody: Equatable {
    public let webhook: Webhook?
}

extension UpdateWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(Webhook.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

extension Webhook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case createTime
        case description
        case updateTime
        case webhookArn
        case webhookId
        case webhookUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime.timeIntervalSince1970, forKey: .updateTime)
        }
        if let webhookArn = webhookArn {
            try encodeContainer.encode(webhookArn, forKey: .webhookArn)
        }
        if let webhookId = webhookId {
            try encodeContainer.encode(webhookId, forKey: .webhookId)
        }
        if let webhookUrl = webhookUrl {
            try encodeContainer.encode(webhookUrl, forKey: .webhookUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webhookArn)
        webhookArn = webhookArnDecoded
        let webhookIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webhookId)
        webhookId = webhookIdDecoded
        let webhookUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webhookUrl)
        webhookUrl = webhookUrlDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension Webhook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Webhook(branchName: \(String(describing: branchName)), createTime: \(String(describing: createTime)), description: \(String(describing: description)), updateTime: \(String(describing: updateTime)), webhookArn: \(String(describing: webhookArn)), webhookId: \(String(describing: webhookId)), webhookUrl: \(String(describing: webhookUrl)))"}
}

/// <p> Describes a webhook that connects repository events to an Amplify app. </p>
public struct Webhook: Equatable {
    /// <p> The name for a branch that is part of an Amplify app. </p>
    public let branchName: String?
    /// <p> The create date and time for a webhook. </p>
    public let createTime: Date?
    /// <p> The description for a webhook. </p>
    public let description: String?
    /// <p> Updates the date and time for a webhook. </p>
    public let updateTime: Date?
    /// <p> The Amazon Resource Name (ARN) for the webhook. </p>
    public let webhookArn: String?
    /// <p> The ID of the webhook. </p>
    public let webhookId: String?
    /// <p> The URL of the webhook. </p>
    public let webhookUrl: String?

    public init (
        branchName: String? = nil,
        createTime: Date? = nil,
        description: String? = nil,
        updateTime: Date? = nil,
        webhookArn: String? = nil,
        webhookId: String? = nil,
        webhookUrl: String? = nil
    )
    {
        self.branchName = branchName
        self.createTime = createTime
        self.description = description
        self.updateTime = updateTime
        self.webhookArn = webhookArn
        self.webhookId = webhookId
        self.webhookUrl = webhookUrl
    }
}
