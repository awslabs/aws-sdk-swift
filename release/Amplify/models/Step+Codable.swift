// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Step: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactsUrl
        case context
        case endTime
        case logUrl
        case screenshots
        case startTime
        case status
        case statusReason
        case stepName
        case testArtifactsUrl
        case testConfigUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsUrl = artifactsUrl {
            try encodeContainer.encode(artifactsUrl, forKey: .artifactsUrl)
        }
        if let context = context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let screenshots = screenshots {
            var screenshotsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .screenshots)
            for (dictKey0, screenshots0) in screenshots {
                try screenshotsContainer.encode(screenshots0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let stepName = stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let testArtifactsUrl = testArtifactsUrl {
            try encodeContainer.encode(testArtifactsUrl, forKey: .testArtifactsUrl)
        }
        if let testConfigUrl = testConfigUrl {
            try encodeContainer.encode(testConfigUrl, forKey: .testConfigUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let artifactsUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactsUrl)
        artifactsUrl = artifactsUrlDecoded
        let testArtifactsUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testArtifactsUrl)
        testArtifactsUrl = testArtifactsUrlDecoded
        let testConfigUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testConfigUrl)
        testConfigUrl = testConfigUrlDecoded
        let screenshotsContainer = try containerValues.decodeIfPresent([String:String].self, forKey: .screenshots)
        var screenshotsDecoded0: [String:String]? = nil
        if let screenshotsContainer = screenshotsContainer {
            screenshotsDecoded0 = [String:String]()
            for (key0, thumbnailurl0) in screenshotsContainer {
                screenshotsDecoded0?[key0] = thumbnailurl0
            }
        }
        screenshots = screenshotsDecoded0
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let contextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .context)
        context = contextDecoded
    }
}
