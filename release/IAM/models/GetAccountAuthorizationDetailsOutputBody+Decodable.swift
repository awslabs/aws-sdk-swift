// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetAccountAuthorizationDetailsOutputBody: Equatable {
    public let userDetailList: [UserDetail]?
    public let groupDetailList: [GroupDetail]?
    public let roleDetailList: [RoleDetail]?
    public let policies: [ManagedPolicyDetail]?
    public let isTruncated: Bool
    public let marker: String?
}

extension GetAccountAuthorizationDetailsOutputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupDetailList = "GroupDetailList"
        case isTruncated = "IsTruncated"
        case marker = "Marker"
        case policies = "Policies"
        case roleDetailList = "RoleDetailList"
        case userDetailList = "UserDetailList"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccountAuthorizationDetailsResult"))
        if containerValues.contains(.userDetailList) {
            struct KeyVal0{struct member{}}
            let userDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userDetailList)
            if let userDetailListWrappedContainer = userDetailListWrappedContainer {
                let userDetailListContainer = try userDetailListWrappedContainer.decodeIfPresent([UserDetail].self, forKey: .member)
                var userDetailListBuffer:[UserDetail]? = nil
                if let userDetailListContainer = userDetailListContainer {
                    userDetailListBuffer = [UserDetail]()
                    for structureContainer0 in userDetailListContainer {
                        userDetailListBuffer?.append(structureContainer0)
                    }
                }
                userDetailList = userDetailListBuffer
            } else {
                userDetailList = []
            }
        } else {
            userDetailList = nil
        }
        if containerValues.contains(.groupDetailList) {
            struct KeyVal0{struct member{}}
            let groupDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .groupDetailList)
            if let groupDetailListWrappedContainer = groupDetailListWrappedContainer {
                let groupDetailListContainer = try groupDetailListWrappedContainer.decodeIfPresent([GroupDetail].self, forKey: .member)
                var groupDetailListBuffer:[GroupDetail]? = nil
                if let groupDetailListContainer = groupDetailListContainer {
                    groupDetailListBuffer = [GroupDetail]()
                    for structureContainer0 in groupDetailListContainer {
                        groupDetailListBuffer?.append(structureContainer0)
                    }
                }
                groupDetailList = groupDetailListBuffer
            } else {
                groupDetailList = []
            }
        } else {
            groupDetailList = nil
        }
        if containerValues.contains(.roleDetailList) {
            struct KeyVal0{struct member{}}
            let roleDetailListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .roleDetailList)
            if let roleDetailListWrappedContainer = roleDetailListWrappedContainer {
                let roleDetailListContainer = try roleDetailListWrappedContainer.decodeIfPresent([RoleDetail].self, forKey: .member)
                var roleDetailListBuffer:[RoleDetail]? = nil
                if let roleDetailListContainer = roleDetailListContainer {
                    roleDetailListBuffer = [RoleDetail]()
                    for structureContainer0 in roleDetailListContainer {
                        roleDetailListBuffer?.append(structureContainer0)
                    }
                }
                roleDetailList = roleDetailListBuffer
            } else {
                roleDetailList = []
            }
        } else {
            roleDetailList = nil
        }
        if containerValues.contains(.policies) {
            struct KeyVal0{struct member{}}
            let policiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policies)
            if let policiesWrappedContainer = policiesWrappedContainer {
                let policiesContainer = try policiesWrappedContainer.decodeIfPresent([ManagedPolicyDetail].self, forKey: .member)
                var policiesBuffer:[ManagedPolicyDetail]? = nil
                if let policiesContainer = policiesContainer {
                    policiesBuffer = [ManagedPolicyDetail]()
                    for structureContainer0 in policiesContainer {
                        policiesBuffer?.append(structureContainer0)
                    }
                }
                policies = policiesBuffer
            } else {
                policies = []
            }
        } else {
            policies = nil
        }
        let isTruncatedDecoded = try containerValues.decode(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}
